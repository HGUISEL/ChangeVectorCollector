Project,fix-commit,fix-shortMessage,fix-date,fix-author,patch
zookeeper,42ea26b75105484ef0504396332c276952224158,ZOOKEEPER-3145: Fix potential watch missing issue due to stale pzxid when replaying CloseSession txn with fuzzy snapshot,2019.09.11 17:27:28,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java
index 9d552f0..4657f8e 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java
@@ -63,6 +63,7 @@
 import org.apache.zookeeper.server.watch.WatchesReport;
 import org.apache.zookeeper.server.watch.WatchesSummary;
 import org.apache.zookeeper.txn.CheckVersionTxn;
+import org.apache.zookeeper.txn.CloseSessionTxn;
 import org.apache.zookeeper.txn.CreateContainerTxn;
 import org.apache.zookeeper.txn.CreateTTLTxn;
 import org.apache.zookeeper.txn.CreateTxn;
@@ -947,7 +948,14 @@
                 rc.stat = setACL(setACLTxn.getPath(), setACLTxn.getAcl(), setACLTxn.getVersion());
                 break;
             case OpCode.closeSession:
-                killSession(header.getClientId(), header.getZxid());
+                long sessionId = header.getClientId();
+                if (txn != null) {
+                    killSession(sessionId, header.getZxid(),
+                            ephemerals.remove(sessionId),
+                            ((CloseSessionTxn) txn).getPaths2Delete());
+                } else {
+                    killSession(sessionId, header.getZxid());
+                }
                 break;
             case OpCode.error:
                 ErrorTxn errTxn = (ErrorTxn) txn;
@@ -1119,20 +1127,45 @@
         // so there is no need for synchronization. The list is not
         // changed here. Only create and delete change the list which
         // are again called from FinalRequestProcessor in sequence.
-        Set<String> list = ephemerals.remove(session);
-        if (list != null) {
-            for (String path : list) {
-                try {
-                    deleteNode(path, zxid);
-                    if (LOG.isDebugEnabled()) {
-                        LOG.debug(""Deleting ephemeral node "" + path + "" for session 0x"" + Long.toHexString(session));
-                    }
-                } catch (NoNodeException e) {
-                    LOG.warn(""Ignoring NoNodeException for path ""
-                             + path
-                             + "" while removing ephemeral for dead session 0x""
-                             + Long.toHexString(session));
+        killSession(session, zxid, ephemerals.remove(session), null);
+    }
+
+    void killSession(long session, long zxid, Set<String> paths2DeleteLocal,
+            List<String> paths2DeleteInTxn) {
+        if (paths2DeleteInTxn != null) {
+            deleteNodes(session, zxid, paths2DeleteInTxn);
+        }
+
+        if (paths2DeleteLocal == null) {
+            return;
+        }
+
+        if (paths2DeleteInTxn != null) {
+            // explicitly check and remove to avoid potential performance
+            // issue when using removeAll
+            for (String path: paths2DeleteInTxn) {
+                paths2DeleteLocal.remove(path);
+            }
+            if (!paths2DeleteLocal.isEmpty()) {
+                LOG.warn(""Unexpected extra paths under session {} which ""
+                        + ""are not in txn 0x{}"", paths2DeleteLocal,
+                        Long.toHexString(zxid));
+            }
+        }
+
+        deleteNodes(session, zxid, paths2DeleteLocal);
+    }
+
+    void deleteNodes(long session, long zxid, Iterable<String> paths2Delete) {
+        for (String path : paths2Delete) {
+            try {
+                deleteNode(path, zxid);
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Deleting ephemeral node {} for session 0x{}"", path, Long.toHexString(session));
                 }
+            } catch (NoNodeException e) {
+                LOG.warn(""Ignoring NoNodeException for path {} while removing ephemeral for dead session 0x{}"",
+                        path, Long.toHexString(session));
             }
         }
     }
"
zookeeper,42ea26b75105484ef0504396332c276952224158,ZOOKEEPER-3145: Fix potential watch missing issue due to stale pzxid when replaying CloseSession txn with fuzzy snapshot,2019.09.11 17:27:28,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java
index cccecbf..8b2bab0 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -66,6 +66,7 @@
 import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
 import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
 import org.apache.zookeeper.txn.CheckVersionTxn;
+import org.apache.zookeeper.txn.CloseSessionTxn;
 import org.apache.zookeeper.txn.CreateContainerTxn;
 import org.apache.zookeeper.txn.CreateSessionTxn;
 import org.apache.zookeeper.txn.CreateTTLTxn;
@@ -532,8 +533,12 @@
             // this request is the last of the session so it should be ok
             //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
             long startTime = Time.currentElapsedTime();
-            Set<String> es = zks.getZKDatabase().getEphemerals(request.sessionId);
             synchronized (zks.outstandingChanges) {
+                // need to move getEphemerals into zks.outstandingChanges
+                // synchronized block, otherwise there will be a race
+                // condition with the on flying deleteNode txn, and we'll
+                // delete the node again here, which is not correct
+                Set<String> es = zks.getZKDatabase().getEphemerals(request.sessionId);
                 for (ChangeRecord c : zks.outstandingChanges) {
                     if (c.stat == null) {
                         // Doing a delete
@@ -545,7 +550,9 @@
                 for (String path2Delete : es) {
                     addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));
                 }
-
+                if (ZooKeeperServer.isCloseSessionTxnEnabled()) {
+                    request.setTxn(new CloseSessionTxn(new ArrayList<String>(es)));
+                }
                 zks.sessionTracker.setSessionClosing(request.sessionId);
             }
             ServerMetrics.getMetrics().CLOSE_SESSION_PREP_TIME.add(Time.currentElapsedTime() - startTime);
"
zookeeper,42ea26b75105484ef0504396332c276952224158,ZOOKEEPER-3145: Fix potential watch missing issue due to stale pzxid when replaying CloseSession txn with fuzzy snapshot,2019.09.11 17:27:28,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java
index b8e0bd2..e982cd1 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -110,6 +110,11 @@
     public static final String ZOOKEEPER_DIGEST_ENABLED = ""zookeeper.digest.enabled"";
     private static boolean digestEnabled;
 
+    // Add a enable/disable option for now, we should remove this one when
+    // this feature is confirmed to be stable
+    public static final String CLOSE_SESSION_TXN_ENABLED = ""zookeeper.closeSessionTxn.enabled"";
+    private static boolean closeSessionTxnEnabled = true;
+
     static {
         LOG = LoggerFactory.getLogger(ZooKeeperServer.class);
 
@@ -127,6 +132,20 @@
 
         digestEnabled = Boolean.parseBoolean(System.getProperty(ZOOKEEPER_DIGEST_ENABLED, ""true""));
         LOG.info(""{} = {}"", ZOOKEEPER_DIGEST_ENABLED, digestEnabled);
+
+        closeSessionTxnEnabled = Boolean.parseBoolean(
+                System.getProperty(CLOSE_SESSION_TXN_ENABLED, ""true""));
+        LOG.info(""{} = {}"", CLOSE_SESSION_TXN_ENABLED, closeSessionTxnEnabled);
+    }
+
+    public static boolean isCloseSessionTxnEnabled() {
+        return closeSessionTxnEnabled;
+    }
+
+    public static void setCloseSessionTxnEnabled(boolean enabled) {
+        ZooKeeperServer.closeSessionTxnEnabled = enabled;
+        LOG.info(""Update {} to {}"", CLOSE_SESSION_TXN_ENABLED,
+                ZooKeeperServer.closeSessionTxnEnabled);
     }
 
     protected ZooKeeperServerBean jmxServerBean;
"
zookeeper,42ea26b75105484ef0504396332c276952224158,ZOOKEEPER-3145: Fix potential watch missing issue due to stale pzxid when replaying CloseSession txn with fuzzy snapshot,2019.09.11 17:27:28,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/util/SerializeUtils.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/util/SerializeUtils.java
index 25e86a0..2454c43 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/util/SerializeUtils.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/util/SerializeUtils.java
@@ -34,7 +34,9 @@
 import org.apache.zookeeper.common.IOUtils;
 import org.apache.zookeeper.server.DataTree;
 import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.ZooTrace;
+import org.apache.zookeeper.txn.CloseSessionTxn;
 import org.apache.zookeeper.txn.CreateContainerTxn;
 import org.apache.zookeeper.txn.CreateSessionTxn;
 import org.apache.zookeeper.txn.CreateTTLTxn;
@@ -67,7 +69,9 @@
             txn = new CreateSessionTxn();
             break;
         case OpCode.closeSession:
-            return null;
+            txn = ZooKeeperServer.isCloseSessionTxnEnabled()
+                    ?  new CloseSessionTxn() : null;
+            break;
         case OpCode.create:
         case OpCode.create2:
             txn = new CreateTxn();
@@ -115,6 +119,10 @@
                     create.setAcl(createv0.getAcl());
                     create.setEphemeral(createv0.getEphemeral());
                     create.setParentCVersion(-1);
+                } else if (hdr.getType() == OpCode.closeSession) {
+                    // perhaps this is before CloseSessionTxn was added,
+                    // ignore it and reset txn to null
+                    txn = null;
                 } else {
                     throw e;
                 }
"
zookeeper,8460f4ed48c5f9018d882bee2be748de42e965f9,ZOOKEEPER-3540: Avoid client port unavailable by skip binding the same client port during reconfig,2019.09.11 01:50:37,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java
index fec7a86..dd5aa75 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java
@@ -622,9 +622,18 @@
     }
 
     public void reconfigure(InetSocketAddress addr) {
+        LOG.info(""binding to port {}, {}"", addr, localAddress);
+        if (addr != null && localAddress != null) {
+            if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress()
+                    && localAddress.getAddress().isAnyLocalAddress()
+                    && addr.getPort() == localAddress.getPort())) {
+                 LOG.info(""address is the same, skip rebinding"");
+                 return;
+            }
+        }
+
         Channel oldChannel = parentChannel;
         try {
-            LOG.info(""binding to port {}"", addr);
             parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();
             // Port changes after bind() if the original port was 0, update
             // localAddress to get the real port.
@@ -734,4 +743,8 @@
         this.secure = secure;
     }
 
+    // VisibleForTest
+    public Channel getParentChannel() {
+        return parentChannel;
+    }
 }
"
zookeeper,68c21988d55c57e483370d3ee223c22da2d1bbcf,ZOOKEEPER-3056: Fails to load database with missing snapshot file but with valid transaction log file.,2019.09.02 15:23:06,Michael Han,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index c590765..cf08f6e 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -59,6 +59,7 @@
     TxnLog txnLog;
     SnapShot snapLog;
     private final boolean autoCreateDB;
+    private final boolean trustEmptySnapshot;
     public static final int VERSION = 2;
     public static final String version = ""version-"";
 
@@ -72,6 +73,10 @@
 
     private static final String ZOOKEEPER_DB_AUTOCREATE_DEFAULT = ""true"";
 
+    public static final String ZOOKEEPER_SNAPSHOT_TRUST_EMPTY = ""zookeeper.snapshot.trust.empty"";
+
+    private static final String EMPTY_SNAPSHOT_WARNING = ""No snapshot found, but there are log entries. "";
+
     /**
      * This listener helps
      * the external apis calling
@@ -102,6 +107,9 @@
         boolean enableAutocreate = Boolean.parseBoolean(
             System.getProperty(ZOOKEEPER_DATADIR_AUTOCREATE, ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT));
 
+        trustEmptySnapshot = Boolean.getBoolean(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);
+        LOG.info(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY + "" : "" + trustEmptySnapshot);
+
         if (!this.dataDir.exists()) {
             if (!enableAutocreate) {
                 throw new DatadirException(String.format(
@@ -232,11 +240,18 @@
         } else {
             trustEmptyDB = autoCreateDB;
         }
+
         if (-1L == deserializeResult) {
             /* this means that we couldn't find any snapshot, so we need to
              * initialize an empty database (reported in ZOOKEEPER-2325) */
             if (txnLog.getLastLoggedZxid() != -1) {
-                throw new IOException(""No snapshot found, but there are log entries. "" + ""Something is broken!"");
+                // ZOOKEEPER-3056: provides an escape hatch for users upgrading
+                // from old versions of zookeeper (3.4.x, pre 3.5.3).
+                if (!trustEmptySnapshot) {
+                    throw new IOException(EMPTY_SNAPSHOT_WARNING + ""Something is broken!"");
+                } else {
+                    LOG.warn(EMPTY_SNAPSHOT_WARNING + ""This should only be allowed during upgrading."");
+                }
             }
 
             if (trustEmptyDB) {
@@ -600,5 +615,4 @@
     public long getTotalLogSize() {
         return txnLog.getTotalLogSize();
     }
-
 }
"
zookeeper,6692d7a5b4bc3f0dbd36677c06e782ef5240153a,ZOOKEEPER-3320: Leader election port stop listen when hostname unresolvable for some time,2019.08.06 19:52:07,Igor Skokov,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 3b6133a..5039d83 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -18,6 +18,8 @@
 
 package org.apache.zookeeper.server.quorum;
 
+import static org.apache.zookeeper.common.NetUtils.formatInetAddr;
+
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.DataInputStream;
@@ -36,6 +38,7 @@
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Map;
+import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
@@ -43,24 +46,20 @@
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.NoSuchElementException;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
-
+import javax.net.ssl.SSLSocket;
 import org.apache.zookeeper.common.X509Exception;
 import org.apache.zookeeper.server.ExitCode;
-import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
-import org.apache.zookeeper.server.util.ConfigUtils;
 import org.apache.zookeeper.server.ZooKeeperThread;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
 import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;
 import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;
 import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
+import org.apache.zookeeper.server.util.ConfigUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.net.ssl.SSLSocket;
-import static org.apache.zookeeper.common.NetUtils.formatInetAddr;
-
 /**
  * This class implements a connection manager for leader election using TCP. It
  * maintains one connection for every pair of servers. The tricky part is to
@@ -848,12 +847,39 @@
      */
     public class Listener extends ZooKeeperThread {
 
+        private static final String ELECTION_PORT_BIND_RETRY = ""zookeeper.electionPortBindRetry"";
+        private static final int DEFAULT_PORT_BIND_MAX_RETRY = 3;
+
+        private final int portBindMaxRetry;
+        private Runnable socketBindErrorHandler = () -> System.exit(ExitCode.UNABLE_TO_BIND_QUORUM_PORT.getValue());
         volatile ServerSocket ss = null;
 
         public Listener() {
             // During startup of thread, thread name will be overridden to
             // specific election address
             super(""ListenerThread"");
+
+            // maximum retry count while trying to bind to election port
+            // see ZOOKEEPER-3320 for more details
+            final Integer maxRetry = Integer.getInteger(ELECTION_PORT_BIND_RETRY,
+                                                        DEFAULT_PORT_BIND_MAX_RETRY);
+            if (maxRetry >= 0) {
+                LOG.info(""Election port bind maximum retries is {}"",
+                         maxRetry == 0 ? ""infinite"" : maxRetry);
+                portBindMaxRetry = maxRetry;
+            } else {
+                LOG.info(""'{}' contains invalid value: {}(must be >= 0). ""
+                         + ""Use default value of {} instead."",
+                         ELECTION_PORT_BIND_RETRY, maxRetry, DEFAULT_PORT_BIND_MAX_RETRY);
+                portBindMaxRetry = DEFAULT_PORT_BIND_MAX_RETRY;
+            }
+        }
+
+        /**
+         * Change socket bind error handler. Used for testing.
+         */
+        void setSocketBindErrorHandler(Runnable errorHandler) {
+            this.socketBindErrorHandler = errorHandler;
         }
 
         /**
@@ -865,7 +891,7 @@
             InetSocketAddress addr;
             Socket client = null;
             Exception exitException = null;
-            while((!shutdown) && (numRetries < 3)){
+            while ((!shutdown) && (portBindMaxRetry == 0 || numRetries < portBindMaxRetry)) {
                 try {
                     if (self.shouldUsePortUnification()) {
                         LOG.info(""Creating TLS-enabled quorum server socket"");
@@ -935,15 +961,18 @@
             }
             LOG.info(""Leaving listener"");
             if (!shutdown) {
-                LOG.error(""As I'm leaving the listener thread, ""
-                        + ""I won't be able to participate in leader ""
-                        + ""election any longer: ""
-                        + formatInetAddr(self.getElectionAddress()));
-                if (exitException instanceof BindException) {
+                LOG.error(""As I'm leaving the listener thread after ""
+                          + numRetries + "" errors. ""
+                          + ""I won't be able to participate in leader ""
+                          + ""election any longer: ""
+                          + formatInetAddr(self.getElectionAddress())
+                          + "". Use "" + ELECTION_PORT_BIND_RETRY + "" property to ""
+                          + ""increase retry count."");
+                if (exitException instanceof SocketException) {
                     // After leaving listener thread, the host cannot join the
                     // quorum anymore, this is a severe error that we cannot
                     // recover from, so we need to exit
-                    System.exit(ExitCode.UNABLE_TO_BIND_QUORUM_PORT.getValue());
+                    socketBindErrorHandler.run();
                 }
             } else if (ss != null) {
                 // Clean up for shutdown.
"
zookeeper,3882a0171f91280bf1adbbd4ffaeb17cb5131316,ZOOKEEPER-3479: Logging false leader election times,2019.08.03 03:08:47,Karolos Antoniadis,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 6dacc49..42fed41 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -911,9 +911,8 @@
             LOG.warn(""Failed to register with JMX"", e);
             self.jmxLeaderElectionBean = null;
         }
-        if (self.start_fle == 0) {
-           self.start_fle = Time.currentElapsedTime();
-        }
+
+        self.start_fle = Time.currentElapsedTime();
         try {
             Map<Long, Vote> recvset = new HashMap<Long, Vote>();
 
"
zookeeper,3882a0171f91280bf1adbbd4ffaeb17cb5131316,ZOOKEEPER-3479: Logging false leader election times,2019.08.03 03:08:47,Karolos Antoniadis,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 521f6d4..ce794d1 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -1399,7 +1399,6 @@
                     }
                     break;
                 }
-                start_fle = Time.currentElapsedTime();
             }
         } finally {
             LOG.warn(""QuorumPeer main thread exited"");
"
zookeeper,05ee9413e7a31703395b81fb8d72baf1cb09a46d,ZOOKEEPER-3320: Leader election port stop listen when hostname unresolvable for some time,2019.07.29 18:49:27,Igor Skokov,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index d97da2a..4be8fa6 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -18,6 +18,8 @@
 
 package org.apache.zookeeper.server.quorum;
 
+import static org.apache.zookeeper.common.NetUtils.formatInetAddr;
+
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.DataInputStream;
@@ -36,6 +38,7 @@
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Map;
+import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
@@ -43,24 +46,20 @@
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.NoSuchElementException;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
-
+import javax.net.ssl.SSLSocket;
 import org.apache.zookeeper.common.X509Exception;
 import org.apache.zookeeper.server.ExitCode;
-import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
-import org.apache.zookeeper.server.util.ConfigUtils;
 import org.apache.zookeeper.server.ZooKeeperThread;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
 import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;
 import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;
 import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
+import org.apache.zookeeper.server.util.ConfigUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.net.ssl.SSLSocket;
-import static org.apache.zookeeper.common.NetUtils.formatInetAddr;
-
 /**
  * This class implements a connection manager for leader election using TCP. It
  * maintains one connection for every pair of servers. The tricky part is to
@@ -848,12 +847,30 @@
      */
     public class Listener extends ZooKeeperThread {
 
+        private static final String ELECTION_PORT_BIND_RETRY = ""zookeeper.electionPortBindRetry"";
+        private static final int DEFAULT_PORT_BIND_MAX_RETRY = 3;
+
+        private final int portBindMaxRetry;
         volatile ServerSocket ss = null;
 
         public Listener() {
             // During startup of thread, thread name will be overridden to
             // specific election address
             super(""ListenerThread"");
+
+            // maximum retry count while trying to bind to election port
+            // see ZOOKEEPER-3320 for more details
+            final Integer maxRetry = Integer.getInteger(ELECTION_PORT_BIND_RETRY,
+                                                        DEFAULT_PORT_BIND_MAX_RETRY);
+            if (maxRetry >= 0) {
+                LOG.info(""Election port bind maximum retries is {}"", maxRetry);
+                portBindMaxRetry = maxRetry;
+            } else {
+                LOG.info(""'{}' contains invalid value: {}(must be >= 0). ""
+                         + ""Use default value of {} instead."",
+                         ELECTION_PORT_BIND_RETRY, maxRetry, DEFAULT_PORT_BIND_MAX_RETRY);
+                portBindMaxRetry = DEFAULT_PORT_BIND_MAX_RETRY;
+            }
         }
 
         /**
@@ -865,7 +882,7 @@
             InetSocketAddress addr;
             Socket client = null;
             Exception exitException = null;
-            while((!shutdown) && (numRetries < 3)){
+            while((!shutdown) && (numRetries < portBindMaxRetry)){
                 try {
                     if (self.shouldUsePortUnification()) {
                         LOG.info(""Creating TLS-enabled quorum server socket"");
@@ -935,11 +952,14 @@
             }
             LOG.info(""Leaving listener"");
             if (!shutdown) {
-                LOG.error(""As I'm leaving the listener thread, ""
-                        + ""I won't be able to participate in leader ""
-                        + ""election any longer: ""
-                        + formatInetAddr(self.getElectionAddress()));
-                if (exitException instanceof BindException) {
+                LOG.error(""As I'm leaving the listener thread after ""
+                          + numRetries + "" errors. ""
+                          + ""I won't be able to participate in leader ""
+                          + ""election any longer: ""
+                          + formatInetAddr(self.getElectionAddress())
+                          + "". Use "" + ELECTION_PORT_BIND_RETRY + "" property to ""
+                          + ""increase retry count."");
+                if (exitException instanceof SocketException) {
                     // After leaving listener thread, the host cannot join the
                     // quorum anymore, this is a severe error that we cannot
                     // recover from, so we need to exit
"
zookeeper,ce33b7faed60ea0b7c6f2eb1edbf56eec20a8bc2,ZOOKEEPER-3356: Implement advanced Netty flow control based on feedback from ZK,2019.07.23 22:55:47,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java
index 3a3442f..33161e4 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -68,6 +68,8 @@
     private final NettyServerCnxnFactory factory;
     private boolean initialized;
 
+    public int readIssuedAfterReadComplete;
+
     NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {
         super(zks);
         this.channel = channel;
@@ -321,6 +323,7 @@
             queuedBuffer.consolidate();
         }
         queuedBuffer.addComponent(true, buf);
+        ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());
     }
 
     /**
@@ -553,11 +556,11 @@
     }
 
     /**
-     * An event that triggers a change in the channel's ""Auto Read"" setting.
+     * An event that triggers a change in the channel's read setting.
      * Used for throttling. By using an enum we can treat the two values as
      * singletons and compare with ==.
      */
-    enum AutoReadEvent {
+    enum ReadEvent {
         DISABLE,
         ENABLE
     }
@@ -573,7 +576,7 @@
             if (LOG.isDebugEnabled()) {
                 LOG.debug(""Throttling - disabling recv {}"", this);
             }
-            channel.pipeline().fireUserEventTriggered(AutoReadEvent.DISABLE);
+            channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);
         }
     }
 
@@ -583,7 +586,7 @@
             if (LOG.isDebugEnabled()) {
                 LOG.debug(""Sending unthrottle event {}"", this);
             }
-            channel.pipeline().fireUserEventTriggered(AutoReadEvent.ENABLE);
+            channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);
         }
     }
 
@@ -659,4 +662,12 @@
     Channel getChannel() {
         return channel;
     }
+
+    public int getQueuedReadableBytes() {
+        checkIsInEventLoop(""getQueuedReadableBytes"");
+        if (queuedBuffer != null) {
+            return queuedBuffer.readableBytes();
+        }
+        return 0;
+    }
 }
"
zookeeper,ce33b7faed60ea0b7c6f2eb1edbf56eec20a8bc2,ZOOKEEPER-3356: Implement advanced Netty flow control based on feedback from ZK,2019.07.23 22:55:47,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java
index 9a05df6..e3ae959 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java
@@ -104,6 +104,9 @@
     int listenBacklog = -1;
     private final ClientX509Util x509Util;
 
+    public static final String NETTY_ADVANCED_FLOW_CONTROL = ""zookeeper.netty.advancedFlowControl.enabled"";
+    private boolean advancedFlowControlEnabled = false;
+
     private static final AttributeKey<NettyServerCnxn> CONNECTION_ATTRIBUTE =
             AttributeKey.valueOf(""NettyServerCnxn"");
 
@@ -239,18 +242,31 @@
         @Override
         public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
             try {
-                if (evt == NettyServerCnxn.AutoReadEvent.ENABLE) {
-                    LOG.debug(""Received AutoReadEvent.ENABLE"");
+                if (evt == NettyServerCnxn.ReadEvent.ENABLE) {
+                    LOG.debug(""Received ReadEvent.ENABLE"");
                     NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();
                     // TODO(ilyam): Not sure if cnxn can be null here. It becomes null if channelInactive()
                     // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run
                     // after either of those. Check for null just to be safe ...
                     if (cnxn != null) {
-                        cnxn.processQueuedBuffer();
+                        if (cnxn.getQueuedReadableBytes() > 0) {
+                            cnxn.processQueuedBuffer();
+                            if (advancedFlowControlEnabled &&
+                                    cnxn.getQueuedReadableBytes() == 0) {
+                                // trigger a read if we have consumed all
+                                // backlog
+                                ctx.read();
+                                if (LOG.isDebugEnabled()) {
+                                    LOG.debug(""Issued a read after queuedBuffer drained"");
+                                }
+                            }
+                        }
                     }
-                    ctx.channel().config().setAutoRead(true);
-                } else if (evt == NettyServerCnxn.AutoReadEvent.DISABLE) {
-                    LOG.debug(""Received AutoReadEvent.DISABLE"");
+                    if (!advancedFlowControlEnabled) {
+                        ctx.channel().config().setAutoRead(true);
+                    }
+                } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {
+                    LOG.debug(""Received ReadEvent.DISABLE"");
                     ctx.channel().config().setAutoRead(false);
                 }
             } finally {
@@ -283,6 +299,23 @@
             }
         }
 
+        @Override
+        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+            if (advancedFlowControlEnabled) {
+                NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();
+                if (cnxn != null && cnxn.getQueuedReadableBytes() == 0 &&
+                        cnxn.readIssuedAfterReadComplete == 0) {
+                    ctx.read();
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""Issued a read since we don't have "" +
+                                ""anything to consume after channelReadComplete"");
+                    }
+                }
+            }
+
+            ctx.fireChannelReadComplete();
+        }
+
         // Use a single listener instance to reduce GC
         // Note: this listener is only added when LOG.isTraceEnabled() is true,
         // so it should not do any work other than trace logging.
@@ -375,8 +408,33 @@
             }
         }
     }
+
+    @Sharable
+    static class ReadIssuedTrackingHandler extends ChannelDuplexHandler {
+
+        @Override
+        public void read(ChannelHandlerContext ctx) throws Exception {
+            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();
+            if (cnxn != null) {
+                cnxn.readIssuedAfterReadComplete++;
+            }
+
+            ctx.read();
+        }
+
+        @Override
+        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();
+            if (cnxn != null) {
+                cnxn.readIssuedAfterReadComplete = 0;
+            }
+
+            ctx.fireChannelReadComplete();
+        }
+    }
     
     CnxnChannelHandler channelHandler = new CnxnChannelHandler();
+    ReadIssuedTrackingHandler readIssuedTrackingHandler = new ReadIssuedTrackingHandler();
 
     private ServerBootstrap configureBootstrapAllocator(ServerBootstrap bootstrap) {
         ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();
@@ -404,6 +462,9 @@
         }
         this.shouldUsePortUnification = usePortUnification;
 
+        this.advancedFlowControlEnabled = Boolean.getBoolean(NETTY_ADVANCED_FLOW_CONTROL);
+        LOG.info(""{} = {}"", NETTY_ADVANCED_FLOW_CONTROL, this.advancedFlowControlEnabled);
+
         EventLoopGroup bossGroup = NettyUtils.newNioOrEpollEventLoopGroup(
                 NettyUtils.getClientReachableLocalInetAddressCount());
         EventLoopGroup workerGroup = NettyUtils.newNioOrEpollEventLoopGroup();
@@ -419,6 +480,9 @@
                     @Override
                     protected void initChannel(SocketChannel ch) throws Exception {
                         ChannelPipeline pipeline = ch.pipeline();
+                        if (advancedFlowControlEnabled) {
+                            pipeline.addLast(readIssuedTrackingHandler);
+                        }
                         if (secure) {
                             initSSL(pipeline, false);
                         } else if (shouldUsePortUnification) {
@@ -700,4 +764,14 @@
     static void clearTestAllocator() {
         TEST_ALLOCATOR.set(null);
     }
+
+    // VisibleForTest
+    public void setAdvancedFlowControlEnabled(boolean advancedFlowControlEnabled) {
+        this.advancedFlowControlEnabled = advancedFlowControlEnabled;
+    }
+
+    // VisibleForTest
+    public void setSecure(boolean secure) {
+        this.secure = secure;
+    }
 }
"
zookeeper,ce33b7faed60ea0b7c6f2eb1edbf56eec20a8bc2,ZOOKEEPER-3356: Implement advanced Netty flow control based on feedback from ZK,2019.07.23 22:55:47,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerMetrics.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerMetrics.java
index ca05f94..9573a4a 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerMetrics.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerMetrics.java
@@ -225,6 +225,8 @@
         STALE_REQUESTS_DROPPED = metricsContext.getCounter(""stale_requests_dropped"");
         STALE_REPLIES = metricsContext.getCounter(""stale_replies"");
         REQUEST_THROTTLE_WAIT_COUNT = metricsContext.getCounter(""request_throttle_wait_count"");
+
+        NETTY_QUEUED_BUFFER = metricsContext.getSummary(""netty_queued_buffer_capacity"", DetailLevel.BASIC);
     }
 
     /**
@@ -424,6 +426,8 @@
     public final Counter STALE_REPLIES;
     public final Counter REQUEST_THROTTLE_WAIT_COUNT;
 
+    public final Summary NETTY_QUEUED_BUFFER;
+
     private final MetricsProvider metricsProvider;
 
     public void resetAll() {
"
zookeeper,a6c36b69cc72d7d67e392dab5360007d6f737bef,ZOOKEEPER-2563: A revisit to setquota,2019.07.17 20:42:32,maoling,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeperMain.java b/zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeperMain.java
index ce575b1..8b0caf9 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeperMain.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeperMain.java
@@ -43,8 +43,6 @@
 import org.apache.zookeeper.cli.VersionCommand;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.apache.zookeeper.ZooDefs.Ids;
-import org.apache.zookeeper.data.Stat;
 
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -381,214 +379,6 @@
       }
     }
 
-    /**
-     * trim the quota tree to recover unwanted tree elements
-     * in the quota's tree
-     * @param zk the zookeeper client
-     * @param path the path to start from and go up and see if their
-     * is any unwanted parent in the path.
-     * @return true if sucessful
-     * @throws KeeperException
-     * @throws IOException
-     * @throws InterruptedException
-     */
-    private static boolean trimProcQuotas(ZooKeeper zk, String path)
-        throws KeeperException, IOException, InterruptedException
-    {
-        if (Quotas.quotaZookeeper.equals(path)) {
-            return true;
-        }
-        List<String> children = zk.getChildren(path, false);
-        if (children.size() == 0) {
-            zk.delete(path, -1);
-            String parent = path.substring(0, path.lastIndexOf('/'));
-            return trimProcQuotas(zk, parent);
-        } else {
-            return true;
-        }
-    }
-
-    /**
-     * this method deletes quota for a node.
-     * @param zk the zookeeper client
-     * @param path the path to delete quota for
-     * @param bytes true if number of bytes needs to
-     * be unset
-     * @param numNodes true if number of nodes needs
-     * to be unset
-     * @return true if quota deletion is successful
-     * @throws KeeperException
-     * @throws IOException
-     * @throws InterruptedException
-     */
-    public static boolean delQuota(ZooKeeper zk, String path,
-            boolean bytes, boolean numNodes)
-        throws KeeperException, IOException, InterruptedException
-    {
-        String parentPath = Quotas.quotaZookeeper + path;
-        String quotaPath = Quotas.quotaZookeeper + path + ""/"" + Quotas.limitNode;
-        if (zk.exists(quotaPath, false) == null) {
-            System.out.println(""Quota does not exist for "" + path);
-            return true;
-        }
-        byte[] data = null;
-        try {
-            data = zk.getData(quotaPath, false, new Stat());
-        } catch(KeeperException.NoNodeException ne) {
-            System.err.println(""quota does not exist for "" + path);
-            return true;
-        }
-        StatsTrack strack = new StatsTrack(new String(data));
-        if (bytes && !numNodes) {
-            strack.setBytes(-1L);
-            zk.setData(quotaPath, strack.toString().getBytes(), -1);
-        } else if (!bytes && numNodes) {
-            strack.setCount(-1);
-            zk.setData(quotaPath, strack.toString().getBytes(), -1);
-        } else if (bytes && numNodes) {
-            // delete till you can find a node with more than
-            // one child
-            List<String> children = zk.getChildren(parentPath, false);
-            /// delete the direct children first
-            for (String child: children) {
-                zk.delete(parentPath + ""/"" + child, -1);
-            }
-            // cut the tree till their is more than one child
-            trimProcQuotas(zk, parentPath);
-        }
-        return true;
-    }
-
-    private static void checkIfParentQuota(ZooKeeper zk, String path)
-        throws InterruptedException, KeeperException
-    {
-        final String[] splits = path.split(""/"");
-        String quotaPath = Quotas.quotaZookeeper;
-        for (String str: splits) {
-            if (str.length() == 0) {
-                // this should only be for the beginning of the path
-                // i.e. ""/..."" - split(path)[0] is empty string before first '/'
-                continue;
-            }
-            quotaPath += ""/"" + str;
-            List<String> children =  null;
-            try {
-                children = zk.getChildren(quotaPath, false);
-            } catch(KeeperException.NoNodeException ne) {
-                LOG.debug(""child removed during quota check"", ne);
-                return;
-            }
-            if (children.size() == 0) {
-                return;
-            }
-            for (String child: children) {
-                if (Quotas.limitNode.equals(child)) {
-                    throw new IllegalArgumentException(path + "" has a parent ""
-                            + quotaPath + "" which has a quota"");
-                }
-            }
-        }
-    }
-
-    /**
-     * this method creates a quota node for the path
-     * @param zk the ZooKeeper client
-     * @param path the path for which quota needs to be created
-     * @param bytes the limit of bytes on this path
-     * @param numNodes the limit of number of nodes on this path
-     * @return true if its successful and false if not.
-     */
-    public static boolean createQuota(ZooKeeper zk, String path,
-            long bytes, int numNodes)
-        throws KeeperException, IOException, InterruptedException
-    {
-        // check if the path exists. We cannot create
-        // quota for a path that already exists in zookeeper
-        // for now.
-        Stat initStat = zk.exists(path, false);
-        if (initStat == null) {
-            throw new IllegalArgumentException(path + "" does not exist."");
-        }
-        // now check if their is already existing
-        // parent or child that has quota
-
-        String quotaPath = Quotas.quotaZookeeper;
-        // check for more than 2 children --
-        // if zookeeper_stats and zookeeper_qutoas
-        // are not the children then this path
-        // is an ancestor of some path that
-        // already has quota
-        String realPath = Quotas.quotaZookeeper + path;
-        try {
-            List<String> children = zk.getChildren(realPath, false);
-            for (String child: children) {
-                if (!child.startsWith(""zookeeper_"")) {
-                    throw new IllegalArgumentException(path + "" has child "" +
-                            child + "" which has a quota"");
-                }
-            }
-        } catch(KeeperException.NoNodeException ne) {
-            // this is fine
-        }
-
-        //check for any parent that has been quota
-        checkIfParentQuota(zk, path);
-
-        // this is valid node for quota
-        // start creating all the parents
-        if (zk.exists(quotaPath, false) == null) {
-            try {
-                zk.create(Quotas.procZookeeper, null, Ids.OPEN_ACL_UNSAFE,
-                        CreateMode.PERSISTENT);
-                zk.create(Quotas.quotaZookeeper, null, Ids.OPEN_ACL_UNSAFE,
-                        CreateMode.PERSISTENT);
-            } catch(KeeperException.NodeExistsException ne) {
-                // do nothing
-            }
-        }
-
-        // now create the direct children
-        // and the stat and quota nodes
-        String[] splits = path.split(""/"");
-        StringBuilder sb = new StringBuilder();
-        sb.append(quotaPath);
-        for (int i=1; i<splits.length; i++) {
-            sb.append(""/"" + splits[i]);
-            quotaPath = sb.toString();
-            try {
-                zk.create(quotaPath, null, Ids.OPEN_ACL_UNSAFE ,
-                        CreateMode.PERSISTENT);
-            } catch(KeeperException.NodeExistsException ne) {
-                //do nothing
-            }
-        }
-        String statPath = quotaPath + ""/"" + Quotas.statNode;
-        quotaPath = quotaPath + ""/"" + Quotas.limitNode;
-        StatsTrack strack = new StatsTrack(null);
-        strack.setBytes(bytes);
-        strack.setCount(numNodes);
-        try {
-            zk.create(quotaPath, strack.toString().getBytes(),
-                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-            StatsTrack stats = new StatsTrack(null);
-            stats.setBytes(0L);
-            stats.setCount(0);
-            zk.create(statPath, stats.toString().getBytes(),
-                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
-        } catch(KeeperException.NodeExistsException ne) {
-            byte[] data = zk.getData(quotaPath, false , new Stat());
-            StatsTrack strackC = new StatsTrack(new String(data));
-            if (bytes != -1L) {
-                strackC.setBytes(bytes);
-            }
-            if (numNodes != -1) {
-                strackC.setCount(numNodes);
-            }
-            zk.setData(quotaPath, strackC.toString().getBytes(), -1);
-        }
-        return true;
-    }
-
     protected boolean processCmd(MyCommandOptions co) throws CliException, IOException, InterruptedException {
         boolean watch = false;
         try {
"
zookeeper,a6c36b69cc72d7d67e392dab5360007d6f737bef,ZOOKEEPER-2563: A revisit to setquota,2019.07.17 20:42:32,maoling,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/cli/SetQuotaCommand.java b/zookeeper-server/src/main/java/org/apache/zookeeper/cli/SetQuotaCommand.java
index 8119454..38fc638 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/cli/SetQuotaCommand.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/cli/SetQuotaCommand.java
@@ -17,7 +17,7 @@
  */
 package org.apache.zookeeper.cli;
 
-import java.io.IOException;
+import java.util.ArrayList;
 import java.util.List;
 import org.apache.commons.cli.*;
 import org.apache.zookeeper.*;
@@ -65,13 +65,17 @@
     public boolean exec() throws CliException {
         // get the args
         String path = args[1];
+        if (path.startsWith(Quotas.quotaZookeeper)) {
+            err.println(""cannot set a quota under the path: "" + Quotas.quotaZookeeper);
+            return false;
+        }
 
         if (cl.hasOption(""b"")) {
             // we are setting the bytes quota
             long bytes = Long.parseLong(cl.getOptionValue(""b""));
             try {
                 createQuota(zk, path, bytes, -1);
-            } catch (KeeperException|IOException|InterruptedException ex) {
+            } catch (KeeperException|InterruptedException|IllegalArgumentException ex) {
                 throw new CliWrapperException(ex);
             }
         } else if (cl.hasOption(""n"")) {
@@ -79,7 +83,7 @@
             int numNodes = Integer.parseInt(cl.getOptionValue(""n""));
             try {
                 createQuota(zk, path, -1L, numNodes);
-            } catch (KeeperException|IOException|InterruptedException ex) {
+            } catch (KeeperException|InterruptedException|IllegalArgumentException ex) {
                 throw new CliWrapperException(ex);
             }
         } else {
@@ -91,7 +95,7 @@
 
     public static boolean createQuota(ZooKeeper zk, String path,
             long bytes, int numNodes)
-            throws KeeperException, IOException, InterruptedException, MalformedPathException {
+            throws KeeperException, InterruptedException, IllegalArgumentException, MalformedPathException {
         // check if the path exists. We cannot create
         // quota for a path that already exists in zookeeper
         // for now.
@@ -113,18 +117,9 @@
         // are not the children then this path
         // is an ancestor of some path that
         // already has quota
-        String realPath = Quotas.quotaZookeeper + path;
-        try {
-            List<String> children = zk.getChildren(realPath, false);
-            for (String child : children) {
-                if (!child.startsWith(""zookeeper_"")) {
-                    throw new IllegalArgumentException(path + "" has child ""
-                            + child + "" which has a quota"");
-                }
-            }
-        } catch (KeeperException.NoNodeException ne) {
-            // this is fine
-        }
+
+        //check if the child node has a quota.
+        checkIfChildQuota(zk, path);
 
         //check for any parent that has been quota
         checkIfParentQuota(zk, path);
@@ -184,6 +179,40 @@
         return true;
     }
 
+    private static void checkIfChildQuota(ZooKeeper zk, String path) throws KeeperException, InterruptedException {
+        String realPath = Quotas.quotaZookeeper + path;
+
+        try {
+            ZKUtil.visitSubTreeDFS(zk, realPath, false, new AsyncCallback.StringCallback() {
+
+                @Override
+                public void processResult(int rc, String quotaPath, Object ctx, String name) {
+                    List<String> children = new ArrayList<>();
+                    try {
+                        children = zk.getChildren(quotaPath, false);
+                    } catch (KeeperException.NoNodeException ne) {
+                        LOG.debug(""child removed during quota check"", ne);
+                        return;
+                    } catch (InterruptedException | KeeperException e) {
+                        e.printStackTrace();
+                    }
+
+                    if (children.size() == 0) {
+                        return;
+                    }
+                    for (String child : children) {
+                        if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {
+                            throw new IllegalArgumentException(path + "" has a child ""
+                                    + quotaPath.substring(Quotas.quotaZookeeper.length()) + "" which has a quota"");
+                        }
+                    }
+                }
+            });
+        } catch (KeeperException.NoNodeException ne) {
+            // this is fine
+        }
+    }
+
     private static void checkIfParentQuota(ZooKeeper zk, String path)
             throws InterruptedException, KeeperException {
         final String[] splits = path.split(""/"");
@@ -206,9 +235,9 @@
                 return;
             }
             for (String child : children) {
-                if (Quotas.limitNode.equals(child)) {
+                if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {
                     throw new IllegalArgumentException(path + "" has a parent ""
-                            + quotaPath + "" which has a quota"");
+                            + quotaPath.substring(Quotas.quotaZookeeper.length()) + "" which has a quota"");
                 }
             }
         }
"
zookeeper,4cadbb1a649b70a2243bc4c1e5f736df4d35c462,ZOOKEEPER-2418: txnlog diff sync can skip sending some transactions t…,2019.07.04 03:54:12,Brian Nixon,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java
index a3d5a4d..c33fa04 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -852,11 +852,24 @@
                     currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid,
                                                          minCommittedLog, maxCommittedLog);
 
-                    LOG.debug(""Queueing committedLog 0x"" + Long.toHexString(currentZxid));
-                    Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();
-                    currentZxid = queueCommittedProposals(committedLogItr, currentZxid,
-                                                         null, maxCommittedLog);
-                    needSnap = false;
+                    if (currentZxid < minCommittedLog) {
+                        LOG.info(""Detected gap between end of txnlog: 0x{} and start of committedLog: 0x{}"",
+                                Long.toHexString(currentZxid),
+                                Long.toHexString(minCommittedLog));
+                        currentZxid = peerLastZxid;
+                        // Clear out currently queued requests and revert
+                        // to sending a snapshot.
+                        queuedPackets.clear();
+                        needOpPacket = true;
+                    } else {
+                        LOG.debug(""Queueing committedLog 0x{}"",
+                                Long.toHexString(currentZxid));
+                        Iterator<Proposal> committedLogItr =
+                                db.getCommittedLog().iterator();
+                        currentZxid = queueCommittedProposals(committedLogItr,
+                                currentZxid, null, maxCommittedLog);
+                        needSnap = false;
+                    }
                 }
                 // closing the resources
                 if (txnLogItr instanceof TxnLogProposalIterator) {
"
zookeeper,5874a0f355417024ce8ebe03ab2f6eaf5b9a228c,ZOOKEEPER-3296: Explicitly closing the sslsocket when it failed handshake to prevent issue where peers cannot join quorum,2019.06.14 16:06:42,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 7ba068b..7870bb3 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -635,10 +635,12 @@
     /**
      * Try to establish a connection to server with id sid using its electionAddr.
      *
+     * VisibleForTesting.
+     *
      *  @param sid  server id
      *  @return boolean success indication
      */
-    synchronized private boolean connectOne(long sid, InetSocketAddress electionAddr){
+    synchronized boolean connectOne(long sid, InetSocketAddress electionAddr){
         if (senderWorkerMap.get(sid) != null) {
             LOG.debug(""There is a connection already for server "" + sid);
             return true;
@@ -648,18 +650,18 @@
         try {
             LOG.debug(""Opening channel to server "" + sid);
             if (self.isSslQuorum()) {
-                 SSLSocket sslSock = self.getX509Util().createSSLSocket();
-                 setSockOpts(sslSock);
-                 sslSock.connect(electionAddr, cnxTO);
-                 sslSock.startHandshake();
-                 sock = sslSock;
-                 LOG.info(""SSL handshake complete with {} - {} - {}"", sslSock.getRemoteSocketAddress(), sslSock.getSession().getProtocol(), sslSock.getSession().getCipherSuite());
+                 sock = self.getX509Util().createSSLSocket();
              } else {
                  sock = new Socket();
-                 setSockOpts(sock);
-                 sock.connect(electionAddr, cnxTO);
-
              }
+            setSockOpts(sock);
+            sock.connect(electionAddr, cnxTO);
+            if (sock instanceof SSLSocket) {
+                SSLSocket sslSock = (SSLSocket) sock;
+                sslSock.startHandshake();
+                LOG.info(""SSL handshake complete with {} - {} - {}"", sslSock.getRemoteSocketAddress(), sslSock.getSession().getProtocol(), sslSock.getSession().getCipherSuite());
+            }
+
              LOG.debug(""Connected to server "" + sid);
             // Sends connection request asynchronously if the quorum
             // sasl authentication is enabled. This is required because
"
zookeeper,5874a0f355417024ce8ebe03ab2f6eaf5b9a228c,ZOOKEEPER-3296: Explicitly closing the sslsocket when it failed handshake to prevent issue where peers cannot join quorum,2019.06.14 16:06:42,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 8e866bd..8811875 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -883,10 +883,15 @@
         quorumStats = new QuorumStats(this);
         jmxRemotePeerBean = new HashMap<Long, RemotePeerBean>();
         adminServer = AdminServerFactory.createAdminServer();
-        x509Util = new QuorumX509Util();
+        x509Util = createX509Util();
         initialize();
     }
 
+    // VisibleForTesting
+    QuorumX509Util createX509Util() {
+        return new QuorumX509Util();
+    }
+
     /**
      * For backward compatibility purposes, we instantiate QuorumMaj by default.
      */
"
zookeeper,968f5f365e53d0bcbbe0225cc382327badbd8380,ZOOKEEPER-3399: Remove logging in getGlobalOutstandingLimit for optimal performance.,2019.05.26 02:43:31,Michael Han,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
index e153286..90013e4 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
@@ -136,7 +136,6 @@
     public int getGlobalOutstandingLimit() {
         int divisor = self.getQuorumSize() > 2 ? self.getQuorumSize() - 1 : 1;
         int globalOutstandingLimit = super.getGlobalOutstandingLimit() / divisor;
-        LOG.info(""Override {} to {}"", GLOBAL_OUTSTANDING_LIMIT, globalOutstandingLimit);
         return globalOutstandingLimit;
     }
 
"
zookeeper,968f5f365e53d0bcbbe0225cc382327badbd8380,ZOOKEEPER-3399: Remove logging in getGlobalOutstandingLimit for optimal performance.,2019.05.26 02:43:31,Michael Han,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
index f861dfa..d348744 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
@@ -108,7 +108,6 @@
     public int getGlobalOutstandingLimit() {
         int divisor = self.getQuorumSize() > 2 ? self.getQuorumSize() - 1 : 1;
         int globalOutstandingLimit = super.getGlobalOutstandingLimit() / divisor;
-        LOG.info(""Override {} to {}"", GLOBAL_OUTSTANDING_LIMIT, globalOutstandingLimit);
         return globalOutstandingLimit;
     }
 
"
zookeeper,e2bb6e80f598415bba975edcff166ff1bd750340,ZOOKEEPER-2694: sync CLI command does not wait for result from server,2019.05.24 01:42:39,maoling,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java b/zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java
index c0be18d..f82ff84 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/cli/SyncCommand.java
@@ -16,6 +16,11 @@
  */
 package org.apache.zookeeper.cli;
 
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
 import org.apache.commons.cli.CommandLine;
 import org.apache.commons.cli.Options;
 import org.apache.commons.cli.ParseException;
@@ -30,6 +35,7 @@
 
     private static Options options = new Options();
     private String[] args;
+    public static final long SYNC_TIMEOUT = TimeUnit.SECONDS.toMillis(30L);
 
     public SyncCommand() {
         super(""sync"", ""path"");
@@ -55,18 +61,30 @@
     @Override
     public boolean exec() throws CliException {
         String path = args[1];
+        CompletableFuture<Integer> cf = new CompletableFuture<>();
+
         try {
             zk.sync(path, new AsyncCallback.VoidCallback() {
-
                 public void processResult(int rc, String path, Object ctx) {
-                    out.println(""Sync returned "" + rc);
+                    cf.complete(rc);
                 }
             }, null);
+
+            int resultCode = cf.get(SYNC_TIMEOUT, TimeUnit.MILLISECONDS);
+            if(resultCode == 0) {
+                out.println(""Sync is OK"");
+            } else {
+                out.println(""Sync has failed. rc="" + resultCode);
+            }
         } catch (IllegalArgumentException ex) {
             throw new MalformedPathException(ex.getMessage());
+        } catch (InterruptedException ie) {
+            Thread.currentThread().interrupt();
+            throw new CliWrapperException(ie);
+        } catch (TimeoutException | ExecutionException ex) {
+            throw new CliWrapperException(ex);
         }
 
-
         return false;
     }
 }
"
zookeeper,46b2018dbe008e010462e0dc06ddb73981d19d2a,ZOOKEEPER-3306: Fixing node not accessible issue due the inconsistent ACL reference map after SNAP sync,2019.04.29 23:49:30,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java
index debfe90..af04291 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java
@@ -452,6 +452,19 @@
             throw new KeeperException.NoNodeException();
         }
         synchronized (parent) {
+            // Add the ACL to ACL cache first, to avoid the ACL not being
+            // created race condition during fuzzy snapshot sync.
+            //
+            // This is the simplest fix, which may add ACL reference count
+            // again if it's already counted in in the ACL map of fuzzy
+            // snapshot, which might also happen for deleteNode txn, but
+            // at least it won't cause the ACL not exist issue.
+            //
+            // Later we can audit and delete all non-referenced ACLs from
+            // ACL map when loading the snapshot/txns from disk, like what
+            // we did for the global sessions.
+            Long longval = aclCache.convertAcls(acl);
+
             Set<String> children = parent.getChildren();
             if (children.contains(childName)) {
                 throw new KeeperException.NodeExistsException();
@@ -470,7 +483,6 @@
                 parent.stat.setCversion(parentCVersion);
                 parent.stat.setPzxid(zxid);
             }
-            Long longval = aclCache.convertAcls(acl);
             DataNode child = new DataNode(data, longval, stat);
             parent.addChild(childName);
             nodeDataSize.addAndGet(getNodeSize(path, child.data));
@@ -1249,8 +1261,11 @@
         oa.writeRecord(node, ""node"");
     }
 
-    public void serialize(OutputArchive oa, String tag) throws IOException {
+    public void serializeAcls(OutputArchive oa) throws IOException { 
         aclCache.serialize(oa);
+    }
+
+    public void serializeNodes(OutputArchive oa) throws IOException { 
         serializeNode(oa, new StringBuilder(""""));
         // / marks end of stream
         // we need to check if clear had been called in between the snapshot.
@@ -1259,6 +1274,11 @@
         }
     }
 
+    public void serialize(OutputArchive oa, String tag) throws IOException {
+        serializeAcls(oa);
+        serializeNodes(oa);
+    }
+
     public void deserialize(InputArchive ia, String tag) throws IOException {
         aclCache.deserialize(ia);
         nodes.clear();
"
zookeeper,c000f96504198d999daee2b0ccb3c4217f16dc97,ZOOKEEPER-2474: add a way for client to reattach to a session when using ZKClientConfig,2019.03.13 03:08:39,maoling,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java b/zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java
index b99e729..c606421 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeper.java
@@ -1140,17 +1140,96 @@
     public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,
             long sessionId, byte[] sessionPasswd, boolean canBeReadOnly,
             HostProvider aHostProvider) throws IOException {
-        LOG.info(""Initiating client connection, connectString="" + connectString
-                + "" sessionTimeout="" + sessionTimeout
-                + "" watcher="" + watcher
-                + "" sessionId="" + Long.toHexString(sessionId)
-                + "" sessionPasswd=""
-                + (sessionPasswd == null ? ""<null>"" : ""<hidden>""));
+    	this(connectString, sessionTimeout, watcher, sessionId, sessionPasswd,
+    			canBeReadOnly, aHostProvider, null);
+    }
 
-        this.clientConfig = new ZKClientConfig();
+    /**
+     * To create a ZooKeeper client object, the application needs to pass a
+     * connection string containing a comma separated list of host:port pairs,
+     * each corresponding to a ZooKeeper server.
+     * <p>
+     * Session establishment is asynchronous. This constructor will initiate
+     * connection to the server and return immediately - potentially (usually)
+     * before the session is fully established. The watcher argument specifies
+     * the watcher that will be notified of any changes in state. This
+     * notification can come at any point before or after the constructor call
+     * has returned.
+     * <p>
+     * The instantiated ZooKeeper client object will pick an arbitrary server
+     * from the connectString and attempt to connect to it. If establishment of
+     * the connection fails, another server in the connect string will be tried
+     * (the order is non-deterministic, as we random shuffle the list), until a
+     * connection is established. The client will continue attempts until the
+     * session is explicitly closed (or the session is expired by the server).
+     * <p>
+     * Added in 3.2.0: An optional ""chroot"" suffix may also be appended to the
+     * connection string. This will run the client commands while interpreting
+     * all paths relative to this root (similar to the unix chroot command).
+     * <p>
+     * Use {@link #getSessionId} and {@link #getSessionPasswd} on an established
+     * client connection, these values must be passed as sessionId and
+     * sessionPasswd respectively if reconnecting. Otherwise, if not
+     * reconnecting, use the other constructor which does not require these
+     * parameters.
+     * <p>
+     * For backward compatibility, there is another version
+     * {@link #ZooKeeper(String, int, Watcher, long, byte[], boolean)} which uses
+     * default {@link StaticHostProvider}
+     *
+     * @param connectString
+     *            comma separated host:port pairs, each corresponding to a zk
+     *            server. e.g. ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002""
+     *            If the optional chroot suffix is used the example would look
+     *            like: ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a""
+     *            where the client would be rooted at ""/app/a"" and all paths
+     *            would be relative to this root - ie getting/setting/etc...
+     *            ""/foo/bar"" would result in operations being run on
+     *            ""/app/a/foo/bar"" (from the server perspective).
+     * @param sessionTimeout
+     *            session timeout in milliseconds
+     * @param watcher
+     *            a watcher object which will be notified of state changes, may
+     *            also be notified for node events
+     * @param sessionId
+     *            specific session id to use if reconnecting
+     * @param sessionPasswd
+     *            password for this session
+     * @param canBeReadOnly
+     *            (added in 3.4) whether the created client is allowed to go to
+     *            read-only mode in case of partitioning. Read-only mode
+     *            basically means that if the client can't find any majority
+     *            servers but there's partitioned server it could reach, it
+     *            connects to one in read-only mode, i.e. read requests are
+     *            allowed while write requests are not. It continues seeking for
+     *            majority in the background.
+     * @param aHostProvider
+     *            use this as HostProvider to enable custom behaviour.
+     * @param clientConfig
+     *            (added in 3.5.2) passing this conf object gives each client the flexibility of
+     *            configuring properties differently compared to other instances
+     * @throws IOException in cases of network failure
+     * @throws IllegalArgumentException if an invalid chroot path is specified
+     *
+     * @since 3.5.5
+     */
+    public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,
+    		long sessionId, byte[] sessionPasswd, boolean canBeReadOnly,
+    		HostProvider aHostProvider, ZKClientConfig clientConfig) throws IOException {
+    	LOG.info(""Initiating client connection, connectString="" + connectString
+    			+ "" sessionTimeout="" + sessionTimeout
+    			+ "" watcher="" + watcher
+    			+ "" sessionId="" + Long.toHexString(sessionId)
+    			+ "" sessionPasswd=""
+    			+ (sessionPasswd == null ? ""<null>"" : ""<hidden>""));
+
+        if (clientConfig == null) {
+            clientConfig = new ZKClientConfig();
+        }
+        this.clientConfig = clientConfig;
         watchManager = defaultWatchManager();
         watchManager.defaultWatcher = watcher;
-       
+
         ConnectStringParser connectStringParser = new ConnectStringParser(
                 connectString);
         hostProvider = aHostProvider;
@@ -1191,7 +1270,7 @@
      * reconnecting, use the other constructor which does not require these
      * parameters.
      * <p>
-     * This constructor uses a StaticHostProvider; there is another one  
+     * This constructor uses a StaticHostProvider; there is another one
      * to enable custom behaviour.
      *
      * @param connectString
"
zookeeper,e10c93a590cc1b73eebad48d18cfcbceb3ec0d4d,"ZOOKEEPER-3253: client should not send requests with cxid=-4, -2, or -1",2019.03.06 11:32:04,Samuel Just,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java b/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java
index 6b62ed9..0cae4a4 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java
@@ -1513,7 +1513,8 @@
         }
     }
 
-    private int xid = 1;
+    // @VisibleForTesting
+    protected int xid = 1;
 
     // @VisibleForTesting
     volatile States state = States.NOT_CONNECTED;
@@ -1523,6 +1524,12 @@
      * the server. Thus, getXid() must be public.
      */
     synchronized public int getXid() {
+        // Avoid negative cxid values.  In particular, cxid values of -4, -2, and -1 are special and
+        // must not be used for requests -- see SendThread.readResponse.
+        // Skip from MAX to 1.
+        if (xid == Integer.MAX_VALUE) {
+            xid = 1;
+        }
         return xid++;
     }
 
"
zookeeper,af741cb319d4760cfab1cd3b560635adacd8deca,ZOOKEEPER-1392: Request READ or ADMIN permission for getAcl(),2019.01.10 01:22:40,Andor Molnar,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java
index 07efbdf..3c41297 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -18,8 +18,17 @@
 
 package org.apache.zookeeper.server;
 
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
 import org.apache.commons.lang.StringUtils;
 import org.apache.jute.Record;
+import org.apache.zookeeper.common.Time;
+import org.apache.zookeeper.data.Id;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.Code;
 import org.apache.zookeeper.KeeperException.SessionMovedException;
@@ -33,7 +42,6 @@
 import org.apache.zookeeper.Watcher.WatcherType;
 import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.ZooDefs.OpCode;
-import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.proto.CheckWatchesRequest;
@@ -368,11 +376,36 @@
                 GetACLRequest getACLRequest = new GetACLRequest();
                 ByteBufferInputStream.byteBuffer2Record(request.request,
                         getACLRequest);
-                Stat stat = new Stat();
                 path = getACLRequest.getPath();
+                DataNode n = zks.getZKDatabase().getNode(path);
+                if (n == null) {
+                    throw new KeeperException.NoNodeException();
+                }
+                PrepRequestProcessor.checkACL(zks, request.cnxn, zks.getZKDatabase().aclForNode(n),
+                        ZooDefs.Perms.READ | ZooDefs.Perms.ADMIN,
+                        request.authInfo, path, null);
+
+                Stat stat = new Stat();
                 List<ACL> acl =
-                    zks.getZKDatabase().getACL(path, stat);
-                rsp = new GetACLResponse(acl, stat);
+                        zks.getZKDatabase().getACL(path, stat);
+                try {
+                    PrepRequestProcessor.checkACL(zks, request.cnxn, zks.getZKDatabase().aclForNode(n),
+                            ZooDefs.Perms.ADMIN,
+                            request.authInfo, path, null);
+                    rsp = new GetACLResponse(acl, stat);
+                } catch (KeeperException.NoAuthException e) {
+                    List<ACL> acl1 = new ArrayList<ACL>(acl.size());
+                    for (ACL a : acl) {
+                        if (""digest"".equals(a.getId().getScheme())) {
+                            Id id = a.getId();
+                            Id id1 = new Id(id.getScheme(), id.getId().replaceAll("":.*"", "":x""));
+                            acl1.add(new ACL(a.getPerms(), id1));
+                        } else {
+                            acl1.add(a);
+                        }
+                    }
+                    rsp = new GetACLResponse(acl1, stat);
+                }
                 break;
             }
             case OpCode.getChildren: {
"
zookeeper,0b504dec95b09acb05b40505588f7cda8131fea6,ZOOKEEPER-3218: Add min notification interval property for fast leader election,2019.01.18 11:42:12,Brian Nixon,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 84e269c..9ebdabd 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -68,7 +68,34 @@
      * the system up again after long partitions. Currently 60 seconds.
      */
 
-    final static int maxNotificationInterval = 60000;
+    private static int maxNotificationInterval = 60000;
+
+    /**
+     * Lower bound for notification check. The observer don't need to use
+     * the same lower bound as participant members
+     */
+    private static int minNotificationInterval = finalizeWait;
+
+    /**
+     * Minimum notification interval, default is equal to finalizeWait
+     */
+    public static final String MIN_NOTIFICATION_INTERVAL =
+            ""zookeeper.fastleader.minNotificationInterval"";
+
+    /**
+     * Maximum notification interval, default is 60s
+     */
+    public static final String MAX_NOTIFICATION_INTERVAL =
+            ""zookeeper.fastleader.maxNotificationInterval"";
+
+    static {
+        minNotificationInterval = Integer.getInteger(MIN_NOTIFICATION_INTERVAL,
+                minNotificationInterval);
+        LOG.info(""{}={}"", MIN_NOTIFICATION_INTERVAL, minNotificationInterval);
+        maxNotificationInterval = Integer.getInteger(MAX_NOTIFICATION_INTERVAL,
+                maxNotificationInterval);
+        LOG.info(""{}={}"", MAX_NOTIFICATION_INTERVAL, maxNotificationInterval);
+    }
 
     /**
      * Connection manager. Fast leader election uses TCP for
@@ -898,7 +925,7 @@
 
             Map<Long, Vote> outofelection = new HashMap<Long, Vote>();
 
-            int notTimeout = finalizeWait;
+            int notTimeout = minNotificationInterval;
 
             synchronized(this){
                 logicalclock.incrementAndGet();
"
zookeeper,d149b134049dc8527ba81a9546836942fcabc5b6,ZOOKEEPER-2284: LogFormatter and SnapshotFormatter does not handle FileNotFoundException gracefully,2019.01.15 03:43:00,maoling,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/ZKUtil.java b/zookeeper-server/src/main/java/org/apache/zookeeper/ZKUtil.java
index a6abf2f..f9cfe4b 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/ZKUtil.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/ZKUtil.java
@@ -17,6 +17,7 @@
  */
 package org.apache.zookeeper;
 
+import java.io.File;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Deque;
@@ -88,6 +89,24 @@
             zk.delete(tree.get(i), -1, cb, ctx); //Delete all versions of the node with -1.
         }
     }
+    
+    /**
+     * @param filePath the file path to be validated
+     * @return Returns null if valid otherwise error message
+     */
+    public static String validateFileInput(String filePath) {
+        File file = new File(filePath);
+        if (!file.exists()) {
+            return ""File '"" + file.getAbsolutePath() + ""' does not exist."";
+        }
+        if (!file.canRead()) {
+            return ""Read permission is denied on the file '"" + file.getAbsolutePath() + ""'"";
+        }
+        if (file.isDirectory()) {
+            return ""'"" + file.getAbsolutePath() + ""' is a direcory. it must be a file."";
+        }
+        return null;
+    }
 
     /**
      * BFS Traversal of the system under pathRoot, with the entries in the list, in the
"
zookeeper,d149b134049dc8527ba81a9546836942fcabc5b6,ZOOKEEPER-2284: LogFormatter and SnapshotFormatter does not handle FileNotFoundException gracefully,2019.01.15 03:43:00,maoling,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/LogFormatter.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/LogFormatter.java
index 0e72a67..92ac503 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/LogFormatter.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/LogFormatter.java
@@ -31,6 +31,7 @@
 import org.apache.yetus.audience.InterfaceAudience;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.apache.zookeeper.ZKUtil;
 import org.apache.zookeeper.server.persistence.FileHeader;
 import org.apache.zookeeper.server.persistence.FileTxnLog;
 import org.apache.zookeeper.server.util.SerializeUtils;
@@ -48,6 +49,13 @@
             System.err.println(""USAGE: LogFormatter log_file"");
             System.exit(ExitCode.INVALID_INVOCATION.getValue());
         }
+        
+        String error = ZKUtil.validateFileInput(args[0]);
+        if (null != error) {
+            System.err.println(error);
+            System.exit(ExitCode.INVALID_INVOCATION.getValue());
+        }
+        
         FileInputStream fis = new FileInputStream(args[0]);
         BinaryInputArchive logStream = BinaryInputArchive.getArchive(fis);
         FileHeader fhdr = new FileHeader();
"
zookeeper,d149b134049dc8527ba81a9546836942fcabc5b6,ZOOKEEPER-2284: LogFormatter and SnapshotFormatter does not handle FileNotFoundException gracefully,2019.01.15 03:43:00,maoling,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotFormatter.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotFormatter.java
index 2a80d89..50230ed 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotFormatter.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/SnapshotFormatter.java
@@ -34,6 +34,7 @@
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.InputArchive;
 import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.zookeeper.ZKUtil;
 import org.apache.zookeeper.data.StatPersisted;
 import org.apache.zookeeper.server.persistence.FileSnap;
 import org.apache.zookeeper.server.persistence.Util;
@@ -78,7 +79,13 @@
             System.err.println(""       -json dump znode info in json format"");
             System.exit(ExitCode.INVALID_INVOCATION.getValue());
         }
-
+        
+        String error = ZKUtil.validateFileInput(snapshotFile);
+        if (null != error) {
+            System.err.println(error);
+            System.exit(ExitCode.INVALID_INVOCATION.getValue());
+        }
+        
         if (dumpData && dumpJson) {
             System.err.println(""Cannot specify both data dump (-d) and json mode (-json) in same call"");
             System.exit(ExitCode.INVALID_INVOCATION.getValue());
"
zookeeper,db53d02869faa7c9819689315daa3933125c89a8,ZOOKEEPER-3125: Only patching the pzxid when it's larger than the current pzxid,2018.12.20 23:17:52,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java
index c24396a..b51e51f 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java
@@ -569,7 +569,12 @@
         }
         synchronized (parent) {
             parent.removeChild(childName);
-            parent.stat.setPzxid(zxid);
+            // Only update pzxid when the zxid is larger than the current pzxid,
+            // otherwise we might override some higher pzxid set by a create
+            // Txn, which could cause the cversion and pzxid inconsistent
+            if (zxid > parent.stat.getPzxid()) {
+                parent.stat.setPzxid(zxid);
+            }
         }
 
         DataNode node = nodes.get(path);
"
zookeeper,6ea3c0b6897ec3a833f5b86fe8612bc9b2ac672c,ZOOKEEPER-2778: QuorumPeer: address potential reconfiguration deadlocks,2018.12.07 20:41:50,Michael Edwards,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
index b33404e..035db0c 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -41,6 +41,7 @@
 import java.util.Properties;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 
 import javax.security.sasl.SaslException;
 
@@ -114,7 +115,11 @@
     LocalPeerBean jmxLocalPeerBean;
     private Map<Long, RemotePeerBean> jmxRemotePeerBean;
     LeaderElectionBean jmxLeaderElectionBean;
-    private QuorumCnxManager qcm;
+
+    // The QuorumCnxManager is held through an AtomicReference to ensure cross-thread visibility
+    // of updates; see the implementation comment at setLastSeenQuorumVerifier().
+    private AtomicReference<QuorumCnxManager> qcmRef = new AtomicReference<>();
+
     QuorumAuthServer authServer;
     QuorumAuthLearner authLearner;
 
@@ -127,6 +132,18 @@
      */
     private ZKDatabase zkDb;
 
+    public static final class AddressTuple {
+        public final InetSocketAddress quorumAddr;
+        public final InetSocketAddress electionAddr;
+        public final InetSocketAddress clientAddr;
+
+        public AddressTuple(InetSocketAddress quorumAddr, InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
+            this.quorumAddr = quorumAddr;
+            this.electionAddr = electionAddr;
+            this.clientAddr = clientAddr;
+        }
+    }
+
     public static class QuorumServer {
         public InetSocketAddress addr = null;
 
@@ -442,10 +459,10 @@
      */
 
     //last committed quorum verifier
-    public QuorumVerifier quorumVerifier;
+    private QuorumVerifier quorumVerifier;
     
     //last proposed quorum verifier
-    public QuorumVerifier lastSeenQuorumVerifier = null;
+    private QuorumVerifier lastSeenQuorumVerifier = null;
 
     // Lock object that guard access to quorumVerifier and lastSeenQuorumVerifier.
     final Object QV_LOCK = new Object();
@@ -716,16 +733,14 @@
 
     DatagramSocket udpSocket;
 
-    private InetSocketAddress myQuorumAddr;
-    private InetSocketAddress myElectionAddr = null;
-    private InetSocketAddress myClientAddr = null;
+    private final AtomicReference<AddressTuple> myAddrs = new AtomicReference<>();
 
     /**
      * Resolves hostname for a given server ID.
      *
      * This method resolves hostname for a given server ID in both quorumVerifer
      * and lastSeenQuorumVerifier. If the server ID matches the local server ID,
-     * it also updates myQuorumAddr and myElectionAddr.
+     * it also updates myAddrs.
      */
     public void recreateSocketAddresses(long id) {
         QuorumVerifier qv = getQuorumVerifier();
@@ -734,8 +749,7 @@
             if (qs != null) {
                 qs.recreateSocketAddresses();
                 if (id == getId()) {
-                    setQuorumAddress(qs.addr);
-                    setElectionAddress(qs.electionAddr);
+                    setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);
                 }
             }
         }
@@ -748,42 +762,46 @@
         }
     }
 
-    public InetSocketAddress getQuorumAddress(){
-        synchronized (QV_LOCK) {
-            return myQuorumAddr;
+    private AddressTuple getAddrs(){
+        AddressTuple addrs = myAddrs.get();
+        if (addrs != null) {
+            return addrs;
+        }
+        try {
+            synchronized (QV_LOCK) {
+                addrs = myAddrs.get();
+                while (addrs == null) {
+                    QV_LOCK.wait();
+                    addrs = myAddrs.get();
+                }
+                return addrs;
+            }
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            throw new RuntimeException(e);
         }
     }
-    
-    public void setQuorumAddress(InetSocketAddress addr){
-        synchronized (QV_LOCK) {
-            myQuorumAddr = addr;
-        }
+
+    public InetSocketAddress getQuorumAddress(){
+        return getAddrs().quorumAddr;
     }
 
     public InetSocketAddress getElectionAddress(){
+        return getAddrs().electionAddr;
+    }
+
+    public InetSocketAddress getClientAddress(){
+        final AddressTuple addrs = myAddrs.get();
+        return (addrs == null) ? null : addrs.clientAddr;
+    }
+
+    private void setAddrs(InetSocketAddress quorumAddr, InetSocketAddress electionAddr, InetSocketAddress clientAddr){
         synchronized (QV_LOCK) {
-            return myElectionAddr;
+            myAddrs.set(new AddressTuple(quorumAddr, electionAddr, clientAddr));
+            QV_LOCK.notifyAll();
         }
     }
 
-    public void setElectionAddress(InetSocketAddress addr){
-        synchronized (QV_LOCK) {
-            myElectionAddr = addr;
-        }
-    }
-    
-    public InetSocketAddress getClientAddress(){
-        synchronized (QV_LOCK) {
-            return myClientAddr;
-        }
-    }
-    
-    public void setClientAddress(InetSocketAddress addr){
-        synchronized (QV_LOCK) {
-            myClientAddr = addr;
-        }
-    }
-    
     private int electionType;
 
     Election electionAlg;
@@ -1050,7 +1068,12 @@
             le = new AuthFastLeaderElection(this, true);
             break;
         case 3:
-            qcm = createCnxnManager();
+            QuorumCnxManager qcm = createCnxnManager();
+            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);
+            if (oldQcm != null) {
+                LOG.warn(""Clobbering already-set QuorumCnxManager (restarting leader election?)"");
+                oldQcm.halt();
+            }
             QuorumCnxManager.Listener listener = qcm.listener;
             if(listener != null){
                 listener.start();
@@ -1515,18 +1538,6 @@
         }
     }
     
-    private void connectNewPeers(){
-        synchronized (QV_LOCK) {
-            if (qcm != null && quorumVerifier != null && lastSeenQuorumVerifier != null) {
-                Map<Long, QuorumServer> committedView = quorumVerifier.getAllMembers();
-                for (Entry<Long, QuorumServer> e : lastSeenQuorumVerifier.getAllMembers().entrySet()) {
-                    if (e.getKey() != getId() && !committedView.containsKey(e.getKey()))
-                        qcm.connectOne(e.getKey());
-                }
-            }
-        }
-    }
-
     public synchronized void restartLeaderElection(QuorumVerifier qvOLD, QuorumVerifier qvNEW){
         if (qvOLD == null || !qvOLD.equals(qvNEW)) {
             LOG.warn(""Restarting Leader Election"");
@@ -1544,33 +1555,61 @@
         return configFilename + QuorumPeerConfig.nextDynamicConfigFileSuffix;
     }
     
-    public void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk){
-        synchronized (QV_LOCK) {
-            if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {
-                LOG.error(""setLastSeenQuorumVerifier called with stale config "" + qv.getVersion() +
-                        "". Current version: "" + quorumVerifier.getVersion());
+    // On entry to this method, qcm must be non-null and the locks on both qcm and QV_LOCK
+    // must be held.  We don't want quorumVerifier/lastSeenQuorumVerifier to change out from
+    // under us, so we have to hold QV_LOCK; and since the call to qcm.connectOne() will take
+    // the lock on qcm (and take QV_LOCK again inside that), the caller needs to have taken
+    // qcm outside QV_LOCK to avoid a deadlock against other callers of qcm.connectOne().
+    private void connectNewPeers(QuorumCnxManager qcm){
+        if (quorumVerifier != null && lastSeenQuorumVerifier != null) {
+            Map<Long, QuorumServer> committedView = quorumVerifier.getAllMembers();
+            for (Entry<Long, QuorumServer> e : lastSeenQuorumVerifier.getAllMembers().entrySet()) {
+                if (e.getKey() != getId() && !committedView.containsKey(e.getKey()))
+                    qcm.connectOne(e.getKey());
+            }
+        }
+    }
 
-            }
-            // assuming that a version uniquely identifies a configuration, so if
-            // version is the same, nothing to do here.
-            if (lastSeenQuorumVerifier != null &&
-                    lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {
-                return;
-            }
-            lastSeenQuorumVerifier = qv;
-            connectNewPeers();
-            if (writeToDisk) {
-                try {
-                    String fileName = getNextDynamicConfigFilename();
-                    if (fileName != null) {
-                        QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);
+    public void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk){
+        // If qcm is non-null, we may call qcm.connectOne(), which will take the lock on qcm
+        // and then take QV_LOCK.  Take the locks in the same order to ensure that we don't
+        // deadlock against other callers of connectOne().  If qcmRef gets set in another
+        // thread while we're inside the synchronized block, that does no harm; if we didn't
+        // take a lock on qcm (because it was null when we sampled it), we won't call
+        // connectOne() on it.  (Use of an AtomicReference is enough to guarantee visibility
+        // of updates that provably happen in another thread before entering this method.)
+        QuorumCnxManager qcm = qcmRef.get();
+        Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;
+        synchronized (outerLockObject) {
+            synchronized (QV_LOCK) {
+                if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {
+                    LOG.error(""setLastSeenQuorumVerifier called with stale config "" + qv.getVersion() +
+                            "". Current version: "" + quorumVerifier.getVersion());
+                }
+                // assuming that a version uniquely identifies a configuration, so if
+                // version is the same, nothing to do here.
+                if (lastSeenQuorumVerifier != null &&
+                        lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {
+                    return;
+                }
+                lastSeenQuorumVerifier = qv;
+                if (qcm != null) {
+                    connectNewPeers(qcm);
+                }
+
+                if (writeToDisk) {
+                    try {
+                        String fileName = getNextDynamicConfigFilename();
+                        if (fileName != null) {
+                            QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);
+                        }
+                    } catch (IOException e) {
+                        LOG.error(""Error writing next dynamic config file to disk: "", e.getMessage());
                     }
-                } catch (IOException e) {
-                    LOG.error(""Error writing next dynamic config file to disk: "", e.getMessage());
                 }
             }
         }
-     }       
+    }
     
     public QuorumVerifier setQuorumVerifier(QuorumVerifier qv, boolean writeToDisk){
         synchronized (QV_LOCK) {
@@ -1610,9 +1649,7 @@
             }
             QuorumServer qs = qv.getAllMembers().get(getId());
             if (qs != null) {
-                setQuorumAddress(qs.addr);
-                setElectionAddress(qs.electionAddr);
-                setClientAddress(qs.clientAddr);
+                setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);
             }
             return prevQV;
         }
@@ -1795,7 +1832,7 @@
      * get reference to QuorumCnxManager
      */
     public QuorumCnxManager getQuorumCnxManager() {
-        return qcm;
+        return qcmRef.get();
     }
     private long readLongFromFile(String name) throws IOException {
         File file = new File(logFactory.getSnapDir(), name);
"
zookeeper,b7403b790ff8729f817680afcdef38cb98b87720,ZOOKEEPER-1818: Correctly handle potential inconsistent zxid/electionEpoch and peerEpoch during leader election,2018.12.06 18:56:21,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 5e8a6ca..84e269c 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -71,14 +71,6 @@
     final static int maxNotificationInterval = 60000;
 
     /**
-     * This value is passed to the methods that check the quorum
-     * majority of an established ensemble for those values that
-     * should not be taken into account in the comparison
-     * (electionEpoch and zxid).
-     */
-    final static int IGNOREVALUE = -1;
-
-    /**
      * Connection manager. Fast leader election uses TCP for
      * communication between peers, and QuorumCnxManager manages
      * such connections.
@@ -742,7 +734,7 @@
      *            Identifier of the vote received last
      * @return the SyncedLearnerTracker with vote details
      */
-    private SyncedLearnerTracker getVoteTracker(Map<Long, Vote> votes, Vote vote) {
+    protected SyncedLearnerTracker getVoteTracker(Map<Long, Vote> votes, Vote vote) {
         SyncedLearnerTracker voteSet = new SyncedLearnerTracker();
         voteSet.addQuorumVerifier(self.getQuorumVerifier());
         if (self.getLastSeenQuorumVerifier() != null
@@ -775,7 +767,7 @@
      * @param   leader  leader id
      * @param   electionEpoch   epoch id
      */
-    private boolean checkLeader(
+    protected boolean checkLeader(
             Map<Long, Vote> votes,
             long leader,
             long electionEpoch){
@@ -999,6 +991,7 @@
                                     "", proposed election epoch=0x"" + Long.toHexString(n.electionEpoch));
                         }
 
+                        // don't care about the version if it's in LOOKING state
                         recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));
 
                         voteSet = getVoteTracker(
@@ -1023,9 +1016,9 @@
                              */
                             if (n == null) {
                                 setPeerState(proposedLeader, voteSet);
-
                                 Vote endVote = new Vote(proposedLeader,
-                                        proposedZxid, proposedEpoch);
+                                        proposedZxid, logicalclock.get(), 
+                                        proposedEpoch);
                                 leaveInstance(endVote);
                                 return endVote;
                             }
@@ -1042,14 +1035,13 @@
                          */
                         if(n.electionEpoch == logicalclock.get()){
                             recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));
-                            voteSet = getVoteTracker(
-                                    recvset, new Vote(n.leader, n.zxid,
-                                    n.electionEpoch, n.peerEpoch, n.state));
-                            if(voteSet.hasAllQuorums()
-                                            && checkLeader(outofelection, n.leader, n.electionEpoch)) {
+                            voteSet = getVoteTracker(recvset, new Vote(n.version, 
+                                      n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));
+                            if (voteSet.hasAllQuorums() && 
+                                    checkLeader(outofelection, n.leader, n.electionEpoch)) {
                                 setPeerState(n.leader, voteSet);
-
-                                Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);
+                                Vote endVote = new Vote(n.leader, 
+                                        n.zxid, n.electionEpoch, n.peerEpoch);
                                 leaveInstance(endVote);
                                 return endVote;
                             }
@@ -1058,29 +1050,20 @@
                         /*
                          * Before joining an established ensemble, verify that
                          * a majority are following the same leader.
-                         * Only peer epoch is used to check that the votes come
-                         * from the same ensemble. This is because there is at
-                         * least one corner case in which the ensemble can be
-                         * created with inconsistent zxid and election epoch
-                         * info. However, given that only one ensemble can be
-                         * running at a single point in time and that each
-                         * epoch is used only once, using only the epoch to
-                         * compare the votes is sufficient.
-                         *
-                         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732
                          */
-                        outofelection.put(n.sid, new Vote(n.leader,
-                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));
-                        voteSet = getVoteTracker(
-                                outofelection, new Vote(n.leader,
-                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));
-                        if (voteSet.hasAllQuorums()
-                                && checkLeader(outofelection, n.leader, IGNOREVALUE)) {
+                        outofelection.put(n.sid, new Vote(n.version, n.leader,
+                                n.zxid, n.electionEpoch, n.peerEpoch, n.state));
+                        voteSet = getVoteTracker(outofelection, new Vote(n.version, 
+                                n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));
+
+                        if (voteSet.hasAllQuorums() &&
+                                checkLeader(outofelection, n.leader, n.electionEpoch)) {
                             synchronized(this){
                                 logicalclock.set(n.electionEpoch);
                                 setPeerState(n.leader, voteSet);
                             }
-                            Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);
+                            Vote endVote = new Vote(n.leader, n.zxid, 
+                                    n.electionEpoch, n.peerEpoch);
                             leaveInstance(endVote);
                             return endVote;
                         }
"
zookeeper,b7403b790ff8729f817680afcdef38cb98b87720,ZOOKEEPER-1818: Correctly handle potential inconsistent zxid/electionEpoch and peerEpoch during leader election,2018.12.06 18:56:21,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 7abde4b..b33404e 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -1997,8 +1997,40 @@
     /**
      * Updates leader election info to avoid inconsistencies when
      * a new server tries to join the ensemble.
+     *
+     * Here is the inconsistency scenario we try to solve by updating the peer 
+     * epoch after following leader:
+     *
+     * Let's say we have an ensemble with 3 servers z1, z2 and z3.
+     *
+     * 1. z1, z2 were following z3 with peerEpoch to be 0xb8, the new epoch is 
+     *    0xb9, aka current accepted epoch on disk.
+     * 2. z2 get restarted, which will use 0xb9 as it's peer epoch when loading
+     *    the current accept epoch from disk.
+     * 3. z2 received notification from z1 and z3, which is following z3 with 
+     *    epoch 0xb8, so it started following z3 again with peer epoch 0xb8.
+     * 4. before z2 successfully connected to z3, z3 get restarted with new 
+     *    epoch 0xb9.
+     * 5. z2 will retry around a few round (default 5s) before giving up, 
+     *    meanwhile it will report z3 as leader.
+     * 6. z1 restarted, and looking with peer epoch 0xb9.
+     * 7. z1 voted z3, and z3 was elected as leader again with peer epoch 0xb9.
+     * 8. z2 successfully connected to z3 before giving up, but with peer 
+     *    epoch 0xb8.
+     * 9. z1 get restarted, looking for leader with peer epoch 0xba, but cannot 
+     *    join, because z2 is reporting peer epoch 0xb8, while z3 is reporting 
+     *    0xb9.
+     *
+     * By updating the election vote after actually following leader, we can 
+     * avoid this kind of stuck happened.
+     *
+     * Btw, the zxid and electionEpoch could be inconsistent because of the same 
+     * reason, it's better to update these as well after syncing with leader, but 
+     * that required protocol change which is non trivial. This problem is worked 
+     * around by skipping comparing the zxid and electionEpoch when counting for 
+     * votes for out of election servers during looking for leader.
      * 
-     * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732
+     * {@see https://issues.apache.org/jira/browse/ZOOKEEPER-1732}
      */
     protected void updateElectionVote(long newEpoch) {
         Vote currentVote = getCurrentVote();
"
zookeeper,b7403b790ff8729f817680afcdef38cb98b87720,ZOOKEEPER-1818: Correctly handle potential inconsistent zxid/electionEpoch and peerEpoch during leader election,2018.12.06 18:56:21,Fangmin Lyu,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Vote.java b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Vote.java
index 8152c66..2c2b9bd 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Vote.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Vote.java
@@ -125,11 +125,48 @@
             return false;
         }
         Vote other = (Vote) o;
-        return (id == other.id
+
+        if ((state == ServerState.LOOKING) ||
+                (other.state == ServerState.LOOKING)) {
+            return (id == other.id
                     && zxid == other.zxid
                     && electionEpoch == other.electionEpoch
                     && peerEpoch == other.peerEpoch);
-
+        } else {
+            /*
+             * There are two things going on in the logic below:
+             * 
+             * 1. skip comparing the zxid and electionEpoch for votes for servers 
+             *    out of election. 
+             *    
+             *    Need to skip those because they can be inconsistent due to  
+             *    scenarios described in QuorumPeer.updateElectionVote. 
+             *
+             *    And given that only one ensemble can be running at a single point 
+             *    in time and that each epoch is used only once, using only id and 
+             *    epoch to compare the votes is sufficient.
+             *
+             *    {@see https://issues.apache.org/jira/browse/ZOOKEEPER-1805}
+             *
+             * 2. skip comparing peerEpoch if if we're running with mixed ensemble 
+             *    with (version > 0x0) and without the change (version = 0x0) 
+             *    introduced in ZOOKEEPER-1732.
+             *
+             *    {@see https://issues.apache.org/jira/browse/ZOOKEEPER-1732}
+             *
+             *    The server running with and without ZOOKEEPER-1732 will return 
+             *    different peerEpoch. During rolling upgrades, it's possible
+             *    that 2/5 servers are returning epoch 1, while the other 2/5
+             *    are returning epoch 2, the other server need to ignore the 
+             *    peerEpoch to be able to join it.
+             */
+            if ((version > 0x0) ^ (other.version > 0x0)) {
+                return id == other.id;
+            } else {
+                return (id == other.id
+                        && peerEpoch == other.peerEpoch);
+            }
+        }
     }
 
     @Override
"
zookeeper,91c6cb253c98a5c792314b1c7998ab5b939dddad,ZOOKEEPER-2822: Wrong `ObjectName` about `MBeanServer` in JMX module,2018.11.27 17:57:53,asdf2014,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ManagedUtil.java b/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ManagedUtil.java
index 43451b0..04b5bdd 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ManagedUtil.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/jmx/ManagedUtil.java
@@ -33,13 +33,13 @@
 public class ManagedUtil {
     private static final Logger LOG = LoggerFactory.getLogger(ManagedUtil.class);
 
-    private static final boolean isLog4jJmxEnabled() {
+    private static boolean isLog4jJmxEnabled() {
         boolean enabled = false;
 
         try {
             Class.forName(""org.apache.log4j.spi.LoggerRepository"");
 
-            if (Boolean.getBoolean(""zookeeper.jmx.log4j.disable"") == true) {
+            if (Boolean.getBoolean(""zookeeper.jmx.log4j.disable"")) {
                 LOG.info(""Log4j found but jmx support is disabled."");
             } else {
                 enabled = true;
@@ -69,9 +69,10 @@
             try {
                 // Create and Register the top level Log4J MBean
                 // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();
-                Object hdm = Class.forName(""org.apache.log4j.jmx.HierarchyDynamicMBean"").getDeclaredConstructor().newInstance();
+                Object hdm = Class.forName(""org.apache.log4j.jmx.HierarchyDynamicMBean"").getConstructor().newInstance();
 
-                ObjectName mbo = new ObjectName(""log4j:hiearchy=default"");
+                String mbean = System.getProperty(""zookeeper.jmx.log4j.mbean"", ""log4j:hierarchy=default"");
+                ObjectName mbo = new ObjectName(mbean);
                 mbs.registerMBean(hdm, mbo);
 
                 // Add the root logger to the Hierarchy MBean
"
zookeeper,83fd6e298dda420125f8be35fda68cb226b0ee05,ZOOKEEPER-3156: Add in option to canonicalize host name,2018.11.06 03:40:55,Robert Evans,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java b/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java
index f02142f..ef53edf 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxn.java
@@ -793,7 +793,7 @@
             super(msg);
         }
     }
-    
+
     /**
      * This class services the outgoing request queue and generates the heart
      * beats. It also spawns the ReadThread.
@@ -1080,7 +1080,8 @@
                     if (zooKeeperSaslClient != null) {
                         zooKeeperSaslClient.shutdown();
                     }
-                    zooKeeperSaslClient = new ZooKeeperSaslClient(getServerPrincipal(addr), clientConfig);
+                    zooKeeperSaslClient = new ZooKeeperSaslClient(SaslServerPrincipal.getServerPrincipal(addr, clientConfig),
+                        clientConfig);
                 } catch (LoginException e) {
                     // An authentication error occurred when the SASL client tried to initialize:
                     // for Kerberos this means that the client failed to authenticate with the KDC.
@@ -1099,13 +1100,6 @@
             clientCnxnSocket.connect(addr);
         }
 
-        private String getServerPrincipal(InetSocketAddress addr) {
-            String principalUserName = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_USERNAME,
-                    ZKClientConfig.ZK_SASL_CLIENT_USERNAME_DEFAULT);
-            String serverPrincipal = principalUserName + ""/"" + addr.getHostString();
-            return serverPrincipal;
-        }
-
         private void logStartConnect(InetSocketAddress addr) {
             String msg = ""Opening socket connection to server "" + addr;
             if (zooKeeperSaslClient != null) {
"
zookeeper,83fd6e298dda420125f8be35fda68cb226b0ee05,ZOOKEEPER-3156: Add in option to canonicalize host name,2018.11.06 03:40:55,Robert Evans,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/SaslServerPrincipal.java b/zookeeper-server/src/main/java/org/apache/zookeeper/SaslServerPrincipal.java
new file mode 100644
index 0000000..2694f77
--- /dev/null
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/SaslServerPrincipal.java
@@ -0,0 +1,132 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Computes the Server Principal for a SASL client.
+ */
+public class SaslServerPrincipal {
+    private static final Logger LOG = LoggerFactory.getLogger(SaslServerPrincipal.class);
+
+    /**
+     * Get the name of the server principal for a SASL client.
+     * @param addr the address of the host.
+     * @param clientConfig the configuration for the client.
+     * @return the name of the principal.
+     */
+    static String getServerPrincipal(InetSocketAddress addr, ZKClientConfig clientConfig) {
+        return getServerPrincipal(new WrapperInetSocketAddress(addr), clientConfig);
+    }
+
+    /**
+     * Get the name of the server principal for a SASL client.  This is visible for testing purposes.
+     * @param addr the address of the host.
+     * @param clientConfig the configuration for the client.
+     * @return the name of the principal.
+     */
+    static String getServerPrincipal(WrapperInetSocketAddress addr, ZKClientConfig clientConfig) {
+        String principalUserName = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_USERNAME,
+            ZKClientConfig.ZK_SASL_CLIENT_USERNAME_DEFAULT);
+        String hostName = addr.getHostName();
+
+        boolean canonicalize = true;
+        String canonicalizeText = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME,
+            ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME_DEFAULT);
+        try {
+            canonicalize = Boolean.parseBoolean(canonicalizeText);
+        } catch (IllegalArgumentException ea) {
+            LOG.warn(""Could not parse config {} \""{}\"" into a boolean using default {}"", ZKClientConfig
+                .ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, canonicalizeText, canonicalize);
+        }
+
+        if (canonicalize) {
+            WrapperInetAddress ia = addr.getAddress();
+            if (ia == null) {
+                throw new IllegalArgumentException(""Unable to canonicalize address "" + addr + "" because it's not resolvable"");
+            }
+
+            String canonicalHostName = ia.getCanonicalHostName();
+            //avoid using literal IP address when security check fails
+            if (!canonicalHostName.equals(ia.getHostAddress())) {
+                hostName = canonicalHostName;
+            }
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""Canonicalized address to {}"", hostName);
+            }
+        }
+        String serverPrincipal = principalUserName + ""/"" + hostName;
+        return serverPrincipal;
+    }
+
+    /**
+     * This is here to provide a way to unit test the core logic as the methods for
+     * InetSocketAddress are marked as final.
+     */
+    static class WrapperInetSocketAddress {
+        private final InetSocketAddress addr;
+
+        WrapperInetSocketAddress(InetSocketAddress addr) {
+            this.addr = addr;
+        }
+
+        public String getHostName() {
+            return addr.getHostName();
+        }
+
+        public WrapperInetAddress getAddress() {
+            InetAddress ia = addr.getAddress();
+            return ia == null ? null : new WrapperInetAddress(ia);
+        }
+
+        @Override
+        public String toString() {
+            return addr.toString();
+        }
+    }
+
+    /**
+     * This is here to provide a way to unit test the core logic as the methods for
+     * InetAddress are marked as final.
+     */
+    static class WrapperInetAddress {
+        private final InetAddress ia;
+
+        WrapperInetAddress(InetAddress ia) {
+            this.ia = ia;
+        }
+
+        public String getCanonicalHostName() {
+            return ia.getCanonicalHostName();
+        }
+
+        public String getHostAddress() {
+            return ia.getHostAddress();
+        }
+
+        @Override
+        public String toString() {
+            return ia.toString();
+        }
+    }
+}
"
zookeeper,83fd6e298dda420125f8be35fda68cb226b0ee05,ZOOKEEPER-3156: Add in option to canonicalize host name,2018.11.06 03:40:55,Robert Evans,"diff --git a/zookeeper-server/src/main/java/org/apache/zookeeper/client/ZKClientConfig.java b/zookeeper-server/src/main/java/org/apache/zookeeper/client/ZKClientConfig.java
index 097f2f0..b2d214b 100644
--- a/zookeeper-server/src/main/java/org/apache/zookeeper/client/ZKClientConfig.java
+++ b/zookeeper-server/src/main/java/org/apache/zookeeper/client/ZKClientConfig.java
@@ -33,6 +33,9 @@
 public class ZKClientConfig extends ZKConfig {
     public static final String ZK_SASL_CLIENT_USERNAME = ""zookeeper.sasl.client.username"";
     public static final String ZK_SASL_CLIENT_USERNAME_DEFAULT = ""zookeeper"";
+    public static final String ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME =
+        ""zookeeper.sasl.client.canonicalize.hostname"";
+    public static final String ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME_DEFAULT = ""true"";
     @SuppressWarnings(""deprecation"")
     public static final String LOGIN_CONTEXT_NAME_KEY = ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY;;
     public static final String LOGIN_CONTEXT_NAME_KEY_DEFAULT = ""Client"";
"
zookeeper,a8cf62678131626b778d0572290d582f70a2cbfc,ZOOKEEPER-2847: Cannot bind to client port when reconfig based on old static config,2018.10.01 13:11:18,Yisong Yue,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 2b68a1c..cbf643e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -137,6 +137,8 @@
         public String hostname;
         
         public LearnerType type = LearnerType.PARTICIPANT;
+
+        public boolean isClientAddrFromStatic = false;
         
         private List<InetSocketAddress> myAddrs;
 
@@ -306,7 +308,7 @@
             }           
             if (type == LearnerType.OBSERVER) sw.append("":observer"");
             else if (type == LearnerType.PARTICIPANT) sw.append("":participant"");            
-            if (clientAddr!=null){
+            if (clientAddr!=null && !isClientAddrFromStatic){
                 sw.append("";"");
                 sw.append(delimitedHostString(clientAddr));
                 sw.append("":"");
@@ -1602,7 +1604,7 @@
 
     private boolean needEraseClientInfoFromStaticConfig() {
         QuorumServer server = quorumVerifier.getAllMembers().get(getId());
-        return (server != null && server.clientAddr != null);
+        return (server != null && server.clientAddr != null && !server.isClientAddrFromStatic);
     }
 
     /**
"
zookeeper,a8cf62678131626b778d0572290d582f70a2cbfc,ZOOKEEPER-2847: Cannot bind to client port when reconfig based on old static config,2018.10.01 13:11:18,Yisong Yue,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 6aaf172..f4e8a5f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -712,7 +712,10 @@
                         "" is different from client address found in dynamic file: "" + qs.clientAddr);
         }
         if (qs != null && qs.clientAddr != null) clientPortAddress = qs.clientAddr;
-        if (qs != null && qs.clientAddr == null) qs.clientAddr = clientPortAddress;
+        if (qs != null && qs.clientAddr == null) {
+            qs.clientAddr = clientPortAddress;
+            qs.isClientAddrFromStatic = true;
+        }
     }
 
     private void setupPeerType() {
"
zookeeper,e116d32b63039fe9f0677f0af76c0a77fe74c82b,ZOOKEEPER-2847: Cannot bind to client port when reconfig based on old static config,2018.09.22 13:43:45,Yisong Yue,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 19558cf..6aaf172 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -712,6 +712,7 @@
                         "" is different from client address found in dynamic file: "" + qs.clientAddr);
         }
         if (qs != null && qs.clientAddr != null) clientPortAddress = qs.clientAddr;
+        if (qs != null && qs.clientAddr == null) qs.clientAddr = clientPortAddress;
     }
 
     private void setupPeerType() {
"
zookeeper,b58791016424e662c816e2253de96f3771f5d301,ZOOKEEPER-3144: Fix potential ephemeral nodes inconsistent due to global session inconsistent with fuzzy snapshot,2018.09.15 07:08:19,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 09c6a8a..70cb75b 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -268,21 +268,21 @@
      */
     public void loadData() throws IOException, InterruptedException {
         /*
-         * When a new leader starts executing Leader#lead, it 
+         * When a new leader starts executing Leader#lead, it
          * invokes this method. The database, however, has been
          * initialized before running leader election so that
          * the server could pick its zxid for its initial vote.
          * It does it by invoking QuorumPeer#getLastLoggedZxid.
          * Consequently, we don't need to initialize it once more
-         * and avoid the penalty of loading it a second time. Not 
+         * and avoid the penalty of loading it a second time. Not
          * reloading it is particularly important for applications
          * that host a large database.
-         * 
+         *
          * The following if block checks whether the database has
          * been initialized or not. Note that this method is
-         * invoked by at least one other method: 
+         * invoked by at least one other method:
          * ZooKeeperServer#startdata.
-         *  
+         *
          * See ZOOKEEPER-1642 for more detail.
          */
         if(zkDb.isInitialized()){
@@ -291,7 +291,7 @@
         else {
             setZxid(zkDb.loadDataBase());
         }
-        
+
         // Clean up dead sessions
         List<Long> deadSessions = new LinkedList<Long>();
         for (Long session : zkDb.getSessions()) {
@@ -364,7 +364,7 @@
     public SessionTracker getSessionTracker() {
         return sessionTracker;
     }
-    
+
     long getNextZxid() {
         return hzxid.incrementAndGet();
     }
@@ -1181,7 +1181,7 @@
                     String authorizationID = saslServer.getAuthorizationID();
                     LOG.info(""adding SASL authorization for authorizationID: "" + authorizationID);
                     cnxn.addAuthInfo(new Id(""sasl"",authorizationID));
-                    if (System.getProperty(""zookeeper.superUser"") != null && 
+                    if (System.getProperty(""zookeeper.superUser"") != null &&
                         authorizationID.equals(System.getProperty(""zookeeper.superUser""))) {
                         cnxn.addAuthInfo(new Id(""super"", """"));
                     }
@@ -1224,11 +1224,7 @@
         ProcessTxnResult rc;
         int opCode = request != null ? request.type : hdr.getType();
         long sessionId = request != null ? request.sessionId : hdr.getClientId();
-        if (hdr != null) {
-            rc = getZKDatabase().processTxn(hdr, txn);
-        } else {
-            rc = new ProcessTxnResult();
-        }
+
         if (opCode == OpCode.createSession) {
             if (hdr != null && txn instanceof CreateSessionTxn) {
                 CreateSessionTxn cst = (CreateSessionTxn) txn;
@@ -1241,6 +1237,12 @@
         } else if (opCode == OpCode.closeSession) {
             sessionTracker.removeSession(sessionId);
         }
+
+        if (hdr != null) {
+            rc = getZKDatabase().processTxn(hdr, txn);
+        } else {
+            rc = new ProcessTxnResult();
+        }
         return rc;
     }
 
"
zookeeper,14870ddd4b87afe3af497ec0569ce439c0488053,ZOOKEEPER-1823: zkTxnLogToolkit -dump should support printing transaction data as a string,2018.09.12 20:32:07,maoling,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/TxnLogToolkit.java b/src/java/main/org/apache/zookeeper/server/persistence/TxnLogToolkit.java
index 7adaf25..496b9a4 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/TxnLogToolkit.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/TxnLogToolkit.java
@@ -31,6 +31,10 @@
 import org.apache.zookeeper.server.ExitCode;
 import org.apache.zookeeper.server.TraceFormatter;
 import org.apache.zookeeper.server.util.SerializeUtils;
+import org.apache.zookeeper.txn.CreateContainerTxn;
+import org.apache.zookeeper.txn.CreateTTLTxn;
+import org.apache.zookeeper.txn.CreateTxn;
+import org.apache.zookeeper.txn.SetDataTxn;
 import org.apache.zookeeper.txn.TxnHeader;
 
 import java.io.Closeable;
@@ -222,13 +226,14 @@
     private void printTxn(byte[] bytes, String prefix) throws IOException {
         TxnHeader hdr = new TxnHeader();
         Record txn = SerializeUtils.deserializeTxn(bytes, hdr);
+        String txnStr = getDataStrFromTxn(txn);
         String txns = String.format(""%s session 0x%s cxid 0x%s zxid 0x%s %s %s"",
                 DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(hdr.getTime())),
                 Long.toHexString(hdr.getClientId()),
                 Long.toHexString(hdr.getCxid()),
                 Long.toHexString(hdr.getZxid()),
                 TraceFormatter.op2String(hdr.getType()),
-                txn);
+                txnStr);
         if (prefix != null && !"""".equals(prefix.trim())) {
             System.out.print(prefix + "" - "");
         }
@@ -239,6 +244,41 @@
         }
     }
 
+    /**
+     * get transaction log data string with node's data as a string
+     * @param txn
+     * @return
+     */
+    private static String getDataStrFromTxn(Record txn) {
+        StringBuilder txnData = new StringBuilder();
+        if (txn == null) {
+            return txnData.toString();
+        }
+        if (txn instanceof CreateTxn) {
+            CreateTxn createTxn = ((CreateTxn) txn);
+            txnData.append(createTxn.getPath() + "","" + new String(createTxn.getData()))
+                   .append("","" + createTxn.getAcl() + "","" + createTxn.getEphemeral())
+                   .append("","" + createTxn.getParentCVersion());
+        } else if (txn instanceof SetDataTxn) {
+            SetDataTxn setDataTxn = ((SetDataTxn) txn);
+            txnData.append(setDataTxn.getPath() + "","" + new String(setDataTxn.getData()))
+                   .append("","" + setDataTxn.getVersion());
+        } else if (txn instanceof CreateContainerTxn) {
+            CreateContainerTxn createContainerTxn = ((CreateContainerTxn) txn);
+            txnData.append(createContainerTxn.getPath() + "","" + new String(createContainerTxn.getData()))
+                   .append("","" + createContainerTxn.getAcl() + "","" + createContainerTxn.getParentCVersion());
+        } else if (txn instanceof CreateTTLTxn) {
+            CreateTTLTxn createTTLTxn = ((CreateTTLTxn) txn);
+            txnData.append(createTTLTxn.getPath() + "","" + new String(createTTLTxn.getData()))
+                   .append("","" + createTTLTxn.getAcl() + "","" + createTTLTxn.getParentCVersion())
+                   .append("","" + createTTLTxn.getTtl());
+        } else {
+            txnData.append(txn.toString());
+        }
+
+        return txnData.toString();
+    }
+    
     private void openTxnLogFile() throws FileNotFoundException {
         txnFis = new FileInputStream(txnLogFile);
         logStream = BinaryInputArchive.getArchive(txnFis);
@@ -274,7 +314,7 @@
         Option quietOpt = new Option(""v"", ""verbose"", false, ""Be verbose in recovery mode: print all entries, not just fixed ones."");
         options.addOption(quietOpt);
 
-        Option dumpOpt = new Option(""d"", ""dump"", false, ""Dump mode. Dump all entries of the log file. (this is the default)"");
+        Option dumpOpt = new Option(""d"", ""dump"", false, ""Dump mode. Dump all entries of the log file with printing the content of a nodepath (default)"");
         options.addOption(dumpOpt);
 
         Option forceOpt = new Option(""y"", ""yes"", false, ""Non-interactive mode: repair all CRC errors without asking"");
"
zookeeper,6651a126cd85ced8b26786875b81be140ad97c80,ZOOKEEPER-3125: Fixing pzxid consistent issue when replaying a txn for a deleted node,2018.09.12 20:29:13,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index e0e6661..ac91c10 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -545,6 +545,19 @@
         int lastSlash = path.lastIndexOf('/');
         String parentName = path.substring(0, lastSlash);
         String childName = path.substring(lastSlash + 1);
+
+        // The child might already be deleted during taking fuzzy snapshot,
+        // but we still need to update the pzxid here before throw exception
+        // for no such child
+        DataNode parent = nodes.get(parentName);
+        if (parent == null) {
+            throw new KeeperException.NoNodeException();
+        }
+        synchronized (parent) {
+            parent.removeChild(childName);
+            parent.stat.setPzxid(zxid);
+        }
+
         DataNode node = nodes.get(path);
         if (node == null) {
             throw new KeeperException.NoNodeException();
@@ -554,13 +567,11 @@
             aclCache.removeUsage(node.acl);
             nodeDataSize.addAndGet(-getNodeSize(path, node.data));
         }
-        DataNode parent = nodes.get(parentName);
-        if (parent == null) {
-            throw new KeeperException.NoNodeException();
-        }
+
+        // Synchronized to sync the containers and ttls change, probably
+        // only need to sync on containers and ttls, will update it in a
+        // separate patch.
         synchronized (parent) {
-            parent.removeChild(childName);
-            parent.stat.setPzxid(zxid);
             long eowner = node.stat.getEphemeralOwner();
             EphemeralType ephemeralType = EphemeralType.get(eowner);
             if (ephemeralType == EphemeralType.CONTAINER) {
@@ -576,6 +587,7 @@
                 }
             }
         }
+
         if (parentName.startsWith(procZookeeper) && Quotas.limitNode.equals(childName)) {
             // delete the node in the trie.
             // we need to update the trie as well
@@ -1198,8 +1210,7 @@
             Set<String> childs = node.getChildren();
             children = childs.toArray(new String[childs.size()]);
         }
-        oa.writeString(pathString, ""path"");
-        oa.writeRecord(nodeCopy, ""node"");
+        serializeNodeData(oa, pathString, nodeCopy);
         path.append('/');
         int off = path.length();
         for (String child : children) {
@@ -1212,6 +1223,12 @@
         }
     }
 
+    // visiable for test
+    public void serializeNodeData(OutputArchive oa, String path, DataNode node) throws IOException {
+        oa.writeString(path, ""path"");
+        oa.writeRecord(node, ""node"");
+    }
+
     public void serialize(OutputArchive oa, String tag) throws IOException {
         aclCache.serialize(oa);
         serializeNode(oa, new StringBuilder(""""));
"
zookeeper,4ad2341c18020ecb08e7e26b79cacc3569b9d31e,"ZOOKEEPER-2261: When only secureClientPort is configured connections, configuration, connection_stat_reset, and stats admin commands throw NullPointerException",2018.09.11 07:17:45,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 64f242f..2c9e5e7 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -869,6 +869,10 @@
         return serverCnxnFactory;
     }
 
+    public ServerCnxnFactory getSecureServerCnxnFactory() {
+        return secureServerCnxnFactory;
+    }
+
     public void setSecureServerCnxnFactory(ServerCnxnFactory factory) {
         secureServerCnxnFactory = factory;
     }
"
zookeeper,4ad2341c18020ecb08e7e26b79cacc3569b9d31e,"ZOOKEEPER-2261: When only secureClientPort is configured connections, configuration, connection_stat_reset, and stats admin commands throw NullPointerException",2018.09.11 07:17:45,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/admin/Commands.java b/src/java/main/org/apache/zookeeper/server/admin/Commands.java
index fefccf3..3f37246 100644
--- a/src/java/main/org/apache/zookeeper/server/admin/Commands.java
+++ b/src/java/main/org/apache/zookeeper/server/admin/Commands.java
@@ -18,7 +18,9 @@
 
 package org.apache.zookeeper.server.admin;
 
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -29,6 +31,7 @@
 import org.apache.zookeeper.Environment.Entry;
 import org.apache.zookeeper.Version;
 import org.apache.zookeeper.server.DataTree;
+import org.apache.zookeeper.server.ServerCnxnFactory;
 import org.apache.zookeeper.server.ServerStats;
 import org.apache.zookeeper.server.ZKDatabase;
 import org.apache.zookeeper.server.ZooKeeperServer;
@@ -174,7 +177,18 @@
         @Override
         public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs) {
             CommandResponse response = initializeResponse();
-            response.put(""connections"", zkServer.getServerCnxnFactory().getAllConnectionInfo(false));
+            ServerCnxnFactory serverCnxnFactory = zkServer.getServerCnxnFactory();
+            if (serverCnxnFactory != null) {
+                response.put(""connections"", serverCnxnFactory.getAllConnectionInfo(false));
+            } else {
+                response.put(""connections"", Collections.emptyList());
+            }
+            ServerCnxnFactory secureServerCnxnFactory = zkServer.getSecureServerCnxnFactory();
+            if (secureServerCnxnFactory != null) {
+                response.put(""secure_connections"", secureServerCnxnFactory.getAllConnectionInfo(false));
+            } else {
+                response.put(""secure_connections"", Collections.emptyList());
+            }
             return response;
         }
     }
"
zookeeper,181de25c0dc703eaff77dd6415b676f09564277a,ZOOKEEPER-1990: fix Random instances,2018.09.10 18:44:50,Norbert Kalmar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index b28c980..f02142f 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -801,7 +801,7 @@
     class SendThread extends ZooKeeperThread {
         private long lastPingSentNs;
         private final ClientCnxnSocket clientCnxnSocket;
-        private Random r = new Random(System.nanoTime());        
+        private Random r = new Random();
         private boolean isFirstConnect = true;
 
         void readResponse(ByteBuffer incomingBuffer) throws IOException {
"
zookeeper,181de25c0dc703eaff77dd6415b676f09564277a,ZOOKEEPER-1990: fix Random instances,2018.09.10 18:44:50,Norbert Kalmar,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index 47701dc..57cca9c 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -61,7 +61,7 @@
      * invoked after flush returns successfully.
      */
     private final LinkedList<Request> toFlush = new LinkedList<Request>();
-    private final Random r = new Random(System.nanoTime());
+    private final Random r = new Random();
     /**
      * The number of log entries to log before starting a snapshot
      */
"
zookeeper,95557a30edbdfdf4479a1cb142e0d82a4ba6061d,ZOOKEEPER-3131: Remove watcher when session closed in NettyServerCnxn,2018.09.07 09:34:55,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index ec808a6..948fb3a 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -73,7 +73,7 @@
 
     NettyServerCnxnFactory factory;
     boolean initialized;
-    
+
     NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {
         this.channel = channel;
         this.closingChannel = false;
@@ -83,11 +83,11 @@
             this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);
         }
     }
-    
+
     @Override
     public void close() {
         closingChannel = true;
-        
+
         if (LOG.isDebugEnabled()) {
             LOG.debug(""close called for sessionid:0x""
                     + Long.toHexString(sessionId));
@@ -119,6 +119,10 @@
             }
         }
 
+        if (zkServer != null) {
+            zkServer.removeCnxn(this);
+        }
+
         if (channel.isOpen()) {
             // Since we don't check on the futures created by write calls to the channel complete we need to make sure
             // that all writes have been completed before closing the channel or we risk data loss
@@ -174,7 +178,7 @@
         @Override
         public ChannelFuture getFuture() {return null;}
     };
-    
+
     @Override
     public void sendResponse(ReplyHeader h, Record r, String tag)
             throws IOException {
@@ -226,7 +230,7 @@
      */
     private class SendBufferWriter extends Writer {
         private StringBuffer sb = new StringBuffer();
-        
+
         /**
          * Check if we are ready to send another chunk.
          * @param force force sending, even if not a full chunk
@@ -415,7 +419,7 @@
     public void disableRecv() {
         disableRecvNoWait().awaitUninterruptibly();
     }
-    
+
     private ChannelFuture disableRecvNoWait() {
         throttled = true;
         if (LOG.isDebugEnabled()) {
@@ -423,7 +427,7 @@
         }
         return channel.setReadable(false);
     }
-    
+
     @Override
     public long getOutstandingRequests() {
         return outstandingCount.longValue();
"
zookeeper,e501d9cc67fbaa6e825292fd838711259b6c9789,ZOOKEEPER-3127: Fixing potential data inconsistency due to update last processed zxid with partial multi-op txn,2018.09.06 05:35:38,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 9a4f1a7..e0e6661 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -788,7 +788,11 @@
 
     public volatile long lastProcessedZxid = 0;
 
-    public ProcessTxnResult processTxn(TxnHeader header, Record txn)
+    public ProcessTxnResult processTxn(TxnHeader header, Record txn) {
+        return this.processTxn(header, txn, false);
+    }
+
+    public ProcessTxnResult processTxn(TxnHeader header, Record txn, boolean isSubTxn)
     {
         ProcessTxnResult rc = new ProcessTxnResult();
 
@@ -943,7 +947,7 @@
                         TxnHeader subHdr = new TxnHeader(header.getClientId(), header.getCxid(),
                                                          header.getZxid(), header.getTime(),
                                                          subtxn.getType());
-                        ProcessTxnResult subRc = processTxn(subHdr, record);
+                        ProcessTxnResult subRc = processTxn(subHdr, record, true);
                         rc.multiResult.add(subRc);
                         if (subRc.err != 0 && rc.err == 0) {
                             rc.err = subRc.err ;
@@ -961,22 +965,41 @@
                 LOG.debug(""Failed: "" + header + "":"" + txn, e);
             }
         }
+
+
         /*
-         * A snapshot might be in progress while we are modifying the data
-         * tree. If we set lastProcessedZxid prior to making corresponding
-         * change to the tree, then the zxid associated with the snapshot
-         * file will be ahead of its contents. Thus, while restoring from
-         * the snapshot, the restore method will not apply the transaction
-         * for zxid associated with the snapshot file, since the restore
-         * method assumes that transaction to be present in the snapshot.
+         * Things we can only update after the whole txn is applied to data
+         * tree.
          *
-         * To avoid this, we first apply the transaction and then modify
-         * lastProcessedZxid.  During restore, we correctly handle the
-         * case where the snapshot contains data ahead of the zxid associated
-         * with the file.
+         * If we update the lastProcessedZxid with the first sub txn in multi
+         * and there is a snapshot in progress, it's possible that the zxid
+         * associated with the snapshot only include partial of the multi op.
+         *
+         * When loading snapshot, it will only load the txns after the zxid
+         * associated with snapshot file, which could cause data inconsistency
+         * due to missing sub txns.
+         *
+         * To avoid this, we only update the lastProcessedZxid when the whole
+         * multi-op txn is applied to DataTree.
          */
-        if (rc.zxid > lastProcessedZxid) {
-            lastProcessedZxid = rc.zxid;
+        if (!isSubTxn) {
+            /*
+             * A snapshot might be in progress while we are modifying the data
+             * tree. If we set lastProcessedZxid prior to making corresponding
+             * change to the tree, then the zxid associated with the snapshot
+             * file will be ahead of its contents. Thus, while restoring from
+             * the snapshot, the restore method will not apply the transaction
+             * for zxid associated with the snapshot file, since the restore
+             * method assumes that transaction to be present in the snapshot.
+             *
+             * To avoid this, we first apply the transaction and then modify
+             * lastProcessedZxid.  During restore, we correctly handle the
+             * case where the snapshot contains data ahead of the zxid associated
+             * with the file.
+             */
+            if (rc.zxid > lastProcessedZxid) {
+                lastProcessedZxid = rc.zxid;
+            }
         }
 
         /*
"
zookeeper,e501d9cc67fbaa6e825292fd838711259b6c9789,ZOOKEEPER-3127: Fixing potential data inconsistency due to update last processed zxid with partial multi-op txn,2018.09.06 05:35:38,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 7b00715..04145cb 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -95,7 +95,7 @@
      * @param snapLog the FileTxnSnapLog mapping this zkdatabase
      */
     public ZKDatabase(FileTxnSnapLog snapLog) {
-        dataTree = new DataTree();
+        dataTree = createDataTree();
         sessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();
         this.snapLog = snapLog;
 
@@ -138,7 +138,7 @@
         /* to be safe we just create a new
          * datatree.
          */
-        dataTree = new DataTree();
+        dataTree = createDataTree();
         sessionsWithTimeouts.clear();
         WriteLock lock = logLock.writeLock();
         try {
@@ -644,4 +644,9 @@
     public boolean removeWatch(String path, WatcherType type, Watcher watcher) {
         return dataTree.removeWatch(path, type, watcher);
     }
+
+    // visible for testing
+    public DataTree createDataTree() {
+        return new DataTree();
+    }
 }
"
zookeeper,290f1fc4b907c7d51ec81985e87ef46b8528b8f7,ZOOKEEPER-3117: Correct the LeaderBean.followerInfo to only return the followers list,2018.08.17 21:40:02,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/admin/Commands.java b/src/java/main/org/apache/zookeeper/server/admin/Commands.java
index 4712261..e0c66a6 100644
--- a/src/java/main/org/apache/zookeeper/server/admin/Commands.java
+++ b/src/java/main/org/apache/zookeeper/server/admin/Commands.java
@@ -337,7 +337,7 @@
             if (zkServer instanceof LeaderZooKeeperServer) {
                 Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();
 
-                response.put(""followers"", leader.getLearners().size());
+                response.put(""learners"", leader.getLearners().size());
                 response.put(""synced_followers"", leader.getForwardingFollowers().size());
                 response.put(""pending_syncs"", leader.getNumPendingSyncs());
 
"
zookeeper,290f1fc4b907c7d51ec81985e87ef46b8528b8f7,ZOOKEEPER-3117: Correct the LeaderBean.followerInfo to only return the followers list,2018.08.17 21:40:02,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/command/MonitorCommand.java b/src/java/main/org/apache/zookeeper/server/command/MonitorCommand.java
index a17fe40..9613c7c 100644
--- a/src/java/main/org/apache/zookeeper/server/command/MonitorCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/MonitorCommand.java
@@ -71,7 +71,7 @@
         if (stats.getServerState().equals(""leader"")) {
             Leader leader = ((LeaderZooKeeperServer)zkServer).getLeader();
 
-            print(""followers"", leader.getLearners().size());
+            print(""learners"", leader.getLearners().size());
             print(""synced_followers"", leader.getForwardingFollowers().size());
             print(""pending_syncs"", leader.getNumPendingSyncs());
 
"
zookeeper,290f1fc4b907c7d51ec81985e87ef46b8528b8f7,ZOOKEEPER-3117: Correct the LeaderBean.followerInfo to only return the followers list,2018.08.17 21:40:02,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 1d96165..190d98d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -100,7 +100,7 @@
     // the follower acceptor thread
     volatile LearnerCnxAcceptor cnxAcceptor = null;
 
-    // list of all the followers
+    // list of all the learners, including followers and observers
     private final HashSet<LearnerHandler> learners =
         new HashSet<LearnerHandler>();
 
"
zookeeper,290f1fc4b907c7d51ec81985e87ef46b8528b8f7,ZOOKEEPER-3117: Correct the LeaderBean.followerInfo to only return the followers list,2018.08.17 21:40:02,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderBean.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderBean.java
index 4d4c856..0c3be4a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderBean.java
@@ -20,18 +20,19 @@
 
 import org.apache.zookeeper.server.ZooKeeperServerBean;
 import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
 
 /**
  * Leader MBean interface implementation.
  */
 public class LeaderBean extends ZooKeeperServerBean implements LeaderMXBean {
     private final Leader leader;
-    
+
     public LeaderBean(Leader leader, ZooKeeperServer zks) {
         super(zks);
         this.leader = leader;
     }
-    
+
     public String getName() {
         return ""Leader"";
     }
@@ -39,11 +40,13 @@
     public String getCurrentZxid() {
         return ""0x"" + Long.toHexString(zks.getZxid());
     }
-    
+
     public String followerInfo() {
         StringBuilder sb = new StringBuilder();
         for (LearnerHandler handler : leader.getLearners()) {
-            sb.append(handler.toString()).append(""\n"");
+            if (handler.getLearnerType() == LearnerType.PARTICIPANT) {
+                sb.append(handler.toString()).append(""\n"");
+            }
         }
         return sb.toString();
     }
"
zookeeper,cd209456b67cde5aba771b1a240ebe5607398459,ZOOKEEPER-2926: Fix potential data consistency issue due to the session management bug,2018.08.08 13:21:37,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index b70ad18..eebc86b 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -436,7 +436,7 @@
                 }
 
                 zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
-                ReconfigRequest reconfigRequest = (ReconfigRequest)record; 
+                ReconfigRequest reconfigRequest = (ReconfigRequest)record;
                 LeaderZooKeeperServer lzks;
                 try {
                     lzks = (LeaderZooKeeperServer)zks;
@@ -444,13 +444,13 @@
                     // standalone mode - reconfiguration currently not supported
                     throw new KeeperException.UnimplementedException();
                 }
-                QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();                                                                                 
+                QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();
                 // check that there's no reconfig in progress
                 if (lastSeenQV.getVersion()!=lzks.self.getQuorumVerifier().getVersion()) {
-                       throw new KeeperException.ReconfigInProgress(); 
+                       throw new KeeperException.ReconfigInProgress();
                 }
                 long configId = reconfigRequest.getCurConfigId();
-  
+
                 if (configId != -1 && configId!=lzks.self.getLastSeenQuorumVerifier().getVersion()){
                    String msg = ""Reconfiguration from version "" + configId + "" failed -- last seen version is "" +
                            lzks.self.getLastSeenQuorumVerifier().getVersion();
@@ -458,54 +458,54 @@
                 }
 
                 String newMembers = reconfigRequest.getNewMembers();
-                
-                if (newMembers != null) { //non-incremental membership change                  
+
+                if (newMembers != null) { //non-incremental membership change
                    LOG.info(""Non-incremental reconfig"");
-                
+
                    // Input may be delimited by either commas or newlines so convert to common newline separated format
                    newMembers = newMembers.replaceAll("","", ""\n"");
-                   
+
                    try{
-                       Properties props = new Properties();                        
+                       Properties props = new Properties();
                        props.load(new StringReader(newMembers));
                        request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false);
                        request.qv.setVersion(request.getHdr().getZxid());
                    } catch (IOException | ConfigException e) {
                        throw new KeeperException.BadArgumentsException(e.getMessage());
                    }
-                } else { //incremental change - must be a majority quorum system   
+                } else { //incremental change - must be a majority quorum system
                    LOG.info(""Incremental reconfig"");
-                   
-                   List<String> joiningServers = null; 
+
+                   List<String> joiningServers = null;
                    String joiningServersString = reconfigRequest.getJoiningServers();
                    if (joiningServersString != null)
                    {
                        joiningServers = StringUtils.split(joiningServersString,"","");
                    }
-                   
+
                    List<String> leavingServers = null;
                    String leavingServersString = reconfigRequest.getLeavingServers();
                    if (leavingServersString != null)
                    {
                        leavingServers = StringUtils.split(leavingServersString, "","");
                    }
-                   
+
                    if (!(lastSeenQV instanceof QuorumMaj)) {
                            String msg = ""Incremental reconfiguration requested but last configuration seen has a non-majority quorum system"";
                            LOG.warn(msg);
-                           throw new KeeperException.BadArgumentsException(msg);               
+                           throw new KeeperException.BadArgumentsException(msg);
                    }
                    Map<Long, QuorumServer> nextServers = new HashMap<Long, QuorumServer>(lastSeenQV.getAllMembers());
-                   try {                           
+                   try {
                        if (leavingServers != null) {
                            for (String leaving: leavingServers){
                                long sid = Long.parseLong(leaving);
                                nextServers.remove(sid);
-                           } 
+                           }
                        }
                        if (joiningServers != null) {
                            for (String joiner: joiningServers){
-                        	   // joiner should have the following format: server.x = server_spec;client_spec               
+                        	   // joiner should have the following format: server.x = server_spec;client_spec
                         	   String[] parts = StringUtils.split(joiner, ""="").toArray(new String[0]);
                                if (parts.length != 2) {
                                    throw new KeeperException.BadArgumentsException(""Wrong format of server string"");
@@ -514,7 +514,7 @@
                                Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));
                                QuorumServer qs = new QuorumServer(sid, parts[1]);
                                if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {
-                                   throw new KeeperException.BadArgumentsException(""Wrong format of server string - each server should have 3 ports specified""); 	   
+                                   throw new KeeperException.BadArgumentsException(""Wrong format of server string - each server should have 3 ports specified"");
                                }
 
                                // check duplication of addresses and ports
@@ -527,7 +527,7 @@
 
                                nextServers.remove(qs.id);
                                nextServers.put(qs.id, qs);
-                           }  
+                           }
                        }
                    } catch (ConfigException e){
                        throw new KeeperException.BadArgumentsException(""Reconfiguration failed"");
@@ -543,21 +543,21 @@
                    String msg = ""Reconfig failed - new configuration must include at least 1 follower"";
                    LOG.warn(msg);
                    throw new KeeperException.BadArgumentsException(msg);
-                }                           
-                   
+                }
+
                 if (!lzks.getLeader().isQuorumSynced(request.qv)) {
                    String msg2 = ""Reconfig failed - there must be a connected and synced quorum in new configuration"";
-                   LOG.warn(msg2);             
+                   LOG.warn(msg2);
                    throw new KeeperException.NewConfigNoQuorum();
                 }
-                
-                nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);               
+
+                nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);
                 checkACL(zks, request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, null, null);
-                request.setTxn(new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1));    
+                request.setTxn(new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1));
                 nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());
-                nodeRecord.stat.setVersion(-1);                
+                nodeRecord.stat.setVersion(-1);
                 addChangeRecord(nodeRecord);
-                break;                         
+                break;
             case OpCode.setACL:
                 zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                 SetACLRequest setAclRequest = (SetACLRequest)record;
@@ -579,13 +579,8 @@
                 int to = request.request.getInt();
                 request.setTxn(new CreateSessionTxn(to));
                 request.request.rewind();
-                if (request.isLocalSession()) {
-                    // This will add to local session tracker if it is enabled
-                    zks.sessionTracker.addSession(request.sessionId, to);
-                } else {
-                    // Explicitly add to global session if the flag is not set
-                    zks.sessionTracker.addGlobalSession(request.sessionId, to);
-                }
+                // only add the global session tracker but not to ZKDb
+                zks.sessionTracker.trackSession(request.sessionId, to);
                 zks.setOwner(request.sessionId, request.getOwner());
                 break;
             case OpCode.closeSession:
@@ -759,7 +754,7 @@
                 pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, true);
                 break;
             case OpCode.setData:
-                SetDataRequest setDataRequest = new SetDataRequest();                
+                SetDataRequest setDataRequest = new SetDataRequest();
                 pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, true);
                 break;
             case OpCode.reconfig:
@@ -768,11 +763,11 @@
                 pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest, true);
                 break;
             case OpCode.setACL:
-                SetACLRequest setAclRequest = new SetACLRequest();                
+                SetACLRequest setAclRequest = new SetACLRequest();
                 pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, true);
                 break;
             case OpCode.check:
-                CheckVersionRequest checkRequest = new CheckVersionRequest();              
+                CheckVersionRequest checkRequest = new CheckVersionRequest();
                 pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, true);
                 break;
             case OpCode.multi:
"
zookeeper,cd209456b67cde5aba771b1a240ebe5607398459,ZOOKEEPER-2926: Fix potential data consistency issue due to the session management bug,2018.08.08 13:21:37,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
index 35d6c55..cd43ee2 100644
--- a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
@@ -92,7 +92,7 @@
     }
 
     /* notify the client the session is closing and close/cleanup socket */
-    abstract void sendCloseSession();
+    public abstract void sendCloseSession();
 
     public abstract void process(WatchedEvent event);
 
"
zookeeper,cd209456b67cde5aba771b1a240ebe5607398459,ZOOKEEPER-2926: Fix potential data consistency issue due to the session management bug,2018.08.08 13:21:37,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTracker.java b/src/java/main/org/apache/zookeeper/server/SessionTracker.java
index bbf7df3..9ff7a7f 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTracker.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTracker.java
@@ -47,21 +47,20 @@
     long createSession(int sessionTimeout);
 
     /**
-     * Add a global session to those being tracked.
+     * Track the session expire, not add to ZkDb.
      * @param id sessionId
      * @param to sessionTimeout
-     * @return whether the session was newly added (if false, already existed)
+     * @return whether the session was newly tracked (if false, already tracked)
      */
-    boolean addGlobalSession(long id, int to);
+    boolean trackSession(long id, int to);
 
     /**
-     * Add a session to those being tracked. The session is added as a local
-     * session if they are enabled, otherwise as global.
+     * Add the session to the local session map or global one in zkDB.
      * @param id sessionId
      * @param to sessionTimeout
      * @return whether the session was newly added (if false, already existed)
      */
-    boolean addSession(long id, int to);
+    boolean commitSession(long id, int to);
 
     /**
      * @param sessionId
"
zookeeper,cd209456b67cde5aba771b1a240ebe5607398459,ZOOKEEPER-2926: Fix potential data consistency issue due to the session management bug,2018.08.08 13:21:37,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
index 6fc6eb5..e040493 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
@@ -102,7 +102,7 @@
         this.sessionsWithTimeout = sessionsWithTimeout;
         this.nextSessionId.set(initializeNextSession(serverId));
         for (Entry<Long, Integer> e : sessionsWithTimeout.entrySet()) {
-            addSession(e.getKey(), e.getValue());
+            trackSession(e.getKey(), e.getValue());
         }
 
         EphemeralType.validateServerId(serverId);
@@ -245,17 +245,12 @@
 
     public long createSession(int sessionTimeout) {
         long sessionId = nextSessionId.getAndIncrement();
-        addSession(sessionId, sessionTimeout);
+        trackSession(sessionId, sessionTimeout);
         return sessionId;
     }
 
-    public boolean addGlobalSession(long id, int sessionTimeout) {
-        return addSession(id, sessionTimeout);
-    }
-
-    public synchronized boolean addSession(long id, int sessionTimeout) {
-        sessionsWithTimeout.put(id, sessionTimeout);
-
+    @Override
+    public synchronized boolean trackSession(long id, int sessionTimeout) {
         boolean added = false;
 
         SessionImpl session = sessionsById.get(id);
@@ -285,6 +280,10 @@
         return added;
     }
 
+    public synchronized boolean commitSession(long id, int sessionTimeout) {
+        return sessionsWithTimeout.put(id, sessionTimeout) == null;
+    }
+
     public boolean isTrackingSession(long sessionId) {
         return sessionsById.containsKey(sessionId);
     }
"
zookeeper,cd209456b67cde5aba771b1a240ebe5607398459,ZOOKEEPER-2926: Fix potential data consistency issue due to the session management bug,2018.08.08 13:21:37,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 3d98f8e..64f242f 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -1217,13 +1217,8 @@
         if (opCode == OpCode.createSession) {
             if (hdr != null && txn instanceof CreateSessionTxn) {
                 CreateSessionTxn cst = (CreateSessionTxn) txn;
-                sessionTracker.addGlobalSession(sessionId, cst.getTimeOut());
-            } else if (request != null && request.isLocalSession()) {
-                request.request.rewind();
-                int timeout = request.request.getInt();
-                request.request.rewind();
-                sessionTracker.addSession(request.sessionId, timeout);
-            } else {
+                sessionTracker.commitSession(sessionId, cst.getTimeOut());
+            } else if (request == null || !request.isLocalSession()) {
                 LOG.warn(""*****>>>>> Got ""
                         + txn.getClass() + "" ""
                         + txn.toString());
"
zookeeper,cd209456b67cde5aba771b1a240ebe5607398459,ZOOKEEPER-2926: Fix potential data consistency issue due to the session management bug,2018.08.08 13:21:37,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderSessionTracker.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderSessionTracker.java
index 38bbfe8..e79207b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderSessionTracker.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderSessionTracker.java
@@ -85,31 +85,47 @@
         return globalSessionTracker.isTrackingSession(sessionId);
     }
 
-    public boolean addGlobalSession(long sessionId, int sessionTimeout) {
-        boolean added =
-            globalSessionTracker.addSession(sessionId, sessionTimeout);
-        if (localSessionsEnabled && added) {
+    public boolean trackSession(long sessionId, int sessionTimeout) {
+        boolean tracked =
+            globalSessionTracker.trackSession(sessionId, sessionTimeout);
+        if (localSessionsEnabled && tracked) {
             // Only do extra logging so we know what kind of session this is
             // if we're supporting both kinds of sessions
-            LOG.info(""Adding global session 0x"" + Long.toHexString(sessionId));
+            LOG.info(""Tracking global session 0x"" + Long.toHexString(sessionId));
         }
-        return added;
+        return tracked;
     }
 
-    public boolean addSession(long sessionId, int sessionTimeout) {
-        boolean added;
-        if (localSessionsEnabled && !isGlobalSession(sessionId)) {
-            added = localSessionTracker.addSession(sessionId, sessionTimeout);
-            // Check for race condition with session upgrading
-            if (isGlobalSession(sessionId)) {
-                added = false;
-                localSessionTracker.removeSession(sessionId);
-            } else if (added) {
-              LOG.info(""Adding local session 0x"" + Long.toHexString(sessionId));
-            }
-        } else {
-            added = addGlobalSession(sessionId, sessionTimeout);
+    /**
+     * Synchronized on this to avoid race condition of adding a local session
+     * after committed global session, which may cause the same session being
+     * tracked on this server and leader.
+     */
+    public synchronized boolean commitSession(
+            long sessionId, int sessionTimeout) {
+        boolean added =
+            globalSessionTracker.commitSession(sessionId, sessionTimeout);
+
+        if (added) {
+            LOG.info(""Committing global session 0x"" + Long.toHexString(sessionId));
         }
+
+        // If the session moved before the session upgrade finished, it's
+        // possible that the session will be added to the local session
+        // again. Need to double check and remove it from local session
+        // tracker when the global session is quorum committed, otherwise the
+        // local session might be tracked both locally and on leader.
+        //
+        // This cannot totally avoid the local session being upgraded again
+        // because there is still race condition between create another upgrade
+        // request and process the createSession commit, and there is no way
+        // to know there is a on flying createSession request because it might
+        // be upgraded by other server which owns the session before move.
+        if (localSessionsEnabled) {
+            removeLocalSession(sessionId);
+            finishedUpgrading(sessionId);
+        }
+
         return added;
     }
 
"
zookeeper,cd209456b67cde5aba771b1a240ebe5607398459,ZOOKEEPER-2926: Fix potential data consistency issue due to the session management bug,2018.08.08 13:21:37,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java
index 1cc2ab1..5420494 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java
@@ -58,7 +58,6 @@
     private final long serverId;
     private final AtomicLong nextSessionId = new AtomicLong();
 
-    private final boolean localSessionsEnabled;
     private final ConcurrentMap<Long, Integer> globalSessionsWithTimeouts;
 
     public LearnerSessionTracker(SessionExpirer expirer,
@@ -101,33 +100,44 @@
         return globalSessionsWithTimeouts.containsKey(sessionId);
     }
 
-    public boolean addGlobalSession(long sessionId, int sessionTimeout) {
-        boolean added =
-            globalSessionsWithTimeouts.put(sessionId, sessionTimeout) == null;
-        if (localSessionsEnabled && added) {
-            // Only do extra logging so we know what kind of session this is
-            // if we're supporting both kinds of sessions
-            LOG.info(""Adding global session 0x"" + Long.toHexString(sessionId));
-        }
-        touchTable.get().put(sessionId, sessionTimeout);
-        return added;
+    public boolean trackSession(long sessionId, int sessionTimeout) {
+        // Learner doesn't track global session, do nothing here
+        return false;
     }
 
-    public boolean addSession(long sessionId, int sessionTimeout) {
-        boolean added;
-        if (localSessionsEnabled && !isGlobalSession(sessionId)) {
-            added = localSessionTracker.addSession(sessionId, sessionTimeout);
-            // Check for race condition with session upgrading
-            if (isGlobalSession(sessionId)) {
-                added = false;
-                localSessionTracker.removeSession(sessionId);
-            } else if (added) {
-                LOG.info(""Adding local session 0x""
-                         + Long.toHexString(sessionId));
-            }
-        } else {
-            added = addGlobalSession(sessionId, sessionTimeout);
+    /**
+     * Synchronized on this to avoid race condition of adding a local session
+     * after committed global session, which may cause the same session being
+     * tracked on this server and leader.
+     */
+    public synchronized boolean commitSession(
+            long sessionId, int sessionTimeout) {
+        boolean added =
+            globalSessionsWithTimeouts.put(sessionId, sessionTimeout) == null;
+
+        if (added) {
+            // Only do extra logging so we know what kind of session this is
+            // if we're supporting both kinds of sessions
+            LOG.info(""Committing global session 0x"" + Long.toHexString(sessionId));
         }
+
+        // If the session moved before the session upgrade finished, it's
+        // possible that the session will be added to the local session
+        // again. Need to double check and remove it from local session
+        // tracker when the global session is quorum committed, otherwise the
+        // local session might be tracked both locally and on leader.
+        //
+        // This cannot totally avoid the local session being upgraded again
+        // because there is still race condition between create another upgrade
+        // request and process the createSession commit, and there is no way
+        // to know there is a on flying createSession request because it might
+        // be upgraded by other server which owns the session before move.
+        if (localSessionsEnabled) {
+            removeLocalSession(sessionId);
+            finishedUpgrading(sessionId);
+        }
+
+        touchTable.get().put(sessionId, sessionTimeout);
         return added;
     }
 
@@ -136,7 +146,7 @@
             if (localSessionTracker.touchSession(sessionId, sessionTimeout)) {
                 return true;
             }
-            if (!isGlobalSession(sessionId)) {
+            if (!isGlobalSession(sessionId) && !isUpgradingSession(sessionId)) {
                 return false;
             }
         }
"
zookeeper,cd209456b67cde5aba771b1a240ebe5607398459,ZOOKEEPER-2926: Fix potential data consistency issue due to the session management bug,2018.08.08 13:21:37,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LocalSessionTracker.java b/src/java/main/org/apache/zookeeper/server/quorum/LocalSessionTracker.java
index df6ccb2..523c440 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LocalSessionTracker.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LocalSessionTracker.java
@@ -40,7 +40,9 @@
         return false;
     }
 
-    public boolean addGlobalSession(long sessionId, int sessionTimeout) {
-        throw new UnsupportedOperationException();
+    public long createSession(int sessionTimeout) {
+        long sessionId = super.createSession(sessionTimeout);
+        commitSession(sessionId, sessionTimeout);
+        return sessionId;
     }
 }
"
zookeeper,cd209456b67cde5aba771b1a240ebe5607398459,ZOOKEEPER-2926: Fix potential data consistency issue due to the session management bug,2018.08.08 13:21:37,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/UpgradeableSessionTracker.java b/src/java/main/org/apache/zookeeper/server/quorum/UpgradeableSessionTracker.java
index 2e58ff5..eb50a07 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/UpgradeableSessionTracker.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/UpgradeableSessionTracker.java
@@ -33,7 +33,9 @@
     private static final Logger LOG = LoggerFactory.getLogger(UpgradeableSessionTracker.class);
 
     private ConcurrentMap<Long, Integer> localSessionsWithTimeouts;
+    private ConcurrentMap<Long, Integer> upgradingSessions;
     protected LocalSessionTracker localSessionTracker;
+    protected boolean localSessionsEnabled;
 
     public void start() {}
 
@@ -43,6 +45,7 @@
             new ConcurrentHashMap<Long, Integer>();
         this.localSessionTracker = new LocalSessionTracker(
             expirer, this.localSessionsWithTimeouts, tickTime, id, listener);
+        this.upgradingSessions = new ConcurrentHashMap<Long, Integer>();
     }
 
     public boolean isTrackingSession(long sessionId) {
@@ -54,6 +57,17 @@
             localSessionTracker.isTrackingSession(sessionId);
     }
 
+    public boolean isUpgradingSession(long sessionId) {
+        return upgradingSessions != null &&
+            upgradingSessions.containsKey(sessionId);
+    }
+
+    public void finishedUpgrading(long sessionId) {
+        if (upgradingSessions != null) {
+            upgradingSessions.remove(sessionId);
+        }
+    }
+
     abstract public boolean isGlobalSession(long sessionId);
 
     /**
@@ -74,14 +88,27 @@
         Integer timeout = localSessionsWithTimeouts.remove(sessionId);
         if (timeout != null) {
             LOG.info(""Upgrading session 0x"" + Long.toHexString(sessionId));
-            // Add as global before removing as local
-            addGlobalSession(sessionId, timeout);
+            // Track global session, which will add to global session tracker
+            // on leader and do nothing on learner. Need to start track global
+            // session in leader now to update the session expire between
+            // LeaderRequestProcessor and PrepRequestProcessor.
+            trackSession(sessionId, timeout);
+            // Track ongoing upgrading sessions, learner will use it to find
+            // other sessions it has which are not in local and global sessions
+            upgradingSessions.put(sessionId, timeout);
             localSessionTracker.removeSession(sessionId);
             return timeout;
         }
         return -1;
     }
 
+    protected void removeLocalSession(long sessionId) {
+         if (localSessionTracker == null) {
+            return;
+        }
+        localSessionTracker.removeSession(sessionId);
+    }
+
     public void checkGlobalSession(long sessionId, Object owner)
             throws KeeperException.SessionExpiredException,
             KeeperException.SessionMovedException {
"
zookeeper,148c2cd6ba73e66b1879a2e10ecda4ce4e0e2c7b,ZOOKEEPER-3104: Fix data inconsistency due to NEWLEADER being sent too early,2018.08.04 01:52:08,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index 023d6a6..9b65246 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -74,7 +74,7 @@
      * on the syncLimit. Once the deadline is past this learner should
      * be considered no longer ""sync'd"" with the leader. */
     volatile long tickOfNextAckDeadline;
-    
+
     /**
      * ZooKeeper server identifier of this learner
      */
@@ -159,7 +159,7 @@
 
     private final BufferedInputStream bufferedInput;
     private BufferedOutputStream bufferedOutput;
-    
+
     /**
      * Keep track of whether we have started send packets thread
      */
@@ -176,7 +176,7 @@
      * that we are going to blast it to the learner
      */
     private boolean needOpPacket = true;
-    
+
     /**
      * Last zxid sent to the learner as part of synchronization
      */
@@ -188,6 +188,11 @@
         this.leader = leader;
         this.bufferedInput = bufferedInput;
 
+        if (Boolean.getBoolean(FORCE_SNAP_SYNC)) {
+            forceSnapSync = true;
+            LOG.info(""Forcing snapshot sync is enabled"");
+        }
+
         try {
             if (leader.self != null) {
                 leader.self.authServer.authenticate(sock,
@@ -403,7 +408,7 @@
             } else {
                 LOG.info(""Follower sid: "" + this.sid + "" not in the current config "" + Long.toHexString(leader.self.getQuorumVerifier().getVersion()));
             }
-                        
+
             if (qp.getType() == Leader.OBSERVERINFO) {
                   learnerType = LearnerType.OBSERVER;
             }
@@ -440,11 +445,38 @@
                 leader.waitForEpochAck(this.getSid(), ss);
             }
             peerLastZxid = ss.getLastZxid();
-           
+
             // Take any necessary action if we need to send TRUNC or DIFF
             // startForwarding() will be called in all cases
             boolean needSnap = syncFollower(peerLastZxid, leader.zk.getZKDatabase(), leader);
-            
+
+            /* if we are not truncating or sending a diff just send a snapshot */
+            if (needSnap) {
+                boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;
+                LearnerSnapshot snapshot =
+                        leader.getLearnerSnapshotThrottler().beginSnapshot(exemptFromThrottle);
+                try {
+                    long zxidToSend = leader.zk.getZKDatabase().getDataTreeLastProcessedZxid();
+                    oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), ""packet"");
+                    bufferedOutput.flush();
+
+                    LOG.info(""Sending snapshot last zxid of peer is 0x{}, zxid of leader is 0x{}, ""
+                            + ""send zxid of db as 0x{}, {} concurrent snapshots, ""
+                            + ""snapshot was {} from throttle"",
+                            Long.toHexString(peerLastZxid),
+                            Long.toHexString(leaderLastZxid),
+                            Long.toHexString(zxidToSend),
+                            snapshot.getConcurrentSnapshotNumber(),
+                            snapshot.isEssential() ? ""exempt"" : ""not exempt"");
+                    // Dump data to peer
+                    leader.zk.getZKDatabase().serializeSnapshot(oa);
+                    oa.writeString(""BenWasHere"", ""signature"");
+                    bufferedOutput.flush();
+                } finally {
+                    snapshot.close();
+                }
+            }
+
             LOG.debug(""Sending NEWLEADER message to "" + sid);
             // the version of this quorumVerifier will be set by leader.lead() in case
             // the leader is just being established. waitForEpochAck makes sure that readyToStart is true if
@@ -461,36 +493,9 @@
             }
             bufferedOutput.flush();
 
-            /* if we are not truncating or sending a diff just send a snapshot */
-            if (needSnap) {
-                boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;
-                LearnerSnapshot snapshot = 
-                        leader.getLearnerSnapshotThrottler().beginSnapshot(exemptFromThrottle);
-                try {
-                    long zxidToSend = leader.zk.getZKDatabase().getDataTreeLastProcessedZxid();
-                    oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), ""packet"");
-                    bufferedOutput.flush();
-
-                    LOG.info(""Sending snapshot last zxid of peer is 0x{}, zxid of leader is 0x{}, ""
-                            + ""send zxid of db as 0x{}, {} concurrent snapshots, "" 
-                            + ""snapshot was {} from throttle"",
-                            Long.toHexString(peerLastZxid), 
-                            Long.toHexString(leaderLastZxid),
-                            Long.toHexString(zxidToSend), 
-                            snapshot.getConcurrentSnapshotNumber(),
-                            snapshot.isEssential() ? ""exempt"" : ""not exempt"");
-                    // Dump data to peer
-                    leader.zk.getZKDatabase().serializeSnapshot(oa);
-                    oa.writeString(""BenWasHere"", ""signature"");
-                    bufferedOutput.flush();
-                } finally {
-                    snapshot.close();
-                }
-            }
-
             // Start thread that blast packets in the queue to learner
             startSendingPackets();
-            
+
             /*
              * Have to wait for the first ACK, wait until
              * the leader is ready, and only then we can
@@ -505,12 +510,12 @@
             }
 
             if(LOG.isDebugEnabled()){
-            	LOG.debug(""Received NEWLEADER-ACK message from "" + sid);   
+            	LOG.debug(""Received NEWLEADER-ACK message from "" + sid);
             }
             leader.waitForNewLeaderAck(getSid(), qp.getZxid());
 
             syncLimitCheck.start();
-            
+
             // now that the ack has been processed expect the syncLimit
             sock.setSoTimeout(leader.self.tickTime * leader.self.syncLimit);
 
@@ -526,7 +531,7 @@
             // so we need to mark when the peer can actually start
             // using the data
             //
-            LOG.debug(""Sending UPTODATE message to "" + sid);      
+            LOG.debug(""Sending UPTODATE message to "" + sid);
             queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));
 
             while (true) {
@@ -920,8 +925,8 @@
         }
 
         return queuedZxid;
-    }    
-    
+    }
+
     public void shutdown() {
         // Send the packet of death
         try {
@@ -975,7 +980,7 @@
         QuorumPacket packet = new QuorumPacket(type, zxid, null, null);
         queuePacket(packet);
     }
-    
+
     void queuePacket(QuorumPacket p) {
         queuedPackets.add(p);
     }
@@ -984,7 +989,7 @@
         return isAlive()
         && leader.self.tick.get() <= tickOfNextAckDeadline;
     }
-    
+
     /**
      * For testing, return packet queue
      * @return
"
zookeeper,78e4a1047c701006dd4ec8d09065eda0e7adedb5,ZOOKEEPER-3082: Fix server snapshot behavior when out of disk space,2018.07.30 13:22:23,Brian Nixon,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 76478c4..e6d2998 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -50,12 +50,12 @@
 public class FileTxnSnapLog {
     //the directory containing the
     //the transaction logs
-    private final File dataDir;
+    final File dataDir;
     //the directory containing the
     //the snapshot directory
-    private final File snapDir;
-    private TxnLog txnLog;
-    private SnapShot snapLog;
+    final File snapDir;
+    TxnLog txnLog;
+    SnapShot snapLog;
     private final boolean autoCreateDB;
     public final static int VERSION = 2;
     public final static String version = ""version-"";
@@ -399,8 +399,30 @@
         File snapshotFile = new File(snapDir, Util.makeSnapshotName(lastZxid));
         LOG.info(""Snapshotting: 0x{} to {}"", Long.toHexString(lastZxid),
                 snapshotFile);
-        snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);
-
+        try {
+            snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);
+        } catch (IOException e) {
+            if (snapshotFile.length() == 0) {
+                /* This may be caused by a full disk. In such a case, the server
+                 * will get stuck in a loop where it tries to write a snapshot
+                 * out to disk, and ends up creating an empty file instead.
+                 * Doing so will eventually result in valid snapshots being
+                 * removed during cleanup. */
+                if (snapshotFile.delete()) {
+                    LOG.info(""Deleted empty snapshot file: "" +
+                             snapshotFile.getAbsolutePath());
+                } else {
+                    LOG.warn(""Could not delete empty snapshot file: "" +
+                             snapshotFile.getAbsolutePath());
+                }
+            } else {
+                /* Something else went wrong when writing the snapshot out to
+                 * disk. If this snapshot file is invalid, when restarting,
+                 * ZooKeeper will skip it, and find the last known good snapshot
+                 * instead. */
+            }
+            throw e;
+        }
     }
 
     /**
"
zookeeper,2a372fcdce3c0142c0bb23f06098a2c1a49f807e,ZOOKEEPER-3072: Throttle race condition fix,2018.07.28 11:37:08,Botond Hejj,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index b0e2d64..9596908 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -1130,24 +1130,22 @@
                 cnxn.disableRecv();
             }
             return;
+        } else if (h.getType() == OpCode.sasl) {
+            Record rsp = processSasl(incomingBuffer,cnxn);
+            ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());
+            cnxn.sendResponse(rh,rsp, ""response""); // not sure about 3rd arg..what is it?
+            return;
         } else {
-            if (h.getType() == OpCode.sasl) {
-                Record rsp = processSasl(incomingBuffer,cnxn);
-                ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());
-                cnxn.sendResponse(rh,rsp, ""response""); // not sure about 3rd arg..what is it?
-                return;
-            }
-            else {
-                Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),
-                  h.getType(), incomingBuffer, cnxn.getAuthInfo());
-                si.setOwner(ServerCnxn.me);
-                // Always treat packet from the client as a possible
-                // local request.
-                setLocalSessionFlag(si);
-                submitRequest(si);
-            }
+            cnxn.incrOutstandingRequests(h);
+            Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),
+              h.getType(), incomingBuffer, cnxn.getAuthInfo());
+            si.setOwner(ServerCnxn.me);
+            // Always treat packet from the client as a possible
+            // local request.
+            setLocalSessionFlag(si);
+            submitRequest(si);
+            return;
         }
-        cnxn.incrOutstandingRequests(h);
     }
 
     private Record processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn) throws IOException {
"
zookeeper,9f82798415351a20136ceb1640b1781723e51cc1,ZOOKEEPER-2251: Add Client side packet response timeout to avoid infinite wait.,2018.07.27 12:16:04,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index ba601bc..b28c980 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -201,6 +201,11 @@
     public ZooKeeperSaslClient zooKeeperSaslClient;
 
     private final ZKClientConfig clientConfig;
+    /**
+     * If any request's response in not received in configured requestTimeout
+     * then it is assumed that the response packet is lost.
+     */
+    private long requestTimeout;
 
     public long getSessionId() {
         return sessionId;
@@ -395,6 +400,7 @@
         sendThread = new SendThread(clientCnxnSocket);
         eventThread = new EventThread();
         this.clientConfig=zooKeeper.getClientConfig();
+        initRequestTimeout();
     }
 
     public void start() {
@@ -671,7 +677,8 @@
        }
     }
 
-    private void finishPacket(Packet p) {
+    // @VisibleForTesting
+    protected void finishPacket(Packet p) {
         int err = p.replyHeader.getErr();
         if (p.watchRegistration != null) {
             p.watchRegistration.register(err);
@@ -1246,15 +1253,7 @@
                         }
                         // At this point, there might still be new packets appended to outgoingQueue.
                         // they will be handled in next connection or cleared up if closed.
-                        cleanup();
-                        if (state.isAlive()) {
-                            eventThread.queueEvent(new WatchedEvent(
-                                    Event.EventType.None,
-                                    Event.KeeperState.Disconnected,
-                                    null));
-                        }
-                        clientCnxnSocket.updateNow();
-                        clientCnxnSocket.updateLastSendAndHeard();
+                        cleanAndNotifyState();
                     }
                 }
             }
@@ -1275,6 +1274,16 @@
                            + Long.toHexString(getSessionId()));
         }
 
+        private void cleanAndNotifyState() {
+            cleanup();
+            if (state.isAlive()) {
+                eventThread.queueEvent(new WatchedEvent(Event.EventType.None,
+                        Event.KeeperState.Disconnected, null));
+            }
+            clientCnxnSocket.updateNow();
+            clientCnxnSocket.updateLastSendAndHeard();
+        }
+
         private void pingRwServer() throws RWServerFoundException {
             String result = null;
             InetSocketAddress addr = hostProvider.next(0);
@@ -1506,13 +1515,40 @@
         Packet packet = queuePacket(h, r, request, response, null, null, null,
                 null, watchRegistration, watchDeregistration);
         synchronized (packet) {
-            while (!packet.finished) {
-                packet.wait();
+            if (requestTimeout > 0) {
+                // Wait for request completion with timeout
+                waitForPacketFinish(r, packet);
+            } else {
+                // Wait for request completion infinitely
+                while (!packet.finished) {
+                    packet.wait();
+                }
             }
         }
+        if (r.getErr() == Code.REQUESTTIMEOUT.intValue()) {
+            sendThread.cleanAndNotifyState();
+        }
         return r;
     }
 
+    /**
+     * Wait for request completion with timeout.
+     */
+    private void waitForPacketFinish(ReplyHeader r, Packet packet)
+            throws InterruptedException {
+        long waitStartTime = Time.currentElapsedTime();
+        while (!packet.finished) {
+            packet.wait(requestTimeout);
+            if (!packet.finished && ((Time.currentElapsedTime()
+                    - waitStartTime) >= requestTimeout)) {
+                LOG.error(""Timeout error occurred for the packet '{}'."",
+                        packet);
+                r.setErr(Code.REQUESTTIMEOUT.intValue());
+                break;
+            }
+        }
+    }
+
     public void saslCompleted() {
         sendThread.getClientCnxnSocket().saslCompleted();
     }
@@ -1603,4 +1639,22 @@
             this.ctx = ctx;
         }
     }
+
+    private void initRequestTimeout() {
+        try {
+            requestTimeout = clientConfig.getLong(
+                    ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT,
+                    ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT_DEFAULT);
+            LOG.info(""{} value is {}. feature enabled="",
+                    ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT,
+                    requestTimeout, requestTimeout > 0);
+        } catch (NumberFormatException e) {
+            LOG.error(
+                    ""Configured value {} for property {} can not be parsed to long."",
+                    clientConfig.getProperty(
+                            ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT),
+                    ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT);
+            throw e;
+        }
+    }
 }
"
zookeeper,9f82798415351a20136ceb1640b1781723e51cc1,ZOOKEEPER-2251: Add Client side packet response timeout to avoid infinite wait.,2018.07.27 12:16:04,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/KeeperException.java b/src/java/main/org/apache/zookeeper/KeeperException.java
index 143fac5..f797bb0 100644
--- a/src/java/main/org/apache/zookeeper/KeeperException.java
+++ b/src/java/main/org/apache/zookeeper/KeeperException.java
@@ -144,6 +144,8 @@
                 return new NoWatcherException();
             case RECONFIGDISABLED:
                 return new ReconfigDisabledException();
+            case REQUESTTIMEOUT:
+                return new RequestTimeoutException();
             case OK:
             default:
                 throw new IllegalArgumentException(""Invalid exception code"");
@@ -392,6 +394,8 @@
         EPHEMERALONLOCALSESSION (EphemeralOnLocalSession),
         /** Attempts to remove a non-existing watcher */
         NOWATCHER (-121),
+        /** Request not completed within max allowed time.*/
+        REQUESTTIMEOUT (-122),
         /** Attempts to perform a reconfiguration operation when reconfiguration feature is disabled. */
         RECONFIGDISABLED(-123);
 
@@ -843,4 +847,13 @@
             super(Code.RECONFIGDISABLED, path);
         }
     }
+
+    /**
+     * @see Code#REQUESTTIMEOUT
+     */
+    public static class RequestTimeoutException extends KeeperException {
+        public RequestTimeoutException() {
+            super(Code.REQUESTTIMEOUT);
+        }
+    }
 }
"
zookeeper,9f82798415351a20136ceb1640b1781723e51cc1,ZOOKEEPER-2251: Add Client side packet response timeout to avoid infinite wait.,2018.07.27 12:16:04,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index ebcc500..6cac98e 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -876,12 +876,21 @@
                 connectString);
         hostProvider = aHostProvider;
 
-        cnxn = new ClientCnxn(connectStringParser.getChrootPath(),
+        cnxn = createConnection(connectStringParser.getChrootPath(),
                 hostProvider, sessionTimeout, this, watchManager,
                 getClientCnxnSocket(), canBeReadOnly);
         cnxn.start();
     }
 
+    // @VisibleForTesting
+    protected ClientCnxn createConnection(String chrootPath,
+            HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,
+            ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,
+            boolean canBeReadOnly) throws IOException {
+        return new ClientCnxn(chrootPath, hostProvider, sessionTimeout, this,
+                watchManager, clientCnxnSocket, canBeReadOnly);
+    }
+
     /**
      * To create a ZooKeeper client object, the application needs to pass a
      * connection string containing a comma separated list of host:port pairs,
"
zookeeper,9f82798415351a20136ceb1640b1781723e51cc1,ZOOKEEPER-2251: Add Client side packet response timeout to avoid infinite wait.,2018.07.27 12:16:04,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/client/ZKClientConfig.java b/src/java/main/org/apache/zookeeper/client/ZKClientConfig.java
index 3c10627..097f2f0 100644
--- a/src/java/main/org/apache/zookeeper/client/ZKClientConfig.java
+++ b/src/java/main/org/apache/zookeeper/client/ZKClientConfig.java
@@ -56,9 +56,15 @@
     @SuppressWarnings(""deprecation"")
     public static final String SECURE_CLIENT = ZooKeeper.SECURE_CLIENT;
     public static final int CLIENT_MAX_PACKET_LENGTH_DEFAULT = 4096 * 1024; /* 4 MB */
+    public static final String ZOOKEEPER_REQUEST_TIMEOUT = ""zookeeper.request.timeout"";
+    /**
+     * Feature is disabled by default.
+     */
+    public static final long ZOOKEEPER_REQUEST_TIMEOUT_DEFAULT = 0;
 
     public ZKClientConfig() {
         super();
+        initFromJavaSystemProperties();
     }
 
     public ZKClientConfig(File configFile) throws ConfigException {
@@ -69,6 +75,15 @@
         super(configPath);
     }
 
+    /**
+     * Initialize all the ZooKeeper client properties which are configurable as
+     * java system property
+     */
+    private void initFromJavaSystemProperties() {
+        setProperty(ZOOKEEPER_REQUEST_TIMEOUT,
+                System.getProperty(ZOOKEEPER_REQUEST_TIMEOUT));
+    }
+
     @Override
     protected void handleBackwardCompatibility() {
         /**
@@ -100,4 +115,26 @@
     public boolean isSaslClientEnabled() {
         return Boolean.valueOf(getProperty(ENABLE_CLIENT_SASL_KEY, ENABLE_CLIENT_SASL_DEFAULT));
     }
+
+    /**
+     * Get the value of the <code>key</code> property as an <code>long</code>.
+     * If property is not set, the provided <code>defaultValue</code> is
+     * returned
+     *
+     * @param key
+     *            property key.
+     * @param defaultValue
+     *            default value.
+     * @throws NumberFormatException
+     *             when the value is invalid
+     * @return return property value as an <code>long</code>, or
+     *         <code>defaultValue</code>
+     */
+    public long getLong(String key, long defaultValue) {
+        String value = getProperty(key);
+        if (value != null) {
+            return Long.parseLong(value.trim());
+        }
+        return defaultValue;
+    }
 }
"
zookeeper,0a311873deb1847703c9b62716c626ce43d4ba48,ZOOKEEPER-2184: Zookeeper Client should re-resolve hosts when connection attempts fail,2018.07.16 12:45:45,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/client/HostProvider.java b/src/java/main/org/apache/zookeeper/client/HostProvider.java
index ec3ca97..caeedcc 100644
--- a/src/java/main/org/apache/zookeeper/client/HostProvider.java
+++ b/src/java/main/org/apache/zookeeper/client/HostProvider.java
@@ -34,8 +34,9 @@
  * 
  * * The size() of a HostProvider may never be zero.
  * 
- * A HostProvider must return resolved InetSocketAddress instances on next(),
- * but it's up to the HostProvider, when it wants to do the resolving.
+ * A HostProvider must return resolved InetSocketAddress instances on next() if the next address is resolvable.
+ * In that case, it's up to the HostProvider, whether it returns the next resolvable address in the list or return
+ * the next one as UnResolved.
  * 
  * Different HostProvider could be imagined:
  * 
"
zookeeper,0a311873deb1847703c9b62716c626ce43d4ba48,ZOOKEEPER-2184: Zookeeper Client should re-resolve hosts when connection attempts fail,2018.07.16 12:45:45,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
index cb53936..0602103 100644
--- a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
+++ b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
@@ -22,6 +22,7 @@
 import java.net.InetSocketAddress;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
@@ -32,11 +33,19 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * Most simple HostProvider, resolves only on instantiation.
- * 
+ * Most simple HostProvider, resolves on every next() call.
+ *
+ * Please be aware that although this class doesn't do any DNS caching, there're multiple levels of caching already
+ * present across the stack like in JVM, OS level, hardware, etc. The best we could do here is to get the most recent
+ * address from the underlying system which is considered up-to-date.
+ *
  */
 @InterfaceAudience.Public
 public final class StaticHostProvider implements HostProvider {
+    public interface Resolver {
+        InetAddress[] getAllByName(String name) throws UnknownHostException;
+    }
+
     private static final Logger LOG = LoggerFactory
             .getLogger(StaticHostProvider.class);
 
@@ -64,6 +73,8 @@
 
     private float pOld, pNew;
 
+    private Resolver resolver;
+
     /**
      * Constructs a SimpleHostSet.
      * 
@@ -73,15 +84,29 @@
      *             if serverAddresses is empty or resolves to an empty list
      */
     public StaticHostProvider(Collection<InetSocketAddress> serverAddresses) {
-       sourceOfRandomness = new Random(System.currentTimeMillis() ^ this.hashCode());
+        init(serverAddresses,
+                System.currentTimeMillis() ^ this.hashCode(),
+                new Resolver() {
+            @Override
+            public InetAddress[] getAllByName(String name) throws UnknownHostException {
+                return InetAddress.getAllByName(name);
+            }
+        });
+    }
 
-        this.serverAddresses = resolveAndShuffle(serverAddresses);
-        if (this.serverAddresses.isEmpty()) {
-            throw new IllegalArgumentException(
-                    ""A HostProvider may not be empty!"");
-        }       
-        currentIndex = -1;
-        lastIndex = -1;              
+    /**
+     * Constructs a SimpleHostSet.
+     *
+     * Introduced for testing purposes. getAllByName() is a static method of InetAddress, therefore cannot be easily mocked.
+     * By abstraction of Resolver interface we can easily inject a mocked implementation in tests.
+     *
+     * @param serverAddresses
+     *              possibly unresolved ZooKeeper server addresses
+     * @param resolver
+     *              custom resolver implementation
+     */
+    public StaticHostProvider(Collection<InetSocketAddress> serverAddresses, Resolver resolver) {
+        init(serverAddresses, System.currentTimeMillis() ^ this.hashCode(), resolver);
     }
 
     /**
@@ -96,36 +121,47 @@
      */
     public StaticHostProvider(Collection<InetSocketAddress> serverAddresses,
         long randomnessSeed) {
-        sourceOfRandomness = new Random(randomnessSeed);
-
-        this.serverAddresses = resolveAndShuffle(serverAddresses);
-        if (this.serverAddresses.isEmpty()) {
-            throw new IllegalArgumentException(
-                    ""A HostProvider may not be empty!"");
-        }       
-        currentIndex = -1;
-        lastIndex = -1;              
+        init(serverAddresses, randomnessSeed, new Resolver() {
+            @Override
+            public InetAddress[] getAllByName(String name) throws UnknownHostException {
+                return InetAddress.getAllByName(name);
+            }
+        });
     }
 
-    private List<InetSocketAddress> resolveAndShuffle(Collection<InetSocketAddress> serverAddresses) {
-        List<InetSocketAddress> tmpList = new ArrayList<InetSocketAddress>(serverAddresses.size());       
-        for (InetSocketAddress address : serverAddresses) {
-            try {
-                InetAddress ia = address.getAddress();
-                String addr = (ia != null) ? ia.getHostAddress() : address.getHostString();
-                InetAddress resolvedAddresses[] = InetAddress.getAllByName(addr);
-                for (InetAddress resolvedAddress : resolvedAddresses) {
-                    InetAddress taddr = InetAddress.getByAddress(address.getHostString(), resolvedAddress.getAddress());
-                    tmpList.add(new InetSocketAddress(taddr, address.getPort()));
-                }
-            } catch (UnknownHostException ex) {
-                LOG.warn(""No IP address found for server: {}"", address, ex);
-            }
+    private void init(Collection<InetSocketAddress> serverAddresses, long randomnessSeed, Resolver resolver) {
+        this.sourceOfRandomness = new Random(randomnessSeed);
+        this.resolver = resolver;
+        if (serverAddresses.isEmpty()) {
+            throw new IllegalArgumentException(
+                    ""A HostProvider may not be empty!"");
         }
+        this.serverAddresses = shuffle(serverAddresses);
+        currentIndex = -1;
+        lastIndex = -1;
+    }
+
+    private InetSocketAddress resolve(InetSocketAddress address) {
+        try {
+            String curHostString = address.getHostString();
+            List<InetAddress> resolvedAddresses = new ArrayList<>(Arrays.asList(this.resolver.getAllByName(curHostString)));
+            if (resolvedAddresses.isEmpty()) {
+                return address;
+            }
+            Collections.shuffle(resolvedAddresses);
+            return new InetSocketAddress(resolvedAddresses.get(0), address.getPort());
+        } catch (UnknownHostException e) {
+            LOG.error(""Unable to resolve address: {}"", address.toString(), e);
+            return address;
+        }
+    }
+
+    private List<InetSocketAddress> shuffle(Collection<InetSocketAddress> serverAddresses) {
+        List<InetSocketAddress> tmpList = new ArrayList<>(serverAddresses.size());
+        tmpList.addAll(serverAddresses);
         Collections.shuffle(tmpList, sourceOfRandomness);
         return tmpList;
-    } 
-
+    }
 
     /**
      * Update the list of servers. This returns true if changing connections is necessary for load-balancing, false
@@ -149,15 +185,12 @@
      * @param currentHost the host to which this client is currently connected
      * @return true if changing connections is necessary for load-balancing, false otherwise  
      */
-
-
     @Override
     public synchronized boolean updateServerList(
             Collection<InetSocketAddress> serverAddresses,
             InetSocketAddress currentHost) {
-        // Resolve server addresses and shuffle them
-        List<InetSocketAddress> resolvedList = resolveAndShuffle(serverAddresses);
-        if (resolvedList.isEmpty()) {
+        List<InetSocketAddress> shuffledList = shuffle(serverAddresses);
+        if (shuffledList.isEmpty()) {
             throw new IllegalArgumentException(
                     ""A HostProvider may not be empty!"");
         }
@@ -183,7 +216,7 @@
             }
         }
 
-        for (InetSocketAddress addr : resolvedList) {
+        for (InetSocketAddress addr : shuffledList) {
             if (addr.getPort() == myServer.getPort()
                     && ((addr.getAddress() != null
                             && myServer.getAddress() != null && addr
@@ -200,11 +233,11 @@
         oldServers.clear();
         // Divide the new servers into oldServers that were in the previous list
         // and newServers that were not in the previous list
-        for (InetSocketAddress resolvedAddress : resolvedList) {
-            if (this.serverAddresses.contains(resolvedAddress)) {
-                oldServers.add(resolvedAddress);
+        for (InetSocketAddress address : shuffledList) {
+            if (this.serverAddresses.contains(address)) {
+                oldServers.add(address);
             } else {
-                newServers.add(resolvedAddress);
+                newServers.add(address);
             }
         }
 
@@ -245,11 +278,11 @@
         }
 
         if (!reconfigMode) {
-            currentIndex = resolvedList.indexOf(getServerAtCurrentIndex());
+            currentIndex = shuffledList.indexOf(getServerAtCurrentIndex());
         } else {
             currentIndex = -1;
         }
-        this.serverAddresses = resolvedList;
+        this.serverAddresses = shuffledList;
         currentIndexOld = -1;
         currentIndexNew = -1;
         lastIndex = currentIndex;
@@ -314,7 +347,7 @@
                 addr = nextHostInReconfigMode();
                 if (addr != null) {
                 	currentIndex = serverAddresses.indexOf(addr);
-                	return addr;                
+                	return resolve(addr);
                 }
                 //tried all servers and couldn't connect
                 reconfigMode = false;
@@ -339,7 +372,7 @@
             }
         }
 
-        return addr;
+        return resolve(addr);
     }
 
     public synchronized void onConnected() {
"
zookeeper,b593a8de1cc48534661526685e39d812aa680d36,ZOOKEEPER-2886: Permanent session moved error in multi-op only conne…,2018.07.10 19:46:36,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index 2f60f78..696c5e5 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -170,6 +170,9 @@
             }
 
             KeeperException ke = request.getException();
+            if (ke instanceof SessionMovedException) {
+                throw ke;
+            }
             if (ke != null && request.type != OpCode.multi) {
                 throw ke;
             }
@@ -228,6 +231,9 @@
                             break;
                         case OpCode.error:
                             subResult = new ErrorResult(subTxnResult.err) ;
+                            if (subTxnResult.err == Code.SESSIONMOVED.intValue()) {
+                                throw new SessionMovedException();
+                            }
                             break;
                         default:
                             throw new IOException(""Invalid type of op"");
"
zookeeper,1fb644662b8e0530dec2c5668a3e49b3f614e9de,ZOOKEEPER-3059: EventThread leak in case of Sasl AuthFailed,2018.06.25 19:30:19,Abhishek Singh Chouhan,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 2eef575..ba601bc 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -820,7 +820,8 @@
                 if(replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) {
                     state = States.AUTH_FAILED;                    
                     eventThread.queueEvent( new WatchedEvent(Watcher.Event.EventType.None, 
-                            Watcher.Event.KeeperState.AuthFailed, null) );            		            		
+                            Watcher.Event.KeeperState.AuthFailed, null) );
+                    eventThread.queueEventOfDeath();
                 }
                 if (LOG.isDebugEnabled()) {
                     LOG.debug(""Got auth sessionid:0x""
@@ -1164,6 +1165,9 @@
                                 eventThread.queueEvent(new WatchedEvent(
                                       Watcher.Event.EventType.None,
                                       authState,null));
+                                if (state == States.AUTH_FAILED) {
+                                  eventThread.queueEventOfDeath();
+                                }
                             }
                         }
                         to = readTimeout - clientCnxnSocket.getIdleRecv();
"
zookeeper,13dd5d0db7a5c4fa926d1e44fc2047c24d5d012c,ZOOKEEPER-3009: Potential NPE in NIOServerCnxnFactory,2018.06.15 15:02:41,LJ1043041006,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
index 7a72757..e343bc0 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
@@ -815,8 +815,11 @@
         cnxnExpiryQueue.update(cnxn, cnxn.getSessionTimeout());
     }
 
-    private void addCnxn(NIOServerCnxn cnxn) {
+    private void addCnxn(NIOServerCnxn cnxn) throws IOException {
         InetAddress addr = cnxn.getSocketAddress();
+        if (addr == null) {
+            throw new IOException(""Socket of "" + cnxn + "" has been closed"");
+        }
         Set<NIOServerCnxn> set = ipMap.get(addr);
         if (set == null) {
             // in general we will see 1 connection from each
"
zookeeper,24f093b9c10bcfa5f890f378087e48736ed5bac5,ZOOKEEPER-3051: Updated jackson to the latest version,2018.05.23 12:34:19,Patrick Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/admin/JsonOutputter.java b/src/java/main/org/apache/zookeeper/server/admin/JsonOutputter.java
index f680894..566444f 100644
--- a/src/java/main/org/apache/zookeeper/server/admin/JsonOutputter.java
+++ b/src/java/main/org/apache/zookeeper/server/admin/JsonOutputter.java
@@ -18,18 +18,17 @@
 
 package org.apache.zookeeper.server.admin;
 
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.util.Map;
-
-import org.codehaus.jackson.JsonGenerationException;
-import org.codehaus.jackson.map.JsonMappingException;
-import org.codehaus.jackson.map.ObjectMapper;
-import org.codehaus.jackson.map.PropertyNamingStrategy;
-import org.codehaus.jackson.map.SerializationConfig;
+import com.fasterxml.jackson.core.JsonGenerationException;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.PropertyNamingStrategy;
+import com.fasterxml.jackson.databind.SerializationFeature;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.IOException;
+import java.io.PrintWriter;
+
 public class JsonOutputter implements CommandOutputter {
     static final Logger LOG = LoggerFactory.getLogger(JsonOutputter.class);
 
@@ -39,9 +38,9 @@
 
     public JsonOutputter() {
         mapper = new ObjectMapper();
-        mapper.configure(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING, true);
-        mapper.configure(SerializationConfig.Feature.INDENT_OUTPUT, true);
-        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES);
+        mapper.configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING, true);
+        mapper.configure(SerializationFeature.INDENT_OUTPUT, true);
+        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
     }
 
     @Override
"
zookeeper,dacd27568c0a20244d40f42ff8ee84b5f917128e,"ZOOKEEPER-3041: Typo in error message, affects log analysis; charater --> character",2018.05.17 02:30:31,Hugh O'Brien,"diff --git a/src/java/main/org/apache/zookeeper/common/PathUtils.java b/src/java/main/org/apache/zookeeper/common/PathUtils.java
index 3462c61..d80feab 100644
--- a/src/java/main/org/apache/zookeeper/common/PathUtils.java
+++ b/src/java/main/org/apache/zookeeper/common/PathUtils.java
@@ -90,7 +90,7 @@
                     || c >= '\u007f' && c <= '\u009F'
                     || c >= '\ud800' && c <= '\uf8ff'
                     || c >= '\ufff0' && c <= '\uffff') {
-                reason = ""invalid charater @"" + i;
+                reason = ""invalid character @"" + i;
                 break;
             }
         }
"
zookeeper,2fa315b7d0ed65828479fcdcc9e76ca8552fba4a,ZOOKEEPER-3039: TxnLogToolkit uses Scanner badly,2018.05.11 05:14:24,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/TxnLogToolkit.java b/src/java/main/org/apache/zookeeper/server/persistence/TxnLogToolkit.java
index c6703ea..887d98b 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/TxnLogToolkit.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/TxnLogToolkit.java
@@ -39,8 +39,6 @@
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.Reader;
 import java.text.DateFormat;
 import java.util.Date;
 import java.util.Scanner;
@@ -98,7 +96,7 @@
      */
     public static void main(String[] args) throws Exception {
         try (final TxnLogToolkit lt = parseCommandLine(args)) {
-            lt.dump(new InputStreamReader(System.in));
+            lt.dump(new Scanner(System.in));
             lt.printStat();
         } catch (TxnLogToolkitParseException e) {
             System.err.println(e.getMessage() + ""\n"");
@@ -131,7 +129,7 @@
         }
     }
 
-    public void dump(Reader input) throws Exception {
+    public void dump(Scanner scanner) throws Exception {
         crcFixed = 0;
 
         FileHeader fhdr = new FileHeader();
@@ -172,7 +170,7 @@
                 if (recoveryMode) {
                     if (!force) {
                         printTxn(bytes, ""CRC ERROR"");
-                        if (askForFix(input)) {
+                        if (askForFix(scanner)) {
                             crcValue = crc.getValue();
                             ++crcFixed;
                         }
@@ -201,19 +199,17 @@
         }
     }
 
-    private boolean askForFix(Reader input) throws TxnLogToolkitException {
-        try (Scanner scanner = new Scanner(input)) {
-            while (true) {
-                System.out.print(""Would you like to fix it (Yes/No/Abort) ? "");
-                char answer = Character.toUpperCase(scanner.next().charAt(0));
-                switch (answer) {
-                    case 'Y':
-                        return true;
-                    case 'N':
-                        return false;
-                    case 'A':
-                        throw new TxnLogToolkitException(0, ""Recovery aborted."");
-                }
+    private boolean askForFix(Scanner scanner) throws TxnLogToolkitException {
+        while (true) {
+            System.out.print(""Would you like to fix it (Yes/No/Abort) ? "");
+            char answer = Character.toUpperCase(scanner.next().charAt(0));
+            switch (answer) {
+                case 'Y':
+                    return true;
+                case 'N':
+                    return false;
+                case 'A':
+                    throw new TxnLogToolkitException(0, ""Recovery aborted."");
             }
         }
     }
"
zookeeper,6e64125f2aafc29253904c43ee44233c907e5fca,ZOOKEEPER-3038: Cleanup some nitpicks in TTL implementation,2018.05.10 13:13:16,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/EphemeralType.java b/src/java/main/org/apache/zookeeper/server/EphemeralType.java
index 7861d40..f5d58ae 100644
--- a/src/java/main/org/apache/zookeeper/server/EphemeralType.java
+++ b/src/java/main/org/apache/zookeeper/server/EphemeralType.java
@@ -166,7 +166,7 @@
     public static EphemeralType get(long ephemeralOwner) {
         if (extendedEphemeralTypesEnabled()) {
             if (Boolean.getBoolean(TTL_3_5_3_EMULATION_PROPERTY)) {
-                if (OldEphemeralType.get(ephemeralOwner) == OldEphemeralType.TTL) {
+                if (EphemeralTypeEmulate353.get(ephemeralOwner) == EphemeralTypeEmulate353.TTL) {
                     return TTL;
                 }
             }
"
zookeeper,6e64125f2aafc29253904c43ee44233c907e5fca,ZOOKEEPER-3038: Cleanup some nitpicks in TTL implementation,2018.05.10 13:13:16,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/EphemeralTypeEmulate353.java b/src/java/main/org/apache/zookeeper/server/EphemeralTypeEmulate353.java
new file mode 100644
index 0000000..c8f384f
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/EphemeralTypeEmulate353.java
@@ -0,0 +1,67 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+/**
+ * See https://issues.apache.org/jira/browse/ZOOKEEPER-2901
+ *
+ * version 3.5.3 introduced bugs associated with how TTL nodes were implemented. version 3.5.4
+ * fixes the problems but makes TTL nodes created in 3.5.3 invalid. EphemeralTypeEmulate353 is a copy
+ * of the old - bad - implementation that is provided as a workaround. {@link EphemeralType#TTL_3_5_3_EMULATION_PROPERTY}
+ * can be used to emulate support of the badly specified TTL nodes.
+ */
+public enum EphemeralTypeEmulate353 {
+    /**
+     * Not ephemeral
+     */
+    VOID,
+    /**
+     * Standard, pre-3.5.x EPHEMERAL
+     */
+    NORMAL,
+    /**
+     * Container node
+     */
+    CONTAINER,
+    /**
+     * TTL node
+     */
+    TTL;
+
+    public static final long CONTAINER_EPHEMERAL_OWNER = Long.MIN_VALUE;
+    public static final long MAX_TTL = 0x0fffffffffffffffL;
+    public static final long TTL_MASK = 0x8000000000000000L;
+
+    public static EphemeralTypeEmulate353 get(long ephemeralOwner) {
+        if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {
+            return CONTAINER;
+        }
+        if (ephemeralOwner < 0) {
+            return TTL;
+        }
+        return (ephemeralOwner == 0) ? VOID : NORMAL;
+    }
+
+    public static long ttlToEphemeralOwner(long ttl) {
+        if ((ttl > MAX_TTL) || (ttl <= 0)) {
+            throw new IllegalArgumentException(""ttl must be positive and cannot be larger than: "" + MAX_TTL);
+        }
+        return TTL_MASK | ttl;
+    }
+}
"
zookeeper,6e64125f2aafc29253904c43ee44233c907e5fca,ZOOKEEPER-3038: Cleanup some nitpicks in TTL implementation,2018.05.10 13:13:16,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index d7774eb..cec1f94 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -50,7 +50,6 @@
 import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
-import org.apache.zookeeper.server.EphemeralType;
 import org.apache.zookeeper.server.ServerCnxnFactory;
 import org.apache.zookeeper.server.ZKDatabase;
 import org.apache.zookeeper.server.ZooKeeperServer;
"
zookeeper,088dfdf188663f6bad79b0e87b710737b318537d,ZOOKEEPER-2959: ignore accepted epoch and LEADERINFO ack from observers,2018.05.10 13:00:15,Alexander Shraer,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 52a9113..4774a42 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -97,7 +97,8 @@
 
     final QuorumPeer self;
 
-    private boolean quorumFormed = false;
+    // VisibleForTesting
+    protected boolean quorumFormed = false;
 
     // the follower acceptor thread
     volatile LearnerCnxAcceptor cnxAcceptor = null;
@@ -358,7 +359,8 @@
 
     private final ConcurrentLinkedQueue<Proposal> toBeApplied = new ConcurrentLinkedQueue<Proposal>();
 
-    private final Proposal newLeaderProposal = new Proposal();
+    // VisibleForTesting
+    protected final Proposal newLeaderProposal = new Proposal();
 
     class LearnerCnxAcceptor extends ZooKeeperCriticalThread {
         private volatile boolean stop = false;
@@ -507,7 +509,7 @@
              self.setCurrentEpoch(epoch);    
             
              try {
-                 waitForNewLeaderAck(self.getId(), zk.getZxid(), LearnerType.PARTICIPANT);
+                 waitForNewLeaderAck(self.getId(), zk.getZxid());
              } catch (InterruptedException e) {
                  shutdown(""Waiting for a quorum of followers, only synced with sids: [ ""
                          + newLeaderProposal.ackSetsToString() + "" ]"");
@@ -1163,7 +1165,8 @@
 
         return lastProposed;
     }
-    private final HashSet<Long> connectingFollowers = new HashSet<Long>();
+    // VisibleForTesting
+    protected final Set<Long> connectingFollowers = new HashSet<Long>();
     public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException {
         synchronized(connectingFollowers) {
             if (!waitingForNewEpoch) {
@@ -1172,7 +1175,9 @@
             if (lastAcceptedEpoch >= epoch) {
                 epoch = lastAcceptedEpoch+1;
             }
-            connectingFollowers.add(sid);
+            if (isParticipant(sid)) {
+                connectingFollowers.add(sid);
+            }
             QuorumVerifier verifier = self.getQuorumVerifier();
             if (connectingFollowers.contains(self.getId()) &&
                                             verifier.containsQuorum(connectingFollowers)) {
@@ -1195,8 +1200,10 @@
         }
     }
 
-    private final HashSet<Long> electingFollowers = new HashSet<Long>();
-    private boolean electionFinished = false;
+    // VisibleForTesting
+    protected final Set<Long> electingFollowers = new HashSet<Long>();
+    // VisibleForTesting
+    protected boolean electionFinished = false;
     public void waitForEpochAck(long id, StateSummary ss) throws IOException, InterruptedException {
         synchronized(electingFollowers) {
             if (electionFinished) {
@@ -1210,7 +1217,7 @@
                                                     + leaderStateSummary.getLastZxid()
                                                     + "" (last zxid)"");
                 }
-                if (ss.getLastZxid() != -1) {
+                if (ss.getLastZxid() != -1 && isParticipant(id)) {
                     electingFollowers.add(id);
                 }
             }
@@ -1294,10 +1301,9 @@
      * sufficient acks.
      *
      * @param sid
-     * @param learnerType
      * @throws InterruptedException
      */
-    public void waitForNewLeaderAck(long sid, long zxid, LearnerType learnerType)
+    public void waitForNewLeaderAck(long sid, long zxid)
             throws InterruptedException {
 
         synchronized (newLeaderProposal.qvAcksetPairs) {
@@ -1393,4 +1399,8 @@
     private boolean isRunning() {
         return self.isRunning() && zk.isRunning();
     }
+
+    private boolean isParticipant(long sid) {
+        return self.getQuorumVerifier().getVotingMembers().containsKey(sid);
+    }
 }
"
zookeeper,088dfdf188663f6bad79b0e87b710737b318537d,ZOOKEEPER-2959: ignore accepted epoch and LEADERINFO ack from observers,2018.05.10 13:00:15,Alexander Shraer,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index 7247f5c..f6c68b0 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -507,7 +507,7 @@
             if(LOG.isDebugEnabled()){
             	LOG.debug(""Received NEWLEADER-ACK message from "" + sid);   
             }
-            leader.waitForNewLeaderAck(getSid(), qp.getZxid(), getLearnerType());
+            leader.waitForNewLeaderAck(getSid(), qp.getZxid());
 
             syncLimitCheck.start();
             
"
zookeeper,ceaeccd6e310983d37e685a9d5fff3d7e75cf125,ZOOKEEPER-2901: TTL Nodes don't work with Server IDs > 127,2018.05.10 06:57:41,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 0967b0a..ebcc500 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -1522,7 +1522,7 @@
      * or {@link CreateMode#PERSISTENT_SEQUENTIAL_WITH_TTL}. If the znode has not been modified
      * within the given TTL, it will be deleted once it has no children. The TTL unit is
      * milliseconds and must be greater than 0 and less than or equal to
-     * {@link EphemeralType#MAX_TTL}.
+     * {@link EphemeralType#maxValue()} for {@link EphemeralType#TTL}.
      */
     public String create(final String path, byte data[], List<ACL> acl,
             CreateMode createMode, Stat stat, long ttl)
"
zookeeper,ceaeccd6e310983d37e685a9d5fff3d7e75cf125,ZOOKEEPER-2901: TTL Nodes don't work with Server IDs > 127,2018.05.10 06:57:41,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/cli/CreateCommand.java b/src/java/main/org/apache/zookeeper/cli/CreateCommand.java
index 46ffc17..093be47 100644
--- a/src/java/main/org/apache/zookeeper/cli/CreateCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/CreateCommand.java
@@ -100,7 +100,7 @@
         }
         if (hasT) {
             try {
-                EphemeralType.ttlToEphemeralOwner(ttl);
+                EphemeralType.TTL.toEphemeralOwner(ttl);
             } catch (IllegalArgumentException e) {
                 throw new MalformedCommandException(e.getMessage());
             }
"
zookeeper,ceaeccd6e310983d37e685a9d5fff3d7e75cf125,ZOOKEEPER-2901: TTL Nodes don't work with Server IDs > 127,2018.05.10 06:57:41,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/server/ContainerManager.java b/src/java/main/org/apache/zookeeper/server/ContainerManager.java
index db86e89..4c47aba 100644
--- a/src/java/main/org/apache/zookeeper/server/ContainerManager.java
+++ b/src/java/main/org/apache/zookeeper/server/ContainerManager.java
@@ -158,10 +158,12 @@
             if (node != null) {
                 Set<String> children = node.getChildren();
                 if (children.isEmpty()) {
-                    long elapsed = getElapsed(node);
-                    long ttl = EphemeralType.getTTL(node.stat.getEphemeralOwner());
-                    if ((ttl != 0) && (elapsed > ttl)) {
-                        candidates.add(ttlPath);
+                    if ( EphemeralType.get(node.stat.getEphemeralOwner()) == EphemeralType.TTL ) {
+                        long elapsed = getElapsed(node);
+                        long ttl = EphemeralType.TTL.getValue(node.stat.getEphemeralOwner());
+                        if ((ttl != 0) && (getElapsed(node) > ttl)) {
+                            candidates.add(ttlPath);
+                        }
                     }
                 }
             }
"
zookeeper,ceaeccd6e310983d37e685a9d5fff3d7e75cf125,ZOOKEEPER-2901: TTL Nodes don't work with Server IDs > 127,2018.05.10 06:57:41,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 55f15bd..d5e5fa9 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -812,7 +812,7 @@
                             createTtlTxn.getPath(),
                             createTtlTxn.getData(),
                             createTtlTxn.getAcl(),
-                            EphemeralType.ttlToEphemeralOwner(createTtlTxn.getTtl()),
+                            EphemeralType.TTL.toEphemeralOwner(createTtlTxn.getTtl()),
                             createTtlTxn.getParentCVersion(),
                             header.getZxid(), header.getTime(), stat);
                     rc.stat = stat;
"
zookeeper,ceaeccd6e310983d37e685a9d5fff3d7e75cf125,ZOOKEEPER-2901: TTL Nodes don't work with Server IDs > 127,2018.05.10 06:57:41,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/server/EphemeralType.java b/src/java/main/org/apache/zookeeper/server/EphemeralType.java
index 6d7bb25..7861d40 100644
--- a/src/java/main/org/apache/zookeeper/server/EphemeralType.java
+++ b/src/java/main/org/apache/zookeeper/server/EphemeralType.java
@@ -20,7 +20,47 @@
 
 import org.apache.zookeeper.CreateMode;
 
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
+/**
+ * <p>
+ * Abstraction that interprets the <code>ephemeralOwner</code> field of a ZNode. Originally,
+ * the ephemeralOwner noted that a ZNode is ephemeral and which session created the node.
+ * Through an optional system property (<code>zookeeper.extendedTypesEnabled</code>) ""extended""
+ * features such as TTL Nodes can be enabled. Special bits of the ephemeralOwner are used to
+ * denote which feature is enabled and the remaining bits of the ephemeralOwner are feature
+ * specific.
+ * </p>
+ * <p>
+ * <p>
+ * When the system property <code>zookeeper.extendedTypesEnabled</code> is true, extended types
+ * are enabled. An extended ephemeralOwner is defined as an ephemeralOwner whose high 8 bits are
+ * set (<code>0xff00000000000000L</code>). The two bytes that follow the high 8 bits are
+ * used to denote which extended feature the ephemeralOwner represents. The remaining 5 bytes are
+ * used by the feature for whatever purpose is needed
+ * </p>
+ * <p>
+ * <p>
+ * Currently, the only extended feature is TTL Nodes. It is denoted by the extended feature value of 0.
+ * i.e. for TTL Nodes, the ephemeralOwner has the high byte set to 0xff and the next 2 bytes are 0 followed
+ * by 5 bytes that represent the TTL value in milliseconds. So, an ephemeralOwner with a TTL value of 1
+ * millisecond is: <code>0xff00000000000001</code>.
+ * </p>
+ * <p>
+ * <p>
+ * To add new extended features: a) Add a new name to the enum, b) define a constant EXTENDED_BIT_XXXX that's next
+ * in line (after TTLs, that would be <code>0x0001</code>), c) add a mapping to the extendedFeatureMap via the static
+ * initializer
+ * </p>
+ * <p>
+ * <p>
+ * NOTE: ""Container"" nodes technically are extended types but as it was implemented before this feature they are
+ * denoted specially. An ephemeral owner with only the high bit set (<code>0x8000000000000000L</code>) is by definition
+ * a container node (irrespective of whether or not extended types are enabled).
+ * </p>
+ */
 public enum EphemeralType {
     /**
      * Not ephemeral
@@ -37,41 +77,152 @@
     /**
      * TTL node
      */
-    TTL;
+    TTL() {
+        @Override
+        public long maxValue() {
+            return EXTENDED_FEATURE_VALUE_MASK;  // 12725 days, about 34 years
+        }
+
+        @Override
+        public long toEphemeralOwner(long ttl) {
+            if ((ttl > TTL.maxValue()) || (ttl <= 0)) {
+                throw new IllegalArgumentException(""ttl must be positive and cannot be larger than: "" + TTL.maxValue());
+            }
+            //noinspection PointlessBitwiseExpression
+            return EXTENDED_MASK | EXTENDED_BIT_TTL | ttl;  // TTL_RESERVED_BIT is actually zero - but it serves to document that the proper extended bit needs to be set
+        }
+
+        @Override
+        public long getValue(long ephemeralOwner) {
+            return getExtendedFeatureValue(ephemeralOwner);
+        }
+    };
+
+    /**
+     * For types that support it, the maximum extended value
+     *
+     * @return 0 or max
+     */
+    public long maxValue() {
+        return 0;
+    }
+
+    /**
+     * For types that support it, convert a value to an extended ephemeral owner
+     *
+     * @return 0 or extended ephemeral owner
+     */
+    public long toEphemeralOwner(long value) {
+        return 0;
+    }
+
+    /**
+     * For types that support it, return the extended value from an extended ephemeral owner
+     *
+     * @return 0 or extended value
+     */
+    public long getValue(long ephemeralOwner) {
+        return 0;
+    }
 
     public static final long CONTAINER_EPHEMERAL_OWNER = Long.MIN_VALUE;
-    public static final long MAX_TTL = 0x0fffffffffffffffL;
-    public static final long TTL_MASK = 0x8000000000000000L;
+    public static final long MAX_EXTENDED_SERVER_ID = 0xfe;  // 254
 
+    private static final long EXTENDED_MASK = 0xff00000000000000L;
+    private static final long EXTENDED_BIT_TTL = 0x0000;
+    private static final long RESERVED_BITS_MASK = 0x00ffff0000000000L;
+    private static final long RESERVED_BITS_SHIFT = 40;
+
+    private static final Map<Long, EphemeralType> extendedFeatureMap;
+
+    static {
+        Map<Long, EphemeralType> map = new HashMap<>();
+        map.put(EXTENDED_BIT_TTL, TTL);
+        extendedFeatureMap = Collections.unmodifiableMap(map);
+    }
+
+    private static final long EXTENDED_FEATURE_VALUE_MASK = ~(EXTENDED_MASK | RESERVED_BITS_MASK);
+
+    // Visible for testing
+    static final String EXTENDED_TYPES_ENABLED_PROPERTY = ""zookeeper.extendedTypesEnabled"";
+    static final String TTL_3_5_3_EMULATION_PROPERTY = ""zookeeper.emulate353TTLNodes"";
+
+    /**
+     * Return true if extended ephemeral types are enabled
+     *
+     * @return true/false
+     */
+    public static boolean extendedEphemeralTypesEnabled() {
+        return Boolean.getBoolean(EXTENDED_TYPES_ENABLED_PROPERTY);
+    }
+
+    /**
+     * Convert a ZNode ephemeral owner to an ephemeral type. If extended types are not
+     * enabled, VOID or NORMAL is always returned
+     *
+     * @param ephemeralOwner the ZNode's ephemeral owner
+     * @return type
+     */
     public static EphemeralType get(long ephemeralOwner) {
+        if (extendedEphemeralTypesEnabled()) {
+            if (Boolean.getBoolean(TTL_3_5_3_EMULATION_PROPERTY)) {
+                if (OldEphemeralType.get(ephemeralOwner) == OldEphemeralType.TTL) {
+                    return TTL;
+                }
+            }
+
+            if ((ephemeralOwner & EXTENDED_MASK) == EXTENDED_MASK) {
+                long extendedFeatureBit = getExtendedFeatureBit(ephemeralOwner);
+                EphemeralType ephemeralType = extendedFeatureMap.get(extendedFeatureBit);
+                if (ephemeralType == null) {
+                    throw new IllegalArgumentException(String.format(""Invalid ephemeralOwner. [%s]"", Long.toHexString(ephemeralOwner)));
+                }
+                return ephemeralType;
+            }
+        }
         if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {
             return CONTAINER;
         }
-        if (ephemeralOwner < 0) {
-            return TTL;
-        }
         return (ephemeralOwner == 0) ? VOID : NORMAL;
     }
 
+    /**
+     * Make sure the given server ID is compatible with the current extended ephemeral setting
+     *
+     * @param serverId Server ID
+     * @throws RuntimeException extendedTypesEnabled is true but Server ID is too large
+     */
+    public static void validateServerId(long serverId) {
+        // TODO: in the future, serverId should be validated for all cases, not just the extendedEphemeralTypesEnabled case
+        // TODO: however, for now, it would be too disruptive
+
+        if (extendedEphemeralTypesEnabled()) {
+            if (serverId > EphemeralType.MAX_EXTENDED_SERVER_ID) {
+                throw new RuntimeException(""extendedTypesEnabled is true but Server ID is too large. Cannot be larger than "" + EphemeralType.MAX_EXTENDED_SERVER_ID);
+            }
+        }
+    }
+
+    /**
+     * Utility to validate a create mode and a ttl
+     *
+     * @param mode create mode
+     * @param ttl  ttl
+     * @throws IllegalArgumentException if the ttl is not valid for the mode
+     */
     public static void validateTTL(CreateMode mode, long ttl) {
         if (mode.isTTL()) {
-            ttlToEphemeralOwner(ttl);
+            TTL.toEphemeralOwner(ttl);
         } else if (ttl >= 0) {
             throw new IllegalArgumentException(""ttl not valid for mode: "" + mode);
         }
     }
 
-    public static long getTTL(long ephemeralOwner) {
-        if ((ephemeralOwner < 0) && (ephemeralOwner != CONTAINER_EPHEMERAL_OWNER)) {
-            return (ephemeralOwner & MAX_TTL);
-        }
-        return 0;
+    private static long getExtendedFeatureBit(long ephemeralOwner) {
+        return (ephemeralOwner & RESERVED_BITS_MASK) >> RESERVED_BITS_SHIFT;
     }
 
-    public static long ttlToEphemeralOwner(long ttl) {
-        if ((ttl > MAX_TTL) || (ttl <= 0)) {
-            throw new IllegalArgumentException(""ttl must be positive and cannot be larger than: "" + MAX_TTL);
-        }
-        return TTL_MASK | ttl;
+    private static long getExtendedFeatureValue(long ephemeralOwner) {
+        return ephemeralOwner & EXTENDED_FEATURE_VALUE_MASK;
     }
 }
"
zookeeper,ceaeccd6e310983d37e685a9d5fff3d7e75cf125,ZOOKEEPER-2901: TTL Nodes don't work with Server IDs > 127,2018.05.10 06:57:41,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/server/OldEphemeralType.java b/src/java/main/org/apache/zookeeper/server/OldEphemeralType.java
new file mode 100644
index 0000000..bffec8a
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/OldEphemeralType.java
@@ -0,0 +1,74 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+/**
+ * See https://issues.apache.org/jira/browse/ZOOKEEPER-2901
+ *
+ * version 3.5.3 introduced bugs associated with how TTL nodes were implemented. version 3.5.4
+ * fixes the problems but makes TTL nodes created in 3.5.3 invalid. OldEphemeralType is a copy
+ * of the old - bad - implementation that is provided as a workaround. {@link EphemeralType#TTL_3_5_3_EMULATION_PROPERTY}
+ * can be used to emulate support of the badly specified TTL nodes.
+ */
+public enum OldEphemeralType {
+    /**
+     * Not ephemeral
+     */
+    VOID,
+    /**
+     * Standard, pre-3.5.x EPHEMERAL
+     */
+    NORMAL,
+    /**
+     * Container node
+     */
+    CONTAINER,
+    /**
+     * TTL node
+     */
+    TTL;
+
+    public static final long CONTAINER_EPHEMERAL_OWNER = Long.MIN_VALUE;
+    public static final long MAX_TTL = 0x0fffffffffffffffL;
+    public static final long TTL_MASK = 0x8000000000000000L;
+
+    public static OldEphemeralType get(long ephemeralOwner) {
+        if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {
+            return CONTAINER;
+        }
+        if (ephemeralOwner < 0) {
+            return TTL;
+        }
+        return (ephemeralOwner == 0) ? VOID : NORMAL;
+    }
+
+    public static long getTTL(long ephemeralOwner) {
+        if ((ephemeralOwner < 0) && (ephemeralOwner != CONTAINER_EPHEMERAL_OWNER)) {
+            return (ephemeralOwner & MAX_TTL);
+        }
+        return 0;
+    }
+
+    public static long ttlToEphemeralOwner(long ttl) {
+        if ((ttl > MAX_TTL) || (ttl <= 0)) {
+            throw new IllegalArgumentException(""ttl must be positive and cannot be larger than: "" + MAX_TTL);
+        }
+        return TTL_MASK | ttl;
+    }
+}
"
zookeeper,ceaeccd6e310983d37e685a9d5fff3d7e75cf125,ZOOKEEPER-2901: TTL Nodes don't work with Server IDs > 127,2018.05.10 06:57:41,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 537ef71..f31303a 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -921,9 +921,12 @@
         }
         return retval;
     }
-    
+
     private void validateCreateRequest(String path, CreateMode createMode, Request request, long ttl)
             throws KeeperException {
+        if (createMode.isTTL() && !EphemeralType.extendedEphemeralTypesEnabled()) {
+            throw new KeeperException.UnimplementedException();
+        }
         try {
             EphemeralType.validateTTL(createMode, ttl);
         } catch (IllegalArgumentException e) {
"
zookeeper,ceaeccd6e310983d37e685a9d5fff3d7e75cf125,ZOOKEEPER-2901: TTL Nodes don't work with Server IDs > 127,2018.05.10 06:57:41,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
index b776332..6fc6eb5 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
@@ -84,6 +84,9 @@
         long nextSid;
         nextSid = (Time.currentElapsedTime() << 24) >>> 8;
         nextSid =  nextSid | (id <<56);
+        if (nextSid == EphemeralType.CONTAINER_EPHEMERAL_OWNER) {
+            ++nextSid;  // this is an unlikely edge case, but check it just in case
+        }
         return nextSid;
     }
 
@@ -101,6 +104,8 @@
         for (Entry<Long, Integer> e : sessionsWithTimeout.entrySet()) {
             addSession(e.getKey(), e.getValue());
         }
+
+        EphemeralType.validateServerId(serverId);
     }
 
     volatile boolean running = true;
"
zookeeper,ceaeccd6e310983d37e685a9d5fff3d7e75cf125,ZOOKEEPER-2901: TTL Nodes don't work with Server IDs > 127,2018.05.10 06:57:41,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 9099b2f..8e78073 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -125,6 +125,7 @@
     private final ServerStats serverStats;
     private final ZooKeeperServerListener listener;
     private ZooKeeperServerShutdownHandler zkShutdownHandler;
+    private volatile int createSessionTrackerServerId = 1;
 
     void removeCnxn(ServerCnxn cnxn) {
         zkDb.removeCnxn(cnxn);
@@ -475,9 +476,19 @@
         return listener;
     }
 
+    /**
+     * Change the server ID used by {@link #createSessionTracker()}. Must be called prior to
+     * {@link #startup()} being called
+     *
+     * @param newId ID to use
+     */
+    public void setCreateSessionTrackerServerId(int newId) {
+        createSessionTrackerServerId = newId;
+    }
+
     protected void createSessionTracker() {
         sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(),
-                tickTime, 1, getZooKeeperServerListener());
+                tickTime, createSessionTrackerServerId, getZooKeeperServerListener());
     }
 
     protected void startSessionTracker() {
"
zookeeper,ceaeccd6e310983d37e685a9d5fff3d7e75cf125,ZOOKEEPER-2901: TTL Nodes don't work with Server IDs > 127,2018.05.10 06:57:41,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index cec1f94..d7774eb 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -50,6 +50,7 @@
 import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
+import org.apache.zookeeper.server.EphemeralType;
 import org.apache.zookeeper.server.ServerCnxnFactory;
 import org.apache.zookeeper.server.ZKDatabase;
 import org.apache.zookeeper.server.ZooKeeperServer;
"
zookeeper,b1f6279a8c4708d1df7dd1128dc4fdf41fc7e24a,ZOOKEEPER-2982: Re-try DNS hostname -> IP resolution if node connection fails,2018.05.09 07:54:02,Eron Wright,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index a37cc93..a1a2ff7 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -201,6 +201,9 @@
         Vote current = self.getCurrentVote();
         for (QuorumServer s : self.getView().values()) {
             if (s.id == current.getId()) {
+                // Ensure we have the leader's correct IP address before
+                // attempting to connect.
+                s.recreateSocketAddresses();
                 leaderServer = s;
                 break;
             }
"
zookeeper,2022766ec907f63b1b43fc5455e9e7761cd332f6,ZOOKEEPER-2988: NPE triggered if server receives a vote for a server …,2018.04.30 13:34:57,Brian Nixon,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index f1112b7..1bd0fbf 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -22,7 +22,6 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Map;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
@@ -322,7 +321,7 @@
                          * If it is from a non-voting server (such as an observer or
                          * a non-voting follower), respond right away.
                          */
-                        if(!self.getCurrentAndNextConfigVoters().contains(response.sid)) {
+                        if(!validVoter(response.sid)) {
                             Vote current = self.getCurrentVote();
                             QuorumVerifier qv = self.getQuorumVerifier();
                             ToSend notmsg = new ToSend(ToSend.mType.notification,
@@ -927,10 +926,10 @@
                             tmpTimeOut : maxNotificationInterval);
                     LOG.info(""Notification time out: "" + notTimeout);
                 } 
-                else if (self.getCurrentAndNextConfigVoters().contains(n.sid)) {
+                else if (validVoter(n.sid) && validVoter(n.leader)) {
                     /*
                      * Only proceed if the vote comes from a replica in the current or next
-                     * voting view.
+                     * voting view for a replica in the current or next voting view.
                      */
                     switch (n.state) {
                     case LOOKING:
@@ -1064,7 +1063,12 @@
                         break;
                     }
                 } else {
-                    LOG.warn(""Ignoring notification from non-cluster member "" + n.sid);
+                    if (!validVoter(n.leader)) {
+                        LOG.warn(""Ignoring notification for non-cluster member sid {} from sid {}"", n.leader, n.sid);
+                    }
+                    if (!validVoter(n.sid)) {
+                        LOG.warn(""Ignoring notification for sid {} from non-quorum member sid {}"", n.leader, n.sid);
+                    }
                 }
             }
             return null;
@@ -1082,4 +1086,15 @@
                     manager.getConnectionThreadCount());
         }
     }
+
+    /**
+     * Check if a given sid is represented in either the current or
+     * the next voting view
+     *
+     * @param sid     Server identifier
+     * @return boolean
+     */
+    private boolean validVoter(long sid) {
+        return self.getCurrentAndNextConfigVoters().contains(sid);
+    }
 }
"
zookeeper,5c96887643b2465caabbfd4763c7ebb3cd1aa024,ZOOKEEPER-3027: Accidently removed public API of FileTxnLog.setPreallocSize(),2018.04.28 03:28:15,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FilePadding.java b/src/java/main/org/apache/zookeeper/server/persistence/FilePadding.java
index c4052e9..49fde24 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FilePadding.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FilePadding.java
@@ -46,6 +46,13 @@
     private long currentSize;
 
     /**
+     * Getter of preAllocSize has been added for testing
+     */
+    public static long getPreAllocSize() {
+        return preAllocSize;
+    }
+
+    /**
      * method to allow setting preallocate size
      * of log file to pad the file.
      *
"
zookeeper,5c96887643b2465caabbfd4763c7ebb3cd1aa024,ZOOKEEPER-3027: Accidently removed public API of FileTxnLog.setPreallocSize(),2018.04.28 03:28:15,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index fae7f02..f79521b 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -136,6 +136,15 @@
     }
 
     /**
+      * method to allow setting preallocate size
+      * of log file to pad the file.
+      * @param size the size to set to in bytes
+      */
+    public static void setPreallocSize(long size) {
+        FilePadding.setPreallocSize(size);
+    }
+
+    /**
      * creates a checksum algorithm to be used
      * @return the checksum used for this txnlog
      */
"
zookeeper,2c0168ad37b529447ac8cb1bf866d014f8a97981,ZOOKEEPER-3007: Potential NPE in ReferenceCountedACLCache#deserialize,2018.04.27 07:21:06,gongleigl.gong,"diff --git a/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java b/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java
index 486b845..384d23a 100644
--- a/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java
+++ b/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java
@@ -109,6 +109,9 @@
             }
             List<ACL> aclList = new ArrayList<ACL>();
             Index j = ia.startVector(""acls"");
+            if (j == null) {
+                throw new RuntimeException(""Incorrent format of InputArchive when deserialize DataTree - missing acls"");
+            }
             while (!j.done()) {
                 ACL acl = new ACL();
                 acl.deserialize(ia, ""acl"");
"
zookeeper,fbd21329d32f185d198344f2d394175c92a82f9e,ZOOKEEPER-3006: Potential NPE in ZKDatabase#calculateTxnLogSizeLimit,2018.04.06 13:04:07,Edward Ribeiro,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index a03c955..7b00715 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -18,6 +18,7 @@
 
 package org.apache.zookeeper.server;
 
+import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Collection;
@@ -302,7 +303,10 @@
     public long calculateTxnLogSizeLimit() {
         long snapSize = 0;
         try {
-            snapSize = snapLog.findMostRecentSnapshot().length();
+            File snapFile = snapLog.findMostRecentSnapshot();
+            if (snapFile != null) {
+                snapSize = snapFile.length();
+            }
         } catch (IOException e) {
             LOG.error(""Unable to get size of most recent snapshot"");
         }
"
zookeeper,8cfca3add9c7fd705f9114daf4adaac9fc90f040,ZOOKEEPER-3001: Incorrect log message when try to delete container node,2018.03.26 10:49:14,sel-fish,"diff --git a/src/java/main/org/apache/zookeeper/server/ContainerManager.java b/src/java/main/org/apache/zookeeper/server/ContainerManager.java
index fb1cb66..db86e89 100644
--- a/src/java/main/org/apache/zookeeper/server/ContainerManager.java
+++ b/src/java/main/org/apache/zookeeper/server/ContainerManager.java
@@ -116,12 +116,12 @@
             Request request = new Request(null, 0, 0,
                     ZooDefs.OpCode.deleteContainer, path, null);
             try {
-                LOG.info(""Attempting to delete candidate container: %s"",
+                LOG.info(""Attempting to delete candidate container: {}"",
                         containerPath);
                 requestProcessor.processRequest(request);
             } catch (Exception e) {
-                LOG.error(String.format(""Could not delete container: %s"" ,
-                        containerPath), e);
+                LOG.error(""Could not delete container: {}"",
+                        containerPath, e);
             }
 
             long elapsedMs = Time.currentElapsedTime() - startMs;
"
zookeeper,722ba9409a44a35d287aac803813f508cff2420a,ZOOKEEPER-2845: Apply commit log when restarting server.,2018.02.24 07:49:00,Robert Evans,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 6679e78..a03c955 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -223,6 +223,11 @@
         return sessionsWithTimeouts;
     }
 
+    private final PlayBackListener commitProposalPlaybackListener = new PlayBackListener() {
+        public void onTxnLoaded(TxnHeader hdr, Record txn){
+            addCommittedProposal(hdr, txn);
+        }
+    };
 
     /**
      * load the database from the disk onto memory and also add
@@ -231,19 +236,28 @@
      * @throws IOException
      */
     public long loadDataBase() throws IOException {
-        PlayBackListener listener=new PlayBackListener(){
-            public void onTxnLoaded(TxnHeader hdr,Record txn){
-                Request r = new Request(0, hdr.getCxid(),hdr.getType(), hdr, txn, hdr.getZxid());
-                addCommittedProposal(r);
-            }
-        };
-
-        long zxid = snapLog.restore(dataTree,sessionsWithTimeouts,listener);
+        long zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);
         initialized = true;
         return zxid;
     }
 
     /**
+     * Fast forward the database adding transactions from the committed log into memory.
+     * @return the last valid zxid.
+     * @throws IOException
+     */
+    public long fastForwardDataBase() throws IOException {
+        long zxid = snapLog.fastForwardFromEdits(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);
+        initialized = true;
+        return zxid;
+    }
+
+    private void addCommittedProposal(TxnHeader hdr, Record txn) {
+        Request r = new Request(0, hdr.getCxid(), hdr.getType(), hdr, txn, hdr.getZxid());
+        addCommittedProposal(r);
+    }
+
+    /**
      * maintains a list of last <i>committedLog</i>
      *  or so committed requests. This is used for
      * fast follower synchronization.
"
zookeeper,722ba9409a44a35d287aac803813f508cff2420a,ZOOKEEPER-2845: Apply commit log when restarting server.,2018.02.24 07:49:00,Robert Evans,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index c8cd72d..9099b2f 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -557,14 +557,24 @@
             firstProcessor.shutdown();
         }
 
-        if (fullyShutDown && zkDb != null) {
-            zkDb.clear();
+        if (zkDb != null) {
+            if (fullyShutDown) {
+                zkDb.clear();
+            } else {
+                // else there is no need to clear the database
+                //  * When a new quorum is established we can still apply the diff
+                //    on top of the same zkDb data
+                //  * If we fetch a new snapshot from leader, the zkDb will be
+                //    cleared anyway before loading the snapshot
+                try {
+                    //This will fast forward the database to the latest recorded transactions
+                    zkDb.fastForwardDataBase();
+                } catch (IOException e) {
+                    LOG.error(""Error updating DB"", e);
+                    zkDb.clear();
+                }
+            }
         }
-        // else there is no need to clear the database
-        //  * When a new quorum is established we can still apply the diff
-        //    on top of the same zkDb data
-        //  * If we fetch a new snapshot from leader, the zkDb will be
-        //    cleared anyway before loading the snapshot
 
         unregisterJMX();
     }
"
zookeeper,722ba9409a44a35d287aac803813f508cff2420a,ZOOKEEPER-2845: Apply commit log when restarting server.,2018.02.24 07:49:00,Robert Evans,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 3ca1781..8702bf3 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -239,6 +239,22 @@
                 return -1L;
             }
         }
+        return fastForwardFromEdits(dt, sessions, listener);
+    }
+
+    /**
+     * This function will fast forward the server database to have the latest
+     * transactions in it.  This is the same as restore, but only reads from
+     * the transaction logs and not restores from a snapshot.
+     * @param dt the datatree to write transactions to.
+     * @param sessions the sessions to be restored.
+     * @param listener the playback listener to run on the
+     * database transactions.
+     * @return the highest zxid restored.
+     * @throws IOException
+     */
+    public long fastForwardFromEdits(DataTree dt, Map<Long, Integer> sessions,
+                                     PlayBackListener listener) throws IOException {
         TxnIterator itr = txnLog.read(dt.lastProcessedZxid+1);
         long highestZxid = dt.lastProcessedZxid;
         TxnHeader hdr;
"
zookeeper,f0b67b6e49acec5f022bee25e08f82a29572c97a,ZOOKEEPER-2978: fix potential null pointer exception when deleting node,2018.02.21 07:38:00,achimbab,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index d24404f..0967b0a 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -515,7 +515,7 @@
                 synchronized (existWatches) {
                     Set<Watcher> list = existWatches.remove(clientPath);
                     if (list != null) {
-                        addTo(existWatches.remove(clientPath), result);
+                        addTo(list, result);
                         LOG.warn(""We are triggering an exists watch for delete! Shouldn't happen!"");
                     }
                 }
"
zookeeper,66554218a557cbc86924354bdb20e20b20ff934f,ZOOKEEPER-2949: using hostname and port to create SSLEngine,2018.01.31 05:56:37,Feng Shaobao,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNetty.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNetty.java
old mode 100644
new mode 100755
index 97af9da..ec789cb
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNetty.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNetty.java
@@ -112,7 +112,7 @@
 
         ClientBootstrap bootstrap = new ClientBootstrap(channelFactory);
 
-        bootstrap.setPipelineFactory(new ZKClientPipelineFactory());
+        bootstrap.setPipelineFactory(new ZKClientPipelineFactory(addr.getHostString(), addr.getPort()));
         bootstrap.setOption(""soLinger"", -1);
         bootstrap.setOption(""tcpNoDelay"", true);
 
@@ -340,6 +340,7 @@
             return instance;
         }
     }
+
     /**
      * ZKClientPipelineFactory is the netty pipeline factory for this netty
      * connection implementation.
@@ -347,6 +348,13 @@
     private class ZKClientPipelineFactory implements ChannelPipelineFactory {
         private SSLContext sslContext = null;
         private SSLEngine sslEngine = null;
+        private String host;
+        private int port;
+
+        public ZKClientPipelineFactory(String host, int port) {
+            this.host = host;
+            this.port = port;
+        }
 
         @Override
         public ChannelPipeline getPipeline() throws Exception {
@@ -363,7 +371,7 @@
         private synchronized void initSSL(ChannelPipeline pipeline) throws SSLContextException {
             if (sslContext == null || sslEngine == null) {
                 sslContext = X509Util.createSSLContext(clientConfig);
-                sslEngine = sslContext.createSSLEngine();
+                sslEngine = sslContext.createSSLEngine(host,port);
                 sslEngine.setUseClientMode(true);
             }
             pipeline.addLast(""ssl"", new SslHandler(sslEngine));
"
zookeeper,d1b07d588e445085eff4abeb42cf730cc7c57e83,ZOOKEEPER-1580: QuorumPeer.setRunning is not used,2018.01.30 16:02:41,maoling,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 45f32b9..cec1f94 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -479,7 +479,7 @@
         currentVote = v;
     }
 
-    volatile boolean running = true;
+    private volatile boolean running = true;
 
     /**
      * The number of milliseconds of each tick
@@ -1750,10 +1750,6 @@
     public synchronized void initConfigInZKDatabase() {   
         if (zkDb != null) zkDb.initConfigInZKDatabase(getQuorumVerifier());
     }
-    
-    public void setRunning(boolean running) {
-        this.running = running;
-    }
 
     public boolean isRunning() {
         return running;
"
zookeeper,78708a8587841ccdcb3d07f33d3114e0c8cfc380,"ZOOKEEPER-2964: Conf"" command returns dataDir and dataLogDir opposingly",2018.01.19 09:12:03,Qihong Xu,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 3ac1ddd..c8cd72d 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -185,11 +185,11 @@
         pwriter.print(""secureClientPort="");
         pwriter.println(getSecureClientPort());
         pwriter.print(""dataDir="");
-        pwriter.println(zkDb.snapLog.getDataDir().getAbsolutePath());
+        pwriter.println(zkDb.snapLog.getSnapDir().getAbsolutePath());
         pwriter.print(""dataDirSize="");
         pwriter.println(getDataDirSize());
         pwriter.print(""dataLogDir="");
-        pwriter.println(zkDb.snapLog.getSnapDir().getAbsolutePath());
+        pwriter.println(zkDb.snapLog.getDataDir().getAbsolutePath());
         pwriter.print(""dataLogSize="");
         pwriter.println(getLogDirSize());
         pwriter.print(""tickTime="");
"
zookeeper,4d629d289fc4b1079fff2244b92a337e4068e240,ZOOKEEPER-2249: CRC check failed when preAllocSize smaller than node data,2018.01.19 08:43:11,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 72bb583..a35ae64 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -28,6 +28,7 @@
 import java.io.InputStream;
 import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
@@ -91,6 +92,7 @@
     private static final Logger LOG;
 
     static long preAllocSize =  65536 * 1024;
+    private static final ByteBuffer fill = ByteBuffer.allocateDirect(1);
 
     public final static int TXNLOG_MAGIC =
         ByteBuffer.wrap(""ZKLG"".getBytes()).getInt();
@@ -222,7 +224,7 @@
            currentSize = fos.getChannel().position();
            streamsToFlush.add(fos);
         }
-        padFile(fos);
+        currentSize = padFile(fos.getChannel());
         byte[] buf = Util.marshallTxnEntry(hdr, txn);
         if (buf == null || buf.length == 0) {
             throw new IOException(""Faulty serialization for header "" +
@@ -237,12 +239,46 @@
     }
 
     /**
-     * pad the current file to increase its size
-     * @param out the outputstream to be padded
+     * pad the current file to increase its size to the next multiple of preAllocSize greater than the current size and position
+     * @param fileChannel the fileChannel of the file to be padded
      * @throws IOException
      */
-    private void padFile(FileOutputStream out) throws IOException {
-        currentSize = Util.padLogFile(out, currentSize, preAllocSize);
+    private long padFile(FileChannel fileChannel) throws IOException {
+        long newFileSize = calculateFileSizeWithPadding(fileChannel.position(), currentSize, preAllocSize);
+        if (currentSize != newFileSize) {
+            fileChannel.write((ByteBuffer) fill.position(0), newFileSize - fill.remaining());
+            currentSize = newFileSize;
+        }
+        return currentSize;
+    }
+
+    /**
+     * Calculates a new file size with padding. We only return a new size if
+     * the current file position is sufficiently close (less than 4K) to end of
+     * file and preAllocSize is > 0.
+     *
+     * @param position the point in the file we have written to
+     * @param fileSize application keeps track of the current file size
+     * @param preAllocSize how many bytes to pad
+     * @return the new file size. It can be the same as fileSize if no
+     * padding was done.
+     * @throws IOException
+     */
+    // VisibleForTesting
+    public static long calculateFileSizeWithPadding(long position, long fileSize, long preAllocSize) {
+        // If preAllocSize is positive and we are within 4KB of the known end of the file calculate a new file size
+        if (preAllocSize > 0 && position + 4096 >= fileSize) {
+            // If we have written more than we have previously preallocated we need to make sure the new
+            // file size is larger than what we already have
+            if (position > fileSize){
+                fileSize = position + preAllocSize;
+                fileSize -= fileSize % preAllocSize;
+            } else {
+                fileSize += preAllocSize;
+            }
+        }
+
+        return fileSize;
     }
 
     /**
"
zookeeper,4d629d289fc4b1079fff2244b92a337e4068e240,ZOOKEEPER-2249: CRC check failed when preAllocSize smaller than node data,2018.01.19 08:43:11,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/Util.java b/src/java/main/org/apache/zookeeper/server/persistence/Util.java
index 08ad08a..bf1abaa 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/Util.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/Util.java
@@ -21,7 +21,6 @@
 import java.io.ByteArrayOutputStream;
 import java.io.EOFException;
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.io.Serializable;
@@ -51,7 +50,6 @@
     private static final String SNAP_DIR=""snapDir"";
     private static final String LOG_DIR=""logDir"";
     private static final String DB_FORMAT_CONV=""dbFormatConversion"";
-    private static final ByteBuffer fill = ByteBuffer.allocateDirect(1);
     
     public static String makeURIString(String dataDir, String dataLogDir, 
             String convPolicy){
@@ -196,29 +194,6 @@
     }
 
     /**
-     * Grows the file to the specified number of bytes. This only happenes if
-     * the current file position is sufficiently close (less than 4K) to end of 
-     * file. 
-     * 
-     * @param f output stream to pad
-     * @param currentSize application keeps track of the current file size
-     * @param preAllocSize how many bytes to pad
-     * @return the new file size. It can be the same as currentSize if no
-     * padding was done.
-     * @throws IOException
-     */
-    public static long padLogFile(FileOutputStream f,long currentSize,
-            long preAllocSize) throws IOException{
-        long position = f.getChannel().position();
-        if (position + 4096 >= currentSize) {
-            currentSize = currentSize + preAllocSize;
-            fill.position(0);
-            f.getChannel().write(fill, currentSize-fill.remaining());
-        }
-        return currentSize;
-    }
-
-    /**
      * Reads a transaction entry from the input archive.
      * @param ia archive to read from
      * @return null if the entry is corrupted or EOF has been reached; a buffer
"
zookeeper,e129e7a0b64d6555460d240be2d79e53aaa1bef9,ZOOKEEPER-2893: very poor choice of logging if client fails to connect to server,2017.12.20 03:27:25,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index a1984a3..1a7a783 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -26,6 +26,7 @@
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.net.SocketAddress;
+import java.net.SocketException;
 import java.nio.ByteBuffer;
 import java.util.HashSet;
 import java.util.ArrayList;
@@ -1051,7 +1052,7 @@
         // throws a LoginException: see startConnect() below.
         private boolean saslLoginFailed = false;
 
-        private void startConnect() throws IOException {
+        private void startConnect(InetSocketAddress addr) throws IOException {
             // initializing it for new connection
             saslLoginFailed = false;
             if(!isFirstConnect){
@@ -1063,14 +1064,6 @@
             }
             state = States.CONNECTING;
 
-            InetSocketAddress addr;
-            if (rwServerAddress != null) {
-                addr = rwServerAddress;
-                rwServerAddress = null;
-            } else {
-                addr = hostProvider.next(1000);
-            }
-
             String hostPort = addr.getHostString() + "":"" + addr.getPort();
             MDC.put(""myid"", hostPort);
             setName(getName().replaceAll(""\\(.*\\)"", ""("" + hostPort + "")""));
@@ -1123,6 +1116,7 @@
             int to;
             long lastPingRwServer = Time.currentElapsedTime();
             final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds
+            InetSocketAddress serverAddress = null;
             while (state.isAlive()) {
                 try {
                     if (!clientCnxnSocket.isConnected()) {
@@ -1130,7 +1124,13 @@
                         if (closing) {
                             break;
                         }
-                        startConnect();
+                        if (rwServerAddress != null) {
+                            serverAddress = rwServerAddress;
+                            rwServerAddress = null;
+                        } else {
+                            serverAddress = hostProvider.next(1000);
+                        }
+                        startConnect(serverAddress);
                         clientCnxnSocket.updateLastSendAndHeard();
                     }
 
@@ -1231,14 +1231,14 @@
                             LOG.info(e.getMessage() + RETRY_CONN_MSG);
                         } else if (e instanceof RWServerFoundException) {
                             LOG.info(e.getMessage());
+                        } else if (e instanceof SocketException) {
+                            LOG.info(""Socket error occurred: {}: {}"", serverAddress, e.getMessage());
                         } else {
-                            LOG.warn(
-                                    ""Session 0x""
-                                            + Long.toHexString(getSessionId())
-                                            + "" for server ""
-                                            + clientCnxnSocket.getRemoteSocketAddress()
-                                            + "", unexpected error""
-                                            + RETRY_CONN_MSG, e);
+                            LOG.warn(""Session 0x{} for server {}, unexpected error{}"",
+                                            Long.toHexString(getSessionId()),
+                                            serverAddress,
+                                            RETRY_CONN_MSG,
+                                            e);
                         }
                         // At this point, there might still be new packets appended to outgoingQueue.
                         // they will be handled in next connection or cleared up if closed.
"
zookeeper,f299303add79250ec2181f6c03b15e3754825284,ZOOKEEPER-2931: WriteLock recipe: Fix bug in znode ordering when the sessionId is part of the znode name,2017.11.16 08:21:33,Javier Cacheiro,"diff --git a/src/recipes/lock/src/java/org/apache/zookeeper/recipes/lock/ZNodeName.java b/src/recipes/lock/src/java/org/apache/zookeeper/recipes/lock/ZNodeName.java
index 99b6616..2e32e59 100644
--- a/src/recipes/lock/src/java/org/apache/zookeeper/recipes/lock/ZNodeName.java
+++ b/src/recipes/lock/src/java/org/apache/zookeeper/recipes/lock/ZNodeName.java
@@ -74,15 +74,17 @@
         return name.hashCode() + 37;
     }
 
+    /**
+     * Compare znodes based on their sequence number
+     * @param that other znode to compare to
+     * @return the difference between their sequence numbers: a positive value if this
+     *         znode has a larger sequence number, 0 if they have the same sequence number
+     *         or a negative number if this znode has a lower sequence number
+     */
     public int compareTo(ZNodeName that) {
-        int answer = this.prefix.compareTo(that.prefix);
+        int answer = this.sequence - that.sequence;
         if (answer == 0) {
-            int s1 = this.sequence;
-            int s2 = that.sequence;
-            if (s1 == -1 && s2 == -1) {
-                return this.name.compareTo(that.name);
-            }
-            answer = s1 == -1 ? 1 : s2 == -1 ? -1 : s1 - s2;
+            return this.prefix.compareTo(that.prefix);
         }
         return answer;
     }
"
zookeeper,0fe7a09ab57c73c3a5c91e68a889f600c0739136,ZOOKEEPER-2923: The comment of the variable matchSyncs in class CommitProcessor has a mistake.,2017.11.16 06:33:52,Jiafu Jiang,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
index 7439c7e..1eb7fac 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
@@ -112,10 +112,9 @@
     private Object emptyPoolSync = new Object();
 
     /**
-     * This flag indicates whether we need to wait for a response to come back
-     * from the leader or we just let the sync operation flow through like a
-     * read. The flag will be true if the CommitProcessor is in a Leader
-     * pipeline.
+     * This flag indicates whether we need to wait for a response to come back from the
+     * leader or we just let the sync operation flow through like a read. The flag will
+     * be false if the CommitProcessor is in a Leader pipeline.
      */
     boolean matchSyncs;
 
"
zookeeper,fb10c2b54698c8aab4477670bb0d6f7fe99c5c43,ZOOKEEPER-2914: compiler warning using java 9,2017.10.08 04:22:42,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java b/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
index 1ce4faa..43451b0 100644
--- a/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
+++ b/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
@@ -69,7 +69,7 @@
             try {
                 // Create and Register the top level Log4J MBean
                 // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();
-                Object hdm = Class.forName(""org.apache.log4j.jmx.HierarchyDynamicMBean"").newInstance();
+                Object hdm = Class.forName(""org.apache.log4j.jmx.HierarchyDynamicMBean"").getDeclaredConstructor().newInstance();
 
                 ObjectName mbo = new ObjectName(""log4j:hiearchy=default"");
                 mbs.registerMBean(hdm, mbo);
"
zookeeper,fb10c2b54698c8aab4477670bb0d6f7fe99c5c43,ZOOKEEPER-2914: compiler warning using java 9,2017.10.08 04:22:42,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 6dae02d..446438c 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -252,7 +252,7 @@
                      * so we've got to slice the buffer if it's too big.
                      */
                     b = (ByteBuffer) b.slice().limit(
-                        directBuffer.remaining());
+                            directBuffer.remaining());
                 }
                 /*
                  * put() is going to modify the positions of both
"
zookeeper,fb10c2b54698c8aab4477670bb0d6f7fe99c5c43,ZOOKEEPER-2914: compiler warning using java 9,2017.10.08 04:22:42,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/ServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/ServerCnxnFactory.java
index 1d2b044..dbe47a2 100644
--- a/src/java/main/org/apache/zookeeper/server/ServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/ServerCnxnFactory.java
@@ -130,7 +130,8 @@
             serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();
         }
         try {
-            ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName).newInstance();
+            ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)
+                    .getDeclaredConstructor().newInstance();
             LOG.info(""Using {} as server connection factory"", serverCnxnFactoryName);
             return serverCnxnFactory;
         } catch (Exception e) {
"
zookeeper,fb10c2b54698c8aab4477670bb0d6f7fe99c5c43,ZOOKEEPER-2914: compiler warning using java 9,2017.10.08 04:22:42,Andor Molnar,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java b/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
index c7aa81b..ed69f92 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
@@ -58,7 +58,7 @@
                     try {
                         Class<?> c = ZooKeeperServer.class.getClassLoader()
                                 .loadClass(className);
-                        AuthenticationProvider ap = (AuthenticationProvider) c
+                        AuthenticationProvider ap = (AuthenticationProvider) c.getDeclaredConstructor()
                                 .newInstance();
                         authenticationProviders.put(ap.getScheme(), ap);
                     } catch (Exception e) {
"
zookeeper,ef8b751c491bbc57b628ea9685a774fe40ba43dc,ZOOKEEPER-2581: Not handled NullPointerException while creating key manager and trustManager,2017.09.12 05:56:46,maoling,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/X509AuthenticationProvider.java b/src/java/main/org/apache/zookeeper/server/auth/X509AuthenticationProvider.java
index 902b307..93bc8fc 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/X509AuthenticationProvider.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/X509AuthenticationProvider.java
@@ -27,6 +27,7 @@
 
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.common.ZKConfig;
+import org.apache.zookeeper.common.X509Exception;
 import org.apache.zookeeper.common.X509Exception.KeyManagerException;
 import org.apache.zookeeper.common.X509Exception.TrustManagerException;
 import org.apache.zookeeper.common.X509Util;
@@ -64,7 +65,7 @@
      * <br/><code>zookeeper.ssl.keyStore.password</code>
      * <br/><code>zookeeper.ssl.trustStore.password</code>
      */
-    public X509AuthenticationProvider() {
+    public X509AuthenticationProvider() throws X509Exception {
         String keyStoreLocationProp = System.getProperty(
                 ZKConfig.SSL_KEYSTORE_LOCATION);
         String keyStorePasswordProp = System.getProperty(
@@ -72,25 +73,44 @@
 
         X509KeyManager km = null;
         X509TrustManager tm = null;
-        try {
-            km = X509Util.createKeyManager(
-                    keyStoreLocationProp, keyStorePasswordProp);
-        } catch (KeyManagerException e) {
-            LOG.error(""Failed to create key manager"", e);
+        if (keyStoreLocationProp == null && keyStorePasswordProp == null) {
+            LOG.warn(""keystore not specified for client connection"");
+        } else {
+            if (keyStoreLocationProp == null) {
+                throw new X509Exception(""keystore location not specified for client connection"");
+            }
+            if (keyStorePasswordProp == null) {
+                throw new X509Exception(""keystore password not specified for client connection"");
+            }
+            try {
+                km = X509Util.createKeyManager(
+                        keyStoreLocationProp, keyStorePasswordProp);
+            } catch (KeyManagerException e) {
+                LOG.error(""Failed to create key manager"", e);
+            }
         }
-
+        
         String trustStoreLocationProp = System.getProperty(
                 ZKConfig.SSL_TRUSTSTORE_LOCATION);
         String trustStorePasswordProp = System.getProperty(
                 ZKConfig.SSL_TRUSTSTORE_PASSWD);
 
-        try {
-            tm = X509Util.createTrustManager(
-                    trustStoreLocationProp, trustStorePasswordProp);
-        } catch (TrustManagerException e) {
-            LOG.error(""Failed to create trust manager"", e);
+        if (trustStoreLocationProp == null && trustStorePasswordProp == null) {
+            LOG.warn(""Truststore not specified for client connection"");
+        } else {
+            if (trustStoreLocationProp == null) {
+                throw new X509Exception(""Truststore location not specified for client connection"");
+            }
+            if (trustStorePasswordProp == null) {
+                throw new X509Exception(""Truststore password not specified for client connection"");
+            }
+            try {
+                tm = X509Util.createTrustManager(
+                        trustStoreLocationProp, trustStorePasswordProp);
+            } catch (TrustManagerException e) {
+                LOG.error(""Failed to create trust manager"", e);
+            }
         }
-
         this.keyManager = km;
         this.trustManager = tm;
     }
"
zookeeper,d7c192c1829cc657d3312f47ecb5b97519d1b30d,ZOOKEEPER-2804: Node creation fails with NPE if ACLs are null,2017.08.19 06:35:24,bhupendra jain,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 3218909..d24404f 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -1429,6 +1429,7 @@
         final String clientPath = path;
         PathUtils.validatePath(clientPath, createMode.isSequential());
         EphemeralType.validateTTL(createMode, -1);
+        validateACL(acl);
 
         final String serverPath = prependChroot(clientPath);
 
@@ -1439,9 +1440,6 @@
         request.setData(data);
         request.setFlags(createMode.toFlag());
         request.setPath(serverPath);
-        if (acl != null && acl.size() == 0) {
-            throw new KeeperException.InvalidACLException();
-        }
         request.setAcl(acl);
         ReplyHeader r = cnxn.submitRequest(h, request, response, null);
         if (r.getErr() != 0) {
@@ -1532,15 +1530,13 @@
         final String clientPath = path;
         PathUtils.validatePath(clientPath, createMode.isSequential());
         EphemeralType.validateTTL(createMode, ttl);
+        validateACL(acl);
 
         final String serverPath = prependChroot(clientPath);
 
         RequestHeader h = new RequestHeader();
         setCreateHeader(createMode, h);
         Create2Response response = new Create2Response();
-        if (acl != null && acl.size() == 0) {
-            throw new KeeperException.InvalidACLException();
-        }
         Record record = makeCreateRecord(createMode, serverPath, data, acl, ttl);
         ReplyHeader r = cnxn.submitRequest(h, record, response, null);
         if (r.getErr() != 0) {
@@ -2373,6 +2369,7 @@
     {
         final String clientPath = path;
         PathUtils.validatePath(clientPath);
+        validateACL(acl);
 
         final String serverPath = prependChroot(clientPath);
 
@@ -2380,9 +2377,6 @@
         h.setType(ZooDefs.OpCode.setACL);
         SetACLRequest request = new SetACLRequest();
         request.setPath(serverPath);
-        if (acl != null && acl.size() == 0) {
-            throw new KeeperException.InvalidACLException(clientPath);
-        }
         request.setAcl(acl);
         request.setVersion(aclVersion);
         SetACLResponse response = new SetACLResponse();
@@ -2945,4 +2939,18 @@
             throw ioe;
         }
     }
+
+    /**
+     * Validates the provided ACL list for null, empty or null value in it.
+     * 
+     * @param acl
+     *            ACL list
+     * @throws InvalidACLException
+     *             if ACL list is not valid
+     */
+    private void validateACL(List<ACL> acl) throws KeeperException.InvalidACLException {
+        if (acl == null || acl.isEmpty() || acl.contains(null)) {
+            throw new KeeperException.InvalidACLException();
+        }
+    }
 }
"
zookeeper,d7c192c1829cc657d3312f47ecb5b97519d1b30d,ZOOKEEPER-2804: Node creation fails with NPE if ACLs are null,2017.08.19 06:35:24,bhupendra jain,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 63b35ab..deda6b9 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -912,9 +912,11 @@
     private List<ACL> removeDuplicates(List<ACL> acl) {
 
         LinkedList<ACL> retval = new LinkedList<ACL>();
-        for (ACL a : acl) {
-            if (!retval.contains(a)) {
-                retval.add(a);
+        if (acl != null) {
+            for (ACL a : acl) {
+                if (!retval.contains(a)) {
+                    retval.add(a);
+                }
             }
         }
         return retval;
"
zookeeper,e104175bb47baeb800354078c015e78bfcb7c953,ZOOKEEPER-2786: Flaky test: org.apache.zookeeper.test.ClientTest.testNonExistingOpCode,2017.08.10 03:31:06,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index 142e916..9ff12e9 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -47,6 +47,7 @@
 import org.jboss.netty.buffer.ChannelBuffers;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.ChannelFutureListener;
 import org.jboss.netty.channel.MessageEvent;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -62,6 +63,7 @@
     int sessionTimeout;
     AtomicLong outstandingCount = new AtomicLong();
     Certificate[] clientChain;
+    volatile boolean closingChannel;
 
     /** The ZooKeeperServer for this connection. May be null if the server
      * is not currently serving requests (for example if the server is not
@@ -74,6 +76,7 @@
     
     NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {
         this.channel = channel;
+        this.closingChannel = false;
         this.zkServer = zks;
         this.factory = factory;
         if (this.factory.login != null) {
@@ -83,6 +86,8 @@
     
     @Override
     public void close() {
+        closingChannel = true;
+        
         if (LOG.isDebugEnabled()) {
             LOG.debug(""close called for sessionid:0x""
                     + Long.toHexString(sessionId));
@@ -115,7 +120,10 @@
         }
 
         if (channel.isOpen()) {
-            channel.close();
+            // Since we don't check on the futures created by write calls to the channel complete we need to make sure
+            // that all writes have been completed before closing the channel or we risk data loss
+            // See: http://lists.jboss.org/pipermail/netty-users/2009-August/001122.html
+            channel.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
         }
     }
 
@@ -171,7 +179,7 @@
     @Override
     public void sendResponse(ReplyHeader h, Record r, String tag)
             throws IOException {
-        if (!channel.isOpen()) {
+        if (closingChannel || !channel.isOpen()) {
             return;
         }
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
"
zookeeper,5c4e44332e55bbf21ca59583f3e8ca97fc4bb266,ZOOKEEPER-2853: Update lastZxidSeen in FileTxnLog,2017.08.04 03:41:30,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 9f55ab4..72bb583 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -53,25 +53,25 @@
  * <blockquote><pre>
  * LogFile:
  *     FileHeader TxnList ZeroPad
- * 
+ *
  * FileHeader: {
  *     magic 4bytes (ZKLG)
  *     version 4bytes
  *     dbid 8bytes
  *   }
- * 
+ *
  * TxnList:
  *     Txn || Txn TxnList
- *     
+ *
  * Txn:
  *     checksum Txnlen TxnHeader Record 0x42
- * 
+ *
  * checksum: 8bytes Adler32 is currently used
  *   calculated across payload -- Txnlen, TxnHeader, Record and 0x42
- * 
+ *
  * Txnlen:
  *     len 4bytes
- * 
+ *
  * TxnHeader: {
  *     sessionid 8bytes
  *     cxid 4bytes
@@ -79,13 +79,13 @@
  *     time 8bytes
  *     type 4bytes
  *   }
- *     
+ *
  * Record:
  *     See Jute definition file for details on the various record types
- *      
+ *
  * ZeroPad:
  *     0 padded to EOF (filled during preallocation stage)
- * </pre></blockquote> 
+ * </pre></blockquote>
  */
 public class FileTxnLog implements TxnLog {
     private static final Logger LOG;
@@ -175,7 +175,7 @@
     /**
      * close all the open file handles
      * @throws IOException
-     */
+      */
     public synchronized void close() throws IOException {
         if (logStream != null) {
             logStream.close();
@@ -184,54 +184,56 @@
             log.close();
         }
     }
-    
+
     /**
      * append an entry to the transaction log
      * @param hdr the header of the transaction
      * @param txn the transaction part of the entry
-     * returns true iff something appended, otw false 
+     * returns true iff something appended, otw false
      */
     public synchronized boolean append(TxnHeader hdr, Record txn)
         throws IOException
     {
-        if (hdr != null) {
-            if (hdr.getZxid() <= lastZxidSeen) {
-                LOG.warn(""Current zxid "" + hdr.getZxid()
-                        + "" is <= "" + lastZxidSeen + "" for ""
-                        + hdr.getType());
-            }
-            if (logStream==null) {
-               if(LOG.isInfoEnabled()){
-                    LOG.info(""Creating new log file: log."" +  
-                            Long.toHexString(hdr.getZxid()));
-               }
-               
-               logFileWrite = new File(logDir, (""log."" + 
-                       Long.toHexString(hdr.getZxid())));
-               fos = new FileOutputStream(logFileWrite);
-               logStream=new BufferedOutputStream(fos);
-               oa = BinaryOutputArchive.getArchive(logStream);
-               FileHeader fhdr = new FileHeader(TXNLOG_MAGIC,VERSION, dbId);
-               fhdr.serialize(oa, ""fileheader"");
-               // Make sure that the magic number is written before padding.
-               logStream.flush();
-               currentSize = fos.getChannel().position();
-               streamsToFlush.add(fos);
-            }
-            padFile(fos);
-            byte[] buf = Util.marshallTxnEntry(hdr, txn);
-            if (buf == null || buf.length == 0) {
-                throw new IOException(""Faulty serialization for header "" +
-                        ""and txn"");
-            }
-            Checksum crc = makeChecksumAlgorithm();
-            crc.update(buf, 0, buf.length);
-            oa.writeLong(crc.getValue(), ""txnEntryCRC"");
-            Util.writeTxnBytes(oa, buf);
-            
-            return true;
+        if (hdr == null) {
+            return false;
         }
-        return false;
+        if (hdr.getZxid() <= lastZxidSeen) {
+            LOG.warn(""Current zxid "" + hdr.getZxid()
+                    + "" is <= "" + lastZxidSeen + "" for ""
+                    + hdr.getType());
+        } else {
+            lastZxidSeen = hdr.getZxid();
+        }
+        if (logStream==null) {
+           if(LOG.isInfoEnabled()){
+                LOG.info(""Creating new log file: log."" +
+                        Long.toHexString(hdr.getZxid()));
+           }
+
+           logFileWrite = new File(logDir, (""log."" +
+                   Long.toHexString(hdr.getZxid())));
+           fos = new FileOutputStream(logFileWrite);
+           logStream=new BufferedOutputStream(fos);
+           oa = BinaryOutputArchive.getArchive(logStream);
+           FileHeader fhdr = new FileHeader(TXNLOG_MAGIC,VERSION, dbId);
+           fhdr.serialize(oa, ""fileheader"");
+           // Make sure that the magic number is written before padding.
+           logStream.flush();
+           currentSize = fos.getChannel().position();
+           streamsToFlush.add(fos);
+        }
+        padFile(fos);
+        byte[] buf = Util.marshallTxnEntry(hdr, txn);
+        if (buf == null || buf.length == 0) {
+            throw new IOException(""Faulty serialization for header "" +
+                    ""and txn"");
+        }
+        Checksum crc = makeChecksumAlgorithm();
+        crc.update(buf, 0, buf.length);
+        oa.writeLong(crc.getValue(), ""txnEntryCRC"");
+        Util.writeTxnBytes(oa, buf);
+
+        return true;
     }
 
     /**
@@ -456,10 +458,10 @@
     }
 
     /**
-     * a class that keeps track of the position 
+     * a class that keeps track of the position
      * in the input stream. The position points to offset
-     * that has been consumed by the applications. It can 
-     * wrap buffered input streams to provide the right offset 
+     * that has been consumed by the applications. It can
+     * wrap buffered input streams to provide the right offset
      * for the application.
      */
     static class PositionInputStream extends FilterInputStream {
@@ -468,7 +470,7 @@
             super(in);
             position = 0;
         }
-        
+
         @Override
         public int read() throws IOException {
             int rc = super.read();
@@ -483,9 +485,9 @@
             if (rc > 0) {
                 position += rc;
             }
-            return rc;            
+            return rc;
         }
-        
+
         @Override
         public int read(byte[] b, int off, int len) throws IOException {
             int rc = super.read(b, off, len);
@@ -494,7 +496,7 @@
             }
             return rc;
         }
-        
+
         @Override
         public long skip(long n) throws IOException {
             long rc = super.skip(n);
@@ -522,7 +524,7 @@
             throw new UnsupportedOperationException(""reset"");
         }
     }
-    
+
     /**
      * this class implements the txnlog iterator interface
      * which is used for reading the transaction logs
@@ -535,7 +537,7 @@
         File logFile;
         InputArchive ia;
         static final String CRC_ERROR=""CRC check failed"";
-       
+
         PositionInputStream inputStream=null;
         //stored files is the list of files greater than
         //the zxid we are looking for.
@@ -564,7 +566,7 @@
                 }
             }
         }
-        
+
         /**
          * create an iterator over a transaction database directory
          * @param logDir the transaction database directory
@@ -596,7 +598,7 @@
             goToNextLog();
             next();
         }
-        
+
         /**
          * Return total storage size of txnlog that will return by this iterator.
          */
@@ -634,7 +636,7 @@
             FileHeader header= new FileHeader();
             header.deserialize(ia, ""fileheader"");
             if (header.getMagic() != FileTxnLog.TXNLOG_MAGIC) {
-                throw new IOException(""Transaction log: "" + this.logFile + "" has invalid magic number "" 
+                throw new IOException(""Transaction log: "" + this.logFile + "" has invalid magic number ""
                         + header.getMagic()
                         + "" != "" + FileTxnLog.TXNLOG_MAGIC);
             }
"
zookeeper,69c8cbea1dcc95bb1b4eb01cbfd667a1bfba1f5d,ZOOKEEPER-2862: Incorrect javadoc syntax for web links in StaticHostProvider.java.,2017.08.04 03:32:38,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
index ef70f3f..cb53936 100644
--- a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
+++ b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
@@ -140,9 +140,11 @@
      * If true is returned, the function sets pOld and pNew that correspond to the probability to migrate to ones of the
      * new servers in serverAddresses or one of the old servers (migrating to one of the old servers is done only
      * if our client's currentHost is not in serverAddresses). See nextHostInReconfigMode for the selection logic.
-     * 
-     * See {@link https://issues.apache.org/jira/browse/ZOOKEEPER-1355} for the protocol and its evaluation, and
-	 * StaticHostProviderTest for the tests that illustrate how load balancing works with this policy.
+     *
+     * See <a href=""https://issues.apache.org/jira/browse/ZOOKEEPER-1355"">ZOOKEEPER-1355</a>
+     * for the protocol and its evaluation, and StaticHostProviderTest for the tests that illustrate how load balancing
+     * works with this policy.
+     *
      * @param serverAddresses new host list
      * @param currentHost the host to which this client is currently connected
      * @return true if changing connections is necessary for load-balancing, false otherwise  
"
zookeeper,3f7e4133f3abc17df5eb4f0145d0833417bfdb33,ZOOKEEPER-2852: Read snapshotSizeFactor from system property,2017.08.04 03:28:20,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 2845d28..16baf46 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -80,7 +80,8 @@
      * Default value is to use snapshot if txnlog size exceeds 1/3 the size of snapshot
      */
     public static final String SNAPSHOT_SIZE_FACTOR = ""zookeeper.snapshotSizeFactor"";
-    private double snapshotSizeFactor = 0.33;
+    public static final double DEFAULT_SNAPSHOT_SIZE_FACTOR = 0.33;
+    private double snapshotSizeFactor;
 
     public static final int commitLogCount = 500;
     protected static int commitLogBuffer = 700;
@@ -98,6 +99,23 @@
         dataTree = new DataTree();
         sessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();
         this.snapLog = snapLog;
+
+        try {
+            snapshotSizeFactor = Double.parseDouble(
+                System.getProperty(SNAPSHOT_SIZE_FACTOR,
+                        Double.toString(DEFAULT_SNAPSHOT_SIZE_FACTOR)));
+            if (snapshotSizeFactor > 1) {
+                snapshotSizeFactor = DEFAULT_SNAPSHOT_SIZE_FACTOR;
+                LOG.warn(""The configured {} is invalid, going to use "" +
+                        ""the default {}"", SNAPSHOT_SIZE_FACTOR,
+                        DEFAULT_SNAPSHOT_SIZE_FACTOR);
+            }
+        } catch (NumberFormatException e) {
+            LOG.error(""Error parsing {}, using default value {}"",
+                    SNAPSHOT_SIZE_FACTOR, DEFAULT_SNAPSHOT_SIZE_FACTOR);
+            snapshotSizeFactor = DEFAULT_SNAPSHOT_SIZE_FACTOR;
+        }
+        LOG.info(""{} = {}"", SNAPSHOT_SIZE_FACTOR, snapshotSizeFactor);
     }
 
     /**
@@ -269,8 +287,15 @@
         }
     }
 
-    public double getSnapshotSizeFactor() {
-        return snapshotSizeFactor;
+    public boolean isTxnLogSyncEnabled() {
+        boolean enabled = snapshotSizeFactor >= 0;
+        if (enabled) {
+            LOG.info(""On disk txn sync enabled with snapshotSizeFactor ""
+                + snapshotSizeFactor);
+        } else {
+            LOG.info(""On disk txn sync disabled"");
+        }
+        return enabled;
     }
 
     public long calculateTxnLogSizeLimit() {
"
zookeeper,3f7e4133f3abc17df5eb4f0145d0833417bfdb33,ZOOKEEPER-2852: Read snapshotSizeFactor from system property,2017.08.04 03:28:20,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index 5fc5efc..1fbe708 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -672,7 +672,7 @@
         // Keep track of the latest zxid which already queued
         long currentZxid = peerLastZxid;
         boolean needSnap = true;
-        boolean txnLogSyncEnabled = (db.getSnapshotSizeFactor() >= 0);
+        boolean txnLogSyncEnabled = db.isTxnLogSyncEnabled();
         ReentrantReadWriteLock lock = db.getLogLock();
         ReadLock rl = lock.readLock();
         try {
"
zookeeper,ddf0364903bf7ac7cd25b2e1927f0d9d3c7203c4,ZOOKEEPER-2819: Changing membership configuration via rolling restart …,2017.07.07 01:48:47,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 088d4a4..f2cccd2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -374,6 +374,13 @@
                 // The leader is going to dump the database
                 // db is clear as part of deserializeSnapshot()
                 zk.getZKDatabase().deserializeSnapshot(leaderIs);
+                // ZOOKEEPER-2819: overwrite config node content extracted
+                // from leader snapshot with local config, to avoid potential
+                // inconsistency of config node content during rolling restart.
+                if (!QuorumPeerConfig.isReconfigEnabled()) {
+                    LOG.debug(""Reset config node content from local config after deserialization of snapshot."");
+                    zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());
+                }
                 String signature = leaderIs.readString(""signature"");
                 if (!signature.equals(""BenWasHere"")) {
                     LOG.error(""Missing signature. Got "" + signature);
"
zookeeper,ddf0364903bf7ac7cd25b2e1927f0d9d3c7203c4,ZOOKEEPER-2819: Changing membership configuration via rolling restart …,2017.07.07 01:48:47,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 61ef4ca..da99fd5 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -1742,10 +1742,15 @@
     }
    
     public boolean processReconfig(QuorumVerifier qv, Long suggestedLeaderId, Long zxid, boolean restartLE) {
+       if (!QuorumPeerConfig.isReconfigEnabled()) {
+           LOG.debug(""Reconfig feature is disabled, skip reconfig processing."");
+           return false;
+       }
+
        InetSocketAddress oldClientAddr = getClientAddress();
 
        // update last committed quorum verifier, write the new config to disk
-       // and restart leader election if config changed
+       // and restart leader election if config changed.
        QuorumVerifier prevQV = setQuorumVerifier(qv, true);
 
        // There is no log record for the initial config, thus after syncing
"
zookeeper,ddf0364903bf7ac7cd25b2e1927f0d9d3c7203c4,ZOOKEEPER-2819: Changing membership configuration via rolling restart …,2017.07.07 01:48:47,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index aa13f88..96e32d8 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -363,8 +363,9 @@
         // static configuration params see writeDynamicConfig()
         if (dynamicConfigFileStr == null) {
             setupQuorumPeerConfig(zkProp, true);
-            if (isDistributed()) {
+            if (isDistributed() && isReconfigEnabled()) {
                 // we don't backup static config for standalone mode.
+                // we also don't backup if reconfig feature is disabled.
                 backupOldConfig();
             }
         }
"
zookeeper,7db83eb9dcbd26b79f852e93520db821dabff047,ZOOKEEPER-2818: Improve the ZooKeeper#setACL java doc,2017.07.04 14:56:09,b00902108,"diff --git a/src/contrib/zooinspector/src/java/org/apache/zookeeper/retry/ZooKeeperRetry.java b/src/contrib/zooinspector/src/java/org/apache/zookeeper/retry/ZooKeeperRetry.java
index feb4301..ce959a1 100644
--- a/src/contrib/zooinspector/src/java/org/apache/zookeeper/retry/ZooKeeperRetry.java
+++ b/src/contrib/zooinspector/src/java/org/apache/zookeeper/retry/ZooKeeperRetry.java
@@ -217,12 +217,12 @@
     }
 
     @Override
-    public Stat setACL(String path, List<ACL> acl, int version)
+    public Stat setACL(String path, List<ACL> acl, int aclVersion)
             throws KeeperException, InterruptedException {
         int count = 0;
         do {
             try {
-                return super.setACL(path, acl, version);
+                return super.setACL(path, acl, aclVersion);
             } catch (KeeperException.ConnectionLossException e) {
                 LoggerFactory.getLogger().warn(
                         ""ZooKeeper connection lost.  Trying to reconnect."");
"
zookeeper,7db83eb9dcbd26b79f852e93520db821dabff047,ZOOKEEPER-2818: Improve the ZooKeeper#setACL java doc,2017.07.04 14:56:09,b00902108,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 38eb032..7aeff9e 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -2347,25 +2347,25 @@
 
     /**
      * Set the ACL for the node of the given path if such a node exists and the
-     * given version matches the version of the node. Return the stat of the
+     * given aclVersion matches the acl version of the node. Return the stat of the
      * node.
      * <p>
      * A KeeperException with error code KeeperException.NoNode will be thrown
      * if no node with the given path exists.
      * <p>
      * A KeeperException with error code KeeperException.BadVersion will be
-     * thrown if the given version does not match the node's version.
+     * thrown if the given aclVersion does not match the node's aclVersion.
      *
-     * @param path
-     * @param acl
-     * @param version
+     * @param path the given path for the node
+     * @param acl the given acl for the node
+     * @param aclVersion the given acl version of the node
      * @return the stat of the node.
      * @throws InterruptedException If the server transaction is interrupted.
      * @throws KeeperException If the server signals an error with a non-zero error code.
      * @throws org.apache.zookeeper.KeeperException.InvalidACLException If the acl is invalide.
      * @throws IllegalArgumentException if an invalid path is specified
      */
-    public Stat setACL(final String path, List<ACL> acl, int version)
+    public Stat setACL(final String path, List<ACL> acl, int aclVersion)
         throws KeeperException, InterruptedException
     {
         final String clientPath = path;
@@ -2381,7 +2381,7 @@
             throw new KeeperException.InvalidACLException(clientPath);
         }
         request.setAcl(acl);
-        request.setVersion(version);
+        request.setVersion(aclVersion);
         SetACLResponse response = new SetACLResponse();
         ReplyHeader r = cnxn.submitRequest(h, request, response, null);
         if (r.getErr() != 0) {
"
zookeeper,69710181042a8c1f0461c1739b96171d88f2b126,ZOOKEEPER-2355: Ephemeral node is never deleted if follower fails while reading the proposal packet,2017.07.04 14:39:58,arshadmohammad,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index f048da8..088d4a4 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -370,7 +370,7 @@
                 snapshotNeeded = false;
             }
             else if (qp.getType() == Leader.SNAP) {
-                LOG.info(""Getting a snapshot from leader"");
+                LOG.info(""Getting a snapshot from leader 0x"" + Long.toHexString(qp.getZxid()));
                 // The leader is going to dump the database
                 // db is clear as part of deserializeSnapshot()
                 zk.getZKDatabase().deserializeSnapshot(leaderIs);
@@ -379,6 +379,7 @@
                     LOG.error(""Missing signature. Got "" + signature);
                     throw new IOException(""Missing signature"");                   
                 }
+                zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());
             } else if (qp.getType() == Leader.TRUNC) {
                 //we need to truncate the log to the lastzxid of the leader
                 LOG.warn(""Truncating log to get in sync with the leader 0x""
@@ -390,6 +391,7 @@
                             + Long.toHexString(qp.getZxid()));
                     System.exit(13);
                 }
+                zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());
 
             }
             else {
@@ -399,7 +401,6 @@
 
             }
             zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());
-            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());
             zk.createSessionTracker();            
             
             long lastQueued = 0;
"
zookeeper,fb267672d219c73c0cf2527fafebc1a0b17d3bee,ZOOKEEPER-1782: Let a SASL super user be super,2017.06.24 01:39:05,Robert Evans,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 86f8bea..10994c1 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -1132,6 +1132,10 @@
                     String authorizationID = saslServer.getAuthorizationID();
                     LOG.info(""adding SASL authorization for authorizationID: "" + authorizationID);
                     cnxn.addAuthInfo(new Id(""sasl"",authorizationID));
+                    if (System.getProperty(""zookeeper.superUser"") != null && 
+                        authorizationID.equals(System.getProperty(""zookeeper.superUser""))) {
+                        cnxn.addAuthInfo(new Id(""super"", """"));
+                    }
                 }
             }
             catch (SaslException e) {
"
zookeeper,fb267672d219c73c0cf2527fafebc1a0b17d3bee,ZOOKEEPER-1782: Let a SASL super user be super,2017.06.24 01:39:05,Robert Evans,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/SASLAuthenticationProvider.java b/src/java/main/org/apache/zookeeper/server/auth/SASLAuthenticationProvider.java
index 4690e69..1f60b39 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/SASLAuthenticationProvider.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/SASLAuthenticationProvider.java
@@ -38,11 +38,6 @@
     }
 
     public boolean matches(String id,String aclExpr) {
-        if (System.getProperty(""zookeeper.superUser"") != null) {
-            if (id.equals(System.getProperty(""zookeeper.superUser"")) || id.equals(aclExpr)) {
-              return true;
-            }
-        }
         if ((id.equals(""super"") || id.equals(aclExpr))) {
           return true;
         }
"
zookeeper,111ae5a5b67999925f1921736a14fcfbdb1b7348,ZOOKEEPER-2808: fix miss-referenced ACL count issue when upgrading the ZooKeeper,2017.06.19 02:23:04,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index f0ab2b3..b6fb61d 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -118,7 +118,7 @@
     /** this will be the string thats stored as a child of /zookeeper */
     private static final String configChildZookeeper = configZookeeper
             .substring(procZookeeper.length() + 1);
-    
+
     /**
      * the path trie that keeps track fo the quota nodes in this datatree
      */
@@ -223,13 +223,6 @@
      */
     private final DataNode quotaDataNode = new DataNode(new byte[0], -1L, new StatPersisted());
 
-    /**
-     * create a /zookeeper/config node for maintaining the configuration (membership and quorum system) info for
-     * zookeeper
-     */
-    private DataNode configDataNode = new DataNode(new byte[0], -1L, new StatPersisted());
-
-    
     public DataTree() {
         /* Rather than fight it, let root have an alias */
         nodes.put("""", root);
@@ -241,10 +234,14 @@
 
         procDataNode.addChild(quotaChildZookeeper);
         nodes.put(quotaZookeeper, quotaDataNode);
-        
+
         addConfigNode();
     }
 
+    /**
+     * create a /zookeeper/config node for maintaining the configuration (membership and quorum system) info for
+     * zookeeper
+     */
     public void addConfigNode() {
         DataNode zookeeperZnode = nodes.get(procZookeeper);
         if (zookeeperZnode != null) { // should always be the case
@@ -253,7 +250,7 @@
             assert false : ""There's no /zookeeper znode - this should never happen."";
         }
 
-        nodes.put(configZookeeper, configDataNode);
+        nodes.put(configZookeeper, new DataNode(new byte[0], -1L, new StatPersisted()));
         try {
             // Reconfig node is access controlled by default (ZOOKEEPER-2014).
             setACL(configZookeeper, ZooDefs.Ids.READ_ACL_UNSAFE, -1);
@@ -406,8 +403,8 @@
      * @param zxid
      *            Transaction ID
      * @param time
-     * @throws NodeExistsException 
-     * @throws NoNodeException 
+     * @throws NodeExistsException
+     * @throws NoNodeException
      * @throws KeeperException
      */
     public void createNode(final String path, byte data[], List<ACL> acl,
@@ -415,7 +412,7 @@
     		throws NoNodeException, NodeExistsException {
     	createNode(path, data, acl, ephemeralOwner, parentCVersion, zxid, time, null);
     }
-    
+
     /**
      * Add a new node to the DataTree.
      * @param path
@@ -432,8 +429,8 @@
      * @param time
      * @param outputStat
      * 			  A Stat object to store Stat output results into.
-     * @throws NodeExistsException 
-     * @throws NoNodeException 
+     * @throws NodeExistsException
+     * @throws NoNodeException
      * @throws KeeperException
      */
     public void createNode(final String path, byte data[], List<ACL> acl,
@@ -1327,37 +1324,37 @@
             DataNode node = getNode(path);
             WatchedEvent e = null;
             if (node == null) {
-                watcher.process(new WatchedEvent(EventType.NodeDeleted, 
+                watcher.process(new WatchedEvent(EventType.NodeDeleted,
                             KeeperState.SyncConnected, path));
             } else if (node.stat.getMzxid() > relativeZxid) {
-                watcher.process(new WatchedEvent(EventType.NodeDataChanged, 
+                watcher.process(new WatchedEvent(EventType.NodeDataChanged,
                             KeeperState.SyncConnected, path));
             } else {
                 this.dataWatches.addWatch(path, watcher);
-            }    
-        }    
+            }
+        }
         for (String path : existWatches) {
             DataNode node = getNode(path);
             if (node != null) {
-                watcher.process(new WatchedEvent(EventType.NodeCreated, 
+                watcher.process(new WatchedEvent(EventType.NodeCreated,
                             KeeperState.SyncConnected, path));
             } else {
                 this.dataWatches.addWatch(path, watcher);
-            }    
-        }    
+            }
+        }
         for (String path : childWatches) {
             DataNode node = getNode(path);
             if (node == null) {
-                watcher.process(new WatchedEvent(EventType.NodeDeleted, 
+                watcher.process(new WatchedEvent(EventType.NodeDeleted,
                             KeeperState.SyncConnected, path));
             } else if (node.stat.getPzxid() > relativeZxid) {
-                watcher.process(new WatchedEvent(EventType.NodeChildrenChanged, 
+                watcher.process(new WatchedEvent(EventType.NodeChildrenChanged,
                             KeeperState.SyncConnected, path));
             } else {
                 this.childWatches.addWatch(path, watcher);
-            }    
-        }    
-    }    
+            }
+        }
+    }
 
      /**
       * This method sets the Cversion and Pzxid for the specified node to the
@@ -1436,4 +1433,9 @@
         }
         return removed;
     }
+
+    // visible for testing
+    public ReferenceCountedACLCache getReferenceCountedAclCache() {
+        return aclCache;
+    }
 }
"
zookeeper,111ae5a5b67999925f1921736a14fcfbdb1b7348,ZOOKEEPER-2808: fix miss-referenced ACL count issue when upgrading the ZooKeeper,2017.06.19 02:23:04,Fangmin Lyu,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 05bbb91..2845d28 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -75,13 +75,13 @@
     protected ConcurrentHashMap<Long, Integer> sessionsWithTimeouts;
     protected FileTxnSnapLog snapLog;
     protected long minCommittedLog, maxCommittedLog;
-    
+
     /**
      * Default value is to use snapshot if txnlog size exceeds 1/3 the size of snapshot
      */
     public static final String SNAPSHOT_SIZE_FACTOR = ""zookeeper.snapshotSizeFactor"";
     private double snapshotSizeFactor = 0.33;
-    
+
     public static final int commitLogCount = 500;
     protected static int commitLogBuffer = 700;
     protected LinkedList<Proposal> committedLog = new LinkedList<Proposal>();
@@ -268,7 +268,7 @@
             wl.unlock();
         }
     }
-    
+
     public double getSnapshotSizeFactor() {
         return snapshotSizeFactor;
     }
@@ -570,7 +570,7 @@
         try {
             if (this.dataTree.getNode(ZooDefs.CONFIG_NODE) == null) {
                 // should only happen during upgrade
-                LOG.warn(""configuration znode missing (hould only happen during upgrade), creating the node"");
+                LOG.warn(""configuration znode missing (should only happen during upgrade), creating the node"");
                 this.dataTree.addConfigNode();
             }
             this.dataTree.setData(ZooDefs.CONFIG_NODE, qv.toString().getBytes(), -1, qv.getVersion(), Time.currentWallTime());
@@ -578,7 +578,7 @@
             System.out.println(""configuration node missing - should not happen"");
         }
     }
- 
+
     /**
      * Use for unit testing, so we can turn this feature on/off
      * @param snapshotSizeFactor Set to minus value to turn this off.
@@ -603,7 +603,7 @@
 
     /**
      * Remove watch from the datatree
-     * 
+     *
      * @param path
      *            node to remove watches from
      * @param type
"
zookeeper,fa1dc109d4c1bb7913fee43170ed6131e3dc1b1f,ZOOKEEPER-2775: ZK Client not able to connect with Xid out of order error,2017.06.09 00:59:05,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 2a1da4c..a1984a3 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1052,6 +1052,8 @@
         private boolean saslLoginFailed = false;
 
         private void startConnect() throws IOException {
+            // initializing it for new connection
+            saslLoginFailed = false;
             if(!isFirstConnect){
                 try {
                     Thread.sleep(r.nextInt(1000));
"
zookeeper,3824da0b649c6a6a698cfe6c79ca3d44a9e94f29,ZOOKEEPER-2797: Defend against bad TTLs from misbehaving clients,2017.06.01 12:45:49,Patrick White,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 9ad4eea..a4fc7d3 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -658,10 +658,10 @@
             path = createRequest.getPath();
             acl = createRequest.getAcl();
             data = createRequest.getData();
-            ttl = 0;
+            ttl = -1;
         }
         CreateMode createMode = CreateMode.fromFlag(flags);
-        validateCreateRequest(createMode, request);
+        validateCreateRequest(path, createMode, request, ttl);
         String parentPath = validatePathForCreate(path, request.sessionId);
 
         List<ACL> listACL = fixupACL(path, request.authInfo, acl);
@@ -925,8 +925,14 @@
         return retval;
     }
     
-    private void validateCreateRequest(CreateMode createMode, Request request)
+    private void validateCreateRequest(String path, CreateMode createMode, Request request, long ttl)
             throws KeeperException {
+        try {
+            EphemeralType.validateTTL(createMode, ttl);
+        } catch (IllegalArgumentException e) {
+            BadArgumentsException bae = new BadArgumentsException(path);
+            throw bae;
+        }
         if (createMode.isEphemeral()) {
             // Exception is set when local session failed to upgrade
             // so we just need to report the error
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/CreateCommand.java b/src/java/main/org/apache/zookeeper/cli/CreateCommand.java
index ee6f58a..46ffc17 100644
--- a/src/java/main/org/apache/zookeeper/cli/CreateCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/CreateCommand.java
@@ -118,6 +118,8 @@
         try {
             String newPath = hasT ? zk.create(path, data, acl, flags, new Stat(), ttl) : zk.create(path, data, acl, flags);
             err.println(""Created "" + newPath);
+        } catch(IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch(KeeperException.EphemeralOnLocalSessionException e) {
             err.println(""Unable to create ephemeral node on a local session"");
             throw new CliWrapperException(e);
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/DelQuotaCommand.java b/src/java/main/org/apache/zookeeper/cli/DelQuotaCommand.java
index 31a0546..8005406 100644
--- a/src/java/main/org/apache/zookeeper/cli/DelQuotaCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/DelQuotaCommand.java
@@ -95,7 +95,7 @@
      */
     public static boolean delQuota(ZooKeeper zk, String path,
             boolean bytes, boolean numNodes)
-            throws KeeperException, IOException, InterruptedException {
+            throws KeeperException, IOException, InterruptedException, MalformedPathException {
         String parentPath = Quotas.quotaZookeeper + path;
         String quotaPath = Quotas.quotaZookeeper + path + ""/"" + 
                 Quotas.limitNode;
@@ -106,6 +106,8 @@
         byte[] data = null;
         try {
             data = zk.getData(quotaPath, false, new Stat());
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException.NoNodeException ne) {
             System.err.println(""quota does not exist for "" + path);
             return true;
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/DeleteAllCommand.java b/src/java/main/org/apache/zookeeper/cli/DeleteAllCommand.java
index 4d1b749..a3f7853 100644
--- a/src/java/main/org/apache/zookeeper/cli/DeleteAllCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/DeleteAllCommand.java
@@ -65,6 +65,8 @@
         String path = args[1];
         try {
             ZKUtil.deleteRecursive(zk, path);
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException|InterruptedException ex) {
             throw new CliWrapperException(ex);
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/DeleteCommand.java b/src/java/main/org/apache/zookeeper/cli/DeleteCommand.java
index e2be214..d3c67b6 100644
--- a/src/java/main/org/apache/zookeeper/cli/DeleteCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/DeleteCommand.java
@@ -80,7 +80,9 @@
         }
         
         try {
-        zk.delete(path, version);
+            zk.delete(path, version);
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch(KeeperException|InterruptedException ex) {
             throw new CliWrapperException(ex);
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/GetAclCommand.java b/src/java/main/org/apache/zookeeper/cli/GetAclCommand.java
index 3f9e22b..b5feb60 100644
--- a/src/java/main/org/apache/zookeeper/cli/GetAclCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/GetAclCommand.java
@@ -67,6 +67,8 @@
         List<ACL> acl;
         try {
            acl = zk.getACL(path, stat);
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException|InterruptedException ex) {
             throw new CliWrapperException(ex);
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/GetCommand.java b/src/java/main/org/apache/zookeeper/cli/GetCommand.java
index bbc63e6..6e58a5e 100644
--- a/src/java/main/org/apache/zookeeper/cli/GetCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/GetCommand.java
@@ -83,6 +83,8 @@
         byte data[];
         try {
             data = zk.getData(path, watch, stat);
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException|InterruptedException ex) {
             throw new CliException(ex);
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/ListQuotaCommand.java b/src/java/main/org/apache/zookeeper/cli/ListQuotaCommand.java
index e3b9083..8c51c26 100644
--- a/src/java/main/org/apache/zookeeper/cli/ListQuotaCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/ListQuotaCommand.java
@@ -69,6 +69,8 @@
                     + Quotas.statNode, false, stat);
             out.println(""Output stat for "" + path + "" ""
                     + new StatsTrack(new String(data)).toString());
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException.NoNodeException ne) {
             err.println(""quota for "" + path + "" does not exist."");
         } catch (KeeperException|InterruptedException ex) {
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/Ls2Command.java b/src/java/main/org/apache/zookeeper/cli/Ls2Command.java
index 43f5d0e..aed1b0e 100644
--- a/src/java/main/org/apache/zookeeper/cli/Ls2Command.java
+++ b/src/java/main/org/apache/zookeeper/cli/Ls2Command.java
@@ -60,6 +60,8 @@
         List<String> children;
         try {
             children = zk.getChildren(path, watch, stat);
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException|InterruptedException ex) {
             throw new CliWrapperException(ex);
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/LsCommand.java b/src/java/main/org/apache/zookeeper/cli/LsCommand.java
index ebb1cdd..9e53d5d 100644
--- a/src/java/main/org/apache/zookeeper/cli/LsCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/LsCommand.java
@@ -108,6 +108,8 @@
                 List<String> children = zk.getChildren(path, watch, stat);
                 printChildren(children, stat);
             }
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException|InterruptedException ex) {
             throw new CliWrapperException(ex);
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/MalformedPathException.java b/src/java/main/org/apache/zookeeper/cli/MalformedPathException.java
new file mode 100644
index 0000000..e65765b
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/cli/MalformedPathException.java
@@ -0,0 +1,25 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.cli;
+
+@SuppressWarnings(""serial"")
+public class MalformedPathException extends CliException {
+    public MalformedPathException(String message) {
+        super(message);
+    }
+}
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/RemoveWatchesCommand.java b/src/java/main/org/apache/zookeeper/cli/RemoveWatchesCommand.java
index 604cd4b..2863443 100644
--- a/src/java/main/org/apache/zookeeper/cli/RemoveWatchesCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/RemoveWatchesCommand.java
@@ -62,7 +62,7 @@
     }
 
     @Override
-    public boolean exec() throws CliWrapperException {
+    public boolean exec() throws CliWrapperException, MalformedPathException {
         String path = args[1];
         WatcherType wtype = WatcherType.Any;
         // if no matching option -c or -d or -a is specified, we remove
@@ -79,6 +79,8 @@
 
         try {
             zk.removeAllWatches(path, wtype, local);
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException|InterruptedException ex) {
             throw new CliWrapperException(ex);
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/SetAclCommand.java b/src/java/main/org/apache/zookeeper/cli/SetAclCommand.java
index 7fb4f0f..d2cfc0d 100644
--- a/src/java/main/org/apache/zookeeper/cli/SetAclCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/SetAclCommand.java
@@ -73,6 +73,8 @@
             if (cl.hasOption(""s"")) {
                 new StatPrinter(out).print(stat);
             }
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException|InterruptedException ex) {
             throw new CliWrapperException(ex);
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/SetCommand.java b/src/java/main/org/apache/zookeeper/cli/SetCommand.java
index 10bb129..43ca2e1 100644
--- a/src/java/main/org/apache/zookeeper/cli/SetCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/SetCommand.java
@@ -71,6 +71,8 @@
             if (cl.hasOption(""s"")) {
                 new StatPrinter(out).print(stat);
             }
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException|InterruptedException ex) {
             throw new CliWrapperException(ex);
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/SetQuotaCommand.java b/src/java/main/org/apache/zookeeper/cli/SetQuotaCommand.java
index cd670a2..7df5667 100644
--- a/src/java/main/org/apache/zookeeper/cli/SetQuotaCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/SetQuotaCommand.java
@@ -91,11 +91,16 @@
 
     public static boolean createQuota(ZooKeeper zk, String path,
             long bytes, int numNodes)
-            throws KeeperException, IOException, InterruptedException {
+            throws KeeperException, IOException, InterruptedException, MalformedPathException {
         // check if the path exists. We cannot create
         // quota for a path that already exists in zookeeper
         // for now.
-        Stat initStat = zk.exists(path, false);
+        Stat initStat;
+        try {
+            initStat = zk.exists(path, false);
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
+        }
         if (initStat == null) {
             throw new IllegalArgumentException(path + "" does not exist."");
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/StatCommand.java b/src/java/main/org/apache/zookeeper/cli/StatCommand.java
index b37071b..33d8e87 100644
--- a/src/java/main/org/apache/zookeeper/cli/StatCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/StatCommand.java
@@ -81,6 +81,8 @@
         Stat stat;
         try {
             stat = zk.exists(path, watch);
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
         } catch (KeeperException|InterruptedException ex) {
             throw new CliWrapperException(ex);
         }
"
zookeeper,b0b194533c08c8a111497e853668f751b28ae4e9,ZOOKEEPER-2757: Incorrect path crashes zkCli,2017.05.27 07:52:28,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/cli/SyncCommand.java b/src/java/main/org/apache/zookeeper/cli/SyncCommand.java
index f79db88..74affd2 100644
--- a/src/java/main/org/apache/zookeeper/cli/SyncCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/SyncCommand.java
@@ -57,12 +57,17 @@
     @Override
     public boolean exec() throws CliException {
         String path = args[1];
-        zk.sync(path, new AsyncCallback.VoidCallback() {
+        try {
+            zk.sync(path, new AsyncCallback.VoidCallback() {
 
-            public void processResult(int rc, String path, Object ctx) {
-                out.println(""Sync returned "" + rc);
-            }
-        }, null);
+                public void processResult(int rc, String path, Object ctx) {
+                    out.println(""Sync returned "" + rc);
+                }
+            }, null);
+        } catch (IllegalArgumentException ex) {
+            throw new MalformedPathException(ex.getMessage());
+        }
+
 
         return false;
     }
"
zookeeper,0a3e2d1d4bdbb96f41da7111db3913ef08068722,ZOOKEEPER-2785: Server inappropriately throttles connections under loa…,2017.05.19 06:14:39,Abhishek Singh Chouhan,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index e2fba10..86f8bea 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -1099,6 +1099,7 @@
                 Record rsp = processSasl(incomingBuffer,cnxn);
                 ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());
                 cnxn.sendResponse(rh,rsp, ""response""); // not sure about 3rd arg..what is it?
+                return;
             }
             else {
                 Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),
"
zookeeper,a680655a3569bfc546712cb85eeaea8c9b7de3ad,ZOOKEEPER-1932: Remove deprecated LeaderElection class.,2017.05.11 23:59:42,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 38b0299..61ef4ca 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -29,7 +29,6 @@
 import java.net.DatagramSocket;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.SocketException;
 import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
@@ -831,28 +830,16 @@
         responder.interrupt();
     }
     synchronized public void startLeaderElection() {
-       try {
-           if (getPeerState() == ServerState.LOOKING) {
-               currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());
-           }
-       } catch(IOException e) {
-           RuntimeException re = new RuntimeException(e.getMessage());
-           re.setStackTrace(e.getStackTrace());
-           throw re;
-       }
-
-       // if (!getView().containsKey(myid)) {
-      //      throw new RuntimeException(""My id "" + myid + "" not in the peer list"");
-        //}
-        if (electionType == 0) {
-            try {
-                udpSocket = new DatagramSocket(myQuorumAddr.getPort());
-                responder = new ResponderThread();
-                responder.start();
-            } catch (SocketException e) {
-                throw new RuntimeException(e);
+        try {
+            if (getPeerState() == ServerState.LOOKING) {
+                currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());
             }
+        } catch(IOException e) {
+            RuntimeException re = new RuntimeException(e.getMessage());
+            re.setStackTrace(e.getStackTrace());
+            throw re;
         }
+
         this.electionAlg = createElectionAlgorithm(electionType);
     }
 
@@ -952,29 +939,26 @@
 
         //TODO: use a factory rather than a switch
         switch (electionAlgorithm) {
-        case 0:
-            le = new LeaderElection(this);
-            break;
-        case 1:
-            le = new AuthFastLeaderElection(this);
-            break;
-        case 2:
-            le = new AuthFastLeaderElection(this, true);
-            break;
-        case 3:
-            qcm = new QuorumCnxManager(this);
-            QuorumCnxManager.Listener listener = qcm.listener;
-            if(listener != null){
-                listener.start();
-                FastLeaderElection fle = new FastLeaderElection(this, qcm);
-                fle.start();
-                le = fle;
-            } else {
-                LOG.error(""Null listener when initializing cnx manager"");
-            }
-            break;
-        default:
-            assert false;
+            case 1:
+                le = new AuthFastLeaderElection(this);
+                break;
+            case 2:
+                le = new AuthFastLeaderElection(this, true);
+                break;
+            case 3:
+                qcm = new QuorumCnxManager(this);
+                QuorumCnxManager.Listener listener = qcm.listener;
+                if(listener != null){
+                    listener.start();
+                    FastLeaderElection fle = new FastLeaderElection(this, qcm);
+                    fle.start();
+                    le = fle;
+                } else {
+                    LOG.error(""Null listener when initializing cnx manager"");
+                }
+                break;
+            default:
+                assert false;
         }
         return le;
     }
@@ -982,9 +966,6 @@
     @SuppressWarnings(""deprecation"")
     protected Election makeLEStrategy(){
         LOG.debug(""Initializing leader election protocol..."");
-        if (getElectionType() == 0) {
-            electionAlg = new LeaderElection(this);
-        }
         return electionAlg;
     }
 
"
zookeeper,a680655a3569bfc546712cb85eeaea8c9b7de3ad,ZOOKEEPER-1932: Remove deprecated LeaderElection class.,2017.05.11 23:59:42,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index cb8f1c2..aa13f88 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -255,6 +255,9 @@
                 syncLimit = Integer.parseInt(value);
             } else if (key.equals(""electionAlg"")) {
                 electionAlg = Integer.parseInt(value);
+                if (electionAlg != 1 && electionAlg != 2 && electionAlg != 3) {
+                    throw new ConfigException(""Invalid electionAlg value. Only 1, 2, 3 are supported."");
+                }
             } else if (key.equals(""quorumListenOnAllIPs"")) {
                 quorumListenOnAllIPs = Boolean.parseBoolean(value);
             } else if (key.equals(""peerType"")) {
@@ -594,17 +597,12 @@
                     LOG.warn(""Non-optimial configuration, consider an odd number of servers."");
                 }
             }
-            /*
-             * If using FLE, then every server requires a separate election
-             * port.
-             */            
-           if (eAlg != 0) {
-               for (QuorumServer s : qv.getVotingMembers().values()) {
-                   if (s.electionAddr == null)
-                       throw new IllegalArgumentException(
-                               ""Missing election port for server: "" + s.id);
-               }
-           }   
+
+            for (QuorumServer s : qv.getVotingMembers().values()) {
+                if (s.electionAddr == null)
+                    throw new IllegalArgumentException(
+                            ""Missing election port for server: "" + s.id);
+            }
         }
         return qv;
     }
"
zookeeper,f7281f30467bfecb679f3e3d436337dfd16c810a,ZOOKEEPER-2316: comment does not match code logic,2017.04.28 06:20:32,Umesh Panchaksharaiah,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 0ef5e2c..5cd836f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -724,7 +724,9 @@
        // concurrent reconfigs are allowed, this can happen.
        if (outstandingProposals.containsKey(zxid - 1)) return false;
        
-       // getting a quorum from all necessary configurations
+       // in order to be committed, a proposal must be accepted by a quorum.
+       //
+       // getting a quorum from all necessary configurations.
         if (!p.hasAllQuorums()) {
            return false;                 
         }
@@ -737,8 +739,6 @@
                     + (lastCommitted+1));
         }     
         
-        // in order to be committed, a proposal must be accepted by a quorum              
-        
         outstandingProposals.remove(zxid);
         
         if (p.request != null) {
"
zookeeper,6e91424b220ccbefc8456e1b8a5e0ba0e5130f9a,ZOOKEEPER-2747: Fix ZooKeeperAdmin Compilation Warning,2017.04.18 08:56:21,Abraham Fine,"diff --git a/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java b/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java
index 4aad9da..afdb729 100644
--- a/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java
+++ b/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java
@@ -47,6 +47,8 @@
  *
  * @since 3.5.3
  */
+// See ZooKeeper.java for an explanation of why we need @SuppressWarnings(""try"")
+@SuppressWarnings(""try"")
 public class ZooKeeperAdmin extends ZooKeeper {
     private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperAdmin.class);
 
"
zookeeper,b3ef40bffe49c1e42aee23a600a775194f36bca0,ZOOKEEPER-2743: Netty connection leaks JMX connection bean.,2017.04.11 02:19:34,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index cf5bd8a..142e916 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -87,6 +87,12 @@
             LOG.debug(""close called for sessionid:0x""
                     + Long.toHexString(sessionId));
         }
+
+        // ZOOKEEPER-2743:
+        // Always unregister connection upon close to prevent
+        // connection bean leak under certain race conditions.
+        factory.unregisterConnection(this);
+
         synchronized(factory.cnxns){
             // if this is not in cnxns then it's already closed
             if (!factory.cnxns.remove(this)) {
@@ -111,7 +117,6 @@
         if (channel.isOpen()) {
             channel.close();
         }
-        factory.unregisterConnection(this);
     }
 
     @Override
"
zookeeper,d8adc547f9856747905b7d46450f13fa98df147f,ZOOKEEPER-2737: close netty connection when exceptions occur during w…,2017.03.28 02:31:44,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
index 25b682b..a024689 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
@@ -144,8 +144,8 @@
             if (cnxn != null) {
                 if (LOG.isDebugEnabled()) {
                     LOG.debug(""Closing "" + cnxn);
-                    cnxn.close();
                 }
+                cnxn.close();
             }
         }
 
"
zookeeper,63577ba52a829391ded3ae11c62c0e996865b5c7,ZOOKEEPER-2725: Promote local session to global when ephemeral created in multi-op,2017.03.22 01:49:56,Brian Nixon,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
index df7b407..f6e4f11 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
@@ -23,6 +23,8 @@
 
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.MultiTransactionRecord;
+import org.apache.zookeeper.Op;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.proto.CreateRequest;
 import org.apache.zookeeper.server.ByteBufferInputStream;
@@ -62,18 +64,41 @@
         // This is called by the request processor thread (either follower
         // or observer request processor), which is unique to a learner.
         // So will not be called concurrently by two threads.
-        if (request.type != OpCode.create ||
+        if ((request.type != OpCode.create && request.type != OpCode.create2 && request.type != OpCode.multi) ||
             !upgradeableSessionTracker.isLocalSession(request.sessionId)) {
             return null;
         }
-        CreateRequest createRequest = new CreateRequest();
-        request.request.rewind();
-        ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
-        request.request.rewind();
-        CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());
-        if (!createMode.isEphemeral()) {
-            return null;
+
+        if (OpCode.multi == request.type) {
+            MultiTransactionRecord multiTransactionRecord = new MultiTransactionRecord();
+            request.request.rewind();
+            ByteBufferInputStream.byteBuffer2Record(request.request, multiTransactionRecord);
+            request.request.rewind();
+            boolean containsEphemeralCreate = false;
+            for (Op op : multiTransactionRecord) {
+                if (op.getType() == OpCode.create || op.getType() == OpCode.create2) {
+                    CreateRequest createRequest = (CreateRequest)op.toRequestRecord();
+                    CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());
+                    if (createMode.isEphemeral()) {
+                        containsEphemeralCreate = true;
+                        break;
+                    }
+                }
+            }
+            if (!containsEphemeralCreate) {
+                return null;
+            }
+        } else {
+            CreateRequest createRequest = new CreateRequest();
+            request.request.rewind();
+            ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
+            request.request.rewind();
+            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());
+            if (!createMode.isEphemeral()) {
+                return null;
+            }
         }
+
         // Uh oh.  We need to upgrade before we can proceed.
         if (!self.isLocalSessionsUpgradingEnabled()) {
             throw new KeeperException.EphemeralOnLocalSessionException();
"
zookeeper,0313a0e0b6c47b316271533165e5830d1ca04478,ZOOKEEPER-2726 ZOOKEEPER-2693: Patch for introduces potential race condition,2017.03.17 04:57:12,Kyle Nusbaum,"diff --git a/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java b/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java
index 82e09dc..45bd942 100644
--- a/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java
+++ b/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java
@@ -169,7 +169,7 @@
     private static boolean whiteListInitialized = false;
 
     // @VisibleForTesting
-    public static void resetWhiteList() {
+    public synchronized static void resetWhiteList() {
         whiteListInitialized = false;
         whiteListedCommands.clear();
     }
@@ -202,7 +202,7 @@
      * @param command The command string.
      * @return true if the specified command is enabled
      */
-    public static boolean isEnabled(String command) {
+    public synchronized static boolean isEnabled(String command) {
         if (whiteListInitialized) {
             return whiteListedCommands.contains(command);
         }
"
zookeeper,5fe68506f217246c7ebd96803f9c78e13ec2f11a,ZOOKEEPER-2693: DOS attack on wchp/wchc four letter words (4lw),2017.03.05 03:22:03,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 76b9be0..6dae02d 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -47,6 +47,7 @@
 import org.apache.zookeeper.server.command.CommandExecutor;
 import org.apache.zookeeper.server.command.FourLetterCommands;
 import org.apache.zookeeper.server.command.SetTraceMaskCommand;
+import org.apache.zookeeper.server.command.NopCommand;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -478,12 +479,11 @@
     {
         // We take advantage of the limited size of the length to look
         // for cmds. They are all 4-bytes which fits inside of an int
-        String cmd = FourLetterCommands.getCmdMapView().get(len);
-        if (cmd == null) {
+        if (!FourLetterCommands.isKnown(len)) {
             return false;
         }
-        LOG.info(""Processing "" + cmd + "" command from ""
-                + sock.socket().getRemoteSocketAddress());
+
+        String cmd = FourLetterCommands.getCommandString(len);
         packetReceived();
 
         /** cancel the selection key to remove the socket handling
@@ -505,6 +505,19 @@
 
         final PrintWriter pwriter = new PrintWriter(
                 new BufferedWriter(new SendBufferWriter()));
+
+        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.
+        if (!FourLetterCommands.isEnabled(cmd)) {
+            LOG.debug(""Command {} is not executed because it is not in the whitelist."", cmd);
+            NopCommand nopCmd = new NopCommand(pwriter, this, cmd +
+                    "" is not executed because it is not in the whitelist."");
+            nopCmd.start();
+            return true;
+        }
+
+        LOG.info(""Processing "" + cmd + "" command from ""
+                + sock.socket().getRemoteSocketAddress());
+
         if (len == FourLetterCommands.setTraceMaskCmd) {
             incomingBuffer = ByteBuffer.allocate(8);
             int rc = sock.read(incomingBuffer);
"
zookeeper,5fe68506f217246c7ebd96803f9c78e13ec2f11a,ZOOKEEPER-2693: DOS attack on wchp/wchc four letter words (4lw),2017.03.05 03:22:03,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index 9b6f28e..cf5bd8a 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -41,6 +41,7 @@
 import org.apache.zookeeper.proto.WatcherEvent;
 import org.apache.zookeeper.server.command.CommandExecutor;
 import org.apache.zookeeper.server.command.FourLetterCommands;
+import org.apache.zookeeper.server.command.NopCommand;
 import org.apache.zookeeper.server.command.SetTraceMaskCommand;
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.buffer.ChannelBuffers;
@@ -267,17 +268,30 @@
     {
         // We take advantage of the limited size of the length to look
         // for cmds. They are all 4-bytes which fits inside of an int
-        String cmd = FourLetterCommands.getCmdMapView().get(len);
-        if (cmd == null) {
+        if (!FourLetterCommands.isKnown(len)) {
             return false;
         }
+
+        String cmd = FourLetterCommands.getCommandString(len);
+
         channel.setInterestOps(0).awaitUninterruptibly();
-        LOG.info(""Processing "" + cmd + "" command from ""
-                + channel.getRemoteAddress());
         packetReceived();
 
         final PrintWriter pwriter = new PrintWriter(
                 new BufferedWriter(new SendBufferWriter()));
+
+        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.
+        if (!FourLetterCommands.isEnabled(cmd)) {
+            LOG.debug(""Command {} is not executed because it is not in the whitelist."", cmd);
+            NopCommand nopCmd = new NopCommand(pwriter, this, cmd +
+                    "" is not executed because it is not in the whitelist."");
+            nopCmd.start();
+            return true;
+        }
+
+        LOG.info(""Processing "" + cmd + "" command from ""
+                + channel.getRemoteAddress());
+
        if (len == FourLetterCommands.setTraceMaskCmd) {
             ByteBuffer mask = ByteBuffer.allocate(8);
             message.readBytes(mask);
"
zookeeper,5fe68506f217246c7ebd96803f9c78e13ec2f11a,ZOOKEEPER-2693: DOS attack on wchp/wchc four letter words (4lw),2017.03.05 03:22:03,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java b/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java
index 0364f44..82e09dc 100644
--- a/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java
+++ b/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java
@@ -18,10 +18,15 @@
 
 package org.apache.zookeeper.server.command;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import java.nio.ByteBuffer;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.Arrays;
 
 /**
  * This class contains constants for all the four letter commands
@@ -153,11 +158,82 @@
      */
     public final static int telnetCloseCmd = 0xfff4fffd;
 
-    final static HashMap<Integer, String> cmd2String =
-        new HashMap<Integer, String>();
+    private static final String ZOOKEEPER_4LW_COMMANDS_WHITELIST = ""zookeeper.4lw.commands.whitelist"";
 
-    public static Map<Integer, String> getCmdMapView() {
-        return Collections.unmodifiableMap(cmd2String);
+    private static final Logger LOG = LoggerFactory.getLogger(FourLetterCommands.class);
+
+    private static final Map<Integer, String> cmd2String = new HashMap<Integer, String>();
+
+    private static final Set<String> whiteListedCommands = new HashSet<String>();
+
+    private static boolean whiteListInitialized = false;
+
+    // @VisibleForTesting
+    public static void resetWhiteList() {
+        whiteListInitialized = false;
+        whiteListedCommands.clear();
+    }
+
+    /**
+     * Return the string representation of the specified command code.
+     */
+    public static String getCommandString(int command) {
+        return cmd2String.get(command);
+    }
+
+    /**
+     * Check if the specified command code is from a known command.
+     *
+     * @param command The integer code of command.
+     * @return true if the specified command is known, false otherwise.
+     */
+    public static boolean isKnown(int command) {
+        return cmd2String.containsKey(command);
+    }
+
+    /**
+     * Check if the specified command is enabled.
+     *
+     * In ZOOKEEPER-2693 we introduce a configuration option to only
+     * allow a specific set of white listed commands to execute.
+     * A command will only be executed if it is also configured
+     * in the white list.
+     *
+     * @param command The command string.
+     * @return true if the specified command is enabled
+     */
+    public static boolean isEnabled(String command) {
+        if (whiteListInitialized) {
+            return whiteListedCommands.contains(command);
+        }
+
+        String commands = System.getProperty(ZOOKEEPER_4LW_COMMANDS_WHITELIST);
+        if (commands != null) {
+            String[] list = commands.split("","");
+            for (String cmd : list) {
+                if (cmd.trim().equals(""*"")) {
+                    for (Map.Entry<Integer, String> entry : cmd2String.entrySet()) {
+                        whiteListedCommands.add(entry.getValue());
+                    }
+                    break;
+                }
+                if (!cmd.trim().isEmpty()) {
+                    whiteListedCommands.add(cmd.trim());
+                }
+            }
+        }
+
+        // It is sad that isro and srvr are used by ZooKeeper itself. Need fix this
+        // before deprecating 4lw.
+        if (System.getProperty(""readonlymode.enabled"", ""false"").equals(""true"")) {
+            whiteListedCommands.add(""isro"");
+        }
+        // zkServer.sh depends on ""srvr"".
+        whiteListedCommands.add(""srvr"");
+        whiteListInitialized = true;
+        LOG.info(""The list of known four letter word commands is : {}"", Arrays.asList(cmd2String));
+        LOG.info(""The list of enabled four letter word commands is : {}"", Arrays.asList(whiteListedCommands));
+        return whiteListedCommands.contains(command);
     }
 
     // specify all of the commands that are available
"
zookeeper,5fe68506f217246c7ebd96803f9c78e13ec2f11a,ZOOKEEPER-2693: DOS attack on wchp/wchc four letter words (4lw),2017.03.05 03:22:03,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/command/NopCommand.java b/src/java/main/org/apache/zookeeper/server/command/NopCommand.java
new file mode 100644
index 0000000..4924fcf
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/command/NopCommand.java
@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.command;
+
+import java.io.PrintWriter;
+
+import org.apache.zookeeper.server.ServerCnxn;
+
+/**
+ * A command that does not do anything except reply to client with predefined message.
+ * It is used to inform clients who execute none white listed four letter word commands.
+ */
+public class NopCommand extends AbstractFourLetterCommand {
+    private String msg;
+
+    public NopCommand(PrintWriter pw, ServerCnxn serverCnxn, String msg) {
+        super(pw, serverCnxn);
+        this.msg = msg;
+    }
+
+    @Override
+    public void commandRun() {
+        pw.println(msg);
+    }
+}
"
zookeeper,fd211a5275b6231e668268fb9df2820e07f5f33c,ZOOKEEPER-2687: Deadlock while shutting down the Leader server,2017.02.16 07:04:18,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 7663d71..0ef5e2c 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -590,8 +590,9 @@
 
                     // check leader running status
                     if (!this.isRunning()) {
-                        shutdown(""Unexpected internal error"");
-                        return;
+                        // set shutdown flag
+                        shutdownMessage = ""Unexpected internal error"";
+                        break;
                     }
 
                     if (!tickSkip && !syncedAckSet.hasAllQuorums()) {
"
zookeeper,15e3f7fccc770783786e8097f7a6618509bfee0f,ZOOKEEPER-2617: correct a few spelling typos,2017.02.14 17:23:32,Edward Ribeiro,"diff --git a/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java b/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java
index 26beb4a..57cdd95 100644
--- a/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java
+++ b/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java
@@ -612,7 +612,7 @@
                                 zooKeeper));
                     } catch (Exception e) {
                         LoggerFactory.getLogger().error(
-                                ""Error occured adding node watcher for node: ""
+                                ""Error occurred adding node watcher for node: ""
                                         + node, e);
                     }
                 }
@@ -687,7 +687,7 @@
                     }
                 } catch (Exception e) {
                     LoggerFactory.getLogger().error(
-                            ""Error occured re-adding node watcherfor node ""
+                            ""Error occurred re-adding node watcherfor node ""
                                     + nodePath, e);
                 }
                 nodeListener.processEvent(event.getPath(), event.getType()
"
zookeeper,15e3f7fccc770783786e8097f7a6618509bfee0f,ZOOKEEPER-2617: correct a few spelling typos,2017.02.14 17:23:32,Edward Ribeiro,"diff --git a/src/java/main/org/apache/zookeeper/server/DatadirCleanupManager.java b/src/java/main/org/apache/zookeeper/server/DatadirCleanupManager.java
index bd928cb..4a6d1a2 100644
--- a/src/java/main/org/apache/zookeeper/server/DatadirCleanupManager.java
+++ b/src/java/main/org/apache/zookeeper/server/DatadirCleanupManager.java
@@ -139,7 +139,7 @@
             try {
                 PurgeTxnLog.purge(logsDir, snapsDir, snapRetainCount);
             } catch (Exception e) {
-                LOG.error(""Error occured while purging."", e);
+                LOG.error(""Error occurred while purging."", e);
             }
             LOG.info(""Purge task completed."");
         }
"
zookeeper,15e3f7fccc770783786e8097f7a6618509bfee0f,ZOOKEEPER-2617: correct a few spelling typos,2017.02.14 17:23:32,Edward Ribeiro,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperThread.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperThread.java
index 5f11ebc..189adaf 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperThread.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperThread.java
@@ -52,6 +52,6 @@
      *            - exception object
      */
     protected void handleException(String thName, Throwable e) {
-        LOG.warn(""Exception occured from thread {}"", thName, e);
+        LOG.warn(""Exception occurred from thread {}"", thName, e);
     }
 }
"
zookeeper,201cac20e1a66e7d4180a6c7e18834c0ca6094dc,ZOOKEEPER-2683: RaceConditionTest is flaky,2017.02.14 06:09:59,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
index bd49dbf..cde193e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
@@ -154,7 +154,7 @@
                       true);
           }
 
-          quorumPeer = new QuorumPeer();
+          quorumPeer = getQuorumPeer();
           quorumPeer.setTxnFactory(new FileTxnSnapLog(
                       config.getDataLogDir(),
                       config.getDataDir()));
@@ -189,4 +189,9 @@
           LOG.warn(""Quorum Peer interrupted"", e);
       }
     }
+
+    // @VisibleForTesting
+    protected QuorumPeer getQuorumPeer() {
+        return new QuorumPeer();
+    }
 }
"
zookeeper,c5df1c9acec07036da225b1251cb30be60301224,ZOOKEEPER-2642: rename ZooKeeper reconfig API to reconfigure API.,2017.02.12 08:34:24,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java b/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java
index f60e8d5..4aad9da 100644
--- a/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java
+++ b/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java
@@ -172,8 +172,8 @@
      * @throws InterruptedException If the server transaction is interrupted.
      * @throws KeeperException If the server signals an error with a non-zero error code.
      */
-    public byte[] reconfig(String joiningServers, String leavingServers,
-                           String newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException {
+    public byte[] reconfigure(String joiningServers, String leavingServers,
+                              String newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException {
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.reconfig);
         ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);
@@ -191,13 +191,13 @@
     /**
      * Convenience wrapper around reconfig that takes Lists of strings instead of comma-separated servers.
      *
-     * @see #reconfig
+     * @see #reconfigure
      *
      */
-    public byte[] reconfig(List<String> joiningServers, List<String> leavingServers,
-                           List<String> newMembers, long fromConfig,
-                           Stat stat) throws KeeperException, InterruptedException {
-        return reconfig(StringUtils.joinStrings(joiningServers, "",""),
+    public byte[] reconfigure(List<String> joiningServers, List<String> leavingServers,
+                              List<String> newMembers, long fromConfig,
+                              Stat stat) throws KeeperException, InterruptedException {
+        return reconfigure(StringUtils.joinStrings(joiningServers, "",""),
                         StringUtils.joinStrings(leavingServers, "",""),
                         StringUtils.joinStrings(newMembers, "",""),
                         fromConfig, stat);
@@ -206,11 +206,11 @@
     /**
      * The Asynchronous version of reconfig.
      *
-     * @see #reconfig
+     * @see #reconfigure
      *
      **/
-    public void reconfig(String joiningServers, String leavingServers,
-        String newMembers, long fromConfig, DataCallback cb, Object ctx) {
+    public void reconfigure(String joiningServers, String leavingServers,
+                            String newMembers, long fromConfig, DataCallback cb, Object ctx) {
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.reconfig);
         ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);
@@ -222,13 +222,13 @@
     /**
      * Convenience wrapper around asynchronous reconfig that takes Lists of strings instead of comma-separated servers.
      *
-     * @see #reconfig
+     * @see #reconfigure
      *
      */
-    public void reconfig(List<String> joiningServers,
-        List<String> leavingServers, List<String> newMembers, long fromConfig,
-        DataCallback cb, Object ctx) {
-        reconfig(StringUtils.joinStrings(joiningServers, "",""),
+    public void reconfigure(List<String> joiningServers,
+                            List<String> leavingServers, List<String> newMembers, long fromConfig,
+                            DataCallback cb, Object ctx) {
+        reconfigure(StringUtils.joinStrings(joiningServers, "",""),
                  StringUtils.joinStrings(leavingServers, "",""),
                  StringUtils.joinStrings(newMembers, "",""),
                  fromConfig, cb, ctx);
"
zookeeper,c5df1c9acec07036da225b1251cb30be60301224,ZOOKEEPER-2642: rename ZooKeeper reconfig API to reconfigure API.,2017.02.12 08:34:24,randgalt,"diff --git a/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java b/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java
index a0709f3..342f5d2 100644
--- a/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java
@@ -154,7 +154,7 @@
                 return false;
             }
 
-            byte[] curConfig = ((ZooKeeperAdmin)zk).reconfig(joining,
+            byte[] curConfig = ((ZooKeeperAdmin)zk).reconfigure(joining,
                     leaving, members, version, stat);
             out.println(""Committed new configuration:\n"" + new String(curConfig));
             
"
zookeeper,bbfd0169417c316bbdd22ff7a38176845aa0efc6,ZOOKEEPER-2678: Discovery and Sync can take a very long time on large DBs (master),2017.02.12 08:12:00,Robert (Bobby) Evans,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 079d809..92d3c13 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -526,7 +526,15 @@
         return state == State.RUNNING;
     }
 
-    public synchronized void shutdown() {
+    public void shutdown() {
+        shutdown(false);
+    }
+
+    /**
+     * Shut down the server instance
+     * @param fullyShutDown true if another server using the same database will not replace this one in the same process
+     */
+    public synchronized void shutdown(boolean fullyShutDown) {
         if (!canShutdown()) {
             LOG.debug(""ZooKeeper server is not running, so not proceeding to shutdown!"");
             return;
@@ -544,9 +552,15 @@
         if (firstProcessor != null) {
             firstProcessor.shutdown();
         }
-        if (zkDb != null) {
+
+        if (fullyShutDown && zkDb != null) {
             zkDb.clear();
         }
+        // else there is no need to clear the database
+        //  * When a new quorum is established we can still apply the diff
+        //    on top of the same zkDb data
+        //  * If we fetch a new snapshot from leader, the zkDb will be
+        //    cleared anyway before loading the snapshot
 
         unregisterJMX();
     }
"
zookeeper,bbfd0169417c316bbdd22ff7a38176845aa0efc6,ZOOKEEPER-2678: Discovery and Sync can take a very long time on large DBs (master),2017.02.12 08:12:00,Robert (Bobby) Evans,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
index 5bfeed3..372c78a 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
@@ -167,7 +167,7 @@
                 secureCnxnFactory.join();
             }
             if (zkServer.canShutdown()) {
-                zkServer.shutdown();
+                zkServer.shutdown(true);
             }
         } catch (InterruptedException e) {
             // warn, but generally this is ok
"
zookeeper,bbfd0169417c316bbdd22ff7a38176845aa0efc6,ZOOKEEPER-2678: Discovery and Sync can take a very long time on large DBs (master),2017.02.12 08:12:00,Robert (Bobby) Evans,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 9803197..f048da8 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -358,12 +358,16 @@
         
         QuorumVerifier newLeaderQV = null;
         
-        readPacket(qp);   
+        // In the DIFF case we don't need to do a snapshot because the transactions will sync on top of any existing snapshot
+        // For SNAP and TRUNC the snapshot is needed to save that history
+        boolean snapshotNeeded = true;
+        readPacket(qp);
         LinkedList<Long> packetsCommitted = new LinkedList<Long>();
         LinkedList<PacketInFlight> packetsNotCommitted = new LinkedList<PacketInFlight>();
         synchronized (zk) {
             if (qp.getType() == Leader.DIFF) {
-                LOG.info(""Getting a diff from the leader 0x"" + Long.toHexString(qp.getZxid()));                
+                LOG.info(""Getting a diff from the leader 0x{}"", Long.toHexString(qp.getZxid()));
+                snapshotNeeded = false;
             }
             else if (qp.getType() == Leader.SNAP) {
                 LOG.info(""Getting a snapshot from leader"");
@@ -400,10 +404,13 @@
             
             long lastQueued = 0;
 
-            // in V1.0 we take a snapshot when we get the NEWLEADER message, but in pre V1.0
-            // we take the snapshot at the UPDATE, since V1.0 also gets the UPDATE (after the NEWLEADER)
+            // in Zab V1.0 (ZK 3.4+) we might take a snapshot when we get the NEWLEADER message, but in pre V1.0
+            // we take the snapshot on the UPDATE message, since Zab V1.0 also gets the UPDATE (after the NEWLEADER)
             // we need to make sure that we don't take the snapshot twice.
-            boolean snapshotTaken = false;
+            boolean isPreZAB1_0 = true;
+            //If we are not going to take the snapshot be sure the transactions are not applied in memory
+            // but written out to the transaction log
+            boolean writeToTxnLog = !snapshotNeeded;
             // we are now going to start getting transactions to apply followed by an UPTODATE
             outerLoop:
             while (self.isRunning()) {
@@ -440,7 +447,7 @@
                             throw new Exception(""changes proposed in reconfig"");
                         }
                     }
-                    if (!snapshotTaken) {
+                    if (!writeToTxnLog) {
                         if (pif.hdr.getZxid() != qp.getZxid()) {
                             LOG.warn(""Committing "" + qp.getZxid() + "", but next proposal is "" + pif.hdr.getZxid());
                         } else {
@@ -479,8 +486,7 @@
                         }
                         lastQueued = packet.hdr.getZxid();
                     }
-
-                    if (!snapshotTaken) {
+                    if (!writeToTxnLog) {
                         // Apply to db directly if we haven't taken the snapshot
                         zk.processTxn(packet.hdr, packet.rec);
                     } else {
@@ -498,14 +504,15 @@
                            throw new Exception(""changes proposed in reconfig"");
                        }
                     }
-                    if (!snapshotTaken) { // true for the pre v1.0 case
-                       zk.takeSnapshot();
+                    if (isPreZAB1_0) {
+                        zk.takeSnapshot();
                         self.setCurrentEpoch(newEpoch);
                     }
                     self.setZooKeeperServer(zk);
                     self.adminServer.setZooKeeperServer(zk);
                     break outerLoop;
-                case Leader.NEWLEADER: // it will be NEWLEADER in v1.0        
+                case Leader.NEWLEADER: // Getting NEWLEADER here instead of in discovery 
+                    // means this is Zab 1.0
                    LOG.info(""Learner received NEWLEADER message"");
                    if (qp.getData()!=null && qp.getData().length > 1) {
                        try {                       
@@ -516,10 +523,14 @@
                            e.printStackTrace();
                        }
                    }
+
+                   if (snapshotNeeded) {
+                       zk.takeSnapshot();
+                   }
                    
-                    zk.takeSnapshot();
                     self.setCurrentEpoch(newEpoch);
-                    snapshotTaken = true;
+                    writeToTxnLog = true; //Anything after this needs to go to the transaction log, not applied directly in memory
+                    isPreZAB1_0 = false;
                     writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);
                     break;
                 }
"
zookeeper,26aee2228451257f3b0b5093bc0c101822e06bc8,ZOOKEEPER-2680: Correct DataNode.getChildren() inconsistent behaviour.,2017.02.05 15:22:51,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/server/ContainerManager.java b/src/java/main/org/apache/zookeeper/server/ContainerManager.java
index 8834f29..fb1cb66 100644
--- a/src/java/main/org/apache/zookeeper/server/ContainerManager.java
+++ b/src/java/main/org/apache/zookeeper/server/ContainerManager.java
@@ -149,7 +149,7 @@
                 would be immediately be deleted.
              */
             if ((node != null) && (node.stat.getCversion() > 0) &&
-                    (node.getChildren().size() == 0)) {
+                    (node.getChildren().isEmpty())) {
                 candidates.add(containerPath);
             }
         }
@@ -157,7 +157,7 @@
             DataNode node = zkDb.getDataTree().getNode(ttlPath);
             if (node != null) {
                 Set<String> children = node.getChildren();
-                if ((children == null) || (children.size() == 0)) {
+                if (children.isEmpty()) {
                     long elapsed = getElapsed(node);
                     long ttl = EphemeralType.getTTL(node.stat.getEphemeralOwner());
                     if ((ttl != 0) && (elapsed > ttl)) {
"
zookeeper,26aee2228451257f3b0b5093bc0c101822e06bc8,ZOOKEEPER-2680: Correct DataNode.getChildren() inconsistent behaviour.,2017.02.05 15:22:51,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/server/DataNode.java b/src/java/main/org/apache/zookeeper/server/DataNode.java
index ce359cd..0859aab 100644
--- a/src/java/main/org/apache/zookeeper/server/DataNode.java
+++ b/src/java/main/org/apache/zookeeper/server/DataNode.java
@@ -57,6 +57,8 @@
      */
     private Set<String> children = null;
 
+    private static final Set<String> EMPTY_SET = Collections.emptySet();
+
     /**
      * default constructor for the datanode
      */
@@ -122,11 +124,12 @@
     /**
      * convenience methods to get the children
      * 
-     * @return the children of this datanode
+     * @return the children of this datanode. If the datanode has no children, empty
+     *         set is returned
      */
     public synchronized Set<String> getChildren() {
         if (children == null) {
-            return children;
+            return EMPTY_SET;
         }
 
         return Collections.unmodifiableSet(children);
"
zookeeper,26aee2228451257f3b0b5093bc0c101822e06bc8,ZOOKEEPER-2680: Correct DataNode.getChildren() inconsistent behaviour.,2017.02.05 15:22:51,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 65c30ef..f0ab2b3 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -458,7 +458,7 @@
         }
         synchronized (parent) {
             Set<String> children = parent.getChildren();
-            if (children != null && children.contains(childName)) {
+            if (children.contains(childName)) {
                 throw new KeeperException.NodeExistsException();
             }
 
@@ -677,13 +677,7 @@
             if (stat != null) {
                 n.copyStat(stat);
             }
-            ArrayList<String> children;
-            Set<String> childs = n.getChildren();
-            if (childs == null) {
-                children = new ArrayList<String>(0);
-            } else {
-                children = new ArrayList<String>(childs);
-            }
+            List<String> children=new ArrayList<String>(n.getChildren());
 
             if (watcher != null) {
                 childWatches.addWatch(path, watcher);
@@ -1056,17 +1050,12 @@
         int len = 0;
         synchronized (node) {
             Set<String> childs = node.getChildren();
-            if (childs != null) {
-                children = childs.toArray(new String[childs.size()]);
-            }
+            children = childs.toArray(new String[childs.size()]);
             len = (node.data == null ? 0 : node.data.length);
         }
         // add itself
         counts.count += 1;
         counts.bytes += len;
-        if (children == null || children.length == 0) {
-            return;
-        }
         for (String child : children) {
             getCounts(path + ""/"" + child, counts);
         }
@@ -1106,11 +1095,9 @@
         String children[] = null;
         synchronized (node) {
             Set<String> childs = node.getChildren();
-            if (childs != null) {
-                children = childs.toArray(new String[childs.size()]);
-            }
+            children = childs.toArray(new String[childs.size()]);
         }
-        if (children == null || children.length == 0) {
+        if (children.length == 0) {
             // this node does not have a child
             // is the leaf node
             // check if its the leaf node
@@ -1169,23 +1156,19 @@
             //are never changed
             nodeCopy = new DataNode(node.data, node.acl, statCopy);
             Set<String> childs = node.getChildren();
-            if (childs != null) {
-                children = childs.toArray(new String[childs.size()]);
-            }
+            children = childs.toArray(new String[childs.size()]);
         }
         oa.writeString(pathString, ""path"");
         oa.writeRecord(nodeCopy, ""node"");
         path.append('/');
         int off = path.length();
-        if (children != null) {
-            for (String child : children) {
-                // since this is single buffer being resused
-                // we need
-                // to truncate the previous bytes of string.
-                path.delete(off, Integer.MAX_VALUE);
-                path.append(child);
-                serializeNode(oa, path);
-            }
+        for (String child : children) {
+            // since this is single buffer being resused
+            // we need
+            // to truncate the previous bytes of string.
+            path.delete(off, Integer.MAX_VALUE);
+            path.append(child);
+            serializeNode(oa, path);
         }
     }
 
"
zookeeper,26aee2228451257f3b0b5093bc0c101822e06bc8,ZOOKEEPER-2680: Correct DataNode.getChildren() inconsistent behaviour.,2017.02.05 15:22:51,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 007b066..9ad4eea 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -168,8 +168,7 @@
                     synchronized(n) {
                         children = n.getChildren();
                     }
-                    lastChange = new ChangeRecord(-1, path, n.stat,
-                        children != null ? children.size() : 0,
+                    lastChange = new ChangeRecord(-1, path, n.stat, children.size(),
                             zks.getZKDatabase().aclForNode(n));
                 }
             }
"
zookeeper,26aee2228451257f3b0b5093bc0c101822e06bc8,ZOOKEEPER-2680: Correct DataNode.getChildren() inconsistent behaviour.,2017.02.05 15:22:51,Mohammad Arshad,"diff --git a/src/java/main/org/apache/zookeeper/server/SnapshotFormatter.java b/src/java/main/org/apache/zookeeper/server/SnapshotFormatter.java
index f94c54d..bc43402 100644
--- a/src/java/main/org/apache/zookeeper/server/SnapshotFormatter.java
+++ b/src/java/main/org/apache/zookeeper/server/SnapshotFormatter.java
@@ -94,10 +94,8 @@
             }
             children = n.getChildren();
         }
-        if (children != null) {
-            for (String child : children) {
-                printZnode(dataTree, name + (name.equals(""/"") ? """" : ""/"") + child);
-            }
+        for (String child : children) {
+            printZnode(dataTree, name + (name.equals(""/"") ? """" : ""/"") + child);
         }
     }
 
"
zookeeper,edf75b5e31f0d9e2fbfadbd95bae9d1d6c4737f6,ZOOKEEPER-2622: ZooTrace.logQuorumPacket does nothing,2017.01.28 14:43:53,Flavio Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooTrace.java b/src/java/main/org/apache/zookeeper/server/ZooTrace.java
index 787ae1a..12ce7d0 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooTrace.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooTrace.java
@@ -20,7 +20,7 @@
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-
+import org.apache.zookeeper.server.quorum.LearnerHandler;
 import org.apache.zookeeper.server.quorum.QuorumPacket;
 
 /**
@@ -75,12 +75,10 @@
     static public void logQuorumPacket(Logger log, long mask,
             char direction, QuorumPacket qp)
     {
-        return;
-
-        // if (isTraceEnabled(log, mask)) {
-        // logTraceMessage(LOG, mask, direction + "" ""
-        // + FollowerHandler.packetToString(qp));
-        // }
+        if (isTraceEnabled(log, mask)) { 
+            logTraceMessage(log, mask, direction +
+                    "" "" + LearnerHandler.packetToString(qp));
+         }
     }
 
     static public void logRequest(Logger log, long mask,
"
zookeeper,8771ffdaacb87126a485ae740558f6a288ab980b,ZOOKEEPER-2573: Modify Info.REVISION to adapt git repo,2017.01.25 20:57:25,Edward Ribeiro,"diff --git a/src/java/main/org/apache/zookeeper/Version.java b/src/java/main/org/apache/zookeeper/Version.java
index 4657371..1f5cf1a 100644
--- a/src/java/main/org/apache/zookeeper/Version.java
+++ b/src/java/main/org/apache/zookeeper/Version.java
@@ -20,10 +20,21 @@
 
 public class Version implements org.apache.zookeeper.version.Info {
 
+    /*
+     * Since the SVN to Git port this field doesn't return the revision anymore
+     * TODO: remove this method and associated field declaration in VerGen
+     * @see {@link #getHashRevision()}
+     * @return the default value -1
+     */
+    @Deprecated
     public static int getRevision() {
         return REVISION;
     }
 
+    public static String getRevisionHash() {
+        return REVISION_HASH;
+    }
+
     public static String getBuildDate() {
         return BUILD_DATE;
     }
@@ -34,7 +45,7 @@
     }
 
     public static String getVersionRevision() {
-        return getVersion() + ""-"" + getRevision();
+        return getVersion() + ""-"" + getRevisionHash();
     }
 
     public static String getFullVersion() {
"
zookeeper,8771ffdaacb87126a485ae740558f6a288ab980b,ZOOKEEPER-2573: Modify Info.REVISION to adapt git repo,2017.01.25 20:57:25,Edward Ribeiro,"diff --git a/src/java/main/org/apache/zookeeper/version/util/VerGen.java b/src/java/main/org/apache/zookeeper/version/util/VerGen.java
index d3e9731..014f01d 100644
--- a/src/java/main/org/apache/zookeeper/version/util/VerGen.java
+++ b/src/java/main/org/apache/zookeeper/version/util/VerGen.java
@@ -34,7 +34,7 @@
         System.exit(1);
     }
 
-    public static void generateFile(File outputDir, Version version, int rev, String buildDate)
+    public static void generateFile(File outputDir, Version version, String rev, String buildDate)
     {
         String path = PACKAGE_NAME.replaceAll(""\\."", ""/"");
         File pkgdir = new File(outputDir, path);
@@ -74,18 +74,19 @@
             w.write(""\n"");
             w.write(""package "" + PACKAGE_NAME + "";\n\n"");
             w.write(""public interface "" + TYPE_NAME + "" {\n"");
-            w.write(""    public static final int MAJOR="" + version.maj + "";\n"");
-            w.write(""    public static final int MINOR="" + version.min + "";\n"");
-            w.write(""    public static final int MICRO="" + version.micro + "";\n"");
-            w.write(""    public static final String QUALIFIER=""
+            w.write(""    int MAJOR="" + version.maj + "";\n"");
+            w.write(""    int MINOR="" + version.min + "";\n"");
+            w.write(""    int MICRO="" + version.micro + "";\n"");
+            w.write(""    String QUALIFIER=""
                     + (version.qualifier == null ? null :
                         ""\"""" + version.qualifier + ""\"""")
                     + "";\n"");
-            if (rev < 0) {
+            if (rev.equals(""-1"")) {
                 System.out.println(""Unknown REVISION number, using "" + rev);
             }
-            w.write(""    public static final int REVISION="" + rev + "";\n"");
-            w.write(""    public static final String BUILD_DATE=\"""" + buildDate
+            w.write(""    int REVISION=-1; //TODO: remove as related to SVN VCS\n"");
+            w.write(""    String REVISION_HASH=\"""" + rev + ""\"";\n"");
+            w.write(""    String BUILD_DATE=\"""" + buildDate
                     + ""\"";\n"");
             w.write(""}\n"");
         } catch (IOException e) {
@@ -135,7 +136,7 @@
      *            <li>min - minor version number
      *            <li>micro - minor minor version number
      *            <li>qualifier - optional qualifier (dash followed by qualifier text)
-     *            <li>rev - current SVN revision number
+     *            <li>rev - current Git revision number
      *            <li>buildDate - date the build
      *            </ul>
      */
@@ -149,11 +150,11 @@
                         ""Invalid version number format, must be \""x.y.z(-.*)?\"""");
                 System.exit(1);
             }
-            int rev;
-            try {
-                rev = Integer.parseInt(args[1]);
-            } catch (NumberFormatException e) {
-                rev = -1;
+            String rev = args[1];
+            if (rev == null || rev.trim().isEmpty()) {
+                rev = ""-1"";
+            } else {
+                rev = rev.trim();
             }
             generateFile(new File("".""), version, rev, args[2]);
         } catch (NumberFormatException e) {
"
zookeeper,762f4af65bb1056a582a6f36183a9e28fe0ccab8,ZOOKEEPER-2574: PurgeTxnLog can inadvertently delete required txn log files,2017.01.23 10:13:37,Abhishek Rai,"diff --git a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
index d3cdfbb..e1dc99e 100644
--- a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
@@ -24,10 +24,14 @@
 import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
 import org.apache.zookeeper.server.persistence.Util;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * this class is used to clean up the 
@@ -38,6 +42,7 @@
  * and the corresponding logs.
  */
 public class PurgeTxnLog {
+    private static final Logger LOG = LoggerFactory.getLogger(PurgeTxnLog.class);
 
     private static final String COUNT_ERR_MSG = ""count should be greater than or equal to 3"";
 
@@ -72,18 +77,43 @@
         FileTxnSnapLog txnLog = new FileTxnSnapLog(dataDir, snapDir);
 
         List<File> snaps = txnLog.findNRecentSnapshots(num);
-        retainNRecentSnapshots(txnLog, snaps);
+        int numSnaps = snaps.size();
+        if (numSnaps > 0) {
+            purgeOlderSnapshots(txnLog, snaps.get(numSnaps - 1));
+        }
     }
 
     // VisibleForTesting
-    static void retainNRecentSnapshots(FileTxnSnapLog txnLog, List<File> snaps) {
-        // found any valid recent snapshots?
-        if (snaps.size() == 0)
-            return;
-        File snapShot = snaps.get(snaps.size() -1);
+    static void purgeOlderSnapshots(FileTxnSnapLog txnLog, File snapShot) {
         final long leastZxidToBeRetain = Util.getZxidFromName(
                 snapShot.getName(), PREFIX_SNAPSHOT);
 
+        /**
+         * We delete all files with a zxid in their name that is less than leastZxidToBeRetain.
+         * This rule applies to both snapshot files as well as log files, with the following
+         * exception for log files.
+         *
+         * A log file with zxid less than X may contain transactions with zxid larger than X.  More
+         * precisely, a log file named log.(X-a) may contain transactions newer than snapshot.X if
+         * there are no other log files with starting zxid in the interval (X-a, X].  Assuming the
+         * latter condition is true, log.(X-a) must be retained to ensure that snapshot.X is
+         * recoverable.  In fact, this log file may very well extend beyond snapshot.X to newer
+         * snapshot files if these newer snapshots were not accompanied by log rollover (possible in
+         * the learner state machine at the time of this writing).  We can make more precise
+         * determination of whether log.(leastZxidToBeRetain-a) for the smallest 'a' is actually
+         * needed or not (e.g. not needed if there's a log file named log.(leastZxidToBeRetain+1)),
+         * but the complexity quickly adds up with gains only in uncommon scenarios.  It's safe and
+         * simple to just preserve log.(leastZxidToBeRetain-a) for the smallest 'a' to ensure
+         * recoverability of all snapshots being retained.  We determine that log file here by
+         * calling txnLog.getSnapshotLogs().
+         */
+        final Set<File> retainedTxnLogs = new HashSet<File>();
+        retainedTxnLogs.addAll(Arrays.asList(txnLog.getSnapshotLogs(leastZxidToBeRetain)));
+
+        /**
+         * Finds all candidates for deletion, which are files with a zxid in their name that is less
+         * than leastZxidToBeRetain.  There's an exception to this rule, as noted above.
+         */
         class MyFileFilter implements FileFilter{
             private final String prefix;
             MyFileFilter(String prefix){
@@ -92,6 +122,9 @@
             public boolean accept(File f){
                 if(!f.getName().startsWith(prefix + "".""))
                     return false;
+                if (retainedTxnLogs.contains(f)) {
+                    return false;
+                }
                 long fZxid = Util.getZxidFromName(f.getName(), prefix);
                 if (fZxid >= leastZxidToBeRetain) {
                     return false;
@@ -115,9 +148,11 @@
         // remove the old files
         for(File f: files)
         {
-            System.out.println(""Removing file: ""+
+            final String msg = ""Removing file: ""+
                 DateFormat.getDateTimeInstance().format(f.lastModified())+
-                ""\t""+f.getPath());
+                ""\t""+f.getPath();
+            LOG.info(msg);
+            System.out.println(msg);
             if(!f.delete()){
                 System.err.println(""Failed to remove ""+f.getPath());
             }
"
zookeeper,762f4af65bb1056a582a6f36183a9e28fe0ccab8,ZOOKEEPER-2574: PurgeTxnLog can inadvertently delete required txn log files,2017.01.23 10:13:37,Abhishek Rai,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
index 8f57338..cf464a1 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
@@ -177,19 +177,21 @@
     /**
      * find the last n snapshots. this does not have
      * any checks if the snapshot might be valid or not
-     * @param the number of most recent snapshots 
+     * @param the number of most recent snapshots
      * @return the last n snapshots
      * @throws IOException
      */
     public List<File> findNRecentSnapshots(int n) throws IOException {
         List<File> files = Util.sortDataDir(snapDir.listFiles(), ""snapshot"", false);
-        int i = 0;
+        int count = 0;
         List<File> list = new ArrayList<File>();
         for (File f: files) {
-            if (i==n)
+            if (count == n)
                 break;
-            i++;
-            list.add(f);
+            if (Util.getZxidFromName(f.getName(), ""snapshot"") != -1) {
+                count++;
+                list.add(f);
+            }
         }
         return list;
     }
"
zookeeper,762f4af65bb1056a582a6f36183a9e28fe0ccab8,ZOOKEEPER-2574: PurgeTxnLog can inadvertently delete required txn log files,2017.01.23 10:13:37,Abhishek Rai,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 291f838..84c526b 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -400,8 +400,10 @@
     }
 
     /**
-     * get the snapshot logs that are greater than
-     * the given zxid
+     * get the snapshot logs which may contain transactions newer than the given zxid.
+     * This includes logs with starting zxid greater than given zxid, as well as the
+     * newest transaction log with starting zxid less than given zxid.  The latter log
+     * file may contain transactions beyond given zxid.
      * @param zxid the zxid that contains logs greater than
      * zxid
      * @return
"
zookeeper,7c51b01e89acb38165553366f7e3b2a46c00aa27,ZOOKEEPER-2325: Data inconsistency if all snapshots empty or missing,2017.01.07 09:09:54,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 9a34bd1..b31ff12 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -165,8 +165,22 @@
      */
     public long restore(DataTree dt, Map<Long, Integer> sessions,
             PlayBackListener listener) throws IOException {
-        snapLog.deserialize(dt, sessions);
+        long deserializeResult = snapLog.deserialize(dt, sessions);
         FileTxnLog txnLog = new FileTxnLog(dataDir);
+        if (-1L == deserializeResult) {
+            /* this means that we couldn't find any snapshot, so we need to
+             * initialize an empty database (reported in ZOOKEEPER-2325) */
+            if (txnLog.getLastLoggedZxid() != -1) {
+                throw new IOException(
+                        ""No snapshot found, but there are log entries. "" +
+                        ""Something is broken!"");
+            }
+            /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()
+             *       or use Map on save() */
+            save(dt, (ConcurrentHashMap<Long, Integer>)sessions);
+            /* return a zxid of zero, since we the database is empty */
+            return 0;
+        }
         TxnIterator itr = txnLog.read(dt.lastProcessedZxid+1);
         long highestZxid = dt.lastProcessedZxid;
         TxnHeader hdr;
"
zookeeper,de5c0e9abeb87721f4157662210dfcd38a7c15ea,ZOOKEEPER-2517: jute.maxbuffer is ignored,2016.12.31 07:01:55,arshadmohammad,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
index 4630829..0e5316d 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
@@ -22,6 +22,7 @@
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
+import java.text.MessageFormat;
 import java.util.List;
 import java.util.concurrent.LinkedBlockingDeque;
 
@@ -228,14 +229,20 @@
      */
     abstract void sendPacket(Packet p) throws IOException;
 
-    protected void initProperties() {
-        packetLen = Integer.getInteger(
-                clientConfig.getProperty(ZKConfig.JUTE_MAXBUFFER),
-                ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT);
-        if (LOG.isDebugEnabled()) {
-            LOG.debug(""{} is {}"", ZKConfig.JUTE_MAXBUFFER, packetLen);
+    protected void initProperties() throws IOException {
+        try {
+            packetLen = clientConfig.getInt(ZKConfig.JUTE_MAXBUFFER,
+                    ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT);
+            LOG.info(""{} value is {} Bytes"", ZKConfig.JUTE_MAXBUFFER,
+                    packetLen);
+        } catch (NumberFormatException e) {
+            String msg = MessageFormat.format(
+                    ""Configured value {0} for property {1} can not be parsed to int"",
+                    clientConfig.getProperty(ZKConfig.JUTE_MAXBUFFER),
+                    ZKConfig.JUTE_MAXBUFFER);
+            LOG.error(msg);
+            throw new IOException(msg);
         }
     }
 
-
 }
"
zookeeper,de5c0e9abeb87721f4157662210dfcd38a7c15ea,ZOOKEEPER-2517: jute.maxbuffer is ignored,2016.12.31 07:01:55,arshadmohammad,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNetty.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNetty.java
index 05f8a81..97af9da 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNetty.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNetty.java
@@ -78,7 +78,7 @@
     AtomicBoolean needSasl = new AtomicBoolean();
     Semaphore waitSasl = new Semaphore(0);
 
-    ClientCnxnSocketNetty(ZKClientConfig clientConfig) {
+    ClientCnxnSocketNetty(ZKClientConfig clientConfig) throws IOException {
         this.clientConfig = clientConfig;
         initProperties();
     }
"
zookeeper,de5c0e9abeb87721f4157662210dfcd38a7c15ea,ZOOKEEPER-2517: jute.maxbuffer is ignored,2016.12.31 07:01:55,arshadmohammad,"diff --git a/src/java/main/org/apache/zookeeper/common/ZKConfig.java b/src/java/main/org/apache/zookeeper/common/ZKConfig.java
index 3b08904..8d9c001 100644
--- a/src/java/main/org/apache/zookeeper/common/ZKConfig.java
+++ b/src/java/main/org/apache/zookeeper/common/ZKConfig.java
@@ -223,4 +223,25 @@
         return Boolean.parseBoolean(getProperty(key));
     }
 
+    /**
+     * Get the value of the <code>key</code> property as an <code>int</code>. If
+     * property is not set, the provided <code>defaultValue</code> is returned
+     * 
+     * @param key
+     *            property key.
+     * @param defaultValue
+     *            default value.
+     * @throws NumberFormatException
+     *             when the value is invalid
+     * @return return property value as an <code>int</code>, or
+     *         <code>defaultValue</code>
+     */
+    public int getInt(String key, int defaultValue) {
+        String value = getProperty(key);
+        if (value != null) {
+            return Integer.parseInt(value.trim());
+        }
+        return defaultValue;
+    }
+
 }
"
zookeeper,ef0a8ae686c100f1dc71d7526af962c635696466,ZOOKEEPER-2470: ServerConfig#parse(String[]) ignores tickTime,2016.12.22 12:10:14,Edward Ribeiro,"diff --git a/src/java/main/org/apache/zookeeper/server/ServerConfig.java b/src/java/main/org/apache/zookeeper/server/ServerConfig.java
index d4c32a1..444e126 100644
--- a/src/java/main/org/apache/zookeeper/server/ServerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/ServerConfig.java
@@ -49,20 +49,19 @@
 
     /**
      * Parse arguments for server configuration
-     * @param args clientPort dataDir and optional tickTime
+     * @param args clientPort dataDir and optional tickTime and maxClientCnxns
      * @return ServerConfig configured wrt arguments
      * @throws IllegalArgumentException on invalid usage
      */
     public void parse(String[] args) {
         if (args.length < 2 || args.length > 4) {
-            throw new IllegalArgumentException(""Invalid args:""
-                    + Arrays.toString(args));
+            throw new IllegalArgumentException(""Invalid number of arguments:"" + Arrays.toString(args));
         }
 
         clientPortAddress = new InetSocketAddress(Integer.parseInt(args[0]));
         dataDir = new File(args[1]);
         dataLogDir = dataDir;
-        if (args.length == 3) {
+        if (args.length >= 3) {
             tickTime = Integer.parseInt(args[2]);
         }
         if (args.length == 4) {
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index f2f225c..c944889 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -426,7 +426,7 @@
     }
 
     private void readConnectRequest() throws IOException, InterruptedException {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             throw new IOException(""ZooKeeperServer not running"");
         }
         zkServer.processConnectRequest(this, incomingBuffer);
@@ -539,13 +539,17 @@
         if (len < 0 || len > BinaryInputArchive.maxBuffer) {
             throw new IOException(""Len error "" + len);
         }
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             throw new IOException(""ZooKeeperServer not running"");
         }
         incomingBuffer = ByteBuffer.allocate(len);
         return true;
     }
 
+    boolean isZKServerRunning() {
+        return zkServer == null || !zkServer.isRunning();
+    }
+
     public long getOutstandingRequests() {
         return outstandingRequests.get();
     }
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index c48f6b1..9b6f28e 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -332,7 +332,7 @@
                         bb.flip();
 
                         ZooKeeperServer zks = this.zkServer;
-                        if (zks == null) {
+                        if (zks == null || !zks.isRunning()) {
                             throw new IOException(""ZK down"");
                         }
                         if (initialized) {
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/admin/Commands.java b/src/java/main/org/apache/zookeeper/server/admin/Commands.java
index 21893f1..4f96de3 100644
--- a/src/java/main/org/apache/zookeeper/server/admin/Commands.java
+++ b/src/java/main/org/apache/zookeeper/server/admin/Commands.java
@@ -86,7 +86,7 @@
         if (!commands.containsKey(cmdName)) {
             return new CommandResponse(cmdName, ""Unknown command: "" + cmdName);
         }
-        if (zkServer == null) {
+        if (zkServer == null || !zkServer.isRunning()) {
             return new CommandResponse(cmdName, ""This ZooKeeper instance is not currently serving requests"");
         }
         return commands.get(cmdName).run(zkServer, kwargs);
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/AbstractFourLetterCommand.java b/src/java/main/org/apache/zookeeper/server/command/AbstractFourLetterCommand.java
index 451ae67..a075a91 100644
--- a/src/java/main/org/apache/zookeeper/server/command/AbstractFourLetterCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/AbstractFourLetterCommand.java
@@ -64,6 +64,10 @@
         this.zkServer = zkServer;
     }
 
+    boolean isZKServerRunning() {
+        return zkServer == null || !zkServer.isRunning();
+    }
+
     public void setFactory(ServerCnxnFactory factory) {
         this.factory = factory;
     }
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/CnxnStatResetCommand.java b/src/java/main/org/apache/zookeeper/server/command/CnxnStatResetCommand.java
index cfdf0ba..c44c840 100644
--- a/src/java/main/org/apache/zookeeper/server/command/CnxnStatResetCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/CnxnStatResetCommand.java
@@ -29,7 +29,7 @@
 
     @Override
     public void commandRun() {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             pw.println(ZK_NOT_SERVING);
         } else {
             factory.resetAllConnectionStats();
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/ConfCommand.java b/src/java/main/org/apache/zookeeper/server/command/ConfCommand.java
index f48e453..a06666d 100644
--- a/src/java/main/org/apache/zookeeper/server/command/ConfCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/ConfCommand.java
@@ -29,7 +29,7 @@
 
     @Override
     public void commandRun() {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             pw.println(ZK_NOT_SERVING);
         } else {
             zkServer.dumpConf(pw);
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/ConsCommand.java b/src/java/main/org/apache/zookeeper/server/command/ConsCommand.java
index 61593de..0c8e3dd 100644
--- a/src/java/main/org/apache/zookeeper/server/command/ConsCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/ConsCommand.java
@@ -29,7 +29,7 @@
 
     @Override
     public void commandRun() {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             pw.println(ZK_NOT_SERVING);
         } else {
             for (ServerCnxn c : factory.getConnections()) {
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/DirsCommand.java b/src/java/main/org/apache/zookeeper/server/command/DirsCommand.java
index 5a442e8..09623d7 100644
--- a/src/java/main/org/apache/zookeeper/server/command/DirsCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/DirsCommand.java
@@ -31,7 +31,7 @@
 
     @Override
     public void commandRun() throws IOException {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             pw.println(ZK_NOT_SERVING);
             return;
         }
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/DumpCommand.java b/src/java/main/org/apache/zookeeper/server/command/DumpCommand.java
index f22e3af..903bfd6 100644
--- a/src/java/main/org/apache/zookeeper/server/command/DumpCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/DumpCommand.java
@@ -30,7 +30,7 @@
 
     @Override
     public void commandRun() {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             pw.println(ZK_NOT_SERVING);
         } else {
             pw.println(""SessionTracker dump:"");
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/IsroCommand.java b/src/java/main/org/apache/zookeeper/server/command/IsroCommand.java
index 0615a63..542831e 100644
--- a/src/java/main/org/apache/zookeeper/server/command/IsroCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/IsroCommand.java
@@ -31,7 +31,7 @@
 
     @Override
     public void commandRun() {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             pw.print(""null"");
         } else if (zkServer instanceof ReadOnlyZooKeeperServer) {
             pw.print(""ro"");
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/MonitorCommand.java b/src/java/main/org/apache/zookeeper/server/command/MonitorCommand.java
index c048541..b3e75f3 100644
--- a/src/java/main/org/apache/zookeeper/server/command/MonitorCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/MonitorCommand.java
@@ -36,7 +36,7 @@
 
     @Override
     public void commandRun() {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             pw.println(ZK_NOT_SERVING);
             return;
         }
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/StatCommand.java b/src/java/main/org/apache/zookeeper/server/command/StatCommand.java
index 0b5f911..021b296 100644
--- a/src/java/main/org/apache/zookeeper/server/command/StatCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/StatCommand.java
@@ -37,7 +37,7 @@
 
     @Override
     public void commandRun() {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             pw.println(ZK_NOT_SERVING);
         } else {
             pw.print(""Zookeeper version: "");
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/StatResetCommand.java b/src/java/main/org/apache/zookeeper/server/command/StatResetCommand.java
index 9538ce2..c7d5ad7 100644
--- a/src/java/main/org/apache/zookeeper/server/command/StatResetCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/StatResetCommand.java
@@ -29,7 +29,7 @@
 
     @Override
     public void commandRun() {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             pw.println(ZK_NOT_SERVING);
         } else {
             zkServer.serverStats().reset();
"
zookeeper,eac693cc76a34f96b9116ef33d1e92af7129416d,ZOOKEEPER-2383: Startup race in ZooKeeperServer,2016.12.22 07:32:01,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/command/WatchCommand.java b/src/java/main/org/apache/zookeeper/server/command/WatchCommand.java
index ca97ab9..dd6c247 100644
--- a/src/java/main/org/apache/zookeeper/server/command/WatchCommand.java
+++ b/src/java/main/org/apache/zookeeper/server/command/WatchCommand.java
@@ -32,7 +32,7 @@
 
     @Override
     public void commandRun() {
-        if (zkServer == null) {
+        if (isZKServerRunning()) {
             pw.println(ZK_NOT_SERVING);
         } else {
             DataTree dt = zkServer.getZKDatabase().getDataTree();
"
zookeeper,d72f27279a13986ee0c011e1e5b34edf3a310da9,ZOOKEEPER-2636: Fix C client build break.,2016.11.25 15:08:55,Michael Han,"diff --git a/src/java/main/org/apache/jute/compiler/JRecord.java b/src/java/main/org/apache/jute/compiler/JRecord.java
index 65bcccc..bc98d90 100644
--- a/src/java/main/org/apache/jute/compiler/JRecord.java
+++ b/src/java/main/org/apache/jute/compiler/JRecord.java
@@ -141,116 +141,109 @@
 
     static HashMap<String, String> vectorStructs = new HashMap<String, String>();
     public void genCCode(FileWriter h, FileWriter c) throws IOException {
-        try {
-            for (JField f : mFields) {
-                if (f.getType() instanceof JVector) {
-                    JVector jv = (JVector) f.getType();
-                    JType jvType = jv.getElementType();
-                    String struct_name = JVector.extractVectorName(jvType);
-                    if (vectorStructs.get(struct_name) == null) {
-                        vectorStructs.put(struct_name, struct_name);
-                        h.write(""struct "" + struct_name + "" {\n    int32_t count;\n"" + jv.getElementType().genCDecl(""*data"") + ""\n};\n"");
-                        h.write(""int serialize_"" + struct_name + ""(struct oarchive *out, const char *tag, struct "" + struct_name + "" *v);\n"");
-                        h.write(""int deserialize_"" + struct_name + ""(struct iarchive *in, const char *tag, struct "" + struct_name + "" *v);\n"");
-                        h.write(""int allocate_"" + struct_name + ""(struct "" + struct_name + "" *v, int32_t len);\n"");
-                        h.write(""int deallocate_"" + struct_name + ""(struct "" + struct_name + "" *v);\n"");
-                        c.write(""int allocate_"" + struct_name + ""(struct "" + struct_name + "" *v, int32_t len) {\n"");
-                        c.write(""    if (!len) {\n"");
-                        c.write(""        v->count = 0;\n"");
-                        c.write(""        v->data = 0;\n"");
-                        c.write(""    } else {\n"");
-                        c.write(""        v->count = len;\n"");
-                        c.write(""        v->data = calloc(sizeof(*v->data), len);\n"");
-                        c.write(""    }\n"");
-                        c.write(""    return 0;\n"");
-                        c.write(""}\n"");
-                        c.write(""int deallocate_"" + struct_name + ""(struct "" + struct_name + "" *v) {\n"");
-                        c.write(""    if (v->data) {\n"");
-                        c.write(""        int32_t i;\n"");
-                        c.write(""        for(i=0;i<v->count; i++) {\n"");
-                        c.write(""            deallocate_"" + JRecord.extractMethodSuffix(jvType) + ""(&v->data[i]);\n"");
-                        c.write(""        }\n"");
-                        c.write(""        free(v->data);\n"");
-                        c.write(""        v->data = 0;\n"");
-                        c.write(""    }\n"");
-                        c.write(""    return 0;\n"");
-                        c.write(""}\n"");
-                        c.write(""int serialize_"" + struct_name + ""(struct oarchive *out, const char *tag, struct "" + struct_name + "" *v)\n"");
-                        c.write(""{\n"");
-                        c.write(""    int32_t count = v->count;\n"");
-                        c.write(""    int rc = 0;\n"");
-                        c.write(""    int32_t i;\n"");
-                        c.write(""    rc = out->start_vector(out, tag, &count);\n"");
-                        c.write(""    for(i=0;i<v->count;i++) {\n"");
-                        genSerialize(c, jvType, ""data"", ""data[i]"");
-                        c.write(""    }\n"");
-                        c.write(""    rc = rc ? rc : out->end_vector(out, tag);\n"");
-                        c.write(""    return rc;\n"");
-                        c.write(""}\n"");
-                        c.write(""int deserialize_"" + struct_name + ""(struct iarchive *in, const char *tag, struct "" + struct_name + "" *v)\n"");
-                        c.write(""{\n"");
-                        c.write(""    int rc = 0;\n"");
-                        c.write(""    int32_t i;\n"");
-                        c.write(""    rc = in->start_vector(in, tag, &v->count);\n"");
-                        c.write(""    v->data = calloc(v->count, sizeof(*v->data));\n"");
-                        c.write(""    for(i=0;i<v->count;i++) {\n"");
-                        genDeserialize(c, jvType, ""value"", ""data[i]"");
-                        c.write(""    }\n"");
-                        c.write(""    rc = in->end_vector(in, tag);\n"");
-                        c.write(""    return rc;\n"");
-                        c.write(""}\n"");
+        for (JField f : mFields) {
+            if (f.getType() instanceof JVector) {
+                JVector jv = (JVector) f.getType();
+                JType jvType = jv.getElementType();
+                String struct_name = JVector.extractVectorName(jvType);
+                if (vectorStructs.get(struct_name) == null) {
+                    vectorStructs.put(struct_name, struct_name);
+                    h.write(""struct "" + struct_name + "" {\n    int32_t count;\n"" + jv.getElementType().genCDecl(""*data"") + ""\n};\n"");
+                    h.write(""int serialize_"" + struct_name + ""(struct oarchive *out, const char *tag, struct "" + struct_name + "" *v);\n"");
+                    h.write(""int deserialize_"" + struct_name + ""(struct iarchive *in, const char *tag, struct "" + struct_name + "" *v);\n"");
+                    h.write(""int allocate_"" + struct_name + ""(struct "" + struct_name + "" *v, int32_t len);\n"");
+                    h.write(""int deallocate_"" + struct_name + ""(struct "" + struct_name + "" *v);\n"");
+                    c.write(""int allocate_"" + struct_name + ""(struct "" + struct_name + "" *v, int32_t len) {\n"");
+                    c.write(""    if (!len) {\n"");
+                    c.write(""        v->count = 0;\n"");
+                    c.write(""        v->data = 0;\n"");
+                    c.write(""    } else {\n"");
+                    c.write(""        v->count = len;\n"");
+                    c.write(""        v->data = calloc(sizeof(*v->data), len);\n"");
+                    c.write(""    }\n"");
+                    c.write(""    return 0;\n"");
+                    c.write(""}\n"");
+                    c.write(""int deallocate_"" + struct_name + ""(struct "" + struct_name + "" *v) {\n"");
+                    c.write(""    if (v->data) {\n"");
+                    c.write(""        int32_t i;\n"");
+                    c.write(""        for(i=0;i<v->count; i++) {\n"");
+                    c.write(""            deallocate_"" + JRecord.extractMethodSuffix(jvType) + ""(&v->data[i]);\n"");
+                    c.write(""        }\n"");
+                    c.write(""        free(v->data);\n"");
+                    c.write(""        v->data = 0;\n"");
+                    c.write(""    }\n"");
+                    c.write(""    return 0;\n"");
+                    c.write(""}\n"");
+                    c.write(""int serialize_"" + struct_name + ""(struct oarchive *out, const char *tag, struct "" + struct_name + "" *v)\n"");
+                    c.write(""{\n"");
+                    c.write(""    int32_t count = v->count;\n"");
+                    c.write(""    int rc = 0;\n"");
+                    c.write(""    int32_t i;\n"");
+                    c.write(""    rc = out->start_vector(out, tag, &count);\n"");
+                    c.write(""    for(i=0;i<v->count;i++) {\n"");
+                    genSerialize(c, jvType, ""data"", ""data[i]"");
+                    c.write(""    }\n"");
+                    c.write(""    rc = rc ? rc : out->end_vector(out, tag);\n"");
+                    c.write(""    return rc;\n"");
+                    c.write(""}\n"");
+                    c.write(""int deserialize_"" + struct_name + ""(struct iarchive *in, const char *tag, struct "" + struct_name + "" *v)\n"");
+                    c.write(""{\n"");
+                    c.write(""    int rc = 0;\n"");
+                    c.write(""    int32_t i;\n"");
+                    c.write(""    rc = in->start_vector(in, tag, &v->count);\n"");
+                    c.write(""    v->data = calloc(v->count, sizeof(*v->data));\n"");
+                    c.write(""    for(i=0;i<v->count;i++) {\n"");
+                    genDeserialize(c, jvType, ""value"", ""data[i]"");
+                    c.write(""    }\n"");
+                    c.write(""    rc = in->end_vector(in, tag);\n"");
+                    c.write(""    return rc;\n"");
+                    c.write(""}\n"");
 
-                    }
                 }
             }
-            String rec_name = getName();
-            h.write(""struct "" + rec_name + "" {\n"");
-            for (JField f : mFields) {
-                h.write(f.genCDecl());
-            }
-            h.write(""};\n"");
-            h.write(""int serialize_"" + rec_name + ""(struct oarchive *out, const char *tag, struct "" + rec_name + "" *v);\n"");
-            h.write(""int deserialize_"" + rec_name + ""(struct iarchive *in, const char *tag, struct "" + rec_name + ""*v);\n"");
-            h.write(""void deallocate_"" + rec_name + ""(struct "" + rec_name + ""*);\n"");
-            c.write(""int serialize_"" + rec_name + ""(struct oarchive *out, const char *tag, struct "" + rec_name + "" *v)"");
-            c.write(""{\n"");
-            c.write(""    int rc;\n"");
-            c.write(""    rc = out->start_record(out, tag);\n"");
-            for (JField f : mFields) {
-                genSerialize(c, f.getType(), f.getTag(), f.getName());
-            }
-            c.write(""    rc = rc ? rc : out->end_record(out, tag);\n"");
-            c.write(""    return rc;\n"");
-            c.write(""}\n"");
-            c.write(""int deserialize_"" + rec_name + ""(struct iarchive *in, const char *tag, struct "" + rec_name + ""*v)"");
-            c.write(""{\n"");
-            c.write(""    int rc;\n"");
-            c.write(""    rc = in->start_record(in, tag);\n"");
-            for (JField f : mFields) {
-                genDeserialize(c, f.getType(), f.getTag(), f.getName());
-            }
-            c.write(""    rc = rc ? rc : in->end_record(in, tag);\n"");
-            c.write(""    return rc;\n"");
-            c.write(""}\n"");
-            c.write(""void deallocate_"" + rec_name + ""(struct "" + rec_name + ""*v)"");
-            c.write(""{\n"");
-            for (JField f : mFields) {
-                if (f.getType() instanceof JRecord) {
-                    c.write(""    deallocate_"" + extractStructName(f.getType()) + ""(&v->"" + f.getName() + "");\n"");
-                } else if (f.getType() instanceof JVector) {
-                    JVector vt = (JVector) f.getType();
-                    c.write(""    deallocate_"" + JVector.extractVectorName(vt.getElementType()) + ""(&v->"" + f.getName() + "");\n"");
-                } else if (f.getType() instanceof JCompType) {
-                    c.write(""    deallocate_"" + extractMethodSuffix(f.getType()) + ""(&v->"" + f.getName() + "");\n"");
-                }
-            }
-            c.write(""}\n"");
-        } catch (IOException e) {
-            throw e;
-        } finally {
-            h.close();
-            c.close();
         }
+        String rec_name = getName();
+        h.write(""struct "" + rec_name + "" {\n"");
+        for (JField f : mFields) {
+            h.write(f.genCDecl());
+        }
+        h.write(""};\n"");
+        h.write(""int serialize_"" + rec_name + ""(struct oarchive *out, const char *tag, struct "" + rec_name + "" *v);\n"");
+        h.write(""int deserialize_"" + rec_name + ""(struct iarchive *in, const char *tag, struct "" + rec_name + ""*v);\n"");
+        h.write(""void deallocate_"" + rec_name + ""(struct "" + rec_name + ""*);\n"");
+        c.write(""int serialize_"" + rec_name + ""(struct oarchive *out, const char *tag, struct "" + rec_name + "" *v)"");
+        c.write(""{\n"");
+        c.write(""    int rc;\n"");
+        c.write(""    rc = out->start_record(out, tag);\n"");
+        for (JField f : mFields) {
+            genSerialize(c, f.getType(), f.getTag(), f.getName());
+        }
+        c.write(""    rc = rc ? rc : out->end_record(out, tag);\n"");
+        c.write(""    return rc;\n"");
+        c.write(""}\n"");
+        c.write(""int deserialize_"" + rec_name + ""(struct iarchive *in, const char *tag, struct "" + rec_name + ""*v)"");
+        c.write(""{\n"");
+        c.write(""    int rc;\n"");
+        c.write(""    rc = in->start_record(in, tag);\n"");
+        for (JField f : mFields) {
+            genDeserialize(c, f.getType(), f.getTag(), f.getName());
+        }
+        c.write(""    rc = rc ? rc : in->end_record(in, tag);\n"");
+        c.write(""    return rc;\n"");
+        c.write(""}\n"");
+        c.write(""void deallocate_"" + rec_name + ""(struct "" + rec_name + ""*v)"");
+        c.write(""{\n"");
+        for (JField f : mFields) {
+            if (f.getType() instanceof JRecord) {
+                c.write(""    deallocate_"" + extractStructName(f.getType()) + ""(&v->"" + f.getName() + "");\n"");
+            } else if (f.getType() instanceof JVector) {
+                JVector vt = (JVector) f.getType();
+                c.write(""    deallocate_"" + JVector.extractVectorName(vt.getElementType()) + ""(&v->"" + f.getName() + "");\n"");
+            } else if (f.getType() instanceof JCompType) {
+                c.write(""    deallocate_"" + extractMethodSuffix(f.getType()) + ""(&v->"" + f.getName() + "");\n"");
+            }
+        }
+        c.write(""}\n"");
     }
 
     private void genSerialize(FileWriter c, JType type, String tag, String name) throws IOException {
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 12dd51c..9e6c154 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1523,14 +1523,14 @@
         sendThread.sendPacket(p);
     }
 
-    Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
+    public Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
             Record response, AsyncCallback cb, String clientPath,
             String serverPath, Object ctx, WatchRegistration watchRegistration) {
         return queuePacket(h, r, request, response, cb, clientPath, serverPath,
                 ctx, watchRegistration, null);
     }
 
-    Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
+    public Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
             Record response, AsyncCallback cb, String clientPath,
             String serverPath, Object ctx, WatchRegistration watchRegistration,
             WatchDeregistration watchDeregistration) {
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/KeeperException.java b/src/java/main/org/apache/zookeeper/KeeperException.java
index a05f1ab..ea2b395 100644
--- a/src/java/main/org/apache/zookeeper/KeeperException.java
+++ b/src/java/main/org/apache/zookeeper/KeeperException.java
@@ -139,6 +139,8 @@
                 return new EphemeralOnLocalSessionException();
             case NOWATCHER:
                 return new NoWatcherException();
+            case RECONFIGDISABLED:
+                return new ReconfigDisabledException();
             case OK:
             default:
                 throw new IllegalArgumentException(""Invalid exception code"");
@@ -384,7 +386,9 @@
         /** Attempt to create ephemeral node on a local session */
         EPHEMERALONLOCALSESSION (EphemeralOnLocalSession),
         /** Attempts to remove a non-existing watcher */
-        NOWATCHER (-121);
+        NOWATCHER (-121),
+        /** Attempts to perform a reconfiguration operation when reconfiguration feature is disabled. */
+        RECONFIGDISABLED(-123);
 
         private static final Map<Integer,Code> lookup
             = new HashMap<Integer,Code>();
@@ -469,6 +473,8 @@
                 return ""Ephemeral node on local session"";
             case NOWATCHER:
                 return ""No such watcher"";
+            case RECONFIGDISABLED:
+                return ""Reconfig is disabled"";
             default:
                 return ""Unknown error "" + code;
         }
@@ -515,7 +521,7 @@
 
     @Override
     public String getMessage() {
-        if (path == null) {
+        if (path == null || path.isEmpty()) {
             return ""KeeperErrorCode = "" + getCodeMessage(code);
         }
         return ""KeeperErrorCode = "" + getCodeMessage(code) + "" for "" + path;
@@ -795,4 +801,14 @@
             super(Code.NOWATCHER, path);
         }
     }
+
+    /**
+     * @see Code#RECONFIGDISABLED
+     */
+    public static class ReconfigDisabledException extends KeeperException {
+        public ReconfigDisabledException() { super(Code.RECONFIGDISABLED); }
+        public ReconfigDisabledException(String path) {
+            super(Code.RECONFIGDISABLED, path);
+        }
+    }
 }
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 1c9ed4e..cf274a4 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -39,7 +39,6 @@
 import org.apache.zookeeper.client.ZKClientConfig;
 import org.apache.zookeeper.client.ZooKeeperSaslClient;
 import org.apache.zookeeper.common.PathUtils;
-import org.apache.zookeeper.common.StringUtils;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.proto.CheckWatchesRequest;
@@ -57,7 +56,6 @@
 import org.apache.zookeeper.proto.GetChildrenResponse;
 import org.apache.zookeeper.proto.GetDataRequest;
 import org.apache.zookeeper.proto.GetDataResponse;
-import org.apache.zookeeper.proto.ReconfigRequest;
 import org.apache.zookeeper.proto.RemoveWatchesRequest;
 import org.apache.zookeeper.proto.ReplyHeader;
 import org.apache.zookeeper.proto.RequestHeader;
@@ -156,7 +154,7 @@
         Environment.logEnv(""Client environment:"", LOG);
     }
 
-    private final HostProvider hostProvider;
+    protected final HostProvider hostProvider;
 
     /**
      * This function allows a client to update the connection string by providing 
@@ -215,7 +213,7 @@
         return cnxn.zooKeeperSaslClient;
     }
 
-    private final ZKWatchManager watchManager;
+    protected final ZKWatchManager watchManager;
 
     private final ZKClientConfig clientConfig;
 
@@ -223,19 +221,19 @@
         return clientConfig;
     }
 
-    List<String> getDataWatches() {
+    protected List<String> getDataWatches() {
         synchronized(watchManager.dataWatches) {
             List<String> rc = new ArrayList<String>(watchManager.dataWatches.keySet());
             return rc;
         }
     }
-    List<String> getExistWatches() {
+    protected List<String> getExistWatches() {
         synchronized(watchManager.existWatches) {
             List<String> rc =  new ArrayList<String>(watchManager.existWatches.keySet());
             return rc;
         }
     }
-    List<String> getChildWatches() {
+    protected List<String> getChildWatches() {
         synchronized(watchManager.childWatches) {
             List<String> rc = new ArrayList<String>(watchManager.childWatches.keySet());
             return rc;
@@ -262,7 +260,7 @@
             this.disableAutoWatchReset = disableAutoWatchReset;
         }
 
-        private volatile Watcher defaultWatcher;
+        protected volatile Watcher defaultWatcher;
 
         final private void addTo(Set<Watcher> from, Set<Watcher> to) {
             if (from != null) {
@@ -529,7 +527,7 @@
     /**
      * Register a watcher for a particular path.
      */
-    abstract class WatchRegistration {
+    public abstract class WatchRegistration {
         private Watcher watcher;
         private String clientPath;
         public WatchRegistration(Watcher watcher, String clientPath)
@@ -2177,85 +2175,6 @@
     public void getConfig(boolean watch, DataCallback cb, Object ctx) {
         getConfig(watch ? watchManager.defaultWatcher : null, cb, ctx);
     }
-    
-    /**
-     * Reconfigure - add/remove servers. Return the new configuration.
-     * @param joiningServers
-     *                a comma separated list of servers being added (incremental reconfiguration)
-     * @param leavingServers
-     *                a comma separated list of servers being removed (incremental reconfiguration)
-     * @param newMembers
-     *                a comma separated list of new membership (non-incremental reconfiguration)
-     * @param fromConfig
-     *                version of the current configuration (optional - causes reconfiguration to throw an exception if configuration is no longer current)
-     * @param stat the stat of /zookeeper/config znode will be copied to this
-     *             parameter if not null.
-     * @return new configuration
-     * @throws InterruptedException If the server transaction is interrupted.
-     * @throws KeeperException If the server signals an error with a non-zero error code.     
-     */
-    public byte[] reconfig(String joiningServers, String leavingServers, String newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException
-    {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.reconfig);       
-        ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);        
-        GetDataResponse response = new GetDataResponse();       
-        ReplyHeader r = cnxn.submitRequest(h, request, response, null);
-        if (r.getErr() != 0) {
-            throw KeeperException.create(KeeperException.Code.get(r.getErr()), """");
-        }
-        if (stat != null) {
-            DataTree.copyStat(response.getStat(), stat);
-        }
-        return response.getData();
-    }
-
-    /**
-     * Convenience wrapper around reconfig that takes Lists of strings instead of comma-separated servers.
-     *
-     * @see #reconfig
-     *
-     */
-    public byte[] reconfig(List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException
-    {
-        return reconfig(StringUtils.joinStrings(joiningServers, "",""), 
-        		StringUtils.joinStrings(leavingServers, "",""), 
-        		StringUtils.joinStrings(newMembers, "",""), 
-        		fromConfig, stat);
-    }
-
-    /**
-     * The Asynchronous version of reconfig. 
-     *
-     * @see #reconfig
-     *      
-     **/
-    public void reconfig(String joiningServers, String leavingServers,
-        String newMembers, long fromConfig, DataCallback cb, Object ctx)
-    {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.reconfig);       
-        ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);
-        GetDataResponse response = new GetDataResponse();
-        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb,
-               ZooDefs.CONFIG_NODE, ZooDefs.CONFIG_NODE, ctx, null);
-    }
- 
-    /**
-     * Convenience wrapper around asynchronous reconfig that takes Lists of strings instead of comma-separated servers.
-     *
-     * @see #reconfig
-     *
-     */
-    public void reconfig(List<String> joiningServers,
-        List<String> leavingServers, List<String> newMembers, long fromConfig,
-        DataCallback cb, Object ctx)
-    {
-        reconfig(StringUtils.joinStrings(joiningServers, "",""), 
-        		StringUtils.joinStrings(leavingServers, "",""), 
-        		StringUtils.joinStrings(newMembers, "",""), 
-        		fromConfig, cb, ctx);
-    }
    
     /**
      * Set the data for the node of the given path if such a node exists and the
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index c39395a..a72c5bf 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -66,6 +66,7 @@
 import org.apache.zookeeper.cli.StatCommand;
 import org.apache.zookeeper.cli.SyncCommand;
 import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.admin.ZooKeeperAdmin;
 
 /**
  * The command line client to ZooKeeper.
@@ -275,15 +276,14 @@
         if (zk != null && zk.getState().isAlive()) {
             zk.close();
         }
+
         host = newHost;
         boolean readOnly = cl.getOption(""readonly"") != null;
         if (cl.getOption(""secure"") != null) {
             System.setProperty(ZKClientConfig.SECURE_CLIENT, ""true"");
             System.out.println(""Secure connection is enabled"");
         }
-        zk = new ZooKeeper(host,
-                 Integer.parseInt(cl.getOption(""timeout"")),
-                 new MyWatcher(), readOnly);
+        zk = new ZooKeeperAdmin(host, Integer.parseInt(cl.getOption(""timeout"")), new MyWatcher(), readOnly);
     }
     
     public static void main(String args[]) throws CliException, IOException, InterruptedException
@@ -296,8 +296,6 @@
         cl.parseOptions(args);
         System.out.println(""Connecting to "" + cl.getOption(""server""));
         connectToZK(cl.getOption(""server""));
-        //zk = new ZooKeeper(cl.getOption(""server""),
-//                Integer.parseInt(cl.getOption(""timeout"")), new MyWatcher());
     }
 
     public ZooKeeperMain(ZooKeeper zk) {
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java b/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java
new file mode 100644
index 0000000..f60e8d5
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/admin/ZooKeeperAdmin.java
@@ -0,0 +1,250 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.admin;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.AsyncCallback.DataCallback;
+import org.apache.zookeeper.client.ZKClientConfig;
+import org.apache.zookeeper.common.StringUtils;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.proto.GetDataResponse;
+import org.apache.zookeeper.proto.ReconfigRequest;
+import org.apache.zookeeper.proto.ReplyHeader;
+import org.apache.zookeeper.proto.RequestHeader;
+import org.apache.zookeeper.server.DataTree;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * This is the main class for ZooKeeperAdmin client library.
+ * This library is used to perform cluster administration tasks,
+ * such as reconfigure cluster membership. The ZooKeeperAdmin class
+ * inherits ZooKeeper and has similar usage pattern as ZooKeeper class.
+ * Please check {@link ZooKeeper} class document for more details.
+ *
+ * @since 3.5.3
+ */
+public class ZooKeeperAdmin extends ZooKeeper {
+    private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperAdmin.class);
+
+    /**
+     * Create a ZooKeeperAdmin object which is used to perform dynamic reconfiguration
+     * operations.
+     *
+     * @param connectString
+     *            comma separated host:port pairs, each corresponding to a zk
+     *            server. e.g. ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002"" If
+     *            the optional chroot suffix is used the example would look
+     *            like: ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a""
+     *            where the client would be rooted at ""/app/a"" and all paths
+     *            would be relative to this root - ie getting/setting/etc...
+     *            ""/foo/bar"" would result in operations being run on
+     *            ""/app/a/foo/bar"" (from the server perspective).
+     * @param sessionTimeout
+     *            session timeout in milliseconds
+     * @param watcher
+     *            a watcher object which will be notified of state changes, may
+     *            also be notified for node events
+     *
+     * @throws IOException
+     *             in cases of network failure
+     * @throws IllegalArgumentException
+     *             if an invalid chroot path is specified
+     *
+     * @see ZooKeeper#ZooKeeper(String, int, Watcher)
+     *
+     */
+    public ZooKeeperAdmin(String connectString, int sessionTimeout, Watcher watcher)
+        throws IOException {
+        super(connectString, sessionTimeout, watcher);
+    }
+
+    /**
+     * Create a ZooKeeperAdmin object which is used to perform dynamic reconfiguration
+     * operations.
+     *
+     * @param connectString
+     *            comma separated host:port pairs, each corresponding to a zk
+     *            server. e.g. ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002"" If
+     *            the optional chroot suffix is used the example would look
+     *            like: ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a""
+     *            where the client would be rooted at ""/app/a"" and all paths
+     *            would be relative to this root - ie getting/setting/etc...
+     *            ""/foo/bar"" would result in operations being run on
+     *            ""/app/a/foo/bar"" (from the server perspective).
+     * @param sessionTimeout
+     *            session timeout in milliseconds
+     * @param watcher
+     *            a watcher object which will be notified of state changes, may
+     *            also be notified for node events
+     * @param conf
+     *            passing this conf object gives each client the flexibility of
+     *            configuring properties differently compared to other instances
+     *
+     * @throws IOException
+     *             in cases of network failure
+     * @throws IllegalArgumentException
+     *             if an invalid chroot path is specified
+     *
+     * @see ZooKeeper#ZooKeeper(String, int, Watcher, ZKClientConfig)
+     */
+    public ZooKeeperAdmin(String connectString, int sessionTimeout, Watcher watcher,
+            ZKClientConfig conf) throws IOException {
+        super(connectString, sessionTimeout, watcher, conf);
+    }
+
+    /**
+     * Create a ZooKeeperAdmin object which is used to perform dynamic reconfiguration
+     * operations.
+     *
+     * @param connectString
+     *            comma separated host:port pairs, each corresponding to a zk
+     *            server. e.g. ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002"" If
+     *            the optional chroot suffix is used the example would look
+     *            like: ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a""
+     *            where the client would be rooted at ""/app/a"" and all paths
+     *            would be relative to this root - ie getting/setting/etc...
+     *            ""/foo/bar"" would result in operations being run on
+     *            ""/app/a/foo/bar"" (from the server perspective).
+     * @param sessionTimeout
+     *            session timeout in milliseconds
+     * @param watcher
+     *            a watcher object which will be notified of state changes, may
+     *            also be notified for node events
+     * @param canBeReadOnly
+     *            whether the created client is allowed to go to
+     *            read-only mode in case of partitioning. Read-only mode
+     *            basically means that if the client can't find any majority
+     *            servers but there's partitioned server it could reach, it
+     *            connects to one in read-only mode, i.e. read requests are
+     *            allowed while write requests are not. It continues seeking for
+     *            majority in the background.
+     *
+     * @throws IOException
+     *             in cases of network failure
+     * @throws IllegalArgumentException
+     *             if an invalid chroot path is specified
+     *
+     * @see ZooKeeper#ZooKeeper(String, int, Watcher, boolean)
+     */
+    public ZooKeeperAdmin(String connectString, int sessionTimeout, Watcher watcher,
+                     boolean canBeReadOnly) throws IOException {
+        super(connectString, sessionTimeout, watcher, canBeReadOnly);
+    }
+
+    /**
+     * Reconfigure - add/remove servers. Return the new configuration.
+     * @param joiningServers
+     *                a comma separated list of servers being added (incremental reconfiguration)
+     * @param leavingServers
+     *                a comma separated list of servers being removed (incremental reconfiguration)
+     * @param newMembers
+     *                a comma separated list of new membership (non-incremental reconfiguration)
+     * @param fromConfig
+     *                version of the current configuration
+     *                (optional - causes reconfiguration to throw an exception if configuration is no longer current)
+     * @param stat the stat of /zookeeper/config znode will be copied to this
+     *             parameter if not null.
+     * @return new configuration
+     * @throws InterruptedException If the server transaction is interrupted.
+     * @throws KeeperException If the server signals an error with a non-zero error code.
+     */
+    public byte[] reconfig(String joiningServers, String leavingServers,
+                           String newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.reconfig);
+        ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);
+        GetDataResponse response = new GetDataResponse();
+        ReplyHeader r = cnxn.submitRequest(h, request, response, null);
+        if (r.getErr() != 0) {
+            throw KeeperException.create(KeeperException.Code.get(r.getErr()), """");
+        }
+        if (stat != null) {
+            DataTree.copyStat(response.getStat(), stat);
+        }
+        return response.getData();
+    }
+
+    /**
+     * Convenience wrapper around reconfig that takes Lists of strings instead of comma-separated servers.
+     *
+     * @see #reconfig
+     *
+     */
+    public byte[] reconfig(List<String> joiningServers, List<String> leavingServers,
+                           List<String> newMembers, long fromConfig,
+                           Stat stat) throws KeeperException, InterruptedException {
+        return reconfig(StringUtils.joinStrings(joiningServers, "",""),
+                        StringUtils.joinStrings(leavingServers, "",""),
+                        StringUtils.joinStrings(newMembers, "",""),
+                        fromConfig, stat);
+    }
+
+    /**
+     * The Asynchronous version of reconfig.
+     *
+     * @see #reconfig
+     *
+     **/
+    public void reconfig(String joiningServers, String leavingServers,
+        String newMembers, long fromConfig, DataCallback cb, Object ctx) {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.reconfig);
+        ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);
+        GetDataResponse response = new GetDataResponse();
+        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb,
+               ZooDefs.CONFIG_NODE, ZooDefs.CONFIG_NODE, ctx, null);
+    }
+
+    /**
+     * Convenience wrapper around asynchronous reconfig that takes Lists of strings instead of comma-separated servers.
+     *
+     * @see #reconfig
+     *
+     */
+    public void reconfig(List<String> joiningServers,
+        List<String> leavingServers, List<String> newMembers, long fromConfig,
+        DataCallback cb, Object ctx) {
+        reconfig(StringUtils.joinStrings(joiningServers, "",""),
+                 StringUtils.joinStrings(leavingServers, "",""),
+                 StringUtils.joinStrings(newMembers, "",""),
+                 fromConfig, cb, ctx);
+    }
+
+    /**
+     * String representation of this ZooKeeperAdmin client. Suitable for things
+     * like logging.
+     *
+     * Do NOT count on the format of this string, it may change without
+     * warning.
+     *
+     * @since 3.5.3
+     */
+    @Override
+    public String toString() {
+        return super.toString();
+    }
+}
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/cli/CliCommand.java b/src/java/main/org/apache/zookeeper/cli/CliCommand.java
index 3d0a90b..41e3d85 100644
--- a/src/java/main/org/apache/zookeeper/cli/CliCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/CliCommand.java
@@ -25,7 +25,6 @@
  * base class for all CLI commands
  */
 abstract public class CliCommand {
-
     protected ZooKeeper zk;
     protected PrintStream out;
     protected PrintStream err;
@@ -63,7 +62,7 @@
 
     /**
      * set the zookeper instance
-     * @param zk the zookeper instance
+     * @param zk the ZooKeeper instance.
      */
     public void setZk(ZooKeeper zk) {
         this.zk = zk;
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java b/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java
index deb7914..a0709f3 100644
--- a/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java
@@ -18,12 +18,11 @@
 package org.apache.zookeeper.cli;
 
 import java.io.FileInputStream;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Properties;
 
 import org.apache.commons.cli.*;
 import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.admin.ZooKeeperAdmin;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
 
@@ -146,7 +145,16 @@
     public boolean exec() throws CliException {
         try {
             Stat stat = new Stat();
-            byte[] curConfig = zk.reconfig(joining,
+            if (!(zk instanceof ZooKeeperAdmin)) {
+                // This should never happen when executing reconfig command line,
+                // because it is guaranteed that we have a ZooKeeperAdmin instance ready
+                // to use in CliCommand stack.
+                // The only exception would be in test code where clients can directly set
+                // ZooKeeper object to ZooKeeperMain.
+                return false;
+            }
+
+            byte[] curConfig = ((ZooKeeperAdmin)zk).reconfig(joining,
                     leaving, members, version, stat);
             out.println(""Committed new configuration:\n"" + new String(curConfig));
             
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 4666578..9be80f9 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -245,15 +245,23 @@
         addConfigNode();
     }
 
-     public void addConfigNode() {
-    	 DataNode zookeeperZnode = nodes.get(procZookeeper);
-         if (zookeeperZnode!=null) { // should always be the case
-        	 zookeeperZnode.addChild(configChildZookeeper);
-         } else {
-        	 LOG.error(""There's no /zookeeper znode - this should never happen"");
-         }
-         nodes.put(configZookeeper, configDataNode);   
-     }
+    public void addConfigNode() {
+        DataNode zookeeperZnode = nodes.get(procZookeeper);
+        if (zookeeperZnode != null) { // should always be the case
+            zookeeperZnode.addChild(configChildZookeeper);
+        } else {
+            assert false : ""There's no /zookeeper znode - this should never happen."";
+        }
+
+        nodes.put(configZookeeper, configDataNode);
+        try {
+            // Reconfig node is access controlled by default (ZOOKEEPER-2014).
+            setACL(configZookeeper, ZooDefs.Ids.READ_ACL_UNSAFE, -1);
+        } catch (KeeperException.NoNodeException e) {
+            assert false : ""There's no "" + configZookeeper +
+                    "" znode - this should never happen."";
+        }
+    }
 
     /**
      * is the path one of the special paths owned by zookeeper.
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index e275f9c..4d3b1ea 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -425,6 +425,15 @@
                 addChangeRecord(nodeRecord);
                 break;
             case OpCode.reconfig:
+                if (!QuorumPeerConfig.isReconfigEnabled()) {
+                    LOG.error(""Reconfig operation requested but reconfig feature is disabled."");
+                    throw new KeeperException.ReconfigDisabledException();
+                }
+
+                if (skipACL) {
+                    LOG.warn(""skipACL is set, reconfig operation will skip ACL checks!"");
+                }
+
                 zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                 ReconfigRequest reconfigRequest = (ReconfigRequest)record; 
                 LeaderZooKeeperServer lzks;
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index d4f150b..d23c04b 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -169,7 +169,8 @@
      * @param tickTime the ticktime for the server
      * @throws IOException
      */
-    public ZooKeeperServer(FileTxnSnapLog txnLogFactory, int tickTime) throws IOException {
+    public ZooKeeperServer(FileTxnSnapLog txnLogFactory, int tickTime)
+            throws IOException {
         this(txnLogFactory, tickTime, -1, -1, new ZKDatabase(txnLogFactory));
     }
 
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
index 885a5e1..5bfeed3 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
@@ -110,7 +110,8 @@
      * @throws IOException
      * @throws AdminServerException
      */
-    public void runFromConfig(ServerConfig config) throws IOException, AdminServerException {
+    public void runFromConfig(ServerConfig config)
+            throws IOException, AdminServerException {
         LOG.info(""Starting server"");
         FileTxnSnapLog txnLog = null;
         try {
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 24a4ec1..cb8f1c2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -60,6 +60,7 @@
     public static final String nextDynamicConfigFileSuffix = "".dynamic.next"";
 
     private static boolean standaloneEnabled = true;
+    private static boolean reconfigEnabled = false;
 
     protected InetSocketAddress clientPortAddress;
     protected InetSocketAddress secureClientPortAddress;
@@ -279,7 +280,15 @@
                 } else if (value.toLowerCase().equals(""false"")) {
                     setStandaloneEnabled(false);
                 } else {
-                    throw new ConfigException(""Invalid option for standalone mode. Choose 'true' or 'false.'"");
+                    throw new ConfigException(""Invalid option "" + value + "" for standalone mode. Choose 'true' or 'false.'"");
+                }
+            } else if (key.equals(""reconfigEnabled"")) {
+                if (value.toLowerCase().equals(""true"")) {
+                    setReconfigEnabled(true);
+                } else if (value.toLowerCase().equals(""false"")) {
+                    setReconfigEnabled(false);
+                } else {
+                    throw new ConfigException(""Invalid option "" + value + "" for reconfigEnabled flag. Choose 'true' or 'false.'"");
                 }
             } else if ((key.startsWith(""server."") || key.startsWith(""group"") || key.startsWith(""weight"")) && zkProp.containsKey(""dynamicConfigFile"")) {
                 throw new ConfigException(""parameter: "" + key + "" must be in a separate dynamic config file"");
@@ -732,7 +741,13 @@
     }
     
     public static void setStandaloneEnabled(boolean enabled) {
-	standaloneEnabled = enabled;
+        standaloneEnabled = enabled;
+    }
+
+    public static boolean isReconfigEnabled() { return reconfigEnabled; }
+
+    public static void setReconfigEnabled(boolean enabled) {
+        reconfigEnabled = enabled;
     }
 
 }
"
zookeeper,73e102a58d01b27bc6208bbfbde2d12f0deba1f4,ZOOKEEPER-2014: Only admin should be allowed to reconfig a cluster.,2016.11.14 04:59:29,Michael Han,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
index bfe8588..bd49dbf 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
@@ -126,7 +126,9 @@
         }
     }
 
-    public void runFromConfig(QuorumPeerConfig config) throws IOException, AdminServerException {
+    public void runFromConfig(QuorumPeerConfig config)
+            throws IOException, AdminServerException
+    {
       try {
           ManagedUtil.registerLog4jMBeans();
       } catch (JMException e) {
"
zookeeper,bcb07a09b06c91243ed244f04a71b8daf629e286,ZOOKEEPER-2556: peerType not removed from static config file (Rakesh Kumar Singh via shralex).,2016.11.04 00:07:36,Alexander Shraer,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index e772fa8..24a4ec1 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -480,6 +480,7 @@
                         || key.startsWith(""group"")
                         || key.startsWith(""weight"")
                         || key.startsWith(""dynamicConfigFile"")
+                        || key.startsWith(""peerType"")
                         || (eraseClientPortAddress
                             && (key.startsWith(""clientPort"")
                                 || key.startsWith(""clientPortAddress"")))) {
"
zookeeper,cef5978969bedfe066f903834a9ea4af6d508844,ZOOKEEPER-2606: SaslServerCallbackHandler#handleAuthorizeCallback() should log the exception (Ted Yu via fpj),2016.10.17 17:27:16,fpj,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/SaslServerCallbackHandler.java b/src/java/main/org/apache/zookeeper/server/auth/SaslServerCallbackHandler.java
index 2fbd6ed..7fdffde 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/SaslServerCallbackHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/SaslServerCallbackHandler.java
@@ -134,7 +134,7 @@
             LOG.info(""Setting authorizedID: "" + userNameBuilder);
             ac.setAuthorizedID(userNameBuilder.toString());
         } catch (IOException e) {
-            LOG.error(""Failed to set name based on Kerberos authentication rules."");
+            LOG.error(""Failed to set name based on Kerberos authentication rules."", e);
         }
     }
 
"
zookeeper,422058c222a8a31ec7cfd4113fbdc036181f751d,ZOOKEEPER-2467: NullPointerException when redo Command is passed negative value (Rakesh Kumar Singh via rakeshr),2016.10.16 21:21:43,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index 25d61a4..c39395a 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -616,7 +616,7 @@
             System.exit(exitCode);
         } else if (cmd.equals(""redo"") && args.length >= 2) {
             Integer i = Integer.decode(args[1]);
-            if (commandCount <= i) { // don't allow redoing this redo
+            if (commandCount <= i || i < 0) { // don't allow redoing this redo
                 throw new MalformedCommandException(""Command index out of range"");
             }
             cl.parseCommand(history.get(i));
"
zookeeper,ec20c5434cc8a334b3fd25e27d26dccf4793c8f3,ZOOKEEPER-2579: ZooKeeper server should verify that dataDir and snapDir are writeable before starting (Abraham Fine via phunt),2016.09.19 06:21:51,Patrick Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index c9a06d7..9a34bd1 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -106,6 +106,10 @@
                         + this.dataDir);
             }
         }
+        if (!this.dataDir.canWrite()) {
+            throw new DatadirException(""Cannot write to data directory "" + this.dataDir);
+        }
+
         if (!this.snapDir.exists()) {
             // by default create this directory, but otherwise complain instead
             // See ZOOKEEPER-1161 for more details
@@ -122,6 +126,10 @@
                         + this.snapDir);
             }
         }
+        if (!this.snapDir.canWrite()) {
+            throw new DatadirException(""Cannot write to snap directory "" + this.snapDir);
+        }
+
         txnLog = new FileTxnLog(this.dataDir);
         snapLog = new FileSnap(this.snapDir);
     }
"
zookeeper,c38787f355b6dcd612fc57db0202fc68a01108f7,ZOOKEEPER-2172: Cluster crashes when reconfig a new node as a participant (Arshad Mohammad via phunt),2016.09.09 05:59:36,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 8527af5..9803197 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -431,19 +431,19 @@
                     break;
                 case Leader.COMMIT:
                 case Leader.COMMITANDACTIVATE:
+                    pif = packetsNotCommitted.peekFirst();
+                    if (pif.hdr.getZxid() == qp.getZxid() && qp.getType() == Leader.COMMITANDACTIVATE) {
+                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData()));
+                        boolean majorChange = self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(),
+                                qp.getZxid(), true);
+                        if (majorChange) {
+                            throw new Exception(""changes proposed in reconfig"");
+                        }
+                    }
                     if (!snapshotTaken) {
-                        pif = packetsNotCommitted.peekFirst();
                         if (pif.hdr.getZxid() != qp.getZxid()) {
                             LOG.warn(""Committing "" + qp.getZxid() + "", but next proposal is "" + pif.hdr.getZxid());
                         } else {
-                           if (qp.getType() == Leader.COMMITANDACTIVATE) {
-                               QuorumVerifier qv = self.configFromString(new String(((SetDataTxn)pif.rec).getData()));
-                               boolean majorChange =
-                                       self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(), true);
-                                if (majorChange) {
-                                   throw new Exception(""changes proposed in reconfig"");
-                                }
-                           }
                             zk.processTxn(pif.hdr, pif.rec);
                             packetsNotCommitted.remove();
                         }
"
zookeeper,d8c783d6def783b3208c73a83a09febbb719eefc,"ZOOKEEPER-2539: Throwing nullpointerException when run the command config -c"" when client port is mentioned as separate and not like new style (Rakesh Kumar Singh via phunt)",2016.09.08 23:21:26,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/util/ConfigUtils.java b/src/java/main/org/apache/zookeeper/server/util/ConfigUtils.java
index af21f46..1ca37d1 100644
--- a/src/java/main/org/apache/zookeeper/server/util/ConfigUtils.java
+++ b/src/java/main/org/apache/zookeeper/server/util/ConfigUtils.java
@@ -28,11 +28,11 @@
 
 
 public class ConfigUtils {
-	static public String getClientConfigStr(String configData) {
-        Properties props = new Properties();    	
+    static public String getClientConfigStr(String configData) {
+        Properties props = new Properties();        
         try {
           props.load(new StringReader(configData));
-		} catch (IOException e) {
+        } catch (IOException e) {
             e.printStackTrace();
             return """";
         }
@@ -43,17 +43,20 @@
              String key = entry.getKey().toString().trim();
              String value = entry.getValue().toString().trim();
              if (key.equals(""version"")) version = value;
-             if (!key.startsWith(""server."")) continue;	         
+             if (!key.startsWith(""server."")) continue;           
              QuorumPeer.QuorumServer qs;
              try {
                qs = new QuorumPeer.QuorumServer(-1, value);
-             } catch (ConfigException e) {				
+             } catch (ConfigException e) {              
                     e.printStackTrace();
                     continue;
              }
              if (!first) sb.append("","");
              else first = false;
-             sb.append(qs.clientAddr.getHostString() + "":"" + qs.clientAddr.getPort());
+             if (null != qs.clientAddr) {
+                 sb.append(qs.clientAddr.getHostString()
+                         + "":"" + qs.clientAddr.getPort());
+             }
         }
         return version + "" "" + sb.toString();
     }
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index a82eb51..d4f150b 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -102,8 +102,8 @@
     protected RequestProcessor firstProcessor;
     protected volatile State state = State.INITIAL;
 
-    enum State {
-        INITIAL, RUNNING, SHUTDOWN;
+    protected enum State {
+        INITIAL, RUNNING, SHUTDOWN, ERROR;
     }
 
     /**
@@ -122,7 +122,9 @@
     protected ServerCnxnFactory secureServerCnxnFactory;
 
     private final ServerStats serverStats;
-    private final ZooKeeperServerListener listener = new ZooKeeperServerListenerImpl();
+    private final ZooKeeperServerListener listener;
+    private ZooKeeperServerShutdownHandler zkShutdownHandler;
+
     void removeCnxn(ServerCnxn cnxn) {
         zkDb.removeCnxn(cnxn);
     }
@@ -136,6 +138,7 @@
      */
     public ZooKeeperServer() {
         serverStats = new ServerStats(this);
+        listener = new ZooKeeperServerListenerImpl(this);
     }
 
     /**
@@ -152,7 +155,7 @@
         this.tickTime = tickTime;
         setMinSessionTimeout(minSessionTimeout);
         setMaxSessionTimeout(maxSessionTimeout);
-
+        listener = new ZooKeeperServerListenerImpl(this);
         LOG.info(""Created server with tickTime "" + tickTime
                 + "" minSessionTimeout "" + getMinSessionTimeout()
                 + "" maxSessionTimeout "" + getMaxSessionTimeout()
@@ -446,7 +449,7 @@
 
         registerJMX();
 
-        state = State.RUNNING;
+        setState(State.RUNNING);
         notifyAll();
     }
 
@@ -463,20 +466,6 @@
         return listener;
     }
 
-    /**
-     * Default listener implementation, which will do a graceful shutdown on
-     * notification
-     */
-    private class ZooKeeperServerListenerImpl implements
-            ZooKeeperServerListener {
-
-        @Override
-        public void notifyStopping(String threadName, int exitCode) {
-            LOG.info(""Thread {} exits, error code {}"", threadName, exitCode);
-            shutdown();
-        }
-    }
-
     protected void createSessionTracker() {
         sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(),
                 tickTime, 1, getZooKeeperServerListener());
@@ -486,19 +475,61 @@
         ((SessionTrackerImpl)sessionTracker).start();
     }
 
+    /**
+     * Sets the state of ZooKeeper server. After changing the state, it notifies
+     * the server state change to a registered shutdown handler, if any.
+     * <p>
+     * The following are the server state transitions:
+     * <li>During startup the server will be in the INITIAL state.</li>
+     * <li>After successfully starting, the server sets the state to RUNNING.
+     * </li>
+     * <li>The server transitions to the ERROR state if it hits an internal
+     * error. {@link ZooKeeperServerListenerImpl} notifies any critical resource
+     * error events, e.g., SyncRequestProcessor not being able to write a txn to
+     * disk.</li>
+     * <li>During shutdown the server sets the state to SHUTDOWN, which
+     * corresponds to the server not running.</li>
+     *
+     * @param state new server state.
+     */
+    protected void setState(State state) {
+        this.state = state;
+        // Notify server state changes to the registered shutdown handler, if any.
+        if (zkShutdownHandler != null) {
+            zkShutdownHandler.handle(state);
+        } else {
+            LOG.error(""ZKShutdownHandler is not registered, so ZooKeeper server ""
+                    + ""won't take any action on ERROR or SHUTDOWN server state changes"");
+        }
+    }
+
+    /**
+     * This can be used while shutting down the server to see whether the server
+     * is already shutdown or not.
+     *
+     * @return true if the server is running or server hits an error, false
+     *         otherwise.
+     */
+    protected boolean canShutdown() {
+        return state == State.RUNNING || state == State.ERROR;
+    }
+
+    /**
+     * @return true if the server is running, false otherwise.
+     */
     public boolean isRunning() {
         return state == State.RUNNING;
     }
 
     public synchronized void shutdown() {
-        if (!isRunning()) {
+        if (!canShutdown()) {
             LOG.debug(""ZooKeeper server is not running, so not proceeding to shutdown!"");
             return;
         }
         LOG.info(""shutting down"");
 
         // new RuntimeException(""Calling shutdown"").printStackTrace();
-        state = State.SHUTDOWN;
+        setState(State.SHUTDOWN);
         // Since sessionTracker and syncThreads poll we just have to
         // set running to false and they will detect it during the poll
         // interval.
@@ -1142,4 +1173,15 @@
         return sessionTracker.getSessionExpiryMap();
     }
 
+    /**
+     * This method is used to register the ZooKeeperServerShutdownHandler to get
+     * server's error or shutdown state change notifications.
+     * {@link ZooKeeperServerShutdownHandler#handle(State)} will be called for
+     * every server state changes {@link #setState(State)}.
+     *
+     * @param zkShutdownHandler shutdown handler
+     */
+    void registerServerShutdownHandler(ZooKeeperServerShutdownHandler zkShutdownHandler) {
+        this.zkShutdownHandler = zkShutdownHandler;
+    }
 }
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerListenerImpl.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerListenerImpl.java
new file mode 100644
index 0000000..08f4934
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerListenerImpl.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.server.ZooKeeperServer.State;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Default listener implementation, which will be used to notify internal
+ * errors. For example, if some critical thread has stopped due to fatal errors,
+ * then it will get notifications and will change the state of ZooKeeper server
+ * to ERROR representing an error status.
+ */
+class ZooKeeperServerListenerImpl implements ZooKeeperServerListener {
+    private static final Logger LOG = LoggerFactory
+            .getLogger(ZooKeeperServerListenerImpl.class);
+
+    private final ZooKeeperServer zkServer;
+
+    ZooKeeperServerListenerImpl(ZooKeeperServer zkServer) {
+        this.zkServer = zkServer;
+    }
+
+    @Override
+    public void notifyStopping(String threadName, int exitCode) {
+        LOG.info(""Thread {} exits, error code {}"", threadName, exitCode);
+        zkServer.setState(State.ERROR);
+    }
+}
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
index 7f21561..885a5e1 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
@@ -19,6 +19,7 @@
 package org.apache.zookeeper.server;
 
 import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
 import javax.management.JMException;
@@ -118,9 +119,15 @@
             // run() in this thread.
             // create a file logger url from the command line args
             txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);
-            ZooKeeperServer zkServer = new ZooKeeperServer( txnLog,
+            final ZooKeeperServer zkServer = new ZooKeeperServer(txnLog,
                     config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, null);
 
+            // Registers shutdown handler which will be used to know the
+            // server error or shutdown state changes.
+            final CountDownLatch shutdownLatch = new CountDownLatch(1);
+            zkServer.registerServerShutdownHandler(
+                    new ZooKeeperServerShutdownHandler(shutdownLatch));
+
             // Start Admin server
             adminServer = AdminServerFactory.createAdminServer();
             adminServer.setZooKeeperServer(zkServer);
@@ -146,14 +153,19 @@
             );
             containerManager.start();
 
+            // Watch status of ZooKeeper server. It will do a graceful shutdown
+            // if the server is not running or hits an internal error.
+            shutdownLatch.await();
+
+            shutdown();
+
             if (cnxnFactory != null) {
                 cnxnFactory.join();
             }
             if (secureCnxnFactory != null) {
                 secureCnxnFactory.join();
             }
-
-            if (zkServer.isRunning()) {
+            if (zkServer.canShutdown()) {
                 zkServer.shutdown();
             }
         } catch (InterruptedException e) {
@@ -180,9 +192,16 @@
             secureCnxnFactory.shutdown();
         }
         try {
-            adminServer.shutdown();
+            if (adminServer != null) {
+                adminServer.shutdown();
+            }
         } catch (AdminServerException e) {
             LOG.warn(""Problem stopping AdminServer"", e);
         }
     }
+
+    // VisibleForTesting
+    ServerCnxnFactory getCnxnFactory() {
+        return cnxnFactory;
+    }
 }
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerShutdownHandler.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerShutdownHandler.java
new file mode 100644
index 0000000..499cacb
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerShutdownHandler.java
@@ -0,0 +1,46 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import java.util.concurrent.CountDownLatch;
+
+import org.apache.zookeeper.server.ZooKeeperServer.State;
+
+/**
+ * ZooKeeper server shutdown handler which will be used to handle ERROR or
+ * SHUTDOWN server state transitions, which in turn releases the associated
+ * shutdown latch.
+ */
+class ZooKeeperServerShutdownHandler {
+    private final CountDownLatch shutdownLatch;
+
+    ZooKeeperServerShutdownHandler(CountDownLatch shutdownLatch) {
+        this.shutdownLatch = shutdownLatch;
+    }
+
+    /**
+     * This will be invoked when the server transition to a new server state.
+     *
+     * @param state new server state
+     */
+    void handle(State state) {
+        if (state == State.ERROR || state == State.SHUTDOWN) {
+            shutdownLatch.countDown();
+        }
+    }
+}
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index 64ec459..d0f1a72 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -85,7 +85,7 @@
                 }
                 syncWithLeader(newEpochZxid);                
                 QuorumPacket qp = new QuorumPacket();
-                while (self.isRunning()) {
+                while (this.isRunning()) {
                     readPacket(qp);
                     processPacket(qp);
                 }
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index c536411..db30114 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -586,6 +586,12 @@
                         }
                     }
 
+                    // check leader running status
+                    if (!this.isRunning()) {
+                        shutdown(""Unexpected internal error"");
+                        return;
+                    }
+
                     if (!tickSkip && !syncedAckSet.hasAllQuorums()) {
                         // Lost quorum of last committed and/or last proposed
                         // config, set shutdown flag
@@ -1380,4 +1386,8 @@
             return ""UNKNOWN"";
         }
     }
+
+    private boolean isRunning() {
+        return self.isRunning() && zk.isRunning();
+    }
 }
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 362eef4..8527af5 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -622,4 +622,8 @@
             zk.shutdown();
         }
     }
+
+    boolean isRunning() {
+        return self.isRunning() && zk.isRunning();
+    }
 }
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java
index 45ae416..1d4e8c8 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java
@@ -158,7 +158,7 @@
 
     @Override
     public synchronized void shutdown() {
-        if (!isRunning()) {
+        if (!canShutdown()) {
             LOG.debug(""ZooKeeper server is not running, so not proceeding to shutdown!"");
             return;
         }
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
index 9a8ef06..27368c7 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
@@ -23,13 +23,8 @@
 import java.nio.ByteBuffer;
 
 import org.apache.jute.Record;
-import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.server.ObserverBean;
 import org.apache.zookeeper.server.Request;
-import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
-import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
-import org.apache.zookeeper.server.quorum.QuorumPeer.ServerState;
-import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
 import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
 import org.apache.zookeeper.server.util.SerializeUtils;
 import org.apache.zookeeper.txn.SetDataTxn;
@@ -78,7 +73,7 @@
  
                 syncWithLeader(newLeaderZxid);
                 QuorumPacket qp = new QuorumPacket();
-                while (self.isRunning()) {
+                while (this.isRunning()) {
                     readPacket(qp);
                     processPacket(qp);
                 }
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java
index 123a149..bd2bcc0 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java
@@ -132,7 +132,7 @@
 
     @Override
     public synchronized void shutdown() {
-        if (!isRunning()) {
+        if (!canShutdown()) {
             LOG.debug(""ZooKeeper server is not running, so not proceeding to shutdown!"");
             return;
         }
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
index 52d8765..df7b407 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
@@ -156,4 +156,9 @@
         pwriter.println(""membership: "");
         pwriter.print(new String(self.getQuorumVerifier().toString().getBytes()));
     }
+
+    @Override
+    protected void setState(State state) {
+        this.state = state;
+    }
 }
"
zookeeper,a9a0624823d0704b766e5208079c232dce8f25ea,ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader fails to write transaction log (Rakesh via fpj),2016.08.13 22:01:51,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java
index bd8754b..2ef8a5e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java
@@ -137,7 +137,7 @@
 
     @Override
     public synchronized void shutdown() {
-        if (!isRunning()) {
+        if (!canShutdown()) {
             LOG.debug(""ZooKeeper server is not running, so not proceeding to shutdown!"");
             return;
         }
@@ -172,4 +172,9 @@
         pwriter.print(""peerType="");
         pwriter.println(self.getLearnerType().ordinal());
     }
+
+    @Override
+    protected void setState(State state) {
+        this.state = state;
+    }
 }
"
zookeeper,c0a5d8ba561cf8f9ad8fece964f5cf8894c154ee,ZOOKEEPER-2074: Incorrect exit codes for './zkCli.sh cmd arg' (Abraham Fine via phunt),2016.08.11 02:32:22,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/cli/CliException.java b/src/java/main/org/apache/zookeeper/cli/CliException.java
index 4ab26d8..6e9c6d6 100644
--- a/src/java/main/org/apache/zookeeper/cli/CliException.java
+++ b/src/java/main/org/apache/zookeeper/cli/CliException.java
@@ -22,8 +22,10 @@
 
     protected int exitCode;
 
+    protected static final int DEFAULT_EXCEPTION_EXIT_CODE = 1;
+
     public CliException(String message) {
-        this(message, 1);
+        this(message, DEFAULT_EXCEPTION_EXIT_CODE);
     }
 
     public CliException(String message, int exitCode) {
@@ -32,7 +34,7 @@
     }
 
     public CliException(Throwable cause) {
-        this(cause, 1);
+        this(cause, DEFAULT_EXCEPTION_EXIT_CODE);
     }
 
     public CliException(Throwable cause, int exitCode) {
@@ -41,7 +43,7 @@
     }
 
     public CliException(String message, Throwable cause) {
-        super(message, cause);
+        this(message, cause, DEFAULT_EXCEPTION_EXIT_CODE);
     }
 
     public CliException(String message, Throwable cause, int exitCode) {
"
zookeeper,257c47c5e5e825a452d7e54b35803bfb5da3ef5d,ZOOKEEPER-2500: Fix compilation warnings for CliException classes (Abraham Fine via phunt),2016.08.06 06:05:32,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/cli/CliException.java b/src/java/main/org/apache/zookeeper/cli/CliException.java
index 401071f..4ab26d8 100644
--- a/src/java/main/org/apache/zookeeper/cli/CliException.java
+++ b/src/java/main/org/apache/zookeeper/cli/CliException.java
@@ -17,6 +17,7 @@
  */
 package org.apache.zookeeper.cli;
 
+@SuppressWarnings(""serial"")
 public class CliException extends Exception {
 
     protected int exitCode;
"
zookeeper,257c47c5e5e825a452d7e54b35803bfb5da3ef5d,ZOOKEEPER-2500: Fix compilation warnings for CliException classes (Abraham Fine via phunt),2016.08.06 06:05:32,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/cli/CliParseException.java b/src/java/main/org/apache/zookeeper/cli/CliParseException.java
index 69303da..a6326dc 100644
--- a/src/java/main/org/apache/zookeeper/cli/CliParseException.java
+++ b/src/java/main/org/apache/zookeeper/cli/CliParseException.java
@@ -19,6 +19,7 @@
 
 import org.apache.commons.cli.ParseException;
 
+@SuppressWarnings(""serial"")
 public class CliParseException extends CliException {
     public CliParseException(ParseException parseException) {
         super(parseException);
"
zookeeper,257c47c5e5e825a452d7e54b35803bfb5da3ef5d,ZOOKEEPER-2500: Fix compilation warnings for CliException classes (Abraham Fine via phunt),2016.08.06 06:05:32,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/cli/CliWrapperException.java b/src/java/main/org/apache/zookeeper/cli/CliWrapperException.java
index 302cd98..c0fafda 100644
--- a/src/java/main/org/apache/zookeeper/cli/CliWrapperException.java
+++ b/src/java/main/org/apache/zookeeper/cli/CliWrapperException.java
@@ -19,6 +19,7 @@
 
 import org.apache.zookeeper.KeeperException;
 
+@SuppressWarnings(""serial"")
 public class CliWrapperException extends CliException {
     public CliWrapperException(Throwable cause) {
         super(getMessage(cause), cause);
"
zookeeper,257c47c5e5e825a452d7e54b35803bfb5da3ef5d,ZOOKEEPER-2500: Fix compilation warnings for CliException classes (Abraham Fine via phunt),2016.08.06 06:05:32,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/cli/CommandNotFoundException.java b/src/java/main/org/apache/zookeeper/cli/CommandNotFoundException.java
index 9692da2..7090ef0 100644
--- a/src/java/main/org/apache/zookeeper/cli/CommandNotFoundException.java
+++ b/src/java/main/org/apache/zookeeper/cli/CommandNotFoundException.java
@@ -17,6 +17,7 @@
  */
 package org.apache.zookeeper.cli;
 
+@SuppressWarnings(""serial"")
 public class CommandNotFoundException extends CliException {
 
     public CommandNotFoundException(String command) {
"
zookeeper,257c47c5e5e825a452d7e54b35803bfb5da3ef5d,ZOOKEEPER-2500: Fix compilation warnings for CliException classes (Abraham Fine via phunt),2016.08.06 06:05:32,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/cli/MalformedCommandException.java b/src/java/main/org/apache/zookeeper/cli/MalformedCommandException.java
index cc1ed41..72b19ef 100644
--- a/src/java/main/org/apache/zookeeper/cli/MalformedCommandException.java
+++ b/src/java/main/org/apache/zookeeper/cli/MalformedCommandException.java
@@ -17,6 +17,7 @@
  */
 package org.apache.zookeeper.cli;
 
+@SuppressWarnings(""serial"")
 public class MalformedCommandException extends CliException {
     public MalformedCommandException(String message) {
         super(message);
"
zookeeper,01aea04fe49e0e218e06a898780758c1bb0f2600,ZOOKEEPER-2366: Reconfiguration of client port causes a socket leak. (fpj via cnauroth),2016.06.24 06:45:43,Chris Nauroth,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
index b4741d7..7a72757 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
@@ -688,31 +688,42 @@
         ss.configureBlocking(false);
         acceptThread = new AcceptThread(ss, addr, selectorThreads);
     }
-   
-    @Override
-    public void reconfigure(InetSocketAddress addr){
-        ServerSocketChannel oldSS = ss;        
+
+    private void tryClose(ServerSocketChannel s) {
         try {
-           this.ss = ServerSocketChannel.open();
-           ss.socket().setReuseAddress(true);
-           LOG.info(""binding to port "" + addr);
-           ss.socket().bind(addr);
-           ss.configureBlocking(false);
-           acceptThread.setReconfiguring();
-           oldSS.close();           
-           acceptThread.wakeupSelector();
-           try {
-			  acceptThread.join();
-		   } catch (InterruptedException e) {
-			   LOG.error(""Error joining old acceptThread when reconfiguring client port "" + e.getMessage());
-		   }
-           acceptThread = new AcceptThread(ss, addr, selectorThreads);
-           acceptThread.start();
-        } catch(IOException e) {
-           LOG.error(""Error reconfiguring client port to "" + addr + "" "" + e.getMessage());
+            s.close();
+        } catch (IOException sse) {
+            LOG.error(""Error while closing server socket."", sse);
         }
     }
-    
+
+    @Override
+    public void reconfigure(InetSocketAddress addr) {
+        ServerSocketChannel oldSS = ss;        
+        try {
+            this.ss = ServerSocketChannel.open();
+            ss.socket().setReuseAddress(true);
+            LOG.info(""binding to port "" + addr);
+            ss.socket().bind(addr);
+            ss.configureBlocking(false);
+            acceptThread.setReconfiguring();
+            tryClose(oldSS);
+            acceptThread.wakeupSelector();
+            try {
+                acceptThread.join();
+            } catch (InterruptedException e) {
+                LOG.error(""Error joining old acceptThread when reconfiguring client port {}"",
+                            e.getMessage());
+                Thread.currentThread().interrupt();
+            }
+            acceptThread = new AcceptThread(ss, addr, selectorThreads);
+            acceptThread.start();
+        } catch(IOException e) {
+            LOG.error(""Error reconfiguring client port to {} {}"", addr, e.getMessage());
+            tryClose(oldSS);
+        }
+    }
+
     /** {@inheritDoc} */
     public int getMaxClientCnxnsPerHost() {
         return maxClientCnxns;
"
zookeeper,01aea04fe49e0e218e06a898780758c1bb0f2600,ZOOKEEPER-2366: Reconfiguration of client port causes a socket leak. (fpj via cnauroth),2016.06.24 06:45:43,Chris Nauroth,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
index 8bfd83f..25b682b 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
@@ -488,13 +488,17 @@
         parentChannel = bootstrap.bind(localAddress);
     }
     
-    public void reconfigure(InetSocketAddress addr) 
-    {  
+    public void reconfigure(InetSocketAddress addr) {
        Channel oldChannel = parentChannel;
-       LOG.info(""binding to port "" + addr);
-        parentChannel = bootstrap.bind(addr);
-        localAddress = addr;  
-        oldChannel.close();
+       try {
+           LOG.info(""binding to port {}"", addr);
+           parentChannel = bootstrap.bind(addr);
+           localAddress = addr;
+       } catch (Exception e) {
+           LOG.error(""Error while reconfiguring"", e);
+       } finally {
+           oldChannel.close();
+       }
     }
     
     @Override
"
zookeeper,01aea04fe49e0e218e06a898780758c1bb0f2600,ZOOKEEPER-2366: Reconfiguration of client port causes a socket leak. (fpj via cnauroth),2016.06.24 06:45:43,Chris Nauroth,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index a701443..c536411 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -710,7 +710,7 @@
        // that different operations wait for different sets of acks, and we still want to enforce
        // that they are committed in order. Currently we only permit one outstanding reconfiguration
        // such that the reconfiguration and subsequent outstanding ops proposed while the reconfig is
-       // pending all wait for a quorum of old and new config, so its not possible to get enough acks
+       // pending all wait for a quorum of old and new config, so it's not possible to get enough acks
        // for an operation without getting enough acks for preceding ops. But in the future if multiple
        // concurrent reconfigs are allowed, this can happen.
        if (outstandingProposals.containsKey(zxid - 1)) return false;
@@ -751,7 +751,7 @@
             QuorumVerifier newQV = p.qvAcksetPairs.get(p.qvAcksetPairs.size()-1).getQuorumVerifier();
        
             self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);
-       
+
             if (designatedLeader != self.getId()) {
                 allowedToCommit = false;
             }
@@ -1261,7 +1261,7 @@
         QuorumVerifier newQV = self.getLastSeenQuorumVerifier();
         
         Long designatedLeader = getDesignatedLeader(newLeaderProposal, zk.getZxid());                                         
-        
+
         self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);
         if (designatedLeader != self.getId()) {
             allowedToCommit = false;
"
zookeeper,01aea04fe49e0e218e06a898780758c1bb0f2600,ZOOKEEPER-2366: Reconfiguration of client port causes a socket leak. (fpj via cnauroth),2016.06.24 06:45:43,Chris Nauroth,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index bc5a3bc..68bef42 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -1728,7 +1728,7 @@
         writeLongToFile(ACCEPTED_EPOCH_FILENAME, e);
     }
    
-    public boolean processReconfig(QuorumVerifier qv, Long suggestedLeaderId, Long zxid, boolean restartLE){
+    public boolean processReconfig(QuorumVerifier qv, Long suggestedLeaderId, Long zxid, boolean restartLE) {
        InetSocketAddress oldClientAddr = getClientAddress();
 
        // update last committed quorum verifier, write the new config to disk
@@ -1756,8 +1756,8 @@
                cnxnFactory.reconfigure(myNewQS.clientAddr);
                updateThreadName();
            }
-           
-            boolean roleChange = updateLearnerType(qv);
+
+           boolean roleChange = updateLearnerType(qv);
            boolean leaderChange = false;
            if (suggestedLeaderId != null) {
                // zxid should be non-null too
@@ -1875,7 +1875,9 @@
     }
 
     private void updateThreadName() {
-        String plain = cnxnFactory != null ? cnxnFactory.getLocalAddress().toString() : ""disabled"";
+        String plain = cnxnFactory != null ?
+                cnxnFactory.getLocalAddress() != null ?
+                        cnxnFactory.getLocalAddress().toString() : ""disabled"" : ""disabled"";
         String secure = secureCnxnFactory != null ? secureCnxnFactory.getLocalAddress().toString() : ""disabled"";
         setName(String.format(""QuorumPeer[myid=%d](plain=%s)(secure=%s)"", getId(), plain, secure));
     }
"
zookeeper,2cea41e38e7597a1d5901381f2fc72fce8625b7e,ZOOKEEPER-2380: Deadlock between leader shutdown and forwarding ACK to the leader. (Arshad Mohammad via cnauroth),2016.06.24 06:25:34,Chris Nauroth,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 595ca75..a701443 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -549,6 +549,8 @@
             // We ping twice a tick, so we only update the tick every other
             // iteration
             boolean tickSkip = true;
+            // If not null then shutdown this leader
+            String shutdownMessage = null;
 
             while (true) {
                 synchronized (this) {
@@ -586,12 +588,10 @@
 
                     if (!tickSkip && !syncedAckSet.hasAllQuorums()) {
                         // Lost quorum of last committed and/or last proposed
-                        // config, shutdown
-                        shutdown(""Not sufficient followers synced, only synced with sids: [ ""
-                                + syncedAckSet.ackSetsToString() + "" ]"");
-                        // make sure the order is the same!
-                        // the leader goes to looking
-                        return;
+                        // config, set shutdown flag
+                        shutdownMessage = ""Not sufficient followers synced, only synced with sids: [ ""
+                                + syncedAckSet.ackSetsToString() + "" ]"";
+                        break;
                     }
                     tickSkip = !tickSkip;
                 }
@@ -599,6 +599,10 @@
                     f.ping();
                 }
             }
+            if (shutdownMessage != null) {
+                shutdown(shutdownMessage);
+                // leader goes in looking state
+            }
         } finally {
             zk.unregisterJMX(this);
         }
"
zookeeper,2cea41e38e7597a1d5901381f2fc72fce8625b7e,ZOOKEEPER-2380: Deadlock between leader shutdown and forwarding ACK to the leader. (Arshad Mohammad via cnauroth),2016.06.24 06:25:34,Chris Nauroth,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index c00cdf4..bc5a3bc 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -1642,7 +1642,11 @@
     public void setZKDatabase(ZKDatabase database) {
         this.zkDb = database;
     }
-    
+
+    protected ZKDatabase getZkDb() {
+        return zkDb;
+    }
+
     public synchronized void initConfigInZKDatabase() {   
         if (zkDb != null) zkDb.initConfigInZKDatabase(getQuorumVerifier());
     }
"
zookeeper,aa4a217ca85966ee135adb27804992e97ec18cbc,"ZOOKEEPER-2297: NPE is thrown while creating ""key manager"" and ""trust manager"" (Arshad Mohammad via fpj)",2016.06.24 02:42:11,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java b/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
index e261bcf..406015f 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
@@ -39,10 +39,8 @@
                 return;
             IPAuthenticationProvider ipp = new IPAuthenticationProvider();
             DigestAuthenticationProvider digp = new DigestAuthenticationProvider();
-            X509AuthenticationProvider x509p = new X509AuthenticationProvider();
             authenticationProviders.put(ipp.getScheme(), ipp);
             authenticationProviders.put(digp.getScheme(), digp);
-            authenticationProviders.put(x509p.getScheme(), x509p);
             Enumeration<Object> en = System.getProperties().keys();
             while (en.hasMoreElements()) {
                 String k = (String) en.nextElement();
"
zookeeper,aa4a217ca85966ee135adb27804992e97ec18cbc,"ZOOKEEPER-2297: NPE is thrown while creating ""key manager"" and ""trust manager"" (Arshad Mohammad via fpj)",2016.06.24 02:42:11,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index a68cd2e..e772fa8 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -37,6 +37,7 @@
 import java.util.Map.Entry;
 
 import org.apache.zookeeper.common.StringUtils;
+import org.apache.zookeeper.common.ZKConfig;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.slf4j.MDC;
@@ -330,6 +331,9 @@
             this.secureClientPortAddress = new InetSocketAddress(secureClientPort);
             LOG.info(""secureClientPortAddress is {}"", this.secureClientPortAddress.toString());
         }
+        if (this.secureClientPortAddress != null) {
+            configureSSLAuth();
+        }
 
         if (tickTime == 0) {
             throw new IllegalArgumentException(""tickTime is not set"");
@@ -355,6 +359,26 @@
     }
 
     /**
+     * Configure SSL authentication only if it is not configured.
+     * 
+     * @throws ConfigException
+     *             If authentication scheme is configured but authentication
+     *             provider is not configured.
+     */
+    private void configureSSLAuth() throws ConfigException {
+        String sslAuthProp = ""zookeeper.authProvider."" + System.getProperty(ZKConfig.SSL_AUTHPROVIDER, ""x509"");
+        if (System.getProperty(sslAuthProp) == null) {
+            if (""zookeeper.authProvider.x509"".equals(sslAuthProp)) {
+                System.setProperty(""zookeeper.authProvider.x509"",
+                        ""org.apache.zookeeper.server.auth.X509AuthenticationProvider"");
+            } else {
+                throw new ConfigException(""No auth provider configured for the SSL authentication scheme '""
+                        + System.getProperty(ZKConfig.SSL_AUTHPROVIDER) + ""'."");
+            }
+        }
+    }
+
+    /**
      * Backward compatibility -- It would backup static config file on bootup
      * if users write dynamic configuration in ""zoo.cfg"".
      */
"
zookeeper,0c4b4483338d9c71f313f66d3d5bd7912a8ea30a,ZOOKEEPER-2442: Socket leak in QuorumCnxManager connectOne (Michael Han via rgs),2016.06.09 00:43:15,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index a06dde8..58c159b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -237,9 +237,7 @@
      * @param sid
      */
     public void testInitiateConnection(long sid) throws Exception {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug(""Opening channel to server "" + sid);
-        }
+        LOG.debug(""Opening channel to server "" + sid);
         Socket sock = new Socket();
         setSockOpts(sock);
         sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);
@@ -434,17 +432,14 @@
             LOG.debug(""There is a connection already for server "" + sid);
             return true;
         }
-        try {
 
-             if (LOG.isDebugEnabled()) {
-                 LOG.debug(""Opening channel to server "" + sid);
-             }
-             Socket sock = new Socket();
+        Socket sock = null;
+        try {
+             LOG.debug(""Opening channel to server "" + sid);
+             sock = new Socket();
              setSockOpts(sock);
              sock.connect(electionAddr, cnxTO);
-             if (LOG.isDebugEnabled()) {
-                 LOG.debug(""Connected to server "" + sid);
-             }
+             LOG.debug(""Connected to server "" + sid);
              initiateConnection(sock, sid);
              return true;
          } catch (UnresolvedAddressException e) {
@@ -454,11 +449,13 @@
              // detail.
              LOG.warn(""Cannot open channel to "" + sid
                      + "" at election address "" + electionAddr, e);
+             closeSocket(sock);
              throw e;
          } catch (IOException e) {
              LOG.warn(""Cannot open channel to "" + sid
                      + "" at election address "" + electionAddr,
                      e);
+             closeSocket(sock);
              return false;
          }
    
@@ -574,6 +571,10 @@
      *            Reference to socket
      */
     private void closeSocket(Socket sock) {
+        if (sock == null) {
+            return;
+        }
+
         try {
             sock.close();
         } catch (IOException ie) {
@@ -614,7 +615,7 @@
         public void run() {
             int numRetries = 0;
             InetSocketAddress addr;
-
+            Socket client = null;
             while((!shutdown) && (numRetries < 3)){
                 try {
                     ss = new ServerSocket();
@@ -632,7 +633,7 @@
                     setName(addr.toString());
                     ss.bind(addr);
                     while (!shutdown) {
-                        Socket client = ss.accept();
+                        client = ss.accept();
                         setSockOpts(client);
                         LOG.info(""Received connection request ""
                                 + client.getRemoteSocketAddress());
@@ -654,6 +655,7 @@
                         LOG.error(""Interrupted while sleeping. "" +
                             ""Ignoring exception"", ie);
                     }
+                    closeSocket(client);
                 }
             }
             LOG.info(""Leaving listener"");
@@ -739,9 +741,7 @@
         }
                 
         synchronized boolean finish() {
-            if (LOG.isDebugEnabled()) {
-                LOG.debug(""Calling finish for "" + sid);
-            }
+            LOG.debug(""Calling finish for "" + sid);
             
             if(!running){
                 /*
@@ -752,16 +752,14 @@
             
             running = false;
             closeSocket(sock);
-            // channel = null;
 
             this.interrupt();
             if (recvWorker != null) {
                 recvWorker.finish();
             }
 
-            if (LOG.isDebugEnabled()) {
-                LOG.debug(""Removing entry from senderWorkerMap sid="" + sid);
-            }
+            LOG.debug(""Removing entry from senderWorkerMap sid="" + sid);
+
             senderWorkerMap.remove(sid, this);
             threadCnt.decrementAndGet();
             return running;
@@ -919,9 +917,7 @@
             } finally {
                 LOG.warn(""Interrupting SendWorker"");
                 sw.finish();
-                if (sock != null) {
-                    closeSocket(sock);
-                }
+                closeSocket(sock);
             }
         }
     }
"
zookeeper,bba49d85fc715a568bc6ee7bf9caf42ccb7e410b,ZOOKEEPER-2405: getTGT() in Login.java mishandles confidential information (Michael Han via phunt),2016.05.26 05:44:35,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/Login.java b/src/java/main/org/apache/zookeeper/Login.java
index 3ea666b..fd9a4c2 100644
--- a/src/java/main/org/apache/zookeeper/Login.java
+++ b/src/java/main/org/apache/zookeeper/Login.java
@@ -335,7 +335,8 @@
         for(KerberosTicket ticket: tickets) {
             KerberosPrincipal server = ticket.getServer();
             if (server.getName().equals(""krbtgt/"" + server.getRealm() + ""@"" + server.getRealm())) {
-                LOG.debug(""Found tgt {}."", ticket);
+                LOG.debug(""Client principal is \"""" + ticket.getClient().getName() + ""\""."");
+                LOG.debug(""Server principal is \"""" + ticket.getServer().getName() + ""\""."");
                 return ticket;
             }
         }
"
zookeeper,21ae2cf7dfbfd12e8160503c43b5f379fd049d79,ZOOKEEPER-2413: ContainerManager doesn't close the Timer it creates when stop() is called (Jordan via fpj),2016.04.25 06:21:34,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/ContainerManager.java b/src/java/main/org/apache/zookeeper/server/ContainerManager.java
index 362e6e4..7eca968 100644
--- a/src/java/main/org/apache/zookeeper/server/ContainerManager.java
+++ b/src/java/main/org/apache/zookeeper/server/ContainerManager.java
@@ -100,6 +100,7 @@
         if (timerTask != null) {
             timerTask.cancel();
         }
+        timer.cancel();
     }
 
     /**
"
zookeeper,6380270281f9bb79b7ccfff6cfedbce22f734ca4,ZOOKEEPER-2141 ACL cache in DataTree never removes entries (Adam Milne-Smith via camille),2016.04.07 03:06:30,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java b/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java
index 62aaa93..486b845 100644
--- a/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java
+++ b/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java
@@ -38,33 +38,26 @@
 public class ReferenceCountedACLCache {
     private static final Logger LOG = LoggerFactory.getLogger(ReferenceCountedACLCache.class);
 
-    /**
-     * this is map from longs to acl's. It saves acl's being stored for each
-     * datanode.
-     */
-    private final Map<Long, List<ACL>> longKeyMap =
+    final Map<Long, List<ACL>> longKeyMap =
             new HashMap<Long, List<ACL>>();
 
-    /**
-     * this a map from acls to long.
-     */
-    private final Map<List<ACL>, Long> aclKeyMap =
+    final Map<List<ACL>, Long> aclKeyMap =
             new HashMap<List<ACL>, Long>();
 
-    private final Map<Long, AtomicLongWithEquals> referenceCounter =
+    final Map<Long, AtomicLongWithEquals> referenceCounter =
             new HashMap<Long, AtomicLongWithEquals>();
-    private final long OPEN_UNSAFE_ACL_ID = -1L;
+    private static final long OPEN_UNSAFE_ACL_ID = -1L;
 
     /**
      * these are the number of acls that we have in the datatree
      */
-    private long aclIndex = 0;
+    long aclIndex = 0;
 
     /**
-     * converts the list of acls to a list of longs.
+     * converts the list of acls to a long.
      * Increments the reference counter for this ACL.
      * @param acls
-     * @return a list of longs that map to the acls
+     * @return a long that map to the acls
      */
     public synchronized Long convertAcls(List<ACL> acls) {
         if (acls == null)
@@ -84,11 +77,10 @@
     }
 
     /**
-     * converts a list of longs to a list of acls.
+     * converts a long to a list of acls.
      *
      * @param longVal
-     *            the list of longs
-     * @return a list of ACLs that map to longs
+     * @return a list of ACLs that map to the long
      */
     public synchronized List<ACL> convertLong(Long longVal) {
         if (longVal == null)
@@ -203,34 +195,6 @@
         }
     }
 
-    @Override
-    public synchronized boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        ReferenceCountedACLCache that = (ReferenceCountedACLCache) o;
-        synchronized (that) {
-            if (aclIndex != that.aclIndex) return false;
-        }
-        if (aclKeyMap != null ? !aclKeyMap.equals(that.aclKeyMap) : that.aclKeyMap != null) return false;
-        if (longKeyMap != null ? !longKeyMap.equals(that.longKeyMap) : that.longKeyMap != null) return false;
-        if (referenceCounter != null ? !referenceCounter.equals(that.referenceCounter) : that.referenceCounter != null)
-            return false;
-        return true;
-    }
-
-    @Override
-    public synchronized int hashCode() {
-        int result = longKeyMap != null ? longKeyMap.hashCode() : 0;
-        result = 31 * result + (aclKeyMap != null ? aclKeyMap.hashCode() : 0);
-        result = 31 * result + (referenceCounter != null ? referenceCounter.hashCode() : 0);
-        result = 31 * result + (int) (aclIndex ^ (aclIndex >>> 32));
-        return result;
-    }
-
-    /*
-    For reasons we don't all agree with, AtomicLong does not have an equals.
-     */
     private static class AtomicLongWithEquals extends AtomicLong {
 
         private static final long serialVersionUID = 3355155896813725462L;
"
zookeeper,a3d24843bcc298fa635cf447d35f901116b06cda,ZOOKEEPER-2141. ACL cache in DataTree never removes entries (Adam Milne-Smith via camille),2016.03.23 08:30:42,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index d828258..06c80d3 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -18,7 +18,6 @@
 
 package org.apache.zookeeper.server;
 
-import org.apache.jute.Index;
 import org.apache.jute.InputArchive;
 import org.apache.jute.OutputArchive;
 import org.apache.jute.Record;
@@ -35,7 +34,6 @@
 import org.apache.zookeeper.Watcher.Event.KeeperState;
 import org.apache.zookeeper.Watcher.WatcherType;
 import org.apache.zookeeper.ZooDefs;
-import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.common.PathTrie;
 import org.apache.zookeeper.data.ACL;
@@ -139,23 +137,7 @@
     private final Set<String> containers =
             Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
 
-    /**
-     * this is map from longs to acl's. It saves acl's being stored for each
-     * datanode.
-     */
-    private final Map<Long, List<ACL>> longKeyMap =
-        new HashMap<Long, List<ACL>>();
-
-    /**
-     * this a map from acls to long.
-     */
-    private final Map<List<ACL>, Long> aclKeyMap =
-        new HashMap<List<ACL>, Long>();
-
-    /**
-     * these are the number of acls that we have in the datatree
-     */
-    private long aclIndex = 0;
+    private final ReferenceCountedACLCache aclCache = new ReferenceCountedACLCache();
 
     @SuppressWarnings(""unchecked"")
     public Set<String> getEphemerals(long sessionId) {
@@ -174,54 +156,6 @@
         return new HashSet<String>(containers);
     }
 
-    int getAclSize() {
-        return longKeyMap.size();
-    }
-
-    private long incrementIndex() {
-        return ++aclIndex;
-    }
-
-    /**
-     * converts the list of acls to a list of longs.
-     *
-     * @param acls
-     * @return a list of longs that map to the acls
-     */
-    public synchronized Long convertAcls(List<ACL> acls) {
-        if (acls == null)
-            return -1L;
-        // get the value from the map
-        Long ret = aclKeyMap.get(acls);
-        // could not find the map
-        if (ret != null)
-            return ret;
-        long val = incrementIndex();
-        longKeyMap.put(val, acls);
-        aclKeyMap.put(acls, val);
-        return val;
-    }
-
-    /**
-     * converts a list of longs to a list of acls.
-     *
-     * @param longVal
-     *            the list of longs
-     * @return a list of ACLs that map to longs
-     */
-    public synchronized List<ACL> convertLong(Long longVal) {
-        if (longVal == null)
-            return null;
-        if (longVal == -1L)
-            return Ids.OPEN_ACL_UNSAFE;
-        List<ACL> acls = longKeyMap.get(longVal);
-        if (acls == null) {
-            LOG.error(""ERROR: ACL not available for long "" + longVal);
-            throw new RuntimeException(""Failed to fetch acls for "" + longVal);
-        }
-        return acls;
-    }
-
     public Collection<Long> getSessions() {
         return ephemerals.keySet();
     }
@@ -517,7 +451,7 @@
             }
             parent.stat.setCversion(parentCVersion);
             parent.stat.setPzxid(zxid);
-            Long longval = convertAcls(acl);
+            Long longval = aclCache.convertAcls(acl);
             DataNode child = new DataNode(data, longval, stat);
             parent.addChild(childName);
             nodes.put(path, child);
@@ -581,6 +515,9 @@
             throw new KeeperException.NoNodeException();
         }
         nodes.remove(path);
+        synchronized (node) {
+            aclCache.removeUsage(node.acl);
+        }
         DataNode parent = nodes.get(parentName);
         if (parent == null) {
             throw new KeeperException.NoNodeException();
@@ -740,8 +677,9 @@
             throw new KeeperException.NoNodeException();
         }
         synchronized (n) {
+            aclCache.removeUsage(n.acl);
             n.stat.setAversion(version);
-            n.acl = convertAcls(acl);
+            n.acl = aclCache.convertAcls(acl);
             n.copyStat(stat);
             return stat;
         }
@@ -755,10 +693,20 @@
         }
         synchronized (n) {
             n.copyStat(stat);
-            return new ArrayList<ACL>(convertLong(n.acl));
+            return new ArrayList<ACL>(aclCache.convertLong(n.acl));
         }
     }
 
+    public List<ACL> getACL(DataNode node) {
+        synchronized (node) {
+            return aclCache.convertLong(node.acl);
+        }
+    }
+
+    public int aclCacheSize() {
+        return aclCache.size();
+    }
+
     static public class ProcessTxnResult {
         public long clientId;
 
@@ -1202,45 +1150,8 @@
         }
     }
 
-    private void deserializeList(Map<Long, List<ACL>> longKeyMap,
-            InputArchive ia) throws IOException {
-        int i = ia.readInt(""map"");
-        while (i > 0) {
-            Long val = ia.readLong(""long"");
-            if (aclIndex < val) {
-                aclIndex = val;
-            }
-            List<ACL> aclList = new ArrayList<ACL>();
-            Index j = ia.startVector(""acls"");
-            while (!j.done()) {
-                ACL acl = new ACL();
-                acl.deserialize(ia, ""acl"");
-                aclList.add(acl);
-                j.incr();
-            }
-            longKeyMap.put(val, aclList);
-            aclKeyMap.put(aclList, val);
-            i--;
-        }
-    }
-
-    private synchronized void serializeList(Map<Long, List<ACL>> longKeyMap,
-            OutputArchive oa) throws IOException {
-        oa.writeInt(longKeyMap.size(), ""map"");
-        Set<Map.Entry<Long, List<ACL>>> set = longKeyMap.entrySet();
-        for (Map.Entry<Long, List<ACL>> val : set) {
-            oa.writeLong(val.getKey(), ""long"");
-            List<ACL> aclList = val.getValue();
-            oa.startVector(aclList, ""acls"");
-            for (ACL acl : aclList) {
-                acl.serialize(oa, ""acl"");
-            }
-            oa.endVector(aclList, ""acls"");
-        }
-    }
-
     public void serialize(OutputArchive oa, String tag) throws IOException {
-        serializeList(longKeyMap, oa);
+        aclCache.serialize(oa);
         serializeNode(oa, new StringBuilder(""""));
         // / marks end of stream
         // we need to check if clear had been called in between the snapshot.
@@ -1250,7 +1161,7 @@
     }
 
     public void deserialize(InputArchive ia, String tag) throws IOException {
-        deserializeList(longKeyMap, ia);
+        aclCache.deserialize(ia);
         nodes.clear();
         pTrie.clear();
         String path = ia.readString(""path"");
@@ -1258,6 +1169,9 @@
             DataNode node = new DataNode();
             ia.readRecord(node, ""node"");
             nodes.put(path, node);
+            synchronized (node) {
+                aclCache.addUsage(node.acl);
+            }
             int lastSlash = path.lastIndexOf('/');
             if (lastSlash == -1) {
                 root = node;
@@ -1289,6 +1203,8 @@
         // update the quotas - create path trie
         // and also update the stat nodes
         setupQuota();
+
+        aclCache.purgeUnused();
     }
 
     /**
"
zookeeper,a3d24843bcc298fa635cf447d35f901116b06cda,ZOOKEEPER-2141. ACL cache in DataTree never removes entries (Adam Milne-Smith via camille),2016.03.23 08:30:42,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index 672810e..b41e03e 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -261,9 +261,9 @@
                 rsp = new SetDataResponse(rc.stat);
                 err = Code.get(rc.err);
                 break;
-            }           
+            }
             case OpCode.reconfig: {
-                lastOp = ""RECO"";               
+                lastOp = ""RECO"";
                 rsp = new GetDataResponse(((QuorumZooKeeperServer)zks).self.getQuorumVerifier().toString().getBytes(), rc.stat);
                 err = Code.get(rc.err);
                 break;
@@ -317,11 +317,7 @@
                 if (n == null) {
                     throw new KeeperException.NoNodeException();
                 }
-                Long aclL;
-                synchronized(n) {
-                    aclL = n.acl;
-                }
-                PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().convertLong(aclL),
+                PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),
                         ZooDefs.Perms.READ,
                         request.authInfo);
                 Stat stat = new Stat();
@@ -363,12 +359,7 @@
                 if (n == null) {
                     throw new KeeperException.NoNodeException();
                 }
-                Long aclG;
-                synchronized(n) {
-                    aclG = n.acl;
-
-                }
-                PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().convertLong(aclG),
+                PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),
                         ZooDefs.Perms.READ,
                         request.authInfo);
                 List<String> children = zks.getZKDatabase().getChildren(
@@ -387,11 +378,7 @@
                 if (n == null) {
                     throw new KeeperException.NoNodeException();
                 }
-                Long aclG;
-                synchronized(n) {
-                    aclG = n.acl;
-                }
-                PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().convertLong(aclG),
+                PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),
                         ZooDefs.Perms.READ,
                         request.authInfo);
                 List<String> children = zks.getZKDatabase().getChildren(
"
zookeeper,a3d24843bcc298fa635cf447d35f901116b06cda,ZOOKEEPER-2141. ACL cache in DataTree never removes entries (Adam Milne-Smith via camille),2016.03.23 08:30:42,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 4d7005b..33f638d 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -161,15 +161,13 @@
             if (lastChange == null) {
                 DataNode n = zks.getZKDatabase().getNode(path);
                 if (n != null) {
-                    Long acl;
                     Set<String> children;
                     synchronized(n) {
-                        acl = n.acl;
                         children = n.getChildren();
                     }
                     lastChange = new ChangeRecord(-1, path, n.stat,
                         children != null ? children.size() : 0,
-                            zks.getZKDatabase().convertLong(acl));
+                            zks.getZKDatabase().aclForNode(n));
                 }
             }
         }
"
zookeeper,a3d24843bcc298fa635cf447d35f901116b06cda,ZOOKEEPER-2141. ACL cache in DataTree never removes entries (Adam Milne-Smith via camille),2016.03.23 08:30:42,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java b/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java
new file mode 100644
index 0000000..62aaa93
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/ReferenceCountedACLCache.java
@@ -0,0 +1,259 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import org.apache.jute.Index;
+import org.apache.jute.InputArchive;
+import org.apache.jute.OutputArchive;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.data.ACL;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicLong;
+
+public class ReferenceCountedACLCache {
+    private static final Logger LOG = LoggerFactory.getLogger(ReferenceCountedACLCache.class);
+
+    /**
+     * this is map from longs to acl's. It saves acl's being stored for each
+     * datanode.
+     */
+    private final Map<Long, List<ACL>> longKeyMap =
+            new HashMap<Long, List<ACL>>();
+
+    /**
+     * this a map from acls to long.
+     */
+    private final Map<List<ACL>, Long> aclKeyMap =
+            new HashMap<List<ACL>, Long>();
+
+    private final Map<Long, AtomicLongWithEquals> referenceCounter =
+            new HashMap<Long, AtomicLongWithEquals>();
+    private final long OPEN_UNSAFE_ACL_ID = -1L;
+
+    /**
+     * these are the number of acls that we have in the datatree
+     */
+    private long aclIndex = 0;
+
+    /**
+     * converts the list of acls to a list of longs.
+     * Increments the reference counter for this ACL.
+     * @param acls
+     * @return a list of longs that map to the acls
+     */
+    public synchronized Long convertAcls(List<ACL> acls) {
+        if (acls == null)
+            return OPEN_UNSAFE_ACL_ID;
+
+        // get the value from the map
+        Long ret = aclKeyMap.get(acls);
+        if (ret == null) {
+            ret = incrementIndex();
+            longKeyMap.put(ret, acls);
+            aclKeyMap.put(acls, ret);
+        }
+
+        addUsage(ret);
+
+        return ret;
+    }
+
+    /**
+     * converts a list of longs to a list of acls.
+     *
+     * @param longVal
+     *            the list of longs
+     * @return a list of ACLs that map to longs
+     */
+    public synchronized List<ACL> convertLong(Long longVal) {
+        if (longVal == null)
+            return null;
+        if (longVal == OPEN_UNSAFE_ACL_ID)
+            return ZooDefs.Ids.OPEN_ACL_UNSAFE;
+        List<ACL> acls = longKeyMap.get(longVal);
+        if (acls == null) {
+            LOG.error(""ERROR: ACL not available for long "" + longVal);
+            throw new RuntimeException(""Failed to fetch acls for "" + longVal);
+        }
+        return acls;
+    }
+
+    private long incrementIndex() {
+        return ++aclIndex;
+    }
+
+    public synchronized void deserialize(InputArchive ia) throws IOException {
+        clear();
+        int i = ia.readInt(""map"");
+        while (i > 0) {
+            Long val = ia.readLong(""long"");
+            if (aclIndex < val) {
+                aclIndex = val;
+            }
+            List<ACL> aclList = new ArrayList<ACL>();
+            Index j = ia.startVector(""acls"");
+            while (!j.done()) {
+                ACL acl = new ACL();
+                acl.deserialize(ia, ""acl"");
+                aclList.add(acl);
+                j.incr();
+            }
+            longKeyMap.put(val, aclList);
+            aclKeyMap.put(aclList, val);
+            referenceCounter.put(val, new AtomicLongWithEquals(0));
+            i--;
+        }
+    }
+
+    public synchronized void serialize(OutputArchive oa) throws IOException {
+        oa.writeInt(longKeyMap.size(), ""map"");
+        Set<Map.Entry<Long, List<ACL>>> set = longKeyMap.entrySet();
+        for (Map.Entry<Long, List<ACL>> val : set) {
+            oa.writeLong(val.getKey(), ""long"");
+            List<ACL> aclList = val.getValue();
+            oa.startVector(aclList, ""acls"");
+            for (ACL acl : aclList) {
+                acl.serialize(oa, ""acl"");
+            }
+            oa.endVector(aclList, ""acls"");
+        }
+    }
+
+    public int size() {
+        return aclKeyMap.size();
+    }
+
+    private void clear() {
+        aclKeyMap.clear();
+        longKeyMap.clear();
+        referenceCounter.clear();
+    }
+
+    public synchronized void addUsage(Long acl) {
+        if (acl == OPEN_UNSAFE_ACL_ID) {
+            return;
+        }
+
+        if (!longKeyMap.containsKey(acl)) {
+            LOG.info(""Ignoring acl "" + acl + "" as it does not exist in the cache"");
+            return;
+        }
+
+        AtomicLong count = referenceCounter.get(acl);
+        if (count == null) {
+            referenceCounter.put(acl, new AtomicLongWithEquals(1));
+        } else {
+            count.incrementAndGet();
+        }
+    }
+
+    public synchronized void removeUsage(Long acl) {
+        if (acl == OPEN_UNSAFE_ACL_ID) {
+            return;
+        }
+
+        if (!longKeyMap.containsKey(acl)) {
+            LOG.info(""Ignoring acl "" + acl + "" as it does not exist in the cache"");
+            return;
+        }
+
+        long newCount = referenceCounter.get(acl).decrementAndGet();
+        if (newCount <= 0) {
+            referenceCounter.remove(acl);
+            aclKeyMap.remove(longKeyMap.get(acl));
+            longKeyMap.remove(acl);
+        }
+    }
+
+    public synchronized void purgeUnused() {
+        Iterator<Map.Entry<Long, AtomicLongWithEquals>> refCountIter = referenceCounter.entrySet().iterator();
+        while (refCountIter.hasNext()) {
+            Map.Entry<Long, AtomicLongWithEquals> entry = refCountIter.next();
+            if (entry.getValue().get() <= 0) {
+                Long acl = entry.getKey();
+                aclKeyMap.remove(longKeyMap.get(acl));
+                longKeyMap.remove(acl);
+                refCountIter.remove();
+            }
+        }
+    }
+
+    @Override
+    public synchronized boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        ReferenceCountedACLCache that = (ReferenceCountedACLCache) o;
+        synchronized (that) {
+            if (aclIndex != that.aclIndex) return false;
+        }
+        if (aclKeyMap != null ? !aclKeyMap.equals(that.aclKeyMap) : that.aclKeyMap != null) return false;
+        if (longKeyMap != null ? !longKeyMap.equals(that.longKeyMap) : that.longKeyMap != null) return false;
+        if (referenceCounter != null ? !referenceCounter.equals(that.referenceCounter) : that.referenceCounter != null)
+            return false;
+        return true;
+    }
+
+    @Override
+    public synchronized int hashCode() {
+        int result = longKeyMap != null ? longKeyMap.hashCode() : 0;
+        result = 31 * result + (aclKeyMap != null ? aclKeyMap.hashCode() : 0);
+        result = 31 * result + (referenceCounter != null ? referenceCounter.hashCode() : 0);
+        result = 31 * result + (int) (aclIndex ^ (aclIndex >>> 32));
+        return result;
+    }
+
+    /*
+    For reasons we don't all agree with, AtomicLong does not have an equals.
+     */
+    private static class AtomicLongWithEquals extends AtomicLong {
+
+        private static final long serialVersionUID = 3355155896813725462L;
+
+        public AtomicLongWithEquals(long i) {
+            super(i);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            return equals((AtomicLongWithEquals) o);
+        }
+
+        public boolean equals(AtomicLongWithEquals that) {
+            return get() == that.get();
+        }
+
+        @Override
+        public int hashCode() {
+            return 31 * Long.valueOf(get()).hashCode();
+        }
+    }
+}
"
zookeeper,a3d24843bcc298fa635cf447d35f901116b06cda,ZOOKEEPER-2141. ACL cache in DataTree never removes entries (Adam Milne-Smith via camille),2016.03.23 08:30:42,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 3fa96a6..05bbb91 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -335,7 +335,10 @@
         }
         return new TxnLogProposalIterator(itr);
     }
-    
+
+    public List<ACL> aclForNode(DataNode n) {
+        return dataTree.getACL(n);
+    }
     /**
      * remove a cnxn from the datatree
      * @param cnxn the cnxn to remove from the datatree
@@ -422,15 +425,6 @@
     }
 
     /**
-     * convert from long to the acl entry
-     * @param aclL the long for which to get the acl
-     * @return the acl corresponding to this long entry
-     */
-    public List<ACL> convertLong(Long aclL) {
-        return dataTree.convertLong(aclL);
-    }
-
-    /**
      * get data and stat for a path
      * @param path the path being queried
      * @param stat the stat for this path
@@ -494,7 +488,7 @@
      * @return the acl size of the datatree
      */
     public int getAclSize() {
-        return dataTree.getAclSize();
+        return dataTree.aclCacheSize();
     }
 
     /**
"
zookeeper,7e889d125f4a19f710dc9276402061ba6900e8a4,ZOOKEEPER-2195 fsync.warningthresholdms in zoo.cfg not working (Biju Nair via phunt),2016.03.21 03:31:58,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 00a1c7f..3a6ebd5 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -112,7 +112,11 @@
                 LOG.warn(size + "" is not a valid value for preAllocSize"");
             }
         }
-        fsyncWarningThresholdMS = Long.getLong(""fsync.warningthresholdms"", 1000);
+        /** Local variable to read fsync.warningthresholdms into */
+        Long fsyncWarningThreshold;
+        if ((fsyncWarningThreshold = Long.getLong(""zookeeper.fsync.warningthresholdms"")) == null)
+            fsyncWarningThreshold = Long.getLong(""fsync.warningthresholdms"", 1000);
+        fsyncWarningThresholdMS = fsyncWarningThreshold;
     }
 
     long lastZxidSeen;
"
zookeeper,47da0276906c6fc27a482eb7568bcabc9721cdba,ZOOKEEPER-2379: recent commit broke findbugs qabot check (rakeshr via cnauroth),2016.03.05 09:03:57,Chris Nauroth,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index 446bdb0..aebbfa4 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -64,6 +64,7 @@
     public static final String LOGIN_CONTEXT_NAME_KEY = ""zookeeper.sasl.clientconfig"";
     public static final String ENABLE_CLIENT_SASL_KEY = ""zookeeper.sasl.client"";
     public static final String ENABLE_CLIENT_SASL_DEFAULT = ""true"";
+    private static volatile boolean initializedLogin = false; 
 
     /**
      * Returns true if the SASL client is enabled. By default, the client
@@ -217,7 +218,7 @@
     private SaslClient createSaslClient(final String servicePrincipal,
                                                      final String loginContext) throws LoginException {
         try {
-            if (login == null) {
+            if (!initializedLogin) {
                 synchronized (ZooKeeperSaslClient.class) {
                     if (login == null) {
                         if (LOG.isDebugEnabled()) {
@@ -227,6 +228,7 @@
                         // in order to ensure the login is initialized only once, it must be synchronized the code snippet.
                         login = new Login(loginContext, new ClientCallbackHandler(null));
                         login.startThreadIfNeeded();
+                        initializedLogin = true;
                     }
                 }
             }
"
zookeeper,153a7e64068644a56e69e29ff4a3a277af862bcb,ZOOKEEPER-2375: Prevent multiple initialization of login object in each ZooKeeperSaslClient instance (yuemeng via rakeshr),2016.03.02 15:46:43,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index 4f3d2ec..446bdb0 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -214,17 +214,21 @@
         }
     }
 
-    synchronized private SaslClient createSaslClient(final String servicePrincipal,
+    private SaslClient createSaslClient(final String servicePrincipal,
                                                      final String loginContext) throws LoginException {
         try {
             if (login == null) {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug(""JAAS loginContext is: "" + loginContext);
+                synchronized (ZooKeeperSaslClient.class) {
+                    if (login == null) {
+                        if (LOG.isDebugEnabled()) {
+                            LOG.debug(""JAAS loginContext is: "" + loginContext);
+                        }
+                        // note that the login object is static: it's shared amongst all zookeeper-related connections.
+                        // in order to ensure the login is initialized only once, it must be synchronized the code snippet.
+                        login = new Login(loginContext, new ClientCallbackHandler(null));
+                        login.startThreadIfNeeded();
+                    }
                 }
-                // note that the login object is static: it's shared amongst all zookeeper-related connections.
-                // createSaslClient() must be declared synchronized so that login is initialized only once.
-                login = new Login(loginContext, new ClientCallbackHandler(null));
-                login.startThreadIfNeeded();
             }
             Subject subject = login.getSubject();
             SaslClient saslClient;
"
zookeeper,b286cccd5a56aed88a7d74cffff87a09790ac97d,"ZOOKEEPER-2297: NPE is thrown while creating ""key manager"" and ""trust manager"" (Arshad Mohammad via rakeshr)",2016.01.21 15:07:04,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java b/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
index e261bcf..406015f 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
@@ -39,10 +39,8 @@
                 return;
             IPAuthenticationProvider ipp = new IPAuthenticationProvider();
             DigestAuthenticationProvider digp = new DigestAuthenticationProvider();
-            X509AuthenticationProvider x509p = new X509AuthenticationProvider();
             authenticationProviders.put(ipp.getScheme(), ipp);
             authenticationProviders.put(digp.getScheme(), digp);
-            authenticationProviders.put(x509p.getScheme(), x509p);
             Enumeration<Object> en = System.getProperties().keys();
             while (en.hasMoreElements()) {
                 String k = (String) en.nextElement();
"
zookeeper,54480f6ab72cafb68231695a1f41064e24ebf65d,ZOOKEEPER-2295: TGT refresh time logic is wrong (Arshad Mohammad via rgs),2015.12.09 13:05:19,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/Login.java b/src/java/main/org/apache/zookeeper/Login.java
index f88e5af..19a59af 100644
--- a/src/java/main/org/apache/zookeeper/Login.java
+++ b/src/java/main/org/apache/zookeeper/Login.java
@@ -155,7 +155,6 @@
                         if ((nextRefresh > expiry) ||
                                 ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {
                             // expiry is before next scheduled refresh).
-                            LOG.info(""refreshing now because expiry is before next scheduled refresh time."");
                             nextRefresh = now;
                         } else {
                             if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {
@@ -178,7 +177,9 @@
                             return;
                         }
                     }
-                    if (now < nextRefresh) {
+                    if (now == nextRefresh) {
+                        LOG.info(""refreshing now because expiry is before next scheduled refresh time."");
+                    } else if (now < nextRefresh) {
                         Date until = new Date(nextRefresh);
                         LOG.info(""TGT refresh sleeping until: {}"", until.toString());
                         try {
@@ -193,7 +194,7 @@
                                 + "" clock sync between this host and KDC - (KDC's clock is likely ahead of this host).""
                                 + "" Manual intervention will be required for this client to successfully authenticate.""
                                 + "" Exiting refresh thread."", nextRefreshDate);
-                        return;
+                        break;
                     }
                     if (isUsingTicketCache) {
                         String cmd = ""/usr/bin/kinit"";
"
zookeeper,8d11ef90f71733a59b28828ee84e9955f297d1e2,ZOOKEEPER-2299: NullPointerException in LocalPeerBean for ClientAddress (Arshad Mohammad via rgs),2015.12.07 14:06:45,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java b/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
index 5846bd6..361eb94 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
@@ -19,6 +19,7 @@
 package org.apache.zookeeper.server.quorum;
 
 
+
 /**
  * Implementation of the local peer MBean interface.
  */
@@ -83,8 +84,12 @@
     }
 
     public String getClientAddress() {
-        return peer.getClientAddress().getHostString() + "":"" +
-            peer.getClientAddress().getPort();
+        if (null != peer.cnxnFactory) {
+            return String.format(""%s:%d"", peer.cnxnFactory.getLocalAddress()
+                    .getHostString(), peer.getClientPort());
+        } else {
+            return """";
+        }
     }
 
     public String getLearnerType(){
"
zookeeper,5bcdb84bda57b06d0d4a38ce587ab91cd010e9a2,ZOOKEEPER-2301: QuorumPeer does not listen on passed client IP in the constructor (Arshad Mohammad via rgs),2015.12.07 13:59:37,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 142896b..2d8ec95 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -858,9 +858,8 @@
             long myid, int tickTime, int initLimit, int syncLimit)
         throws IOException
     {
-        this(quorumPeers, snapDir, logDir, electionAlg,
-                myid,tickTime, initLimit,syncLimit, false,
-                ServerCnxnFactory.createFactory(new InetSocketAddress(clientPort), -1),
+        this(quorumPeers, snapDir, logDir, electionAlg, myid, tickTime, initLimit, syncLimit, false,
+                ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),
                 new QuorumMaj(quorumPeers));
     }
 
@@ -876,10 +875,26 @@
     {
         this(quorumPeers, snapDir, logDir, electionAlg,
                 myid,tickTime, initLimit,syncLimit, false,
-                ServerCnxnFactory.createFactory(new InetSocketAddress(clientPort), -1),
+                ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),
                 quorumConfig);
     }
 
+    private static InetSocketAddress getClientAddress(Map<Long, QuorumServer> quorumPeers, long myid, int clientPort)
+            throws IOException {
+        QuorumServer quorumServer = quorumPeers.get(myid);
+        if (null == quorumServer) {
+            throw new IOException(""No QuorumServer correspoding to myid "" + myid);
+        }
+        if (null == quorumServer.clientAddr) {
+            return new InetSocketAddress(clientPort);
+        }
+        if (quorumServer.clientAddr.getPort() != clientPort) {
+            throw new IOException(""QuorumServer port "" + quorumServer.clientAddr.getPort()
+                    + "" does not match with given port "" + clientPort);
+        }
+        return quorumServer.clientAddr;
+    }
+
     /**
      * returns the highest zxid that this host has seen
      *
"
zookeeper,0a3f9d123af076341022ae81697257c5ff8a9428,ZOOKEEPER-2304: JMX ClientPort from ZooKeeperServerBean incorrect (Arshad Mohammad via rgs),2015.12.07 05:37:20,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerBean.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerBean.java
index 50837f4..0853426 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerBean.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerBean.java
@@ -18,8 +18,6 @@
 
 package org.apache.zookeeper.server;
 
-import java.net.InetAddress;
-import java.net.UnknownHostException;
 import java.util.Date;
 
 import org.apache.zookeeper.Version;
@@ -41,12 +39,7 @@
     }
     
     public String getClientPort() {
-        try {
-            return InetAddress.getLocalHost().getHostAddress() + "":""
-                + zks.getClientPort();
-        } catch (UnknownHostException e) {
-            return ""localhost:"" + zks.getClientPort();
-        }
+        return Integer.toString(zks.getClientPort());
     }
     
     public String getName() {
"
zookeeper,9bb9b1d7016433ce98cd33be904ee1e77d484ffd,ZOOKEEPER-2335: Java Compilation Error in ClientCnxn.java (Arshad Mohammad via rgs),2015.12.07 03:58:29,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 7a18b72..f477c9c 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -46,7 +46,6 @@
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.BinaryOutputArchive;
 import org.apache.jute.Record;
-import org.apache.log4j.MDC;
 import org.apache.zookeeper.AsyncCallback.ACLCallback;
 import org.apache.zookeeper.AsyncCallback.Children2Callback;
 import org.apache.zookeeper.AsyncCallback.ChildrenCallback;
@@ -88,6 +87,7 @@
 import org.apache.zookeeper.server.ZooTrace;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.slf4j.MDC;
 
 /**
  * This class manages the socket i/o for the client. ClientCnxn maintains a list
"
zookeeper,8d52816fbd5e7457eef97b65771b6242cdc0fbc1,ZOOKEEPER-2330: ZooKeeper close API does not close Login thread (Arshad Mohammad via rgs),2015.12.06 06:32:41,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 9080ffa..6f1006d 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1464,6 +1464,9 @@
 
         sendThread.close();
         eventThread.queueEventOfDeath();
+        if (null != zooKeeperSaslClient) {
+            zooKeeperSaslClient.shutdown();
+        }
     }
 
     /**
"
zookeeper,8d52816fbd5e7457eef97b65771b6242cdc0fbc1,ZOOKEEPER-2330: ZooKeeper close API does not close Login thread (Arshad Mohammad via rgs),2015.12.06 06:32:41,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index 53f33e8..4f3d2ec 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -580,5 +580,12 @@
         }
     }
 
-
+    /**
+     * close login thread if running
+     */
+    public void shutdown() {
+        if (null != login) {
+            login.shutdown();
+        }
+    }
 }
"
zookeeper,0dc51fc123a8a67380890d4dadc0a2f15d50381b,ZOOKEEPER-2329: Clear javac and javadoc warning from zookeeper (Arshad Mohammad via rgs),2015.11.22 08:33:59,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index 80853e2..d082edc 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -38,7 +38,6 @@
 import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.data.Stat;
-import java.util.StringTokenizer;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -223,7 +222,7 @@
         public boolean parseCommand( String cmdstring ) {
             Matcher matcher = ARGS_PATTERN.matcher(cmdstring);
 
-            List args = new LinkedList();
+            List<String> args = new LinkedList<String>();
             while (matcher.find()) {
                 String value = matcher.group(1);
                 if (QUOTED_PATTERN.matcher(value).matches()) {
@@ -235,7 +234,7 @@
             if (args.isEmpty()){
                 return false;
             }
-            command = (String)args.get(0);
+            command = args.get(0);
             cmdArgs = args;
             return true;
         }
"
zookeeper,0dc51fc123a8a67380890d4dadc0a2f15d50381b,ZOOKEEPER-2329: Clear javac and javadoc warning from zookeeper (Arshad Mohammad via rgs),2015.11.22 08:33:59,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
index 25b949a..37d1984 100644
--- a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
@@ -167,7 +167,7 @@
      * error and usage and then exits
      *
      * @param number
-     * @return
+     * @return count
      */
     private static int validateAndGetCount(String number) {
         int result = 0;
"
zookeeper,0dc51fc123a8a67380890d4dadc0a2f15d50381b,ZOOKEEPER-2329: Clear javac and javadoc warning from zookeeper (Arshad Mohammad via rgs),2015.11.22 08:33:59,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/admin/AdminServer.java b/src/java/main/org/apache/zookeeper/server/admin/AdminServer.java
index cb61f79..41f0bb8 100644
--- a/src/java/main/org/apache/zookeeper/server/admin/AdminServer.java
+++ b/src/java/main/org/apache/zookeeper/server/admin/AdminServer.java
@@ -31,6 +31,7 @@
     public void setZooKeeperServer(ZooKeeperServer zkServer);
 
     public class AdminServerException extends Exception {
+        private static final long serialVersionUID = 1L;
         public AdminServerException(String message, Throwable cause) {
             super(message, cause);
         }
"
zookeeper,0dc51fc123a8a67380890d4dadc0a2f15d50381b,ZOOKEEPER-2329: Clear javac and javadoc warning from zookeeper (Arshad Mohammad via rgs),2015.11.22 08:33:59,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/admin/JettyAdminServer.java b/src/java/main/org/apache/zookeeper/server/admin/JettyAdminServer.java
index f911484..1af00a6 100644
--- a/src/java/main/org/apache/zookeeper/server/admin/JettyAdminServer.java
+++ b/src/java/main/org/apache/zookeeper/server/admin/JettyAdminServer.java
@@ -140,6 +140,8 @@
     }
 
     private class CommandServlet extends HttpServlet {
+        private static final long serialVersionUID = 1L;
+
         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             // Capture the command name from the URL
             String cmd = request.getPathInfo();
"
zookeeper,0dc51fc123a8a67380890d4dadc0a2f15d50381b,ZOOKEEPER-2329: Clear javac and javadoc warning from zookeeper (Arshad Mohammad via rgs),2015.11.22 08:33:59,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/util/KerberosUtil.java b/src/java/main/org/apache/zookeeper/server/util/KerberosUtil.java
index 1434ff0..f5f4e26 100644
--- a/src/java/main/org/apache/zookeeper/server/util/KerberosUtil.java
+++ b/src/java/main/org/apache/zookeeper/server/util/KerberosUtil.java
@@ -36,10 +36,10 @@
     } else {
       classRef = Class.forName(""sun.security.krb5.Config"");
     }
-    getInstanceMethod = classRef.getMethod(""getInstance"", new Class[0]);
+    getInstanceMethod = classRef.getMethod(""getInstance"", new Class<?>[0]);
     kerbConf = getInstanceMethod.invoke(classRef, new Object[0]);
     getDefaultRealmMethod = classRef.getDeclaredMethod(""getDefaultRealm"",
-         new Class[0]);
+         new Class<?>[0]);
     return (String)getDefaultRealmMethod.invoke(kerbConf, new Object[0]);
   }
 }
"
zookeeper,0dc51fc123a8a67380890d4dadc0a2f15d50381b,ZOOKEEPER-2329: Clear javac and javadoc warning from zookeeper (Arshad Mohammad via rgs),2015.11.22 08:33:59,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/util/OSMXBean.java b/src/java/main/org/apache/zookeeper/server/util/OSMXBean.java
index a75af02..972afe7 100644
--- a/src/java/main/org/apache/zookeeper/server/util/OSMXBean.java
+++ b/src/java/main/org/apache/zookeeper/server/util/OSMXBean.java
@@ -86,7 +86,7 @@
             classRef = Class.forName(""com.sun.management.UnixOperatingSystemMXBean"");
             if (classRef.isInstance(osMbean)) {
                 mBeanMethod = classRef.getDeclaredMethod(mBeanMethodName,
-                new Class[0]);
+                new Class<?>[0]);
                 unixos = classRef.cast(osMbean);
                 return (Long)mBeanMethod.invoke(unixos);
             }
"
zookeeper,31b61db08a87b5939ea3fce5328d7ce69df536e6,ZOOKEEPER-1371: Remove dependency on log4j in the source code (Arshad Mohammad via rgs),2015.11.22 06:18:10,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/Login.java b/src/java/main/org/apache/zookeeper/Login.java
index 44b0bdf..f88e5af 100644
--- a/src/java/main/org/apache/zookeeper/Login.java
+++ b/src/java/main/org/apache/zookeeper/Login.java
@@ -32,18 +32,20 @@
 import javax.security.auth.login.LoginException;
 import javax.security.auth.callback.CallbackHandler;
 
-import org.apache.log4j.Logger;
 import org.apache.zookeeper.client.ZooKeeperSaslClient;
 import org.apache.zookeeper.common.Time;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import javax.security.auth.kerberos.KerberosTicket;
 import javax.security.auth.Subject;
+
 import java.util.Date;
 import java.util.Random;
 import java.util.Set;
 
 public class Login {
-    private static final Logger LOG = Logger.getLogger(Login.class);
+    private static final Logger LOG = LoggerFactory.getLogger(Login.class);
     public CallbackHandler callbackHandler;
 
     // LoginThread will sleep until 80% of time from last refresh to
@@ -130,19 +132,20 @@
                     if (tgt == null) {
                         nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;
                         nextRefreshDate = new Date(nextRefresh);
-                        LOG.warn(""No TGT found: will try again at "" + nextRefreshDate);
+                        LOG.warn(""No TGT found: will try again at {}"", nextRefreshDate);
                     } else {
                         nextRefresh = getRefreshTime(tgt);
                         long expiry = tgt.getEndTime().getTime();
                         Date expiryDate = new Date(expiry);
                         if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {
-                            LOG.error(""The TGT cannot be renewed beyond the next expiry date: "" + expiryDate + ""."" +
+                            Object[] logPayload = {expiryDate, principal, principal};
+                            LOG.error(""The TGT cannot be renewed beyond the next expiry date: {}."" +
                                     ""This process will not be able to authenticate new SASL connections after that "" +
                                     ""time (for example, it will not be authenticate a new connection with a Zookeeper "" +
                                     ""Quorum member).  Ask your system administrator to either increase the "" +
-                                    ""'renew until' time by doing : 'modprinc -maxrenewlife "" + principal + ""' within "" +
-                                    ""kadmin, or instead, to generate a keytab for "" + principal + "". Because the TGT's "" +
-                                    ""expiry cannot be further extended by refreshing, exiting refresh thread now."");
+                                    ""'renew until' time by doing : 'modprinc -maxrenewlife {}' within "" +
+                                    ""kadmin, or instead, to generate a keytab for {}. Because the TGT's "" +
+                                    ""expiry cannot be further extended by refreshing, exiting refresh thread now."", logPayload);
                             return;
                         }
                         // determine how long to sleep from looking at ticket's expiry.
@@ -159,23 +162,25 @@
                                 // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).
                                 Date until = new Date(nextRefresh);
                                 Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);
-                                LOG.warn(""TGT refresh thread time adjusted from : "" + until + "" to : "" + newuntil + "" since ""
+                                Object[] logPayload = {until, newuntil, (MIN_TIME_BEFORE_RELOGIN / 1000)};
+                                LOG.warn(""TGT refresh thread time adjusted from : {} to : {} since ""
                                         + ""the former is sooner than the minimum refresh interval (""
-                                        + MIN_TIME_BEFORE_RELOGIN / 1000 + "" seconds) from now."");
+                                        + ""{} seconds) from now."", logPayload);
                             }
                             nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);
                         }
                         nextRefreshDate = new Date(nextRefresh);
                         if (nextRefresh > expiry) {
-                            LOG.error(""next refresh: "" + nextRefreshDate + "" is later than expiry "" + expiryDate
-                                    + "". This may indicate a clock skew problem. Check that this host and the KDC's ""
-                                    + ""hosts' clocks are in sync. Exiting refresh thread."");
+                            Object[] logPayload = {nextRefreshDate, expiryDate};
+                            LOG.error(""next refresh: {} is later than expiry {}.""
+                                    + "" This may indicate a clock skew problem. Check that this host and the KDC's ""
+                                    + ""hosts' clocks are in sync. Exiting refresh thread."", logPayload);
                             return;
                         }
                     }
                     if (now < nextRefresh) {
                         Date until = new Date(nextRefresh);
-                        LOG.info(""TGT refresh sleeping until: "" + until.toString());
+                        LOG.info(""TGT refresh sleeping until: {}"", until.toString());
                         try {
                             Thread.sleep(nextRefresh - now);
                         } catch (InterruptedException ie) {
@@ -184,10 +189,10 @@
                         }
                     }
                     else {
-                        LOG.error(""nextRefresh:"" + nextRefreshDate + "" is in the past: exiting refresh thread. Check""
+                        LOG.error(""nextRefresh:{} is in the past: exiting refresh thread. Check""
                                 + "" clock sync between this host and KDC - (KDC's clock is likely ahead of this host).""
                                 + "" Manual intervention will be required for this client to successfully authenticate.""
-                                + "" Exiting refresh thread."");
+                                + "" Exiting refresh thread."", nextRefreshDate);
                         return;
                     }
                     if (isUsingTicketCache) {
@@ -199,7 +204,7 @@
                         int retry = 1;
                         while (retry >= 0) {
                             try {
-                                LOG.debug(""running ticket cache refresh command: "" + cmd + "" "" + kinitArgs);
+                                LOG.debug(""running ticket cache refresh command: {} {}"", cmd, kinitArgs);
                                 Shell.execCommand(cmd, kinitArgs);
                                 break;
                             } catch (Exception e) {
@@ -213,8 +218,9 @@
                                         return;
                                     }
                                 } else {
-                                    LOG.warn(""Could not renew TGT due to problem running shell command: '"" + cmd
-                                            + "" "" + kinitArgs + ""'"" + ""; exception was:"" + e + "". Exiting refresh thread."",e);
+                                    Object[] logPayload = {cmd, kinitArgs, e.toString(), e};
+                                    LOG.warn(""Could not renew TGT due to problem running shell command: '{}""
+                                            + "" {}'; exception was:{}. Exiting refresh thread."", logPayload);
                                     return;
                                 }
                             }
@@ -237,7 +243,7 @@
                                         throw le;
                                     }
                                 } else {
-                                    LOG.error(""Could not refresh TGT for principal: "" + principal + ""."", le);
+                                    LOG.error(""Could not refresh TGT for principal: {}."", principal, le);
                                 }
                             }
                         }
@@ -264,7 +270,7 @@
             try {
                 t.join();
             } catch (InterruptedException e) {
-                LOG.warn(""error while waiting for Login thread to shutdown: "" + e);
+                LOG.warn(""error while waiting for Login thread to shutdown: "", e);
             }
         }
     }
@@ -295,8 +301,8 @@
     private long getRefreshTime(KerberosTicket tgt) {
         long start = tgt.getStartTime().getTime();
         long expires = tgt.getEndTime().getTime();
-        LOG.info(""TGT valid starting at:        "" + tgt.getStartTime().toString());
-        LOG.info(""TGT expires:                  "" + tgt.getEndTime().toString());
+        LOG.info(""TGT valid starting at:        {}"", tgt.getStartTime().toString());
+        LOG.info(""TGT expires:                  {}"", tgt.getEndTime().toString());
         long proposedRefresh = start + (long) ((expires - start) *
                 (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * rng.nextDouble())));
         if (proposedRefresh > expires) {
@@ -313,7 +319,7 @@
         for(KerberosTicket ticket: tickets) {
             KerberosPrincipal server = ticket.getServer();
             if (server.getName().equals(""krbtgt/"" + server.getRealm() + ""@"" + server.getRealm())) {
-                LOG.debug(""Found tgt "" + ticket + ""."");
+                LOG.debug(""Found tgt {}."", ticket);
                 return ticket;
             }
         }
@@ -323,9 +329,9 @@
     private boolean hasSufficientTimeElapsed() {
         long now = Time.currentElapsedTime();
         if (now - getLastLogin() < MIN_TIME_BEFORE_RELOGIN ) {
-            LOG.warn(""Not attempting to re-login since the last re-login was "" +
-                    ""attempted less than "" + (MIN_TIME_BEFORE_RELOGIN/1000) + "" seconds""+
-                    "" before."");
+            LOG.warn(""Not attempting to re-login since the last re-login was ""
+                    + ""attempted less than {} seconds before."",
+                    (MIN_TIME_BEFORE_RELOGIN / 1000));
             return false;
         }
         // register most recent relogin attempt
@@ -382,7 +388,7 @@
         if (!hasSufficientTimeElapsed()) {
             return;
         }
-        LOG.info(""Initiating logout for "" + principal);
+        LOG.info(""Initiating logout for {}"", principal);
         synchronized (Login.class) {
             //clear up the kerberos state. But the tokens are not cleared! As per
             //the Java kerberos login module code, only the kerberos credentials
@@ -391,7 +397,7 @@
             //login and also update the subject field of this instance to
             //have the new credentials (pass it to the LoginContext constructor)
             login = new LoginContext(loginContextName, getSubject());
-            LOG.info(""Initiating re-login for "" + principal);
+            LOG.info(""Initiating re-login for {}"", principal);
             login.login();
             setLogin(login);
         }
"
zookeeper,31b61db08a87b5939ea3fce5328d7ce69df536e6,ZOOKEEPER-1371: Remove dependency on log4j in the source code (Arshad Mohammad via rgs),2015.11.22 06:18:10,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/Shell.java b/src/java/main/org/apache/zookeeper/Shell.java
index e9e85b9..1e6763f 100644
--- a/src/java/main/org/apache/zookeeper/Shell.java
+++ b/src/java/main/org/apache/zookeeper/Shell.java
@@ -38,8 +38,10 @@
 import java.util.Timer;
 import java.util.TimerTask;
 import java.util.concurrent.atomic.AtomicBoolean;
-import org.apache.log4j.Logger;
+
 import org.apache.zookeeper.common.Time;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A base class for running a Unix command.
@@ -50,7 +52,7 @@
  */
 abstract public class Shell {
   
-  private static final Logger LOG = Logger.getLogger(Shell.class);
+    private static final Logger LOG = LoggerFactory.getLogger(Shell.class);
   
   /** a Unix command to get the current user's name */
   public final static String USER_NAME_COMMAND = ""whoami"";
"
zookeeper,31b61db08a87b5939ea3fce5328d7ce69df536e6,ZOOKEEPER-1371: Remove dependency on log4j in the source code (Arshad Mohammad via rgs),2015.11.22 06:18:10,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java b/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
index e4be47c..19b45ba 100644
--- a/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
+++ b/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
@@ -31,14 +31,15 @@
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
-import org.apache.log4j.Logger;
 import org.apache.zookeeper.common.X509Exception.SSLContextException;
 import org.apache.zookeeper.common.X509Util;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class FourLetterWordMain {
     //in milliseconds, socket should connect/read within this period otherwise SocketTimeoutException
     private static final int DEFAULT_SOCKET_TIMEOUT = 5000;
-    protected static final Logger LOG = Logger.getLogger(FourLetterWordMain.class);
+    protected static final Logger LOG = LoggerFactory.getLogger(FourLetterWordMain.class);
     /**
      * Send the 4letterword
      * @param host the destination host
@@ -81,7 +82,7 @@
      */
     public static String send4LetterWord(String host, int port, String cmd, boolean secure, int timeout)
             throws IOException, SSLContextException {
-        LOG.info(""connecting to "" + host + "" "" + port);
+        LOG.info(""connecting to {} {}"", host, port);
         Socket sock;
         InetSocketAddress hostaddress= host != null ? new InetSocketAddress(host, port) :
             new InetSocketAddress(InetAddress.getByName(null), port);
"
zookeeper,31b61db08a87b5939ea3fce5328d7ce69df536e6,ZOOKEEPER-1371: Remove dependency on log4j in the source code (Arshad Mohammad via rgs),2015.11.22 06:18:10,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java b/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
index 64e1942..1ce4faa 100644
--- a/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
+++ b/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
@@ -24,47 +24,96 @@
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.log4j.LogManager;
-import org.apache.log4j.Logger;
-import org.apache.log4j.jmx.HierarchyDynamicMBean;
-import org.apache.log4j.spi.LoggerRepository;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Shared utilities
  */
 public class ManagedUtil {
+    private static final Logger LOG = LoggerFactory.getLogger(ManagedUtil.class);
+
+    private static final boolean isLog4jJmxEnabled() {
+        boolean enabled = false;
+
+        try {
+            Class.forName(""org.apache.log4j.spi.LoggerRepository"");
+
+            if (Boolean.getBoolean(""zookeeper.jmx.log4j.disable"") == true) {
+                LOG.info(""Log4j found but jmx support is disabled."");
+            } else {
+                enabled = true;
+                LOG.info(""Log4j found with jmx enabled."");
+            }
+
+        } catch (ClassNotFoundException e) {
+            LOG.info(""Log4j not found."");
+        }
+
+        return enabled;
+    }
+
+
     /**
      * Register the log4j JMX mbeans. Set environment variable
      * ""zookeeper.jmx.log4j.disable"" to true to disable registration.
      * @see http://logging.apache.org/log4j/1.2/apidocs/index.html?org/apache/log4j/jmx/package-summary.html
      * @throws JMException if registration fails
      */
+    @SuppressWarnings(""rawtypes"")
     public static void registerLog4jMBeans() throws JMException {
-        if (Boolean.getBoolean(""zookeeper.jmx.log4j.disable"") == true) {
-            return;
-        }
-        
-        MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();
+        if (isLog4jJmxEnabled()) {
+            LOG.debug(""registerLog4jMBeans()"");
+            MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();
 
-        // Create and Register the top level Log4J MBean
-        HierarchyDynamicMBean hdm = new HierarchyDynamicMBean();
+            try {
+                // Create and Register the top level Log4J MBean
+                // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();
+                Object hdm = Class.forName(""org.apache.log4j.jmx.HierarchyDynamicMBean"").newInstance();
 
-        ObjectName mbo = new ObjectName(""log4j:hiearchy=default"");
-        mbs.registerMBean(hdm, mbo);
+                ObjectName mbo = new ObjectName(""log4j:hiearchy=default"");
+                mbs.registerMBean(hdm, mbo);
 
-        // Add the root logger to the Hierarchy MBean
-        Logger rootLogger = Logger.getRootLogger();
-        hdm.addLoggerMBean(rootLogger.getName());
+                // Add the root logger to the Hierarchy MBean
+                // org.apache.log4j.Logger rootLogger =
+                // org.apache.log4j.Logger.getRootLogger();
+                Object rootLogger = Class.forName(""org.apache.log4j.Logger"")
+                        .getMethod(""getRootLogger"", (Class<?>[]) null)
+                        .invoke(null, (Object[]) null);
 
-        // Get each logger from the Log4J Repository and add it to
-        // the Hierarchy MBean created above.
-        LoggerRepository r = LogManager.getLoggerRepository();
-        Enumeration enumer = r.getCurrentLoggers();
-        Logger logger = null;
+                // hdm.addLoggerMBean(rootLogger.getName());
+                Object rootLoggerName = rootLogger.getClass()
+                        .getMethod(""getName"", (Class<?>[]) null)
+                        .invoke(rootLogger, (Object[]) null);
+                hdm.getClass().getMethod(""addLoggerMBean"", String.class)
+                        .invoke(hdm, rootLoggerName);
 
-        while (enumer.hasMoreElements()) {
-           logger = (Logger) enumer.nextElement();
-           hdm.addLoggerMBean(logger.getName());
+                // Get each logger from the Log4J Repository and add it to the
+                // Hierarchy MBean created above.
+                // org.apache.log4j.spi.LoggerRepository r =
+                // org.apache.log4j.LogManager.getLoggerRepository();
+                Object r = Class.forName(""org.apache.log4j.LogManager"")
+                        .getMethod(""getLoggerRepository"", (Class<?>[]) null)
+                        .invoke(null, (Object[]) null);
+
+                // Enumeration enumer = r.getCurrentLoggers();
+                Enumeration enumer = (Enumeration) r.getClass()
+                        .getMethod(""getCurrentLoggers"", (Class<?>[]) null)
+                        .invoke(r, (Object[]) null);
+
+                while (enumer.hasMoreElements()) {
+                    Object logger = enumer.nextElement();
+                    // hdm.addLoggerMBean(logger.getName());
+                    Object loggerName = logger.getClass()
+                            .getMethod(""getName"", (Class<?>[]) null)
+                            .invoke(logger, (Object[]) null);
+                    hdm.getClass().getMethod(""addLoggerMBean"", String.class)
+                            .invoke(hdm, loggerName);
+                }
+            } catch (Exception e) {
+                LOG.error(""Problems while registering log4j jmx beans!"", e);
+                throw new JMException(e.toString());
+            }
         }
     }
 
"
zookeeper,df7e637a4d073c75270c32b107b7c1ceab29d148,ZOOKEEPER-1853: zkCli.sh can't issue a CREATE command containing spaces in the data (Ryan Lamore via rgs),2015.11.09 06:54:06,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index 7829b5d..80853e2 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -39,6 +39,9 @@
 import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.data.Stat;
 import java.util.StringTokenizer;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 import org.apache.commons.cli.ParseException;
 import org.apache.zookeeper.cli.AddAuthCommand;
 import org.apache.zookeeper.cli.CliCommand;
@@ -145,6 +148,8 @@
         private Map<String,String> options = new HashMap<String,String>();
         private List<String> cmdArgs = null;
         private String command = null;
+        public static final Pattern ARGS_PATTERN = Pattern.compile(""\\s*([^\""\']\\S*|\""[^\""]*\""|'[^']*')\\s*"");
+        public static final Pattern QUOTED_PATTERN = Pattern.compile(""^([\'\""])(.*)(\\1)$"");
 
         public MyCommandOptions() {
           options.put(""server"", ""localhost:2181"");
@@ -216,18 +221,22 @@
          * @return true if parsing succeeded.
          */
         public boolean parseCommand( String cmdstring ) {
-            StringTokenizer cmdTokens = new StringTokenizer(cmdstring, "" "");          
-            String[] args = new String[cmdTokens.countTokens()];
-            int tokenIndex = 0;
-            while (cmdTokens.hasMoreTokens()) {
-                args[tokenIndex] = cmdTokens.nextToken();
-                tokenIndex++;
+            Matcher matcher = ARGS_PATTERN.matcher(cmdstring);
+
+            List args = new LinkedList();
+            while (matcher.find()) {
+                String value = matcher.group(1);
+                if (QUOTED_PATTERN.matcher(value).matches()) {
+                    // Strip off the surrounding quotes
+                    value = value.substring(1, value.length() - 1);
+                }
+                args.add(value);
             }
-            if (args.length == 0){
+            if (args.isEmpty()){
                 return false;
             }
-            command = args[0];
-            cmdArgs = Arrays.asList(args);
+            command = (String)args.get(0);
+            cmdArgs = args;
             return true;
         }
     }
"
zookeeper,80803034aabb68229730b9d7429525bd460c3183,ZOOKEEPER-2227: stmk four-letter word fails execution at server while reading trace mask argument (Chris Nauroth via rgs),2015.11.09 06:36:17,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 9153ebb..337e44a 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -506,6 +506,7 @@
         final PrintWriter pwriter = new PrintWriter(
                 new BufferedWriter(new SendBufferWriter()));
         if (len == FourLetterCommands.setTraceMaskCmd) {
+            incomingBuffer = ByteBuffer.allocate(8);
             int rc = sock.read(incomingBuffer);
             if (rc < 0) {
                 throw new IOException(""Read error"");
"
zookeeper,80803034aabb68229730b9d7429525bd460c3183,ZOOKEEPER-2227: stmk four-letter word fails execution at server while reading trace mask argument (Chris Nauroth via rgs),2015.11.09 06:36:17,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index ada6063..e1c29d9 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -279,10 +279,9 @@
         final PrintWriter pwriter = new PrintWriter(
                 new BufferedWriter(new SendBufferWriter()));
        if (len == FourLetterCommands.setTraceMaskCmd) {
-            ByteBuffer mask = ByteBuffer.allocate(4);
+            ByteBuffer mask = ByteBuffer.allocate(8);
             message.readBytes(mask);
-
-            bb.flip();
+            mask.flip();
             long traceMask = mask.getLong();
             ZooTrace.setTextTraceLevel(traceMask);
             SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);
"
zookeeper,ee0daa7a8223dad09071893ef2e2c3a1aeb8eec9,ZOOKEEPER-2211: PurgeTxnLog does not correctly purge when snapshots and logs are at different locations (Arshad Mohammad via rgs),2015.11.09 06:21:38,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
index 244ea1b..25b949a 100644
--- a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
@@ -38,12 +38,16 @@
  * and the corresponding logs.
  */
 public class PurgeTxnLog {
+
+    private static final String COUNT_ERR_MSG = ""count should be greater than or equal to 3"";
+
     static void printUsage(){
+        System.out.println(""Usage:"");
         System.out.println(""PurgeTxnLog dataLogDir [snapDir] -n count"");
         System.out.println(""\tdataLogDir -- path to the txn log directory"");
         System.out.println(""\tsnapDir -- path to the snapshot directory"");
-        System.out.println(""\tcount -- the number of old snaps/logs you want to keep"");
-        System.exit(1);
+        System.out.println(""\tcount -- the number of old snaps/logs you want "" +
+            ""to keep, value should be greater than or equal to 3"");
     }
 
     private static final String PREFIX_SNAPSHOT = ""snapshot"";
@@ -62,7 +66,7 @@
      */
     public static void purge(File dataDir, File snapDir, int num) throws IOException {
         if (num < 3) {
-            throw new IllegalArgumentException(""count should be greater than 3"");
+            throw new IllegalArgumentException(COUNT_ERR_MSG);
         }
 
         FileTxnSnapLog txnLog = new FileTxnSnapLog(dataDir, snapDir);
@@ -115,22 +119,74 @@
     }
     
     /**
-     * @param args PurgeTxnLog dataLogDir
-     *     dataLogDir -- txn log directory
-     *     -n num (number of snapshots to keep)
+     * @param args dataLogDir [snapDir] -n count
+     * dataLogDir -- path to the txn log directory
+     * snapDir -- path to the snapshot directory
+     * count -- the number of old snaps/logs you want to keep, value should be greater than or equal to 3<br>
      */
     public static void main(String[] args) throws IOException {
-        if(args.length<3 || args.length>4)
-            printUsage();
-        int i = 0;
-        File dataDir=new File(args[0]);
-        File snapDir=dataDir;
-        if(args.length==4){
-            i++;
-            snapDir=new File(args[i]);
+        if (args.length < 3 || args.length > 4) {
+            printUsageThenExit();
         }
-        i++; i++;
-        int num = Integer.parseInt(args[i]);
+        File dataDir = validateAndGetFile(args[0]);
+        File snapDir = dataDir;
+        int num = -1;
+        String countOption = """";
+        if (args.length == 3) {
+            countOption = args[1];
+            num = validateAndGetCount(args[2]);
+        } else {
+            snapDir = validateAndGetFile(args[1]);
+            countOption = args[2];
+            num = validateAndGetCount(args[3]);
+        }
+        if (!""-n"".equals(countOption)) {
+            printUsageThenExit();
+        }
         purge(dataDir, snapDir, num);
     }
+
+    /**
+     * validates file existence and returns the file
+     *
+     * @param path
+     * @return File
+     */
+    private static File validateAndGetFile(String path) {
+        File file = new File(path);
+        if (!file.exists()) {
+            System.err.println(""Path '"" + file.getAbsolutePath()
+                    + ""' does not exist. "");
+            printUsageThenExit();
+        }
+        return file;
+    }
+
+    /**
+     * Returns integer if parsed successfully and it is valid otherwise prints
+     * error and usage and then exits
+     *
+     * @param number
+     * @return
+     */
+    private static int validateAndGetCount(String number) {
+        int result = 0;
+        try {
+            result = Integer.parseInt(number);
+            if (result < 3) {
+                System.err.println(COUNT_ERR_MSG);
+                printUsageThenExit();
+            }
+        } catch (NumberFormatException e) {
+            System.err
+                    .println(""'"" + number + ""' can not be parsed to integer."");
+            printUsageThenExit();
+        }
+        return result;
+    }
+
+    private static void printUsageThenExit() {
+        printUsage();
+        System.exit(1);
+    }
 }
"
zookeeper,495f7f99d46a4baf4896adac8afe5b9eba158db1,ZOOKEEPER-2142: JMX ObjectName is incorrect for observers (Edward Ribeiro via michim),2015.11.01 07:18:39,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/ObserverBean.java b/src/java/main/org/apache/zookeeper/server/ObserverBean.java
index 4e0e82a..72d724e 100644
--- a/src/java/main/org/apache/zookeeper/server/ObserverBean.java
+++ b/src/java/main/org/apache/zookeeper/server/ObserverBean.java
@@ -34,6 +34,10 @@
         this.observer = observer;
     }
 
+    public String getName() {
+        return ""Observer"";
+    }
+
     public int getPendingRevalidationCount() {
        return this.observer.getPendingRevalidationsCount(); 
     }
"
zookeeper,08cc9187d9eb327b2a71bc9a8c62636815dfe9e5,ZOOKEEPER-1460: IPv6 literal address not supported for quorum members (Joseph Walton via cnauroth),2015.10.19 02:00:41,Chris Nauroth,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index ae7aa68..142896b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -173,17 +173,38 @@
                type = LearnerType.PARTICIPANT;
             } else {
                throw new ConfigException(""Unrecognised peertype: "" + s);
-            }   
-        }       
+            }
+        }
 
-        private static final String wrongFormat = "" does not have the form server_cofig or server_config;client_config""+
+        private static String[] splitWithLeadingHostname(String s)
+                throws ConfigException
+        {
+            /* Does it start with an IPv6 literal? */
+            if (s.startsWith(""["")) {
+                int i = s.indexOf(""]:"");
+                if (i < 0) {
+                    throw new ConfigException(s + "" starts with '[' but has no matching ']:'"");
+                }
+
+                String[] sa = s.substring(i + 2).split("":"");
+                String[] nsa = new String[sa.length + 1];
+                nsa[0] = s.substring(1, i);
+                System.arraycopy(sa, 0, nsa, 1, sa.length);
+
+                return nsa;
+            } else {
+                return s.split("":"");
+            }
+        }
+
+        private static final String wrongFormat = "" does not have the form server_config or server_config;client_config""+
         "" where server_config is host:port:port or host:port:port:type and client_config is port or host:port"";
-        
+
         public QuorumServer(long sid, String addressStr) throws ConfigException {
             // LOG.warn(""sid = "" + sid + "" addressStr = "" + addressStr);
             this.id = sid;
             String serverClientParts[] = addressStr.split("";"");
-            String serverParts[] = serverClientParts[0].split("":"");
+            String serverParts[] = splitWithLeadingHostname(serverClientParts[0]);
             if ((serverClientParts.length > 2) || (serverParts.length < 3)
                     || (serverParts.length > 4)) {
                 throw new ConfigException(addressStr + wrongFormat);
@@ -191,7 +212,7 @@
 
             if (serverClientParts.length == 2) {
                 //LOG.warn(""ClientParts: "" + serverClientParts[1]);
-                String clientParts[] = serverClientParts[1].split("":"");
+                String clientParts[] = splitWithLeadingHostname(serverClientParts[1]);
                 if (clientParts.length > 2) {
                     throw new ConfigException(addressStr + wrongFormat);
                 }
@@ -252,11 +273,21 @@
             this.myAddrs = excludedSpecialAddresses(this.myAddrs);
         }
 
+        private static String delimitedHostString(InetSocketAddress addr)
+        {
+            String host = addr.getHostString();
+            if (host.contains("":"")) {
+                return ""["" + host + ""]"";
+            } else {
+                return host;
+            }
+        }
+
         public String toString(){
-            StringWriter sw = new StringWriter();            
+            StringWriter sw = new StringWriter();
             //addr should never be null, but just to make sure
-            if (addr !=null) { 
-                sw.append(addr.getHostString());
+            if (addr !=null) {
+                sw.append(delimitedHostString(addr));
                 sw.append("":"");
                 sw.append(String.valueOf(addr.getPort()));
             }
@@ -268,7 +299,7 @@
             else if (type == LearnerType.PARTICIPANT) sw.append("":participant"");            
             if (clientAddr!=null){
                 sw.append("";"");
-                sw.append(clientAddr.getHostString());
+                sw.append(delimitedHostString(clientAddr));
                 sw.append("":"");
                 sw.append(String.valueOf(clientAddr.getPort()));
             }
"
zookeeper,b2f66fae04438602ee9b0092ac0c6657177e10e1,ZOOKEEPER-2244: On Windows zookeeper fails to restart (Arshad Mohammad via rakeshr),2015.09.29 10:56:44,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index aec2899..a68cd2e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -43,6 +43,7 @@
 import org.apache.zookeeper.common.AtomicFileWritingIdiom;
 import org.apache.zookeeper.common.AtomicFileWritingIdiom.OutputStreamStatement;
 import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;
+import org.apache.zookeeper.common.PathUtils;
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
 import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
@@ -467,8 +468,9 @@
                 }
 
                 // updates the dynamic file pointer
+                String dynamicConfigFilePath = PathUtils.normalizeFileSystemPath(dynamicFile.getCanonicalPath());
                 out.write(""dynamicConfigFile=""
-                         .concat(dynamicFile.getCanonicalPath())
+                         .concat(dynamicConfigFilePath)
                          .concat(""\n""));
             }
         });
"
zookeeper,1ea6879ba784aacc1cd0b4a91967f64f51d7aae9,ZOOKEEPER-2279: QuorumPeer loadDataBase() error message is incorrect(Arshad Mohammad via rakeshr),2015.09.25 15:33:36,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index fc82b10..ae7aa68 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -762,7 +762,7 @@
             	writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);
             }
             if (acceptedEpoch < currentEpoch) {
-                throw new IOException(""The current epoch, "" + ZxidUtils.zxidToString(currentEpoch) + "" is less than the accepted epoch, "" + ZxidUtils.zxidToString(acceptedEpoch));
+                throw new IOException(""The accepted epoch, "" + ZxidUtils.zxidToString(acceptedEpoch) + "" is less than the current epoch, "" + ZxidUtils.zxidToString(currentEpoch));
             }
         } catch(IOException ie) {
             LOG.error(""Unable to load database on disk"", ie);
"
zookeeper,239556e2344f75626b5c6c3f656508e797093011,ZOOKEEPER-2269: NullPointerException in RemotePeerBean (Arshad Mohammad via rgs),2015.09.10 13:35:52,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java b/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java
index 15d4cff..dcf5684 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java
@@ -51,7 +51,11 @@
     }
 
     public String getClientAddress() {
-        return peer.clientAddr.getHostString() + "":"" + peer.clientAddr.getPort();
+        if (null == peer.clientAddr) {
+            return """";
+        }
+        return peer.clientAddr.getHostString() + "":""
+                + peer.clientAddr.getPort();
     }
 
     public String getLearnerType() {
"
zookeeper,cfc9f24934f920ad45b8c522f0bd05220e5aaf74,ZOOKEEPER-2264: Wrong error message when secureClientPortAddress is configured but secureClientPort is not configured (Arshad Mohammad via rakeshr),2015.09.07 03:02:42,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index db61c77..aec2899 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -304,7 +304,7 @@
 
         if (clientPort == 0) {
             LOG.info(""clientPort is not set"");
-            if (this.clientPortAddress != null) {
+            if (clientPortAddress != null) {
                 throw new IllegalArgumentException(""clientPortAddress is set but clientPort is not set"");
             }
         } else if (clientPortAddress != null) {
@@ -318,8 +318,8 @@
 
         if (secureClientPort == 0) {
             LOG.info(""secureClientPort is not set"");
-            if (this.secureClientPortAddress != null) {
-                throw new IllegalArgumentException(""clientPortAddress is set but clientPort is not set"");
+            if (secureClientPortAddress != null) {
+                throw new IllegalArgumentException(""secureClientPortAddress is set but secureClientPort is not set"");
             }
         } else if (secureClientPortAddress != null) {
             this.secureClientPortAddress = new InetSocketAddress(
"
zookeeper,d95b521be0d275fcf3495ae31ebff94a469bb26d,ZOOKEEPER-2239: JMX State from LocalPeerBean incorrect (Kevin Lee via rgs),2015.08.06 05:16:29,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java b/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
index 8c7a168..5846bd6 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
@@ -66,7 +66,7 @@
     }
     
     public String getState() {
-        return peer.getState().toString();
+        return peer.getServerState();
     }
     
     public String getQuorumAddress() {
"
zookeeper,9a9d587861606884cca5b4a532078f925b50e40c,ZOOKEEPER-2224: Four letter command hangs when network is slow (Arshad Mohammad via rakeshr),2015.07.05 13:05:33,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java b/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
index 87cc0cf..e4be47c 100644
--- a/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
+++ b/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
@@ -22,7 +22,10 @@
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.net.SocketTimeoutException;
 
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
@@ -33,6 +36,8 @@
 import org.apache.zookeeper.common.X509Util;
 
 public class FourLetterWordMain {
+    //in milliseconds, socket should connect/read within this period otherwise SocketTimeoutException
+    private static final int DEFAULT_SOCKET_TIMEOUT = 5000;
     protected static final Logger LOG = Logger.getLogger(FourLetterWordMain.class);
     /**
      * Send the 4letterword
@@ -45,7 +50,7 @@
      */
     public static String send4LetterWord(String host, int port, String cmd)
             throws IOException, SSLContextException {
-        return send4LetterWord(host, port, cmd, false);
+        return send4LetterWord(host, port, cmd, false, DEFAULT_SOCKET_TIMEOUT);
     }
 
     /**
@@ -60,20 +65,39 @@
      */
     public static String send4LetterWord(String host, int port, String cmd, boolean secure)
             throws IOException, SSLContextException {
+        return send4LetterWord(host, port, cmd, secure, DEFAULT_SOCKET_TIMEOUT);
+    }
+
+    /**
+     * Send the 4letterword
+     * @param host the destination host
+     * @param port the destination port
+     * @param cmd the 4letterword
+     * @param secure whether to use SSL
+     * @param timeout in milliseconds, maximum time to wait while connecting/reading data
+     * @return server response
+     * @throws java.io.IOException
+     * @throws SSLContextException
+     */
+    public static String send4LetterWord(String host, int port, String cmd, boolean secure, int timeout)
+            throws IOException, SSLContextException {
         LOG.info(""connecting to "" + host + "" "" + port);
         Socket sock;
-
+        InetSocketAddress hostaddress= host != null ? new InetSocketAddress(host, port) :
+            new InetSocketAddress(InetAddress.getByName(null), port);
         if (secure) {
             LOG.info(""using secure socket"");
             SSLContext sslContext = X509Util.createSSLContext();
             SSLSocketFactory socketFactory = sslContext.getSocketFactory();
-            SSLSocket sslSock = (SSLSocket) socketFactory.createSocket(host, port);
+            SSLSocket sslSock = (SSLSocket) socketFactory.createSocket();
+            sslSock.connect(hostaddress, timeout);
             sslSock.startHandshake();
             sock = sslSock;
         } else {
-            sock = new Socket(host, port);
+            sock = new Socket();
+            sock.connect(hostaddress, timeout);
         }
-
+        sock.setSoTimeout(timeout);
         BufferedReader reader = null;
         try {
             OutputStream outstream = sock.getOutputStream();
@@ -95,6 +119,8 @@
                 sb.append(line + ""\n"");
             }
             return sb.toString();
+        } catch (SocketTimeoutException e) {
+            throw new IOException(""Exception while executing four letter word: "" + cmd, e);
         } finally {
             sock.close();
             if (reader != null) {
"
zookeeper,a61b4e1b528cb4c70627e9f9295b34bb05a79303,ZOOKEEPER-2221: Zookeeper JettyAdminServer server should start on configured IP (Surendra Singh Lilhore via rgs),2015.07.01 03:50:11,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/admin/JettyAdminServer.java b/src/java/main/org/apache/zookeeper/server/admin/JettyAdminServer.java
index 4691558..f911484 100644
--- a/src/java/main/org/apache/zookeeper/server/admin/JettyAdminServer.java
+++ b/src/java/main/org/apache/zookeeper/server/admin/JettyAdminServer.java
@@ -32,6 +32,7 @@
 
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.mortbay.jetty.Server;
+import org.mortbay.jetty.nio.SelectChannelConnector;
 import org.mortbay.jetty.servlet.Context;
 import org.mortbay.jetty.servlet.ServletHolder;
 import org.slf4j.Logger;
@@ -54,26 +55,36 @@
     static final Logger LOG = LoggerFactory.getLogger(JettyAdminServer.class);
 
     public static final int DEFAULT_PORT = 8080;
+    private static final String DEFAULT_ADDRESS = ""0.0.0.0"";
     public static final String DEFAULT_COMMAND_URL = ""/commands"";
 
     private final Server server;
     private ZooKeeperServer zkServer;
     private final int port;
+    private String address;
     private final String commandUrl;
 
     public JettyAdminServer() throws AdminServerException {
-        this(Integer.getInteger(""zookeeper.admin.serverPort"", DEFAULT_PORT),
-             System.getProperty(""zookeeper.admin.commandURL"", DEFAULT_COMMAND_URL));
+        this(System.getProperty(""zookeeper.admin.serverAddress"",
+                DEFAULT_ADDRESS), Integer.getInteger(
+                ""zookeeper.admin.serverPort"", DEFAULT_PORT), System
+                .getProperty(""zookeeper.admin.commandURL"", DEFAULT_COMMAND_URL));
     }
 
-    public JettyAdminServer(int port, String commandUrl) {
+    public JettyAdminServer(String address, int port, String commandUrl) {
         this.port = port;
         this.commandUrl = commandUrl;
+        this.address = address;
 
-        server = new Server(port);
+        server = new Server();
+        SelectChannelConnector connector = new SelectChannelConnector();
+        connector.setHost(address);
+        connector.setPort(port);
+        server.addConnector(connector);
         Context context = new Context(server, ""/"");
         server.setHandler(context);
-        context.addServlet(new ServletHolder(new CommandServlet()), commandUrl + ""/*"");
+        context.addServlet(new ServletHolder(new CommandServlet()), commandUrl
+                + ""/*"");
     }
 
     /**
@@ -86,12 +97,13 @@
         } catch (Exception e) {
             // Server.start() only throws Exception, so let's at least wrap it
             // in an identifiable subclass
-            throw new AdminServerException(
-                    String.format(""Problem starting AdminServer on port %d, command URL %s"",
-                                  port, commandUrl), e);
+            throw new AdminServerException(String.format(
+                    ""Problem starting AdminServer on address %s,""
+                            + "" port %d and command URL %s"", address, port,
+                    commandUrl), e);
         }
-        LOG.info(String.format(""Started AdminServer on port %d, command URL %s"",
-                               port, commandUrl));
+        LOG.info(String.format(""Started AdminServer on address %s, port %d""
+                + "" and command URL %s"", address, port, commandUrl));
     }
 
     /**
@@ -106,9 +118,10 @@
         try {
             server.stop();
         } catch (Exception e) {
-            throw new AdminServerException(
-                    String.format(""Problem stopping AdminServer on port %d, command URL %s"",
-                                  port, commandUrl), e);
+            throw new AdminServerException(String.format(
+                    ""Problem stopping AdminServer on address %s,""
+                            + "" port %d and command URL %s"", address, port, commandUrl),
+                    e);
         }
     }
 
"
zookeeper,c520e1e826d88955db7637a33cd4f20c20c0bd7a,ZOOKEEPER-2193: reconfig command completes even if parameter is wrong obviously (Yasuhito Fukuda via rgs),2015.06.27 09:03:30,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index eb045de..4d7005b 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -551,6 +551,15 @@
                                if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {
                                    throw new KeeperException.BadArgumentsException(""Wrong format of server string - each server should have 3 ports specified""); 	   
                                }
+
+                               // check duplication of addresses and ports
+                               for (QuorumServer nqs: nextServers.values()) {
+                                   if (qs.id == nqs.id) {
+                                       continue;
+                                   }
+                                   qs.checkAddressDuplicate(nqs);
+                               }
+
                                nextServers.remove(qs.id);
                                nextServers.put(Long.valueOf(qs.id), qs);
                            }  
"
zookeeper,c520e1e826d88955db7637a33cd4f20c20c0bd7a,ZOOKEEPER-2193: reconfig command completes even if parameter is wrong obviously (Yasuhito Fukuda via rgs),2015.06.27 09:03:30,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index f15f831..fc82b10 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -43,6 +43,7 @@
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.apache.zookeeper.KeeperException.BadArgumentsException;
 import org.apache.zookeeper.common.AtomicFileWritingIdiom;
 import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;
 import org.apache.zookeeper.common.Time;
@@ -119,29 +120,20 @@
         
         public LearnerType type = LearnerType.PARTICIPANT;
         
-        
+        private List<InetSocketAddress> myAddrs;
+
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = clientAddr;
+            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);
         }
 
-        
         public QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = electionAddr;
-            this.clientAddr = null;
+            this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-            this.electionAddr = null;
-            this.clientAddr = null;
+            this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);
         }
 
         /**
@@ -228,26 +220,37 @@
             } catch (NumberFormatException e) {
                 throw new ConfigException(""Address unresolved: "" + serverParts[0] + "":"" + serverParts[2]);
             }
-            if (serverParts.length == 4) setType(serverParts[3]);
+
+            if (serverParts.length == 4) {
+                setType(serverParts[3]);
+            }
+
+            setMyAddrs();
         }
 
         public QuorumServer(long id, InetSocketAddress addr,
                     InetSocketAddress electionAddr, LearnerType type) {
+            this(id, addr, electionAddr, (InetSocketAddress)null, type);
+        }
+
+        public QuorumServer(long id, InetSocketAddress addr,
+                InetSocketAddress electionAddr, InetSocketAddress clientAddr, LearnerType type) {
             this.id = id;
             this.addr = addr;
             this.electionAddr = electionAddr;
             this.type = type;
-            this.clientAddr = null;
+            this.clientAddr = clientAddr;
+
+            setMyAddrs();
         }
 
-    public QuorumServer(long id, InetSocketAddress addr,
-                InetSocketAddress electionAddr, InetSocketAddress clientAddr, LearnerType type) {
-        this.id = id;
-        this.addr = addr;
-        this.electionAddr = electionAddr;
-        this.type = type;
-        this.clientAddr = clientAddr;
-    }
+        private void setMyAddrs() {
+            this.myAddrs = new ArrayList<InetSocketAddress>();
+            this.myAddrs.add(this.addr);
+            this.myAddrs.add(this.clientAddr);
+            this.myAddrs.add(this.electionAddr);
+            this.myAddrs = excludedSpecialAddresses(this.myAddrs);
+        }
 
         public String toString(){
             StringWriter sw = new StringWriter();            
@@ -293,6 +296,44 @@
             if (!checkAddressesEqual(clientAddr, qs.clientAddr)) return false;                    
             return true;
         }
+
+        public void checkAddressDuplicate(QuorumServer s) throws BadArgumentsException {
+            List<InetSocketAddress> otherAddrs = new ArrayList<InetSocketAddress>();
+            otherAddrs.add(s.addr);
+            otherAddrs.add(s.clientAddr);
+            otherAddrs.add(s.electionAddr);
+            otherAddrs = excludedSpecialAddresses(otherAddrs);
+
+            for (InetSocketAddress my: this.myAddrs) {
+
+                for (InetSocketAddress other: otherAddrs) {
+                    if (my.equals(other)) {
+                        String error = String.format(""%s of server.%d conflicts %s of server.%d"", my, this.id, other, s.id);
+                        throw new BadArgumentsException(error);
+                    }
+                }
+            }
+        }
+
+        private List<InetSocketAddress> excludedSpecialAddresses(List<InetSocketAddress> addrs) {
+            List<InetSocketAddress> included = new ArrayList<InetSocketAddress>();
+            InetAddress wcAddr = new InetSocketAddress(0).getAddress();
+
+            for (InetSocketAddress addr : addrs) {
+                if (addr == null) {
+                    continue;
+                }
+                InetAddress inetaddr = addr.getAddress();
+
+                if (inetaddr == null ||
+                    inetaddr.equals(wcAddr) || // wildCard address(0.0.0.0)
+                    inetaddr.isLoopbackAddress()) { // loopback address(localhost/127.0.0.1)
+                    continue;
+                }
+                included.add(addr);
+            }
+            return included;
+        }
     }
 
 
"
zookeeper,6a2f5e3e76f85e7aeba72f94397315bec96ea4f1,ZOOKEEPER-2212: distributed race condition related to QV version (Akihiro Suda via rgs),2015.06.16 08:05:25,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index e040d3a..5b80a75 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -294,14 +294,19 @@
                                         LOG.info(""{} Received version: {} my version: {}"", self.getId(),
                                                 Long.toHexString(rqv.getVersion()),
                                                 Long.toHexString(self.getQuorumVerifier().getVersion()));
-                                        self.processReconfig(rqv, null, null, false);
-                                        if (!rqv.equals(curQV)) {
-                                            LOG.info(""restarting leader election"");
-                                            self.shuttingDownLE = true;
-                                            self.getElectionAlg().shutdown();
-                                            
-                                            break;
-                                       }
+                                        if (self.getPeerState() == ServerState.LOOKING) {
+                                            LOG.debug(""Invoking processReconfig(), state: {}"", self.getServerState());
+                                            self.processReconfig(rqv, null, null, false);
+                                            if (!rqv.equals(curQV)) {
+                                                LOG.info(""restarting leader election"");
+                                                self.shuttingDownLE = true;
+                                                self.getElectionAlg().shutdown();
+
+                                                break;
+                                            }
+                                        } else {
+                                            LOG.debug(""Skip processReconfig(), state: {}"", self.getServerState());
+                                        }
                                     }
                                 } catch (IOException e) {
                                     LOG.error(""Something went wrong while processing config received from {}"", response.sid);
"
zookeeper,2d94a794d33a27567b37b772c08316277ee4e547,ZOOKEEPER-706: Large numbers of watches can cause session re-establishment to fail (Chris Thunes via rgs),2015.06.13 09:42:49,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 6532cf6..ccb6007 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -28,6 +28,7 @@
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.util.HashSet;
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
@@ -99,6 +100,16 @@
     private static final String ZK_SASL_CLIENT_USERNAME =
         ""zookeeper.sasl.client.username"";
 
+    /* ZOOKEEPER-706: If a session has a large number of watches set then
+     * attempting to re-establish those watches after a connection loss may
+     * fail due to the SetWatches request exceeding the server's configured
+     * jute.maxBuffer value. To avoid this we instead split the watch
+     * re-establishement across multiple SetWatches calls. This constant
+     * controls the size of each call. It is set to 128kB to be conservative
+     * with respect to the server's 1MB default for jute.maxBuffer.
+     */
+    private static final int SET_WATCHES_MAX_LENGTH = 128 * 1024;
+
     /** This controls whether automatic watch resetting is enabled.
      * Clients automatically reset watches during session reconnect, this
      * option allows the client to turn off this behavior by setting
@@ -983,15 +994,45 @@
                 List<String> childWatches = zooKeeper.getChildWatches();
                 if (!dataWatches.isEmpty()
                         || !existWatches.isEmpty() || !childWatches.isEmpty()) {
-                    SetWatches sw = new SetWatches(lastZxid,
-                            prependChroot(dataWatches),
-                            prependChroot(existWatches),
-                            prependChroot(childWatches));
-                    RequestHeader h = new RequestHeader();
-                    h.setType(ZooDefs.OpCode.setWatches);
-                    h.setXid(-8);
-                    Packet packet = new Packet(h, new ReplyHeader(), sw, null, null);
-                    outgoingQueue.addFirst(packet);
+                    Iterator<String> dataWatchesIter = prependChroot(dataWatches).iterator();
+                    Iterator<String> existWatchesIter = prependChroot(existWatches).iterator();
+                    Iterator<String> childWatchesIter = prependChroot(childWatches).iterator();
+                    long setWatchesLastZxid = lastZxid;
+
+                    while (dataWatchesIter.hasNext()
+                           || existWatchesIter.hasNext() || childWatchesIter.hasNext()) {
+                        List<String> dataWatchesBatch = new ArrayList<String>();
+                        List<String> existWatchesBatch = new ArrayList<String>();
+                        List<String> childWatchesBatch = new ArrayList<String>();
+                        int batchLength = 0;
+
+                        // Note, we may exceed our max length by a bit when we add the last
+                        // watch in the batch. This isn't ideal, but it makes the code simpler.
+                        while (batchLength < SET_WATCHES_MAX_LENGTH) {
+                            final String watch;
+                            if (dataWatchesIter.hasNext()) {
+                                watch = dataWatchesIter.next();
+                                dataWatchesBatch.add(watch);
+                            } else if (existWatchesIter.hasNext()) {
+                                watch = existWatchesIter.next();
+                                existWatchesBatch.add(watch);
+                            } else if (childWatchesIter.hasNext()) {
+                                watch = childWatchesIter.next();
+                                childWatchesBatch.add(watch);
+                            } else {
+                                break;
+                            }
+                            batchLength += watch.length();
+                        }
+
+                        SetWatches sw = new SetWatches(setWatchesLastZxid,
+                                                       dataWatchesBatch,
+                                                       existWatchesBatch,
+                                                       childWatchesBatch);
+                        RequestHeader header = new RequestHeader(-8, OpCode.setWatches);
+                        Packet packet = new Packet(header, new ReplyHeader(), sw, null, null);
+                        outgoingQueue.addFirst(packet);
+                    }
                 }
             }
 
"
zookeeper,9bee4674c015a71785daeb7a6da93676a3450699,ZOOKEEPER-2213: Empty path in Set crashes server and prevents restart (Hongchao Deng via rgs),2015.06.12 03:09:19,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 73fa4e6..eb045de 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -384,13 +384,7 @@
                 if (createMode.isSequential()) {
                     path = path + String.format(Locale.ENGLISH, ""%010d"", parentCVersion);
                 }
-                try {
-                    PathUtils.validatePath(path);
-                } catch(IllegalArgumentException ie) {
-                    LOG.info(""Invalid path "" + path + "" with session 0x"" +
-                            Long.toHexString(request.sessionId));
-                    throw new KeeperException.BadArgumentsException(path);
-                }
+                validatePath(path, request.sessionId);
                 try {
                     if (getRecordForPath(path) != null) {
                         throw new KeeperException.NodeExistsException(path);
@@ -465,6 +459,7 @@
                 if(deserialize)
                     ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);
                 path = setDataRequest.getPath();
+                validatePath(path, request.sessionId);
                 nodeRecord = getRecordForPath(path);
                 checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);
                 int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);
@@ -595,6 +590,7 @@
                 if(deserialize)
                     ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);
                 path = setAclRequest.getPath();
+                validatePath(path, request.sessionId);
                 List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());
                 nodeRecord = getRecordForPath(path);
                 checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo);
@@ -650,6 +646,7 @@
                 if(deserialize)
                     ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);
                 path = checkVersionRequest.getPath();
+                validatePath(path, request.sessionId);
                 nodeRecord = getRecordForPath(path);
                 checkACL(zks, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo);
                 request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(),
@@ -661,6 +658,16 @@
         }
     }
 
+    private void validatePath(String path, long sessionId) throws BadArgumentsException {
+        try {
+            PathUtils.validatePath(path);
+        } catch(IllegalArgumentException ie) {
+            LOG.info(""Invalid path {} with session 0x{}, reason: {}"",
+                    path, Long.toHexString(sessionId), ie.getMessage());
+            throw new BadArgumentsException(path);
+        }
+    }
+
     private String getParentPathAndValidate(String path)
             throws BadArgumentsException {
         int lastSlash = path.lastIndexOf('/');
"
zookeeper,71dd96a232cb590e90601fde4bfafcd4eef1f82a,ZOOKEEPER-2201: Network issues can cause cluster to hang due to near-deadlock (Donny Nadolny via rgs),2015.06.06 10:48:52,Raúl Gutiérrez Segalés,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 9120458..d828258 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -1174,14 +1174,20 @@
             return;
         }
         String children[] = null;
+        DataNode nodeCopy;
         synchronized (node) {
-            oa.writeString(pathString, ""path"");
-            oa.writeRecord(node, ""node"");
+            StatPersisted statCopy = new StatPersisted();
+            copyStatPersisted(node.stat, statCopy);
+            //we do not need to make a copy of node.data because the contents
+            //are never changed
+            nodeCopy = new DataNode(node.data, node.acl, statCopy);
             Set<String> childs = node.getChildren();
             if (childs != null) {
                 children = childs.toArray(new String[childs.size()]);
             }
         }
+        oa.writeString(pathString, ""path"");
+        oa.writeRecord(nodeCopy, ""node"");
         path.append('/');
         int off = path.length();
         if (children != null) {
"
zookeeper,3a7a240ef7381edf15925045e9f94408177e51cd,"ZOOKEEPER-2187: remove duplicated code between CreateRequest{,2} (Raul Gutierrez Segales via hdeng)",2015.05.30 02:45:53,Hongchao Deng,"diff --git a/src/java/main/org/apache/zookeeper/MultiTransactionRecord.java b/src/java/main/org/apache/zookeeper/MultiTransactionRecord.java
index ea913b4..ca7dd98 100644
--- a/src/java/main/org/apache/zookeeper/MultiTransactionRecord.java
+++ b/src/java/main/org/apache/zookeeper/MultiTransactionRecord.java
@@ -66,18 +66,10 @@
             MultiHeader h = new MultiHeader(op.getType(), false, -1);
             h.serialize(archive, tag);
             switch (op.getType()) {
-               case ZooDefs.OpCode.create:
-                    op.toRequestRecord().serialize(archive, tag);
-                    break;
-               case ZooDefs.OpCode.create2:
-                   op.toRequestRecord().serialize(archive, tag);
-                   break;
+                case ZooDefs.OpCode.create:
+                case ZooDefs.OpCode.create2:
                 case ZooDefs.OpCode.delete:
-                    op.toRequestRecord().serialize(archive, tag);
-                    break;
                 case ZooDefs.OpCode.setData:
-                    op.toRequestRecord().serialize(archive, tag);
-                    break;
                 case ZooDefs.OpCode.check:
                     op.toRequestRecord().serialize(archive, tag);
                     break;
@@ -98,15 +90,11 @@
         while (!h.getDone()) {
             switch (h.getType()) {
                case ZooDefs.OpCode.create:
+               case ZooDefs.OpCode.create2:
                     CreateRequest cr = new CreateRequest();
                     cr.deserialize(archive, tag);
                     add(Op.create(cr.getPath(), cr.getData(), cr.getAcl(), cr.getFlags()));
                     break;
-               case ZooDefs.OpCode.create2:
-                   Create2Request cr2 = new Create2Request();
-                   cr2.deserialize(archive, tag);
-                   add(Op.create(cr2.getPath(), cr2.getData(), cr2.getAcl(), cr2.getFlags()));
-                   break;
                 case ZooDefs.OpCode.delete:
                     DeleteRequest dr = new DeleteRequest();
                     dr.deserialize(archive, tag);
"
zookeeper,3a7a240ef7381edf15925045e9f94408177e51cd,"ZOOKEEPER-2187: remove duplicated code between CreateRequest{,2} (Raul Gutierrez Segales via hdeng)",2015.05.30 02:45:53,Hongchao Deng,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index dd8ecf4..fdee4e6 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -53,7 +53,6 @@
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.proto.CheckWatchesRequest;
-import org.apache.zookeeper.proto.Create2Request;
 import org.apache.zookeeper.proto.Create2Response;
 import org.apache.zookeeper.proto.CreateRequest;
 import org.apache.zookeeper.proto.CreateResponse;
@@ -1284,7 +1283,7 @@
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.create2);
-        Create2Request request = new Create2Request();
+        CreateRequest request = new CreateRequest();
         Create2Response response = new Create2Response();
         request.setData(data);
         request.setFlags(createMode.toFlag());
@@ -1349,7 +1348,7 @@
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.create2);
-        Create2Request request = new Create2Request();
+        CreateRequest request = new CreateRequest();
         Create2Response response = new Create2Response();
         ReplyHeader r = new ReplyHeader();
         request.setData(data);
"
zookeeper,3a7a240ef7381edf15925045e9f94408177e51cd,"ZOOKEEPER-2187: remove duplicated code between CreateRequest{,2} (Raul Gutierrez Segales via hdeng)",2015.05.30 02:45:53,Hongchao Deng,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 4911acf..0e8133e 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -54,7 +54,6 @@
 import org.apache.zookeeper.data.Id;
 import org.apache.zookeeper.data.StatPersisted;
 import org.apache.zookeeper.proto.CreateRequest;
-import org.apache.zookeeper.proto.Create2Request;
 import org.apache.zookeeper.proto.DeleteRequest;
 import org.apache.zookeeper.proto.ReconfigRequest;
 import org.apache.zookeeper.proto.SetACLRequest;
@@ -365,58 +364,9 @@
                 Time.currentWallTime(), type));
 
         switch (type) {
-            case OpCode.create: {
-                CreateRequest createRequest = (CreateRequest)record;
-                if (deserialize) {
-                    ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
-                }
-                CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());
-                validateCreateRequest(createMode, request);
-                String path = createRequest.getPath();
-                String parentPath = validatePathForCreate(path, request.sessionId);
-
-                List<ACL> listACL = fixupACL(path, request.authInfo, createRequest.getAcl());
-                ChangeRecord parentRecord = getRecordForPath(parentPath);
-
-                checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo);
-                int parentCVersion = parentRecord.stat.getCversion();
-                if (createMode.isSequential()) {
-                    path = path + String.format(Locale.ENGLISH, ""%010d"", parentCVersion);
-                }
-                try {
-                    PathUtils.validatePath(path);
-                } catch(IllegalArgumentException ie) {
-                    LOG.info(""Invalid path "" + path + "" with session 0x"" +
-                            Long.toHexString(request.sessionId));
-                    throw new KeeperException.BadArgumentsException(path);
-                }
-                try {
-                    if (getRecordForPath(path) != null) {
-                        throw new KeeperException.NodeExistsException(path);
-                    }
-                } catch (KeeperException.NoNodeException e) {
-                    // ignore this one
-                }
-                boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;
-                if (ephemeralParent) {
-                    throw new KeeperException.NoChildrenForEphemeralsException(path);
-                }
-                int newCversion = parentRecord.stat.getCversion()+1;
-                request.setTxn(new CreateTxn(path, createRequest.getData(), listACL, createMode.isEphemeral(),
-                        newCversion));
-                StatPersisted s = new StatPersisted();
-                if (createMode.isEphemeral()) {
-                    s.setEphemeralOwner(request.sessionId);
-                }
-                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());
-                parentRecord.childCount++;
-                parentRecord.stat.setCversion(newCversion);
-                addChangeRecord(parentRecord);
-                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));
-                break;
-            }
+            case OpCode.create:
             case OpCode.create2: {
-                Create2Request createRequest = (Create2Request)record;
+                CreateRequest createRequest = (CreateRequest)record;
                 if (deserialize) {
                     ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
                 }
@@ -715,11 +665,8 @@
         try {
             switch (request.type) {
             case OpCode.create:
-                CreateRequest createRequest = new CreateRequest();
-                pRequest2Txn(request.type, zks.getNextZxid(), request, createRequest, true);
-                break;
             case OpCode.create2:
-                Create2Request create2Request = new Create2Request();
+                CreateRequest create2Request = new CreateRequest();
                 pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);
                 break;
             case OpCode.delete:
"
zookeeper,692bfe67ad63fb7cf2e1b901f06f1787c74e5f8d,ZOOKEEPER-2186 QuorumCnxManager#receiveConnection may crash with random input (rgs via michim),2015.05.14 14:10:01,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index f6dfb94..022916d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -82,7 +82,17 @@
      */
     
     private long observerCounter = -1;
-    
+
+    /*
+     * Protocol identifier used among peers
+     */
+    public static final long PROTOCOL_VERSION = -65536L;
+
+    /*
+     * Max buffer size to be read from the network.
+     */
+    static public final int maxBuffer = 2048;
+
     /*
      * Connection time out value in milliseconds 
      */
@@ -136,6 +146,72 @@
         long sid;
     }
 
+    /*
+     * This class parses the initial identification sent out by peers with their
+     * sid & hostname.
+     */
+    static public class InitialMessage {
+        public Long sid;
+        public InetSocketAddress electionAddr;
+
+        InitialMessage(Long sid, InetSocketAddress address) {
+            this.sid = sid;
+            this.electionAddr = address;
+        }
+
+        @SuppressWarnings(""serial"")
+        public static class InitialMessageException extends Exception {
+            InitialMessageException(String message, Object... args) {
+                super(String.format(message, args));
+            }
+        }
+
+        static public InitialMessage parse(Long protocolVersion, DataInputStream din)
+            throws InitialMessageException, IOException {
+            Long sid;
+
+            if (protocolVersion != PROTOCOL_VERSION) {
+                throw new InitialMessageException(
+                        ""Got unrecognized protocol version %s"", protocolVersion);
+            }
+
+            sid = din.readLong();
+
+            int remaining = din.readInt();
+            if (remaining <= 0 || remaining > maxBuffer) {
+                throw new InitialMessageException(
+                        ""Unreasonable buffer length: %s"", remaining);
+            }
+
+            byte[] b = new byte[remaining];
+            int num_read = din.read(b);
+
+            if (num_read != remaining) {
+                throw new InitialMessageException(
+                        ""Read only %s bytes out of %s sent by server %s"",
+                        num_read, remaining, sid);
+            }
+
+            // FIXME: IPv6 is not supported. Using something like Guava's HostAndPort
+            //        parser would be good.
+            String addr = new String(b);
+            String[] host_port = addr.split("":"");
+
+            if (host_port.length != 2) {
+                throw new InitialMessageException(""Badly formed address: %s"", addr);
+            }
+
+            int port;
+            try {
+                port = Integer.parseInt(host_port[1]);
+            } catch (NumberFormatException e) {
+                throw new InitialMessageException(""Bad port number: %s"", host_port[1]);
+            }
+
+            return new InitialMessage(sid, new InetSocketAddress(host_port[0], port));
+        }
+    }
+
     public QuorumCnxManager(QuorumPeer self) {
         this.recvQueue = new ArrayBlockingQueue<Message>(RECV_CAPACITY);
         this.queueSendMap = new ConcurrentHashMap<Long, ArrayBlockingQueue<ByteBuffer>>();
@@ -179,7 +255,7 @@
             // Sending id and challenge
             dout = new DataOutputStream(sock.getOutputStream());
             // represents protocol version (in other words - message type)
-            dout.writeLong(0xffff0000);              
+            dout.writeLong(PROTOCOL_VERSION);
             dout.writeLong(self.getId());
             String addr = self.getElectionAddress().getHostString() + "":"" + self.getElectionAddress().getPort();
             byte[] addr_bytes = addr.getBytes();
@@ -229,31 +305,28 @@
      * possible long value to lose the challenge.
      * 
      */
-    public boolean receiveConnection(Socket sock) {
+    public void receiveConnection(Socket sock) {
         Long sid = null, protocolVersion = null;
         InetSocketAddress electionAddr = null;
+
         try {
             DataInputStream din = new DataInputStream(sock.getInputStream());
+
             protocolVersion = din.readLong();
             if (protocolVersion >= 0) { // this is a server id and not a protocol version
                 sid = protocolVersion;
             } else {
-                sid = din.readLong();
-                int num_remaining_bytes = din.readInt();
-                byte[] b = new byte[num_remaining_bytes];
-                int num_read = din.read(b);
-                if (num_read == num_remaining_bytes) {
-                    if (protocolVersion == 0xffff0000) {
-                        String addr = new String(b);
-                        String[] host_port = addr.split("":"");
-                        electionAddr = new InetSocketAddress(host_port[0], Integer.parseInt(host_port[1]));                   
-                    } else {
-                        LOG.error(""Got urecognized protocol version "" + protocolVersion + "" from "" + sid);
-                    }
-                } else {
-                   LOG.error(""Read only "" + num_read + "" bytes out of "" + num_remaining_bytes + "" sent by server "" + sid);          
+                try {
+                    InitialMessage init = InitialMessage.parse(protocolVersion, din);
+                    sid = init.sid;
+                    electionAddr = init.electionAddr;
+                } catch (InitialMessage.InitialMessageException ex) {
+                    LOG.error(ex.toString());
+                    closeSocket(sock);
+                    return;
                 }
-            } 
+            }
+
             if (sid == QuorumPeer.OBSERVER_ID) {
                 /*
                  * Choose identifier at random. We need a value to identify
@@ -261,12 +334,12 @@
                  */
                 
                 sid = observerCounter--;
-                LOG.info(""Setting arbitrary identifier to observer: "" + sid);
+                LOG.info(""Setting arbitrary identifier to observer: {}"", sid);
             }
         } catch (IOException e) {
             closeSocket(sock);
-            LOG.warn(""Exception reading or writing challenge: "" + e.toString());
-            return false;
+            LOG.warn(""Exception reading or writing challenge: {}"", e.toString());
+            return;
         }
         
         //If wins the challenge, then close the new connection.
@@ -284,7 +357,7 @@
             /*
              * Now we start a new connection
              */
-            LOG.debug(""Create new connection to server: "" + sid);
+            LOG.debug(""Create new connection to server: {}"", sid);
             closeSocket(sock);
 
             if (electionAddr != null) {
@@ -293,28 +366,25 @@
                 connectOne(sid);
             }
 
-            // Otherwise start worker threads to receive data.
-        } else {
+        } else { // Otherwise start worker threads to receive data.
             SendWorker sw = new SendWorker(sock, sid);
             RecvWorker rw = new RecvWorker(sock, sid, sw);
             sw.setRecv(rw);
 
             SendWorker vsw = senderWorkerMap.get(sid);
             
-            if(vsw != null)
+            if (vsw != null) {
                 vsw.finish();
-            
+            }
+
             senderWorkerMap.put(sid, sw);
-            
-            queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(
-                        SEND_CAPACITY));
+
+            queueSendMap.putIfAbsent(sid,
+                    new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY));
             
             sw.start();
             rw.start();
-            
-            return true;    
         }
-        return false;
     }
 
     /**
"
zookeeper,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,ZOOKEEPER-2171 avoid reverse lookups in QuorumCnxManager (rgs via michim),2015.05.10 07:27:47,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index ff1a7f8..3a9aff0 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1062,14 +1062,14 @@
             }
 
             setName(getName().replaceAll(""\\(.*\\)"",
-                    ""("" + addr.getHostName() + "":"" + addr.getPort() + "")""));
+                    ""("" + addr.getHostString() + "":"" + addr.getPort() + "")""));
             if (ZooKeeperSaslClient.isEnabled()) {
                 try {
                     String principalUserName = System.getProperty(
                             ZK_SASL_CLIENT_USERNAME, ""zookeeper"");
                     zooKeeperSaslClient =
                         new ZooKeeperSaslClient(
-                                principalUserName+""/""+addr.getHostName());
+                                principalUserName+""/""+addr.getHostString());
                 } catch (LoginException e) {
                     // An authentication error occurred when the SASL client tried to initialize:
                     // for Kerberos this means that the client failed to authenticate with the KDC.
@@ -1257,7 +1257,7 @@
             Socket sock = null;
             BufferedReader br = null;
             try {
-                sock = new Socket(addr.getHostName(), addr.getPort());
+                sock = new Socket(addr.getHostString(), addr.getPort());
                 sock.setSoLinger(false, -1);
                 sock.setSoTimeout(1000);
                 sock.setTcpNoDelay(true);
@@ -1296,7 +1296,7 @@
                 // connection attempt
                 rwServerAddress = addr;
                 throw new RWServerFoundException(""Majority server found at ""
-                        + addr.getHostName() + "":"" + addr.getPort());
+                        + addr.getHostString() + "":"" + addr.getPort());
             }
         }
 
"
zookeeper,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,ZOOKEEPER-2171 avoid reverse lookups in QuorumCnxManager (rgs via michim),2015.05.10 07:27:47,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
index 4e03018..9b856a2 100644
--- a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
+++ b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
@@ -27,7 +27,6 @@
 import java.util.List;
 import java.util.Random;
 
-import org.apache.zookeeper.common.HostNameUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -111,14 +110,11 @@
         for (InetSocketAddress address : serverAddresses) {
             try {
                 InetAddress ia = address.getAddress();
-                String addr = (ia != null) ? ia.getHostAddress() :
-                                             address.getHostName();
+                String addr = (ia != null) ? ia.getHostAddress() : address.getHostString();
                 InetAddress resolvedAddresses[] = InetAddress.getAllByName(addr);
                 for (InetAddress resolvedAddress : resolvedAddresses) {
-                    tmpList.add(new InetSocketAddress(InetAddress.getByAddress(
-                                    HostNameUtils.getHostString(address),
-                                    resolvedAddress.getAddress()),
-                                    address.getPort()));
+                    InetAddress taddr = InetAddress.getByAddress(address.getHostString(), resolvedAddress.getAddress());
+                    tmpList.add(new InetSocketAddress(taddr, address.getPort()));
                 }
             } catch (UnknownHostException ex) {
                 LOG.warn(""No IP address found for server: {}"", address, ex);
@@ -188,7 +184,7 @@
                     && ((addr.getAddress() != null
                             && myServer.getAddress() != null && addr
                             .getAddress().equals(myServer.getAddress())) || addr
-                            .getHostName().equals(myServer.getHostName()))) {
+                            .getHostString().equals(myServer.getHostString()))) {
                 myServerInNewConfig = true;
                 break;
             }
"
zookeeper,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,ZOOKEEPER-2171 avoid reverse lookups in QuorumCnxManager (rgs via michim),2015.05.10 07:27:47,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java b/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
index d200c50..8c7a168 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
@@ -18,7 +18,6 @@
 
 package org.apache.zookeeper.server.quorum;
 
-import org.apache.zookeeper.common.HostNameUtils;
 
 /**
  * Implementation of the local peer MBean interface.
@@ -79,13 +78,13 @@
     }
 
     public String getElectionAddress() {
-        return HostNameUtils.getHostString(peer.getElectionAddress()) + "":""
-                + peer.getElectionAddress().getPort();
+        return peer.getElectionAddress().getHostString() + "":"" +
+            peer.getElectionAddress().getPort();
     }
 
     public String getClientAddress() {
-        return HostNameUtils.getHostString(peer.getClientAddress()) + "":""
-                + peer.getClientAddress().getPort();
+        return peer.getClientAddress().getHostString() + "":"" +
+            peer.getClientAddress().getPort();
     }
 
     public String getLearnerType(){
"
zookeeper,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,ZOOKEEPER-2171 avoid reverse lookups in QuorumCnxManager (rgs via michim),2015.05.10 07:27:47,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 9b3629a..f6dfb94 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -181,7 +181,7 @@
             // represents protocol version (in other words - message type)
             dout.writeLong(0xffff0000);              
             dout.writeLong(self.getId());
-            String addr = self.getElectionAddress().getHostName() + "":"" + self.getElectionAddress().getPort();
+            String addr = self.getElectionAddress().getHostString() + "":"" + self.getElectionAddress().getPort();
             byte[] addr_bytes = addr.getBytes();
             dout.writeInt(addr_bytes.length);
             dout.write(addr_bytes);
"
zookeeper,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,ZOOKEEPER-2171 avoid reverse lookups in QuorumCnxManager (rgs via michim),2015.05.10 07:27:47,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 42ca580..f15f831 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -45,7 +45,6 @@
 
 import org.apache.zookeeper.common.AtomicFileWritingIdiom;
 import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;
-import org.apache.zookeeper.common.HostNameUtils;
 import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
@@ -160,7 +159,7 @@
                 LOG.warn(""Election address has not been initialized"");
                 return;
             }
-            String host = HostNameUtils.getHostString(this.addr);
+            String host = this.addr.getHostString();
             InetAddress address = null;
             try {
                 address = InetAddress.getByName(host);
@@ -254,7 +253,7 @@
             StringWriter sw = new StringWriter();            
             //addr should never be null, but just to make sure
             if (addr !=null) { 
-                sw.append(HostNameUtils.getHostString(addr));
+                sw.append(addr.getHostString());
                 sw.append("":"");
                 sw.append(String.valueOf(addr.getPort()));
             }
@@ -266,7 +265,7 @@
             else if (type == LearnerType.PARTICIPANT) sw.append("":participant"");            
             if (clientAddr!=null){
                 sw.append("";"");
-                sw.append(HostNameUtils.getHostString(clientAddr));
+                sw.append(clientAddr.getHostString());
                 sw.append("":"");
                 sw.append(String.valueOf(clientAddr.getPort()));
             }
"
zookeeper,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,ZOOKEEPER-2171 avoid reverse lookups in QuorumCnxManager (rgs via michim),2015.05.10 07:27:47,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java b/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java
index a5af465..15d4cff 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java
@@ -18,7 +18,6 @@
 
 package org.apache.zookeeper.server.quorum;
 
-import org.apache.zookeeper.common.HostNameUtils;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
 
 /**
@@ -44,17 +43,15 @@
     }
 
     public String getQuorumAddress() {
-        return peer.addr.getHostName()+"":""+peer.addr.getPort();
+        return peer.addr.getHostString()+"":""+peer.addr.getPort();
     }
 
     public String getElectionAddress() {
-        return HostNameUtils.getHostString(peer.electionAddr) + "":""
-                + peer.electionAddr.getPort();
+        return peer.electionAddr.getHostString() + "":"" + peer.electionAddr.getPort();
     }
 
     public String getClientAddress() {
-        return HostNameUtils.getHostString(peer.clientAddr) + "":""
-                + peer.clientAddr.getPort();
+        return peer.clientAddr.getHostString() + "":"" + peer.clientAddr.getPort();
     }
 
     public String getLearnerType() {
"
zookeeper,bd2a1bc422f1a555bb8a4af23cf07bf67ae0459b,ZOOKEEPER-2171 avoid reverse lookups in QuorumCnxManager (rgs via michim),2015.05.10 07:27:47,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/util/ConfigUtils.java b/src/java/main/org/apache/zookeeper/server/util/ConfigUtils.java
index 216a398..af21f46 100644
--- a/src/java/main/org/apache/zookeeper/server/util/ConfigUtils.java
+++ b/src/java/main/org/apache/zookeeper/server/util/ConfigUtils.java
@@ -53,7 +53,7 @@
              }
              if (!first) sb.append("","");
              else first = false;
-             sb.append(qs.clientAddr.getHostName() + "":"" + qs.clientAddr.getPort());
+             sb.append(qs.clientAddr.getHostString() + "":"" + qs.clientAddr.getPort());
         }
         return version + "" "" + sb.toString();
     }
"
zookeeper,62ec21999b721516d86afbcda0ae49509ec82fd0,"ZOOKEEPER-2029 Leader.LearnerCnxAcceptor should handle exceptions in run() (Rakesh R, Asad Saeed via hdeng)",2015.04.11 05:22:34,Hongchao Deng,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 1a95abd..743f4c4 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -44,7 +44,7 @@
 import org.apache.zookeeper.server.FinalRequestProcessor;
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.RequestProcessor;
-import org.apache.zookeeper.server.ZooKeeperThread;
+import org.apache.zookeeper.server.ZooKeeperCriticalThread;
 import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
 import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
 import org.apache.zookeeper.server.util.ZxidUtils;
@@ -348,11 +348,12 @@
 
     private final Proposal newLeaderProposal = new Proposal();
 
-    class LearnerCnxAcceptor extends ZooKeeperThread {
+    class LearnerCnxAcceptor extends ZooKeeperCriticalThread {
         private volatile boolean stop = false;
 
         public LearnerCnxAcceptor() {
-            super(""LearnerCnxAcceptor-"" + ss.getLocalSocketAddress());
+            super(""LearnerCnxAcceptor-"" + ss.getLocalSocketAddress(), zk
+                    .getZooKeeperServerListener());
         }
 
         @Override
@@ -382,7 +383,8 @@
                     }
                 }
             } catch (Exception e) {
-                LOG.warn(""Exception while accepting follower"", e);
+                LOG.warn(""Exception while accepting follower"", e.getMessage());
+                handleException(this.getName(), e);
             }
         }
 
"
zookeeper,75928cb8af4dfda71d99e35e232a2075f3c7b923,ZOOKEEPER-2146 BinaryInputArchive readString should check length before allocating memory (Hongchao Deng via michim),2015.03.25 16:38:44,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/jute/BinaryInputArchive.java b/src/java/main/org/apache/jute/BinaryInputArchive.java
index 6b2cb46..7722bff 100644
--- a/src/java/main/org/apache/jute/BinaryInputArchive.java
+++ b/src/java/main/org/apache/jute/BinaryInputArchive.java
@@ -27,7 +27,7 @@
  *
  */
 public class BinaryInputArchive implements InputArchive {
-    
+    static public final String UNREASONBLE_LENGTH= ""Unreasonable length = "";
     private DataInput in;
     
     static public BinaryInputArchive getArchive(InputStream strm) {
@@ -78,6 +78,7 @@
     public String readString(String tag) throws IOException {
     	int len = in.readInt();
     	if (len == -1) return null;
+        checkLength(len);
     	byte b[] = new byte[len];
     	in.readFully(b);
     	return new String(b, ""UTF8"");
@@ -88,12 +89,7 @@
     public byte[] readBuffer(String tag) throws IOException {
         int len = readInt(tag);
         if (len == -1) return null;
-        // Since this is a rough sanity check, add some padding to maxBuffer to
-        // make up for extra fields, etc. (otherwise e.g. clients may be able to
-        // write buffers larger than we can read from disk!)
-        if (len < 0 || len > maxBuffer + 1024) {
-            throw new IOException(""Unreasonable length = "" + len);
-        }
+        checkLength(len);
         byte[] arr = new byte[len];
         in.readFully(arr);
         return arr;
@@ -122,5 +118,13 @@
     }
     
     public void endMap(String tag) throws IOException {}
-    
+
+    // Since this is a rough sanity check, add some padding to maxBuffer to
+    // make up for extra fields, etc. (otherwise e.g. clients may be able to
+    // write buffers larger than we can read from disk!)
+    private void checkLength(int len) throws IOException {
+        if (len < 0 || len > maxBuffer + 1024) {
+            throw new IOException(UNREASONBLE_LENGTH + len);
+        }
+    }
 }
"
zookeeper,6edc5a35b403072d14b898229fff098fad479f3e,"ZOOKEEPER-2074 Incorrect exit codes for ""./zkCli.sh cmd arg"" (surendra singh lilhore via michim)",2015.02.09 14:36:26,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index 496e887..83273d3 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -273,7 +273,10 @@
         throws KeeperException, IOException, InterruptedException
     {
         ZooKeeperMain main = new ZooKeeperMain(args);
-        main.run();
+        boolean result = main.run();
+        if (!result) {
+            System.exit(1);
+        }
     }
 
     public ZooKeeperMain(String args[]) throws IOException, InterruptedException {
@@ -288,7 +291,7 @@
       this.zk = zk;
     }
 
-    void run() throws KeeperException, IOException, InterruptedException {
+    boolean run() throws KeeperException, IOException, InterruptedException {
         if (cl.getCommand() == null) {
             System.out.println(""Welcome to ZooKeeper!"");
 
@@ -342,9 +345,10 @@
                     executeLine(line);
                 }
             }
+            return true;
         } else {
             // Command line args non-null.  Run what was passed.
-            processCmd(cl);
+            return processCmd(cl);
         }
     }
 
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index c85cc8d..d4467c3 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -64,6 +64,7 @@
 import org.apache.zookeeper.ZooKeeper.WatchRegistration;
 import org.apache.zookeeper.client.HostProvider;
 import org.apache.zookeeper.client.ZooKeeperSaslClient;
+import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.proto.AuthPacket;
 import org.apache.zookeeper.proto.ConnectRequest;
 import org.apache.zookeeper.proto.Create2Response;
@@ -1103,7 +1104,7 @@
             clientCnxnSocket.updateNow();
             clientCnxnSocket.updateLastSendAndHeard();
             int to;
-            long lastPingRwServer = System.currentTimeMillis();
+            long lastPingRwServer = Time.currentElapsedTime();
             final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds
             while (state.isAlive()) {
                 try {
@@ -1178,7 +1179,7 @@
 
                     // If we are in read-only mode, seek for read/write server
                     if (state == States.CONNECTEDREADONLY) {
-                        long now = System.currentTimeMillis();
+                        long now = Time.currentElapsedTime();
                         int idlePingRwServer = (int) (now - lastPingRwServer);
                         if (idlePingRwServer >= pingRwTimeout) {
                             lastPingRwServer = now;
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
index 16cb912..9b46756 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
@@ -27,6 +27,7 @@
 
 import org.apache.jute.BinaryInputArchive;
 import org.apache.zookeeper.ClientCnxn.Packet;
+import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.proto.ConnectResponse;
 import org.apache.zookeeper.server.ByteBufferInputStream;
 import org.slf4j.Logger;
@@ -77,7 +78,7 @@
     }
 
     void updateNow() {
-        now = System.currentTimeMillis();
+        now = Time.currentElapsedTime();
     }
 
     int getIdleRecv() {
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/Login.java b/src/java/main/org/apache/zookeeper/Login.java
index 6d248ab..44b0bdf 100644
--- a/src/java/main/org/apache/zookeeper/Login.java
+++ b/src/java/main/org/apache/zookeeper/Login.java
@@ -34,6 +34,8 @@
 
 import org.apache.log4j.Logger;
 import org.apache.zookeeper.client.ZooKeeperSaslClient;
+import org.apache.zookeeper.common.Time;
+
 import javax.security.auth.kerberos.KerberosTicket;
 import javax.security.auth.Subject;
 import java.util.Date;
@@ -71,7 +73,8 @@
     private String loginContextName = null;
     private String principal = null;
 
-    private long lastLogin = 0;
+    // Initialize 'lastLogin' to do a login at first time
+    private long lastLogin = Time.currentElapsedTime() - MIN_TIME_BEFORE_RELOGIN;
 
     /**
      * LoginThread constructor. The constructor starts the thread used
@@ -121,7 +124,7 @@
                 LOG.info(""TGT refresh thread started."");
                 while (true) {  // renewal thread's main loop. if it exits from here, thread will exit.
                     KerberosTicket tgt = getTGT();
-                    long now = System.currentTimeMillis();
+                    long now = Time.currentWallTime();
                     long nextRefresh;
                     Date nextRefreshDate;
                     if (tgt == null) {
@@ -298,7 +301,7 @@
                 (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * rng.nextDouble())));
         if (proposedRefresh > expires) {
             // proposedRefresh is too far in the future: it's after ticket expires: simply return now.
-            return System.currentTimeMillis();
+            return Time.currentWallTime();
         }
         else {
             return proposedRefresh;
@@ -318,7 +321,7 @@
     }
 
     private boolean hasSufficientTimeElapsed() {
-        long now = System.currentTimeMillis();
+        long now = Time.currentElapsedTime();
         if (now - getLastLogin() < MIN_TIME_BEFORE_RELOGIN ) {
             LOG.warn(""Not attempting to re-login since the last re-login was "" +
                     ""attempted less than "" + (MIN_TIME_BEFORE_RELOGIN/1000) + "" seconds""+
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/Shell.java b/src/java/main/org/apache/zookeeper/Shell.java
index 62169d7..e9e85b9 100644
--- a/src/java/main/org/apache/zookeeper/Shell.java
+++ b/src/java/main/org/apache/zookeeper/Shell.java
@@ -39,10 +39,11 @@
 import java.util.TimerTask;
 import java.util.concurrent.atomic.AtomicBoolean;
 import org.apache.log4j.Logger;
+import org.apache.zookeeper.common.Time;
 
-/** 
+/**
  * A base class for running a Unix command.
- * 
+ *
  * <code>Shell</code> can be used to run unix commands like <code>du</code> or
  * <code>df</code>. It also offers facilities to gate commands by 
  * time-intervals.
@@ -146,7 +147,7 @@
 
   /** check to see if a command needs to be executed and execute if needed */
   protected void run() throws IOException {
-    if (lastTime + interval > System.currentTimeMillis())
+    if (lastTime + interval > Time.currentElapsedTime())
       return;
     exitCode = 0; // reset for next run
     runCommand();
@@ -245,7 +246,7 @@
         LOG.warn(""Error while closing the error stream"", ioe);
       }
       process.destroy();
-      lastTime = System.currentTimeMillis();
+      lastTime = Time.currentElapsedTime();
     }
   }
 
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/ZKUtil.java b/src/java/main/org/apache/zookeeper/ZKUtil.java
index 4713a08..e5215f7 100644
--- a/src/java/main/org/apache/zookeeper/ZKUtil.java
+++ b/src/java/main/org/apache/zookeeper/ZKUtil.java
@@ -120,5 +120,4 @@
         }
         return tree;
     }
-    
 }
\ No newline at end of file
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/common/Time.java b/src/java/main/org/apache/zookeeper/common/Time.java
new file mode 100644
index 0000000..83e53f0
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/common/Time.java
@@ -0,0 +1,52 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.common;
+
+import java.util.Date;
+
+public class Time {
+    /**
+     * Returns time in milliseconds as does System.currentTimeMillis(),
+     * but uses elapsed time from an arbitrary epoch more like System.nanoTime().
+     * The difference is that if somebody changes the system clock,
+     * Time.currentElapsedTime will change but nanoTime won't. On the other hand,
+     * all of ZK assumes that time is measured in milliseconds.
+     * @return  The time in milliseconds from some arbitrary point in time.
+     */
+    public static long currentElapsedTime() {
+        return System.nanoTime() / 1000000;
+    }
+
+    /**
+     * Explicitly returns system dependent current wall time.
+     * @return Current time in msec.
+     */
+    public static long currentWallTime() {
+        return System.currentTimeMillis();
+    }
+
+    /**
+     * This is to convert the elapsedTime to a Date.
+     * @return A date object indicated by the elapsedTime.
+     */
+    public static Date elapsedTimeToDate(long elapsedTime) {
+        long wallTime = currentWallTime() + elapsedTime - currentElapsedTime();
+        return new Date(wallTime);
+    }
+}
\ No newline at end of file
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/ConnectionBean.java b/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
index 917aacf..58917e0 100644
--- a/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
+++ b/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
@@ -22,10 +22,10 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.Arrays;
-import java.util.Date;
 
 import javax.management.ObjectName;
 
+import org.apache.zookeeper.common.Time;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.jmx.MBeanRegistry;
@@ -164,7 +164,7 @@
     }
 
     public String getLastResponseTime() {
-        return new Date(stats.getLastResponseTime()).toString();
+        return Time.elapsedTimeToDate(stats.getLastResponseTime()).toString();
     }
 
     public long getLastLatency() {
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/ExpiryQueue.java b/src/java/main/org/apache/zookeeper/server/ExpiryQueue.java
index a037bf4..cca1fab 100644
--- a/src/java/main/org/apache/zookeeper/server/ExpiryQueue.java
+++ b/src/java/main/org/apache/zookeeper/server/ExpiryQueue.java
@@ -27,6 +27,8 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.ConcurrentHashMap;
 
+import org.apache.zookeeper.common.Time;
+
 /**
  * ExpiryQueue tracks elements in time sorted fixed duration buckets.
  * It's used by SessionTrackerImpl to expire sessions and NIOServerCnxnFactory
@@ -48,7 +50,7 @@
 
     public ExpiryQueue(int expirationInterval) {
         this.expirationInterval = expirationInterval;
-        nextExpirationTime.set(roundToNextInterval(System.currentTimeMillis()));
+        nextExpirationTime.set(roundToNextInterval(Time.currentElapsedTime()));
     }
 
     private long roundToNextInterval(long time) {
@@ -84,7 +86,7 @@
      */
     public Long update(E elem, int timeout) {
         Long prevExpiryTime = elemMap.get(elem);
-        long now = System.currentTimeMillis();
+        long now = Time.currentElapsedTime();
         Long newExpiryTime = roundToNextInterval(now + timeout);
 
         if (newExpiryTime.equals(prevExpiryTime)) {
@@ -123,7 +125,7 @@
      * @return milliseconds until next expiration time, or 0 if has already past
      */
     public long getWaitTime() {
-        long now = System.currentTimeMillis();
+        long now = Time.currentElapsedTime();
         long expirationTime = nextExpirationTime.get();
         return now < expirationTime ? (expirationTime - now) : 0L;
     }
@@ -137,7 +139,7 @@
      *         ready
      */
     public Set<E> poll() {
-        long now = System.currentTimeMillis();
+        long now = Time.currentElapsedTime();
         long expirationTime = nextExpirationTime.get();
         if (now < expirationTime) {
             return Collections.emptySet();
@@ -168,7 +170,7 @@
             if (set != null) {
                 pwriter.print(set.size());
                 pwriter.print("" expire at "");
-                pwriter.print(new Date(time));
+                pwriter.print(Time.elapsedTimeToDate(time));
                 pwriter.println("":"");
                 for (E elem : set) {
                     pwriter.print(""\t"");
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index a97be4a..04bcf72 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -24,6 +24,7 @@
 import java.util.Locale;
 
 import org.apache.jute.Record;
+import org.apache.zookeeper.common.Time;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.KeeperException;
@@ -182,7 +183,7 @@
 
                 lastOp = ""PING"";
                 cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,
-                        request.createTime, System.currentTimeMillis());
+                        request.createTime, Time.currentElapsedTime());
 
                 cnxn.sendResponse(new ReplyHeader(-2,
                         zks.getZKDatabase().getDataTreeLastProcessedZxid(), 0), null, ""response"");
@@ -193,7 +194,7 @@
 
                 lastOp = ""SESS"";
                 cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,
-                        request.createTime, System.currentTimeMillis());
+                        request.createTime, Time.currentElapsedTime());
 
                 zks.finishSessionInit(request.cnxn, true);
                 return;
@@ -459,7 +460,7 @@
 
         zks.serverStats().updateLatency(request.createTime);
         cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp,
-                    request.createTime, System.currentTimeMillis());
+                    request.createTime, Time.currentElapsedTime());
 
         try {
             cnxn.sendResponse(hdr, rsp, ""response"");
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 7a03b4b..2a54665 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -37,6 +37,7 @@
 import org.apache.jute.Record;
 import org.apache.jute.BinaryOutputArchive;
 
+import org.apache.zookeeper.common.Time;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.CreateMode;
@@ -361,7 +362,8 @@
                                 Record record, boolean deserialize)
         throws KeeperException, IOException, RequestProcessorException
     {
-        request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, zks.getTime(), type));
+        request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,
+                Time.currentWallTime(), type));
 
         switch (type) {
             case OpCode.create: {
@@ -748,8 +750,8 @@
                     ByteBufferInputStream.byteBuffer2Record(request.request, multiRequest);
                 } catch(IOException e) {
                     request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(),
-                                                 zks.getTime(), OpCode.multi));
-                   throw e;
+                            Time.currentWallTime(), OpCode.multi));
+                    throw e;
                 }
                 List<Txn> txns = new ArrayList<Txn>();
                 //Each op in a multi-op must have the same zxid!
@@ -807,7 +809,8 @@
                     txns.add(new Txn(type, bb.array()));
                 }
 
-                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, zks.getTime(), request.type));
+                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,
+                        Time.currentWallTime(), request.type));
                 request.setTxn(new MultiTxn(txns));
 
                 break;
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/RateLogger.java b/src/java/main/org/apache/zookeeper/server/RateLogger.java
index fc951cf..acbd522 100644
--- a/src/java/main/org/apache/zookeeper/server/RateLogger.java
+++ b/src/java/main/org/apache/zookeeper/server/RateLogger.java
@@ -18,6 +18,7 @@
 
 package org.apache.zookeeper.server;
 
+import org.apache.zookeeper.common.Time;
 import org.slf4j.Logger;
 
 public class RateLogger {
@@ -43,7 +44,7 @@
     }
 
     public void rateLimitLog(String newMsg) {
-        long now = System.currentTimeMillis();
+        long now = Time.currentElapsedTime();
         if (newMsg.equals(msg)) {
             ++count;
             if (now - timestamp >= 100) {
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/Request.java b/src/java/main/org/apache/zookeeper/server/Request.java
index ee01dcf..bed9b13 100644
--- a/src/java/main/org/apache/zookeeper/server/Request.java
+++ b/src/java/main/org/apache/zookeeper/server/Request.java
@@ -24,6 +24,7 @@
 import org.apache.jute.Record;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.data.Id;
 import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
 import org.apache.zookeeper.txn.TxnHeader;
@@ -75,7 +76,7 @@
 
     public final List<Id> authInfo;
 
-    public final long createTime = System.currentTimeMillis();
+    public final long createTime = Time.currentElapsedTime();
 
     private Object owner;
 
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/ServerStats.java b/src/java/main/org/apache/zookeeper/server/ServerStats.java
index c324629..c8ccf1c 100644
--- a/src/java/main/org/apache/zookeeper/server/ServerStats.java
+++ b/src/java/main/org/apache/zookeeper/server/ServerStats.java
@@ -20,6 +20,8 @@
 
 
 
+import org.apache.zookeeper.common.Time;
+
 /**
  * Basic Server Statistics
  */
@@ -107,7 +109,7 @@
     }
     // mutators
     synchronized void updateLatency(long requestCreateTime) {
-        long latency = System.currentTimeMillis() - requestCreateTime;
+        long latency = Time.currentElapsedTime() - requestCreateTime;
         totalLatency += latency;
         count++;
         if (latency < minLatency) {
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
index 0c2c042..7677390 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
@@ -32,6 +32,7 @@
 
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.SessionExpiredException;
+import org.apache.zookeeper.common.Time;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -81,7 +82,7 @@
      */
     public static long initializeNextSession(long id) {
         long nextSid;
-        nextSid = (System.currentTimeMillis() << 24) >>> 8;
+        nextSid = (Time.currentElapsedTime() << 24) >>> 8;
         nextSid =  nextSid | (id <<56);
         return nextSid;
     }
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/WorkerService.java b/src/java/main/org/apache/zookeeper/server/WorkerService.java
index c55ff48..416e3af 100644
--- a/src/java/main/org/apache/zookeeper/server/WorkerService.java
+++ b/src/java/main/org/apache/zookeeper/server/WorkerService.java
@@ -26,6 +26,7 @@
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 
+import org.apache.zookeeper.common.Time;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -227,11 +228,11 @@
 
     public void join(long shutdownTimeoutMS) {
         // Give the worker threads time to finish executing
-        long now = System.currentTimeMillis();
+        long now = Time.currentElapsedTime();
         long endTime = now + shutdownTimeoutMS;
         for(ExecutorService worker : workers) {
             boolean terminated = false;
-            while ((now = System.currentTimeMillis()) <= endTime) {
+            while ((now = Time.currentElapsedTime()) <= endTime) {
                 try {
                     terminated = worker.awaitTermination(
                         endTime - now, TimeUnit.MILLISECONDS);
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index f336049..3fa96a6 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -41,6 +41,7 @@
 import org.apache.zookeeper.Watcher;
 import org.apache.zookeeper.Watcher.WatcherType;
 import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.server.DataTree.ProcessTxnResult;
@@ -570,17 +571,17 @@
         this.snapLog.close();
     }
 
-    public synchronized void initConfigInZKDatabase(QuorumVerifier qv) {   
-    	if (qv == null) return; // only happens during tests
+    public synchronized void initConfigInZKDatabase(QuorumVerifier qv) {
+        if (qv == null) return; // only happens during tests
         try {
-             if (this.dataTree.getNode(ZooDefs.CONFIG_NODE) == null) {
-            	 // should only happen during upgrade
-            	 LOG.warn(""configuration znode missing (hould only happen during upgrade), creating the node"");
-                 this.dataTree.addConfigNode();
-             }
-             this.dataTree.setData(ZooDefs.CONFIG_NODE, qv.toString().getBytes(), -1, qv.getVersion(), System.currentTimeMillis());           
+            if (this.dataTree.getNode(ZooDefs.CONFIG_NODE) == null) {
+                // should only happen during upgrade
+                LOG.warn(""configuration znode missing (hould only happen during upgrade), creating the node"");
+                this.dataTree.addConfigNode();
+            }
+            this.dataTree.setData(ZooDefs.CONFIG_NODE, qv.toString().getBytes(), -1, qv.getVersion(), Time.currentWallTime());
         } catch (NoNodeException e) {
-           System.out.println(""configuration node missing - should not happen"");         
+            System.out.println(""configuration node missing - should not happen"");
         }
     }
  
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 30a0ed3..0946991 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -41,6 +41,7 @@
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.BinaryOutputArchive;
 import org.apache.jute.Record;
+import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.Environment;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.Code;
@@ -314,10 +315,6 @@
         hzxid.set(zxid);
     }
 
-    long getTime() {
-        return System.currentTimeMillis();
-    }
-
     private void close(long sessionId) {
         Request si = new Request(null, sessionId, 0, OpCode.closeSession, null, null);
         setLocalSessionFlag(si);
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
index 6cd0af8..0f8c9c1 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
@@ -36,6 +36,7 @@
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicLong;
 
+import org.apache.zookeeper.common.Time;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -417,7 +418,7 @@
                 super(""WorkerSender"");
                 maxAttempts = attempts;
                 rand = new Random(java.lang.Thread.currentThread().getId()
-                        + System.currentTimeMillis());
+                        + Time.currentElapsedTime());
             }
 
             long genChallenge() {
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index dfe692f..e040d3a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -28,6 +28,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
+import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.server.ZooKeeperThread;
 import org.apache.zookeeper.server.quorum.QuorumCnxManager.Message;
@@ -871,7 +872,7 @@
             self.jmxLeaderElectionBean = null;
         }
         if (self.start_fle == 0) {
-           self.start_fle = System.currentTimeMillis();
+           self.start_fle = Time.currentElapsedTime();
         }
         try {
             HashMap<Long, Vote> recvset = new HashMap<Long, Vote>();
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index 6dbb0b2..d29e9f8 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -24,6 +24,7 @@
 
 import org.apache.jute.Record;
 import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
 import org.apache.zookeeper.server.util.SerializeUtils;
@@ -61,7 +62,7 @@
      * @throws InterruptedException
      */
     void followLeader() throws InterruptedException {
-        self.end_fle = System.currentTimeMillis();
+        self.end_fle = Time.currentElapsedTime();
         LOG.info(""FOLLOWING - LEADER ELECTION TOOK - "" +
               (self.end_fle - self.start_fle));
         self.start_fle = 0;
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 2058904..9dc0424 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -40,6 +40,7 @@
 
 import org.apache.jute.BinaryOutputArchive;
 import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.server.FinalRequestProcessor;
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.RequestProcessor;
@@ -405,7 +406,7 @@
      * @throws InterruptedException
      */
     void lead() throws IOException, InterruptedException {
-        self.end_fle = System.currentTimeMillis();
+        self.end_fle = Time.currentElapsedTime();
         LOG.info(""LEADING - LEADER ELECTION TOOK - "" +
               (self.end_fle - self.start_fle));
         self.start_fle = 0;
@@ -549,12 +550,12 @@
 
             while (true) {
                 synchronized (this) {
-                    long start = System.currentTimeMillis();
+                    long start = Time.currentElapsedTime();
                     long cur = start;
                     long end = start + self.tickTime / 2;
                     while (cur < end) {
                         wait(end - cur);
-                        cur = System.currentTimeMillis();
+                        cur = Time.currentElapsedTime();
                     }
 
                     if (!tickSkip) {
@@ -1167,12 +1168,12 @@
                 self.setAcceptedEpoch(epoch);
                 connectingFollowers.notifyAll();
             } else {
-                long start = System.currentTimeMillis();
+                long start = Time.currentElapsedTime();
                 long cur = start;
                 long end = start + self.getInitLimit()*self.getTickTime();
                 while(waitingForNewEpoch && cur < end) {
                     connectingFollowers.wait(end - cur);
-                    cur = System.currentTimeMillis();
+                    cur = Time.currentElapsedTime();
                 }
                 if (waitingForNewEpoch) {
                     throw new InterruptedException(""Timeout while waiting for epoch from quorum"");
@@ -1204,12 +1205,12 @@
                 electionFinished = true;
                 electingFollowers.notifyAll();
             } else {
-                long start = System.currentTimeMillis();
+                long start = Time.currentElapsedTime();
                 long cur = start;
                 long end = start + self.getInitLimit()*self.getTickTime();
                 while(!electionFinished && cur < end) {
                     electingFollowers.wait(end - cur);
-                    cur = System.currentTimeMillis();
+                    cur = Time.currentElapsedTime();
                 }
                 if (!electionFinished) {
                     throw new InterruptedException(""Timeout while waiting for epoch to be acked by quorum"");
@@ -1310,12 +1311,12 @@
                 quorumFormed = true;
                 newLeaderProposal.qvAcksetPairs.notifyAll();
             } else {
-                long start = System.currentTimeMillis();
+                long start = Time.currentElapsedTime();
                 long cur = start;
                 long end = start + self.getInitLimit() * self.getTickTime();
                 while (!quorumFormed && cur < end) {
                     newLeaderProposal.qvAcksetPairs.wait(end - cur);
-                    cur = System.currentTimeMillis();
+                    cur = Time.currentElapsedTime();
                 }
                 if (!quorumFormed) {
                     throw new InterruptedException(
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerSnapshotThrottler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerSnapshotThrottler.java
index 97b4891..3542234 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerSnapshotThrottler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerSnapshotThrottler.java
@@ -18,8 +18,7 @@
 
 package org.apache.zookeeper.server.quorum;
 
-import java.util.concurrent.atomic.AtomicInteger;
-
+import org.apache.zookeeper.common.Time;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -97,11 +96,11 @@
             if (!essential
                 && timeoutMillis > 0
                 && snapsInProgress >= maxConcurrentSnapshots) {
-                long timestamp = System.currentTimeMillis();
+                long timestamp = Time.currentElapsedTime();
                 do {
                     snapCountSyncObject.wait(timeoutMillis);
                 } while (snapsInProgress >= maxConcurrentSnapshots
-                         && timestamp + timeoutMillis < System.currentTimeMillis());
+                         && timestamp + timeoutMillis < Time.currentElapsedTime());
             }
 
             if (essential || snapsInProgress < maxConcurrentSnapshots) {
"
zookeeper,2789d1df02e697ea511867546dc569ff6b405ece,ZOOKEEPER-1366 Zookeeper should be tolerant of clock adjustments (Hongchao Deng via michim),2015.02.06 14:17:31,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 388ceeb..04e84ee 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -45,6 +45,7 @@
 import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;
 import org.apache.zookeeper.common.HostNameUtils;
 import org.apache.zookeeper.common.PathUtils;
+import org.apache.zookeeper.common.Time;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
 import org.apache.zookeeper.server.ServerCnxnFactory;
@@ -985,7 +986,7 @@
                     }
                     break;
                 }
-                start_fle = System.currentTimeMillis();
+                start_fle = Time.currentElapsedTime();
             }
         } finally {
             LOG.warn(""QuorumPeer main thread exited"");
"
zookeeper,ffb584be6c5cf020136208e3d93d880b3f141773,ZOOKEEPER-2111 Not isAlive states should be synchronized in ClientCnxn (Hongchao via rakeshr),2015.01.31 16:05:54,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index bde2a69..c85cc8d 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1233,9 +1233,11 @@
                     }
                 }
             }
-            // When it comes to this point, it guarantees that later queued packet to outgoingQueue will be
-            // notified of death.
-            cleanup();
+            synchronized (state) {
+                // When it comes to this point, it guarantees that later queued
+                // packet to outgoingQueue will be notified of death.
+                cleanup();
+            }
             clientCnxnSocket.close();
             if (state.isAlive()) {
                 eventThread.queueEvent(new WatchedEvent(Event.EventType.None,
@@ -1515,15 +1517,21 @@
         packet.clientPath = clientPath;
         packet.serverPath = serverPath;
         packet.watchDeregistration = watchDeregistration;
-        if (!state.isAlive() || closing) {
-            conLossPacket(packet);
-        } else {
-            // If the client is asking to close the session then
-            // mark as closing
-            if (h.getType() == OpCode.closeSession) {
-                closing = true;
+        // The synchronized block here is for two purpose:
+        // 1. synchronize with the final cleanup() in SendThread.run() to avoid race
+        // 2. synchronized against each packet. So if a closeSession packet is added,
+        // later packet will be notified.
+        synchronized (state) {
+            if (!state.isAlive() || closing) {
+                conLossPacket(packet);
+            } else {
+                // If the client is asking to close the session then
+                // mark as closing
+                if (h.getType() == OpCode.closeSession) {
+                    closing = true;
+                }
+                outgoingQueue.add(packet);
             }
-            outgoingQueue.add(packet);
         }
         sendThread.getClientCnxnSocket().packetAdded();
         return packet;
"
zookeeper,a95add82db688000a7dc2ceb15464c368e7702fb,ZOOKEEPER-2072 Netty Server Should Configure Child Channel Pipeline By Specifying ChannelPipelineFactory(Hongchao via rakeshr),2015.01.30 11:23:50,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
index 4126880..09a7948 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
@@ -35,7 +35,10 @@
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelHandler.Sharable;
 import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelPipeline;
+import org.jboss.netty.channel.ChannelPipelineFactory;
 import org.jboss.netty.channel.ChannelStateEvent;
+import org.jboss.netty.channel.Channels;
 import org.jboss.netty.channel.ExceptionEvent;
 import org.jboss.netty.channel.MessageEvent;
 import org.jboss.netty.channel.SimpleChannelHandler;
@@ -242,7 +245,7 @@
     }
     
     CnxnChannelHandler channelHandler = new CnxnChannelHandler();
-    
+
     NettyServerCnxnFactory() {
         bootstrap = new ServerBootstrap(
                 new NioServerSocketChannelFactory(
@@ -254,8 +257,15 @@
         bootstrap.setOption(""child.tcpNoDelay"", true);
         /* set socket linger to off, so that socket close does not block */
         bootstrap.setOption(""child.soLinger"", -1);
+        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+            @Override
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline p = Channels.pipeline();
+                p.addLast(""servercnxnfactory"", channelHandler);
 
-        bootstrap.getPipeline().addLast(""servercnxnfactory"", channelHandler);
+                return p;
+            }
+        });
     }
     
     @Override
"
zookeeper,967437328de3b7b8794c8b9a80e0fdaa41a00570,"ZOOKEEPER-1784 wrong check for COMMITANDACTIVATE in observer code, Learner.java (rgs via shralex).",2015.01.25 09:22:12,Alexander Shraer,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 4dd1e94..87f4c06 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -422,7 +422,7 @@
                     PacketInFlight packet = new PacketInFlight();
                     packet.hdr = new TxnHeader();
 
-                    if (qp.getType() == Leader.COMMITANDACTIVATE) {
+                    if (qp.getType() == Leader.INFORMANDACTIVATE) {
                         ByteBuffer buffer = ByteBuffer.wrap(qp.getData());
                         long suggestedLeaderId = buffer.getLong();
                         byte[] remainingdata = new byte[buffer.remaining()];
"
zookeeper,6aec8db7185cfc17022d90279f83f01ff237346a,ZOOKEEPER-2064 Prevent resource leak in various classes (Ted Yu via fpj),2014.11.30 00:53:52,Flavio Paiva Junqueira,"diff --git a/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/Log4JSource.java b/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/Log4JSource.java
index 78f0898..84a9d98 100644
--- a/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/Log4JSource.java
+++ b/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/Log4JSource.java
@@ -351,11 +351,21 @@
 		
 		LogIterator iter = s.iterator(starttime, endtime);
 		System.out.println(iter);
+		try {
+		  iter.close();
+		} catch (IOException ioe) {
+		  System.out.println(ioe.getMessage());
+		}
 	    }; };
 	    Thread t2 = new Thread() { public void run () { 
 		
 		LogIterator iter = s.iterator(starttime, endtime);
 		System.out.println(iter);
+		try {
+		  iter.close();
+		} catch (IOException ioe) {
+		  System.out.println(ioe.getMessage());
+		}
 	    }; };
 	    Thread t3 = new Thread() { public void run () { 
 		
"
zookeeper,6aec8db7185cfc17022d90279f83f01ff237346a,ZOOKEEPER-2064 Prevent resource leak in various classes (Ted Yu via fpj),2014.11.30 00:53:52,Flavio Paiva Junqueira,"diff --git a/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/RandomAccessFileReader.java b/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/RandomAccessFileReader.java
index 827a8a7..13a41a5 100644
--- a/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/RandomAccessFileReader.java
+++ b/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/RandomAccessFileReader.java
@@ -324,5 +324,6 @@
 	System.out.println(f.readLine());
 	f.seek(pos2);
 	System.out.println(f.readLine());
+	f.close();
     }
 };
"
zookeeper,6aec8db7185cfc17022d90279f83f01ff237346a,ZOOKEEPER-2064 Prevent resource leak in various classes (Ted Yu via fpj),2014.11.30 00:53:52,Flavio Paiva Junqueira,"diff --git a/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/servlets/NumEvents.java b/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/servlets/NumEvents.java
index ed46945..5961a12 100644
--- a/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/servlets/NumEvents.java
+++ b/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/servlets/NumEvents.java
@@ -81,6 +81,7 @@
 	if (LOG.isDebugEnabled()) {
 	    LOG.debug(""handle(start= "" + starttime + "", end="" + endtime + "", numEntries="" + size +"")"");
 	}
+	iter.close();
 	return JSONValue.toJSONString(data);
     }
 }
"
zookeeper,6aec8db7185cfc17022d90279f83f01ff237346a,ZOOKEEPER-2064 Prevent resource leak in various classes (Ted Yu via fpj),2014.11.30 00:53:52,Flavio Paiva Junqueira,"diff --git a/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/servlets/StaticContent.java b/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/servlets/StaticContent.java
index 4af7895..d91acb6 100644
--- a/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/servlets/StaticContent.java
+++ b/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/servlets/StaticContent.java
@@ -39,9 +39,12 @@
 	    response.setStatus(HttpServletResponse.SC_NOT_FOUND);
 	    return;
 	}
-	
-	while (resource.available() > 0) {
+	try {
+	  while (resource.available() > 0) {
 	    response.getWriter().write(resource.read());
+	  }
+	} finally {
+	  resource.close();
 	}
 	//        response.setContentType(""text/plain;charset=utf-8"");
         response.setStatus(HttpServletResponse.SC_OK);
"
zookeeper,6aec8db7185cfc17022d90279f83f01ff237346a,ZOOKEEPER-2064 Prevent resource leak in various classes (Ted Yu via fpj),2014.11.30 00:53:52,Flavio Paiva Junqueira,"diff --git a/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/cfg/RestCfg.java b/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/cfg/RestCfg.java
index c773020..93dd632 100644
--- a/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/cfg/RestCfg.java
+++ b/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/cfg/RestCfg.java
@@ -36,9 +36,13 @@
    }
 
    public RestCfg(InputStream io) throws IOException {
+     try {
        cfg.load(io);
        extractEndpoints();
        extractCredentials();
+     } finally {
+       io.close();
+     }
    }
 
    private void extractCredentials() {
"
zookeeper,576cee6a81f83fec5ab203cc89be47e2c7fc2d7f,ZOOKEEPER-2060 Trace bug in NettyServerCnxnFactory (Ian via fpj),2014.11.20 07:36:57,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
index 7276685..4126880 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
@@ -183,9 +183,11 @@
                         cnxn.queuedBuffer = dynamicBuffer(buf.readableBytes());
                     }
                     cnxn.queuedBuffer.writeBytes(buf);
-                    LOG.debug(Long.toHexString(cnxn.sessionId)
-                            + "" queuedBuffer 0x""
-                            + ChannelBuffers.hexDump(cnxn.queuedBuffer));
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace(Long.toHexString(cnxn.sessionId)
+                                + "" queuedBuffer 0x""
+                                + ChannelBuffers.hexDump(cnxn.queuedBuffer));
+                    }
                 } else {
                     LOG.debug(""not throttled"");
                     if (cnxn.queuedBuffer != null) {
"
zookeeper,783382d89c58561a9ac8b3d886b4b564a7b211c9,ZOOKEEPER-2052 Unable to delete a node when the node has no children (Hongchao Deng and Yip Ng via rakeshr),2014.10.28 13:35:14,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 8542790..7a03b4b 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -159,14 +159,6 @@
         ChangeRecord lastChange = null;
         synchronized (zks.outstandingChanges) {
             lastChange = zks.outstandingChangesForPath.get(path);
-            /*
-            for (int i = 0; i < zks.outstandingChanges.size(); i++) {
-                ChangeRecord c = zks.outstandingChanges.get(i);
-                if (c.path.equals(path)) {
-                    lastChange = c;
-                }
-            }
-            */
             if (lastChange == null) {
                 DataNode n = zks.getZKDatabase().getNode(path);
                 if (n != null) {
@@ -188,6 +180,12 @@
         return lastChange;
     }
 
+    private ChangeRecord getOutstandingChange(String path) {
+        synchronized (zks.outstandingChanges) {
+            return zks.outstandingChangesForPath.get(path);
+        }
+    }
+
     private void addChangeRecord(ChangeRecord c) {
         synchronized (zks.outstandingChanges) {
             zks.outstandingChanges.add(c);
@@ -202,39 +200,37 @@
      * of a failed multi-op.
      *
      * @param multiRequest
+     * @return a map that contains previously existed records that probably need to be
+     *         rolled back in any failure.
      */
     private Map<String, ChangeRecord> getPendingChanges(MultiTransactionRecord multiRequest) {
         HashMap<String, ChangeRecord> pendingChangeRecords = new HashMap<String, ChangeRecord>();
 
-        for(Op op: multiRequest) {
+        for (Op op : multiRequest) {
             String path = op.getPath();
+            ChangeRecord cr = getOutstandingChange(path);
+            // only previously existing records need to be rolled back.
+            if (cr != null) {
+                pendingChangeRecords.put(path, cr);
+            }
 
-            try {
-                ChangeRecord cr = getRecordForPath(path);
-                if (cr != null) {
-                    pendingChangeRecords.put(path, cr);
-                }
-
-                /*
-                 * ZOOKEEPER-1624 - We need to store for parent's ChangeRecord
-                 * of the parent node of a request. So that if this is a
-                 * sequential node creation request, rollbackPendingChanges()
-                 * can restore previous parent's ChangeRecord correctly.
-                 *
-                 * Otherwise, sequential node name generation will be incorrect
-                 * for a subsequent request.
-                 */
-                int lastSlash = path.lastIndexOf('/');
-                if (lastSlash == -1 || path.indexOf('\0') != -1) {
-                    continue;
-                }
-                String parentPath = path.substring(0, lastSlash);
-                ChangeRecord parentCr = getRecordForPath(parentPath);
-                if (parentCr != null) {
-                    pendingChangeRecords.put(parentPath, parentCr);
-                }
-            } catch (KeeperException.NoNodeException e) {
-                // ignore this one
+            /*
+             * ZOOKEEPER-1624 - We need to store for parent's ChangeRecord
+             * of the parent node of a request. So that if this is a
+             * sequential node creation request, rollbackPendingChanges()
+             * can restore previous parent's ChangeRecord correctly.
+             *
+             * Otherwise, sequential node name generation will be incorrect
+             * for a subsequent request.
+             */
+            int lastSlash = path.lastIndexOf('/');
+            if (lastSlash == -1 || path.indexOf('\0') != -1) {
+                continue;
+            }
+            String parentPath = path.substring(0, lastSlash);
+            ChangeRecord parentCr = getOutstandingChange(parentPath);
+            if (parentCr != null) {
+                pendingChangeRecords.put(parentPath, parentCr);
             }
         }
 
@@ -252,7 +248,6 @@
      * @param pendingChangeRecords
      */
     void rollbackPendingChanges(long zxid, Map<String, ChangeRecord>pendingChangeRecords) {
-
         synchronized (zks.outstandingChanges) {
             // Grab a list iterator starting at the END of the list so we can iterate in reverse
             ListIterator<ChangeRecord> iter = zks.outstandingChanges.listIterator(zks.outstandingChanges.size());
@@ -260,27 +255,30 @@
                 ChangeRecord c = iter.previous();
                 if (c.zxid == zxid) {
                     iter.remove();
+                    // Remove all outstanding changes for paths of this multi.
+                    // Previous records will be added back later.
                     zks.outstandingChangesForPath.remove(c.path);
                 } else {
                     break;
                 }
             }
 
-            boolean empty = zks.outstandingChanges.isEmpty();
-            long firstZxid = 0;
-            if (!empty) {
-                firstZxid = zks.outstandingChanges.get(0).zxid;
+            // we don't need to roll back any records because there is nothing left.
+            if (zks.outstandingChanges.isEmpty()) {
+                return;
             }
 
-            Iterator<ChangeRecord> priorIter = pendingChangeRecords.values().iterator();
-            while (priorIter.hasNext()) {
-                ChangeRecord c = priorIter.next();
+            long firstZxid = zks.outstandingChanges.get(0).zxid;
 
-                /* Don't apply any prior change records less than firstZxid */
-                if (!empty && (c.zxid < firstZxid)) {
+            for (ChangeRecord c : pendingChangeRecords.values()) {
+                // Don't apply any prior change records less than firstZxid.
+                // Note that previous outstanding requests might have been removed
+                // once they are completed.
+                if (c.zxid < firstZxid) {
                     continue;
                 }
 
+                // add previously existing records back.
                 zks.outstandingChangesForPath.put(c.path, c);
             }
         }
"
zookeeper,3a3014ad265095bea004bcccea0f28dd960d2234,ZOOKEEPER-2026 Startup order in ServerCnxnFactory-ies is wrong (Stevo Slavic via rakeshr),2014.09.29 02:15:05,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
index 7f188c8..acabb33 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
@@ -745,9 +745,9 @@
     public void startup(ZooKeeperServer zks) throws IOException,
             InterruptedException {
         start();
+        setZooKeeperServer(zks);
         zks.startdata();
         zks.startup();
-        setZooKeeperServer(zks);
     }
 
     @Override
"
zookeeper,3a3014ad265095bea004bcccea0f28dd960d2234,ZOOKEEPER-2026 Startup order in ServerCnxnFactory-ies is wrong (Stevo Slavic via rakeshr),2014.09.29 02:15:05,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
index 8a05f94..7276685 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
@@ -371,9 +371,9 @@
     public void startup(ZooKeeperServer zks) throws IOException,
             InterruptedException {
         start();
+        setZooKeeperServer(zks);
         zks.startdata();
         zks.startup();
-        setZooKeeperServer(zks);
     }
 
     @Override
"
zookeeper,375d298996e01ffabedaecb3dd62eb2b35070e1b,ZOOKEEPER-2039 Jute compareBytes incorrect comparison index (Ian Dimayuga via fpj),2014.09.19 00:47:50,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/jute/Utils.java b/src/java/main/org/apache/jute/Utils.java
index 243f2c8..1205fa2 100644
--- a/src/java/main/org/apache/jute/Utils.java
+++ b/src/java/main/org/apache/jute/Utils.java
@@ -268,15 +268,15 @@
         return stream.toByteArray();
     }
     public static int compareBytes(byte b1[], int off1, int len1, byte b2[], int off2, int len2) {
-    	int i;
-    	for(i=0; i < len1 && i < len2; i++) {
-    		if (b1[off1+i] != b2[off2+i]) {
-    			return b1[off1+i] < b2[off2+1] ? -1 : 1;
-    		}
-    	}
-    	if (len1 != len2) {
-    		return len1 < len2 ? -1 : 1;
-    	}
-    	return 0;
+        int i;
+        for(i=0; i < len1 && i < len2; i++) {
+            if (b1[off1+i] != b2[off2+i]) {
+                return b1[off1+i] < b2[off2+i] ? -1 : 1;
+            }
+        }
+        if (len1 != len2) {
+            return len1 < len2 ? -1 : 1;
+        }
+        return 0;
     }
 }
"
zookeeper,7af77531b0dd0e641e10bac1b25482df6b335b89,"ZOOKEEPER-2030 dynamicConfigFile should have an absolute path, not a relative path, to the dynamic configuration file (Alexander Shraer via michim)",2014.09.17 14:34:28,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 095f8fc..badc8df 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -405,6 +405,11 @@
                 .failForNonExistingPath()
                 .build()).create(configFileStr);
 
+        final File dynamicFile = (new VerifyingFileFactory.Builder(LOG)
+                .warnForRelativePath()
+                .failForNonExistingPath()
+                .build()).create(dynamicFileStr);
+        
         final Properties cfg = new Properties();
         FileInputStream in = new FileInputStream(configFile);
         try {
@@ -436,7 +441,7 @@
 
                 // updates the dynamic file pointer
                 out.write(""dynamicConfigFile=""
-                         .concat(dynamicFileStr)
+                         .concat(dynamicFile.getCanonicalPath())
                          .concat(""\n""));
             }
         });
"
zookeeper,0b585528c8d8c36715b3489900e77c9198301102,ZOOKEEPER-2006. Standalone mode won't take client port from dynamic config. (Hongchao Deng via Alex Shraer),2014.08.20 05:50:41,Alexander Shraer,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 02edcf0..095f8fc 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -54,10 +54,11 @@
 
 public class QuorumPeerConfig {
     private static final Logger LOG = LoggerFactory.getLogger(QuorumPeerConfig.class);
-    private static boolean standaloneEnabled = true;
-
+    private static final int UNSET_SERVERID = -1;
     public static final String nextDynamicConfigFileSuffix = "".dynamic.next"";
 
+    private static boolean standaloneEnabled = true;
+
     protected InetSocketAddress clientPortAddress;
     protected File dataDir;
     protected File dataLogDir;
@@ -78,7 +79,7 @@
     protected int electionPort = 2182;
     protected boolean quorumListenOnAllIPs = false;
 
-    protected long serverId;
+    protected long serverId = UNSET_SERVERID;
 
     protected QuorumVerifier quorumVerifier = null, lastSeenQuorumVerifier = null;
     protected int snapRetainCount = 3;
@@ -152,9 +153,8 @@
                } finally {
                    inConfig.close();
                }
-               quorumVerifier = parseDynamicConfig(dynamicCfg, electionAlg, true, false);
-               checkValidity();
-           
+               setupQuorumPeerConfig(dynamicCfg, false);
+
            } catch (IOException e) {
                throw new ConfigException(""Error processing "" + dynamicConfigFileStr, e);
            } catch (IllegalArgumentException e) {
@@ -318,9 +318,11 @@
         // backward compatibility - dynamic configuration in the same file as
         // static configuration params see writeDynamicConfig()
         if (dynamicConfigFileStr == null) {
-            backupOldConfig();
-            quorumVerifier = parseDynamicConfig(zkProp, electionAlg, true, true);
-            checkValidity();
+            setupQuorumPeerConfig(zkProp, true);
+            if (isDistributed()) {
+                // we don't backup static config for standalone mode.
+                backupOldConfig();
+            }
         }
     }
 
@@ -464,7 +466,16 @@
             return new QuorumMaj(dynamicConfigProp);            
         }          
     }
-    
+
+    void setupQuorumPeerConfig(Properties prop, boolean configBackwardCompatibilityMode)
+            throws IOException, ConfigException {
+        quorumVerifier = parseDynamicConfig(prop, electionAlg, true, configBackwardCompatibilityMode);
+        setupMyId();
+        setupClientPort();
+        setupPeerType();
+        checkValidity();
+    }
+
     /**
      * Parse dynamic configuration file and return
      * quorumVerifier for new configuration.
@@ -490,6 +501,10 @@
         int numParticipators = qv.getVotingMembers().size();
         int numObservers = qv.getObservingMembers().size();
         if (numParticipators == 0) {
+            if (!standaloneEnabled) {
+                throw new IllegalArgumentException(""standaloneEnabled = false then "" +
+                        ""number of participants should be >0"");
+            }
             if (numObservers > 0) {
                 throw new IllegalArgumentException(""Observers w/o participants is an invalid configuration"");
             }
@@ -525,64 +540,73 @@
         }
         return qv;
     }
-    
+
+    private void setupMyId() throws IOException {
+        File myIdFile = new File(dataDir, ""myid"");
+        // standalone server doesn't need myid file.
+        if (!myIdFile.isFile()) {
+            return;
+        }
+        BufferedReader br = new BufferedReader(new FileReader(myIdFile));
+        String myIdString;
+        try {
+            myIdString = br.readLine();
+        } finally {
+            br.close();
+        }
+        try {
+            serverId = Long.parseLong(myIdString);
+            MDC.put(""myid"", myIdString);
+        } catch (NumberFormatException e) {
+            throw new IllegalArgumentException(""serverid "" + myIdString
+                    + "" is not a number"");
+        }
+    }
+
+    private void setupClientPort() throws ConfigException {
+        if (serverId == UNSET_SERVERID) {
+            return;
+        }
+        QuorumServer qs = quorumVerifier.getAllMembers().get(serverId);
+        if (clientPortAddress != null && qs != null && qs.clientAddr != null) {
+            if ((!clientPortAddress.getAddress().isAnyLocalAddress()
+                    && !clientPortAddress.equals(qs.clientAddr)) ||
+                    (clientPortAddress.getAddress().isAnyLocalAddress()
+                            && clientPortAddress.getPort() != qs.clientAddr.getPort()))
+                throw new ConfigException(""client address for this server (id = "" + serverId +
+                        "") in static config file is "" + clientPortAddress +
+                        "" is different from client address found in dynamic file: "" + qs.clientAddr);
+        }
+        if (qs != null && qs.clientAddr != null) clientPortAddress = qs.clientAddr;
+    }
+
+    private void setupPeerType() {
+        // Warn about inconsistent peer type
+        LearnerType roleByServersList = quorumVerifier.getObservingMembers().containsKey(serverId) ? LearnerType.OBSERVER
+                : LearnerType.PARTICIPANT;
+        if (roleByServersList != peerType) {
+            LOG.warn(""Peer type from servers list ("" + roleByServersList
+                    + "") doesn't match peerType ("" + peerType
+                    + ""). Defaulting to servers list."");
+
+            peerType = roleByServersList;
+        }
+    }
 
     public void checkValidity() throws IOException, ConfigException{
-       int numMembers = quorumVerifier.getVotingMembers().size();
-       if (numMembers > 1  || (!standaloneEnabled && numMembers > 0)) {
-           if (initLimit == 0) {
-               throw new IllegalArgumentException(""initLimit is not set"");
-           }
-           if (syncLimit == 0) {
-               throw new IllegalArgumentException(""syncLimit is not set"");
-           }
-            
-                                     
-            File myIdFile = new File(dataDir, ""myid"");
-            if (!myIdFile.exists()) {
-                throw new IllegalArgumentException(myIdFile.toString()
-                        + "" file is missing"");
+        if (isDistributed()) {
+            if (initLimit == 0) {
+                throw new IllegalArgumentException(""initLimit is not set"");
             }
-            BufferedReader br = new BufferedReader(new FileReader(myIdFile));
-            String myIdString;
-            try {
-                myIdString = br.readLine();
-            } finally {
-                br.close();
+            if (syncLimit == 0) {
+                throw new IllegalArgumentException(""syncLimit is not set"");
             }
-            try {
-                serverId = Long.parseLong(myIdString);
-                MDC.put(""myid"", myIdString);
-            } catch (NumberFormatException e) {
-                throw new IllegalArgumentException(""serverid "" + myIdString
-                        + "" is not a number"");
+            if (serverId == UNSET_SERVERID) {
+                throw new IllegalArgumentException(""myid file is missing"");
             }
-
-            QuorumServer qs = quorumVerifier.getAllMembers().get(serverId);
-            if (clientPortAddress!=null && qs!=null && qs.clientAddr!=null){ 
-                if ((!clientPortAddress.getAddress().isAnyLocalAddress()
-                       && !clientPortAddress.equals(qs.clientAddr)) || 
-                   (clientPortAddress.getAddress().isAnyLocalAddress() 
-                       && clientPortAddress.getPort()!=qs.clientAddr.getPort())) 
-                    throw new ConfigException(""client address for this server (id = "" + serverId + "") in static config file is "" + clientPortAddress + "" is different from client address found in dynamic file: "" + qs.clientAddr);
-            }
-            if (qs!=null && qs.clientAddr != null) clientPortAddress = qs.clientAddr;                       
-            
-            // Warn about inconsistent peer type
-            LearnerType roleByServersList = quorumVerifier.getObservingMembers().containsKey(serverId) ? LearnerType.OBSERVER
-                    : LearnerType.PARTICIPANT;
-            if (roleByServersList != peerType) {
-                LOG.warn(""Peer type from servers list ("" + roleByServersList
-                        + "") doesn't match peerType ("" + peerType
-                        + ""). Defaulting to servers list."");
-
-                peerType = roleByServersList;
-            }
-           
        }
-
     }
-    
+
     public InetSocketAddress getClientPortAddress() { return clientPortAddress; }
     public File getDataDir() { return dataDir; }
     public File getDataLogDir() { return dataLogDir; }
"
zookeeper,bad9ede36559615bb7eafe8e4d333f2c7c353faa,ZOOKEEPER-1992. Backward compatibility of the static configuration file (Hongchao Deng via Alex Shraer),2014.08.01 14:38:05,Alexander Shraer,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 02604ad..76f0afc 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -1315,7 +1315,7 @@
         connectNewPeers();
         if (writeToDisk) {
             try {
-               QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename + "".next"", null, false, qv);
+                QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename + "".next"", null, false, qv, false);
            } catch(IOException e){
                 LOG.error(""Error closing file: "", e.getMessage());
             }
@@ -1344,7 +1344,9 @@
                     if (configBackwardCompatibility) {
                         setDynamicConfigFilename(configFilename + "".dynamic"");
                     }
-                    QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, configFilename, configBackwardCompatibility, qv);
+                    QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, configFilename,
+                            configBackwardCompatibility, qv,
+                            needEraseClientInfoFromStaticConfig(prevQV, qv));
                     configBackwardCompatibility = false;
                 } catch(IOException e){
                     LOG.error(""Error closing file: "", e.getMessage());     
@@ -1366,11 +1368,19 @@
            setClientAddress(qs.clientAddr);
        }
        return prevQV;
-    }   
+    }
+
+    private boolean needEraseClientInfoFromStaticConfig(QuorumVerifier oldQV,
+            QuorumVerifier newQV) {
+        QuorumServer myOldSpec = oldQV.getAllMembers().get(getId());
+        QuorumServer myNewSpec = newQV.getAllMembers().get(getId());
+        return (myNewSpec != null && myNewSpec.clientAddr != null 
+                     && (myOldSpec == null || myOldSpec.clientAddr == null));
+    }
+
     /**
      * Get an instance of LeaderElection
      */
-
     public Election getElectionAlg(){
         return electionAlg;
     }
"
zookeeper,bad9ede36559615bb7eafe8e4d333f2c7c353faa,ZOOKEEPER-1992. Backward compatibility of the static configuration file (Hongchao Deng via Alex Shraer),2014.08.01 14:38:05,Alexander Shraer,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index a01df53..c4397a1 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -300,9 +300,12 @@
      * @param configFileStr
      * @param configBackwardCompatibilityMode
      * @param qv
+     * @param needEraseStaticClientInfo indicates whether we need to erase the clientPort
+     *                    and clientPortAddress from static config file.
      */
-    public static void writeDynamicConfig(String dynamicConfigFilename, String configFileStr, 
-            boolean configBackwardCompatibilityMode, final QuorumVerifier qv) throws IOException {
+    public static void writeDynamicConfig(String dynamicConfigFilename, String configFileStr,
+            final boolean configBackwardCompatibilityMode, final QuorumVerifier qv,
+            final boolean needEraseStaticClientInfo) throws IOException {
 
         final String actualDynamicConfigFilename = dynamicConfigFilename;
         new AtomicFileWritingIdiom(new File(actualDynamicConfigFilename), new OutputStreamStatement() {
@@ -313,41 +316,68 @@
             }
         });
         // the following is for users who run without a dynamic config file (old config file)
-        // if the configuration changes (reconfiguration executes), we create a dynamic config
-        // file, remove all the dynamic definitions from the config file and add a pointer
+        // we create a dynamic config file, remove all the dynamic definitions from the config file and add a pointer
         // to the config file. The dynamic config file's name will be the same as the config file's
         // with "".dynamic"" appended to it
-       
-        if (configBackwardCompatibilityMode) {
-               File configFile = (new VerifyingFileFactory.Builder(LOG)
-                   .warnForRelativePath()
-                   .failForNonExistingPath()
-                   .build()).create(configFileStr);
-                   
-               final Properties cfg = new Properties();
-               FileInputStream in = new FileInputStream(configFile);
-               try {
-                   cfg.load(in);
-               } finally {
-                   in.close();
-               }
-               new AtomicFileWritingIdiom(new File(configFileStr), new WriterStatement() {
-                   @Override
-                   public void write(Writer out) throws IOException {
-                       for (Entry<Object, Object> entry : cfg.entrySet()) {
-                           String key = entry.getKey().toString().trim();
-                           String value = entry.getValue().toString().trim();    
-                           if (!key.startsWith(""server."") && !key.startsWith(""group"") 
-                                   && !key.startsWith(""weight"") && !key.equals(""clientPort"") && !key.equals(""clientPortAddress"")){
-                               out.write(key.concat(""="").concat(value).concat(""\n""));
-                           }
-                       }                      
-                       out.write(""dynamicConfigFile="".concat(actualDynamicConfigFilename).concat(""\n""));
-                    
-                   }
-               });
-          }
-    } 
+
+        if (!configBackwardCompatibilityMode && !needEraseStaticClientInfo)
+            return;
+
+        editStaticConfig(configFileStr, actualDynamicConfigFilename,
+                configBackwardCompatibilityMode, needEraseStaticClientInfo);
+    }
+
+    private static void editStaticConfig(final String configFileStr,
+                                         final String dynamicFileStr,
+                                         final boolean backwardCompatible,
+                                         final boolean eraseClientPortAddress)
+            throws IOException {
+        // Some tests may not have a static config file.
+        if (configFileStr == null)
+            return;
+
+        File configFile = (new VerifyingFileFactory.Builder(LOG)
+                .warnForRelativePath()
+                .failForNonExistingPath()
+                .build()).create(configFileStr);
+
+        final Properties cfg = new Properties();
+        FileInputStream in = new FileInputStream(configFile);
+        try {
+            cfg.load(in);
+        } finally {
+            in.close();
+        }
+
+        new AtomicFileWritingIdiom(new File(configFileStr), new WriterStatement() {
+            @Override
+            public void write(Writer out) throws IOException {
+                for (Entry<Object, Object> entry : cfg.entrySet()) {
+                    String key = entry.getKey().toString().trim();
+
+                    if (key.startsWith(""server."")
+                        || key.startsWith(""group"")
+                        || key.startsWith(""weight"")
+                        || (eraseClientPortAddress
+                            && (key.startsWith(""clientPort"")
+                                || key.startsWith(""clientPortAddress"")))) {
+                        // not writing them back to static file
+                        continue;
+                    }
+
+                    String value = entry.getValue().toString().trim();
+                    out.write(key.concat(""="").concat(value).concat(""\n""));
+                }
+
+                if ( ! backwardCompatible )
+                    return;
+
+                out.write(""dynamicConfigFile="".concat(dynamicFileStr).concat(""\n""));
+            }
+        });
+    }
+
+
     public static void deleteFile(String filename){        
        File f = new File(filename);
        if (f.exists()) {
@@ -375,7 +405,7 @@
     /**
      * Parse dynamic configuration file and return
      * quorumVerifier for new configuration.
-     * @param zkProp Properties to parse from.
+     * @param dynamicConfigProp Properties to parse from.
      * @throws IOException
      * @throws ConfigException
      */
@@ -467,12 +497,15 @@
 
             QuorumServer qs = quorumVerifier.getAllMembers().get(serverId);
             if (clientPortAddress!=null && qs!=null && qs.clientAddr!=null){ 
-               if ((!clientPortAddress.getAddress().isAnyLocalAddress()
+                if ((!clientPortAddress.getAddress().isAnyLocalAddress()
                        && !clientPortAddress.equals(qs.clientAddr)) || 
                    (clientPortAddress.getAddress().isAnyLocalAddress() 
                        && clientPortAddress.getPort()!=qs.clientAddr.getPort())) 
-               throw new ConfigException(""client address for this server (id = "" + serverId + "") in static config file is "" + clientPortAddress + "" is different from client address found in dynamic file: "" + qs.clientAddr);                    
-           } 
+                    throw new ConfigException(""client address for this server (id = "" + serverId + "") in static config file is "" + clientPortAddress + "" is different from client address found in dynamic file: "" + qs.clientAddr);
+                else {
+                    editStaticConfig(configFileStr, null, false, true);
+                }
+            }
             if (qs!=null && qs.clientAddr != null) clientPortAddress = qs.clientAddr;                       
             
             // Warn about inconsistent peer type
"
zookeeper,693f81bd103d14c80c38609bbc6cddb356310b3d,ZOOKEEPER-1877. Malformed ACL Id can crash server with skipACL=yes (Chris Chen via phunt),2014.07.25 08:31:57,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 7a59c0a..8542790 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -376,10 +376,7 @@
                 String path = createRequest.getPath();
                 String parentPath = validatePathForCreate(path, request.sessionId);
 
-                List<ACL> listACL = removeDuplicates(createRequest.getAcl());
-                if (!fixupACL(request.authInfo, listACL)) {
-                    throw new KeeperException.InvalidACLException(path);
-                }
+                List<ACL> listACL = fixupACL(path, request.authInfo, createRequest.getAcl());
                 ChangeRecord parentRecord = getRecordForPath(parentPath);
 
                 checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo);
@@ -429,10 +426,7 @@
                 String path = createRequest.getPath();
                 String parentPath = validatePathForCreate(path, request.sessionId);
 
-                List<ACL> listACL = removeDuplicates(createRequest.getAcl());
-                if (!fixupACL(request.authInfo, listACL)) {
-                    throw new KeeperException.InvalidACLException(path);
-                }
+                List<ACL> listACL = fixupACL(path, request.authInfo, createRequest.getAcl());
                 ChangeRecord parentRecord = getRecordForPath(parentPath);
 
                 checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo);
@@ -633,10 +627,7 @@
                 if(deserialize)
                     ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);
                 path = setAclRequest.getPath();
-                List<ACL> listACL = removeDuplicates(setAclRequest.getAcl());
-                if (!fixupACL(request.authInfo, listACL)) {
-                    throw new KeeperException.InvalidACLException(path);
-                }
+                List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());
                 nodeRecord = getRecordForPath(path);
                 checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo);
                 newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);
@@ -921,62 +912,57 @@
      * depend on the requestor's authentication information.
      *
      * @param authInfo list of ACL IDs associated with the client connection
-     * @param acl list of ACLs being assigned to the node (create or setACL operation)
-     * @return
+     * @param acls list of ACLs being assigned to the node (create or setACL operation)
+     * @return verified and expanded ACLs
+     * @throws KeeperException.InvalidACLException
      */
-    private boolean fixupACL(List<Id> authInfo, List<ACL> acl) {
-        if (skipACL) {
-            return true;
+    private List<ACL> fixupACL(String path, List<Id> authInfo, List<ACL> acls)
+        throws KeeperException.InvalidACLException {
+        // check for well formed ACLs
+        // This resolves https://issues.apache.org/jira/browse/ZOOKEEPER-1877
+        List<ACL> uniqacls = removeDuplicates(acls);
+        LinkedList<ACL> rv = new LinkedList<ACL>();
+        if (uniqacls == null || uniqacls.size() == 0) {
+            throw new KeeperException.InvalidACLException(path);
         }
-        if (acl == null || acl.size() == 0) {
-            return false;
-        }
-
-        Iterator<ACL> it = acl.iterator();
-        LinkedList<ACL> toAdd = null;
-        while (it.hasNext()) {
-            ACL a = it.next();
+        for (ACL a: uniqacls) {
+            LOG.debug(""Processing ACL: {}"", a);
+            if (a == null) {
+                throw new KeeperException.InvalidACLException(path);
+            }
             Id id = a.getId();
+            if (id == null || id.getScheme() == null) {
+                throw new KeeperException.InvalidACLException(path);
+            }
             if (id.getScheme().equals(""world"") && id.getId().equals(""anyone"")) {
-                // wide open
+                rv.add(a);
             } else if (id.getScheme().equals(""auth"")) {
                 // This is the ""auth"" id, so we have to expand it to the
                 // authenticated ids of the requestor
-                it.remove();
-                if (toAdd == null) {
-                    toAdd = new LinkedList<ACL>();
-                }
                 boolean authIdValid = false;
                 for (Id cid : authInfo) {
                     AuthenticationProvider ap =
                         ProviderRegistry.getProvider(cid.getScheme());
                     if (ap == null) {
                         LOG.error(""Missing AuthenticationProvider for ""
-                                + cid.getScheme());
+                            + cid.getScheme());
                     } else if (ap.isAuthenticated()) {
                         authIdValid = true;
-                        toAdd.add(new ACL(a.getPerms(), cid));
+                        rv.add(new ACL(a.getPerms(), cid));
                     }
                 }
                 if (!authIdValid) {
-                    return false;
+                    throw new KeeperException.InvalidACLException(path);
                 }
             } else {
                 AuthenticationProvider ap = ProviderRegistry.getProvider(id.getScheme());
-                if (ap == null) {
-                    return false;
+                if (ap == null || !ap.isValid(id.getId())) {
+                    throw new KeeperException.InvalidACLException(path);
                 }
-                if (!ap.isValid(id.getId())) {
-                    return false;
-                }
+                rv.add(a);
             }
         }
-        if (toAdd != null) {
-            for (ACL a : toAdd) {
-                acl.add(a);
-            }
-        }
-        return acl.size() > 0;
+        return rv;
     }
 
     public void processRequest(Request request) {
"
zookeeper,892e10f6a45cca0464dae4089265511b7d0b9a38,ZOOKEEPER-1789. 3.4.x observer causes NPE on 3.5.0 (trunk) participants (Alex Shraer via phunt),2014.07.24 02:36:19,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 10e6480..9f2a032 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -231,13 +231,12 @@
      */
     public boolean receiveConnection(Socket sock) {
         Long sid = null, protocolVersion = null;
-        InetSocketAddress electionAddr;
+        InetSocketAddress electionAddr = null;
         try {
             DataInputStream din = new DataInputStream(sock.getInputStream());
             protocolVersion = din.readLong();
             if (protocolVersion >= 0) { // this is a server id and not a protocol version
-               sid = protocolVersion;  
-                electionAddr = self.getVotingView().get(sid).electionAddr;
+                sid = protocolVersion;
             } else {
                 sid = din.readLong();
                 int num_remaining_bytes = din.readInt();
@@ -250,11 +249,9 @@
                         electionAddr = new InetSocketAddress(host_port[0], Integer.parseInt(host_port[1]));                   
                     } else {
                         LOG.error(""Got urecognized protocol version "" + protocolVersion + "" from "" + sid);
-                        electionAddr = null;
                     }
                 } else {
-                   LOG.error(""Read only "" + num_read + "" bytes out of "" + num_remaining_bytes + "" sent by server "" + sid);
-                   electionAddr = null;                
+                   LOG.error(""Read only "" + num_read + "" bytes out of "" + num_remaining_bytes + "" sent by server "" + sid);          
                 }
             } 
             if (sid == QuorumPeer.OBSERVER_ID) {
@@ -289,7 +286,12 @@
              */
             LOG.debug(""Create new connection to server: "" + sid);
             closeSocket(sock);
-            connectOne(sid, electionAddr);
+
+            if (electionAddr != null) {
+                connectOne(sid, electionAddr);
+            } else {
+                connectOne(sid);
+            }
 
             // Otherwise start worker threads to receive data.
         } else {
"
zookeeper,83a012880184b88834a45ad28d5f659c426e69f4,ZOOKEEPER-1973. Jetty Server changes broke ibm6 support (Bill Havanki via phunt),2014.07.22 02:58:36,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/admin/Commands.java b/src/java/main/org/apache/zookeeper/server/admin/Commands.java
index 8691769..ff16c2d 100644
--- a/src/java/main/org/apache/zookeeper/server/admin/Commands.java
+++ b/src/java/main/org/apache/zookeeper/server/admin/Commands.java
@@ -18,8 +18,6 @@
 
 package org.apache.zookeeper.server.admin;
 
-import java.lang.management.ManagementFactory;
-import java.lang.management.OperatingSystemMXBean;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -38,11 +36,10 @@
 import org.apache.zookeeper.server.quorum.Leader;
 import org.apache.zookeeper.server.quorum.LeaderZooKeeperServer;
 import org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer;
+import org.apache.zookeeper.server.util.OSMXBean;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.sun.management.UnixOperatingSystemMXBean;
-
 /**
  * Class containing static methods for registering and running Commands, as well
  * as default Command definitions.
@@ -310,13 +307,9 @@
             response.put(""ephemerals_count"", zkdb.getDataTree().getEphemeralsCount());
             response.put(""approximate_data_size"", zkdb.getDataTree().approximateDataSize());
 
-            OperatingSystemMXBean osMbean = ManagementFactory.getOperatingSystemMXBean();
-            if (osMbean != null && osMbean instanceof UnixOperatingSystemMXBean) {
-                UnixOperatingSystemMXBean unixos = (UnixOperatingSystemMXBean) osMbean;
-
-                response.put(""open_file_descriptor_count"", unixos.getOpenFileDescriptorCount());
-                response.put(""max_file_descriptor_count"", unixos.getMaxFileDescriptorCount());
-            }
+            OSMXBean osMbean = new OSMXBean();
+            response.put(""open_file_descriptor_count"", osMbean.getOpenFileDescriptorCount());
+            response.put(""max_file_descriptor_count"", osMbean.getMaxFileDescriptorCount());
 
             if (zkServer instanceof LeaderZooKeeperServer) {
                 Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();
"
zookeeper,0214cfcdde243e0adf2e81c94bb3d48e25308f2b,ZOOKEEPER-1807. Observers spam each other creating connections to the election addr (Alex Shraer via fpj),2014.07.19 03:48:56,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index e2f0a2e..c06a1c1 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -315,7 +315,7 @@
                          * If it is from a non-voting server (such as an observer or
                          * a non-voting follower), respond right away.
                          */
-                        if(!self.getVotingView().containsKey(response.sid)){
+                        if(!self.getCurrentAndNextConfigVoters().contains(response.sid)) {
                             Vote current = self.getCurrentVote();
                             QuorumVerifier qv = self.getQuorumVerifier();
                             ToSend notmsg = new ToSend(ToSend.mType.notification,
@@ -658,7 +658,7 @@
      * Send notifications to all peers upon a change in our vote
      */
     private void sendNotifications() {
-        for (long sid : self.getAllKnownServerIds()) {
+        for (long sid : self.getCurrentAndNextConfigVoters()) {
             QuorumVerifier qv = self.getQuorumVerifier();
             ToSend notmsg = new ToSend(ToSend.mType.notification,
                     proposedLeader,
@@ -718,31 +718,36 @@
     }
 
     /**
-     * Termination predicate. Given a set of votes, determines if
-     * have sufficient to declare the end of the election round.
-     *
-     *  @param votes    Set of votes
-     *  @param vote        Identifier of the vote received last
+     * Termination predicate. Given a set of votes, determines if have
+     * sufficient to declare the end of the election round.
+     * 
+     * @param votes
+     *            Set of votes
+     * @param vote
+     *            Identifier of the vote received last
      */
-    private boolean termPredicate(
-            HashMap<Long, Vote> votes,
-            Vote vote) {
-
-        HashSet<Long> set = new HashSet<Long>();
+    private boolean termPredicate(HashMap<Long, Vote> votes, Vote vote) {
+        SyncedLearnerTracker voteSet = new SyncedLearnerTracker();
+        voteSet.addQuorumVerifier(self.getQuorumVerifier());
+        if (self.getLastSeenQuorumVerifier() != null
+                && self.getLastSeenQuorumVerifier().getVersion() > self
+                        .getQuorumVerifier().getVersion()) {
+            voteSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());
+        }
 
         /*
-         * First make the views consistent. Sometimes peers will have
-         * different zxids for a server depending on timing.
+         * First make the views consistent. Sometimes peers will have different
+         * zxids for a server depending on timing.
          */
-        for (Map.Entry<Long,Vote> entry : votes.entrySet()) {
-            if (self.getQuorumVerifier().getVotingMembers().containsKey(entry.getKey())
-                    && vote.equals(entry.getValue())){
-                set.add(entry.getKey());
+        for (Map.Entry<Long, Vote> entry : votes.entrySet()) {
+            if (vote.equals(entry.getValue())) {
+                voteSet.addAck(entry.getKey());
             }
         }
 
-        return self.getQuorumVerifier().containsQuorum(set);
+        return voteSet.hasAllQuorums();
     }
+
     /**
      * In the case there is a leader elected, and a quorum supporting
      * this leader, we have to check if the leader has voted and acked
@@ -914,10 +919,10 @@
                     notTimeout = (tmpTimeOut < maxNotificationInterval?
                             tmpTimeOut : maxNotificationInterval);
                     LOG.info(""Notification time out: "" + notTimeout);
-                }
-                else if(self.getVotingView().containsKey(n.sid)) {
+                } 
+                else if (self.getCurrentAndNextConfigVoters().contains(n.sid)) {
                     /*
-                     * Only proceed if the vote comes from a replica in the
+                     * Only proceed if the vote comes from a replica in the current or next
                      * voting view.
                      */
                     switch (n.state) {
"
zookeeper,0214cfcdde243e0adf2e81c94bb3d48e25308f2b,ZOOKEEPER-1807. Observers spam each other creating connections to the election addr (Alex Shraer via fpj),2014.07.19 03:48:56,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 54fd58b..aa9681b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -1107,12 +1107,14 @@
        return getQuorumVerifier().getObservingMembers();
     }
 
-    public synchronized Set<Long> getAllKnownServerIds(){
-       Set<Long> tmp = new HashSet<Long>(getQuorumVerifier().getAllMembers().keySet());
-       if (getLastSeenQuorumVerifier()!=null) {
-           tmp.addAll(getLastSeenQuorumVerifier().getAllMembers().keySet());
-       }
-       return tmp;
+    public synchronized Set<Long> getCurrentAndNextConfigVoters() {
+        Set<Long> voterIds = new HashSet<Long>(getQuorumVerifier()
+                .getVotingMembers().keySet());
+        if (getLastSeenQuorumVerifier() != null) {
+            voterIds.addAll(getLastSeenQuorumVerifier().getVotingMembers()
+                    .keySet());
+        }
+        return voterIds;
     }
     
     /**
"
zookeeper,bcf09c846cc68c85479659cb1b7c1a076af068cb,ZOOKEEPER-1851. Follower and Observer Request Processors Do Not Forward create2 Requests (Chris Chen via rakeshr),2014.07.19 02:46:51,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/TraceFormatter.java b/src/java/main/org/apache/zookeeper/server/TraceFormatter.java
index 70a63d1..582383d 100644
--- a/src/java/main/org/apache/zookeeper/server/TraceFormatter.java
+++ b/src/java/main/org/apache/zookeeper/server/TraceFormatter.java
@@ -35,6 +35,8 @@
             return ""notification"";
         case OpCode.create:
             return ""create"";
+        case OpCode.create2:
+            return ""create2"";
         case OpCode.delete:
             return ""delete"";
         case OpCode.exists:
"
zookeeper,bcf09c846cc68c85479659cb1b7c1a076af068cb,ZOOKEEPER-1851. Follower and Observer Request Processors Do Not Forward create2 Requests (Chris Chen via rakeshr),2014.07.19 02:46:51,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
index c6a94cb..bf90d59 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
@@ -131,6 +131,7 @@
     protected boolean needCommit(Request request) {
         switch (request.type) {
             case OpCode.create:
+            case OpCode.create2:
             case OpCode.delete:
             case OpCode.setData:
             case OpCode.reconfig:
"
zookeeper,bcf09c846cc68c85479659cb1b7c1a076af068cb,ZOOKEEPER-1851. Follower and Observer Request Processors Do Not Forward create2 Requests (Chris Chen via rakeshr),2014.07.19 02:46:51,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
index 30f24d6..8b16d3f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
@@ -82,6 +82,7 @@
                     zks.getFollower().request(request);
                     break;
                 case OpCode.create:
+                case OpCode.create2:
                 case OpCode.delete:
                 case OpCode.setData:
                 case OpCode.reconfig:
"
zookeeper,bcf09c846cc68c85479659cb1b7c1a076af068cb,ZOOKEEPER-1851. Follower and Observer Request Processors Do Not Forward create2 Requests (Chris Chen via rakeshr),2014.07.19 02:46:51,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
index 195e106..8297bce 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
@@ -91,6 +91,7 @@
                     zks.getObserver().request(request);
                     break;
                 case OpCode.create:
+                case OpCode.create2:
                 case OpCode.delete:
                 case OpCode.setData:
                 case OpCode.reconfig:
"
zookeeper,9a97169a433b6eff5c58ff563bbb783c17248fb5,ZOOKEEPER-1683. ZooKeeper client NPE when updating server list on disconnected client (shralex via michim),2014.07.18 05:56:43,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
index f979c03..adb27ee 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
@@ -377,7 +377,12 @@
     @Override
     void testableCloseSocket() throws IOException {
         LOG.info(""testableCloseSocket() called"");
-        ((SocketChannel) sockKey.channel()).socket().close();
+        // sockKey may be concurrently accessed by multiple
+        // threads. We use tmp here to avoid a race condition
+        SelectionKey tmp = sockKey;
+        if (tmp!=null) {
+           ((SocketChannel) tmp.channel()).socket().close();
+        }
     }
 
     @Override
"
zookeeper,9a97169a433b6eff5c58ff563bbb783c17248fb5,ZOOKEEPER-1683. ZooKeeper client NPE when updating server list on disconnected client (shralex via michim),2014.07.18 05:56:43,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
index 92bdf0f..4e03018 100644
--- a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
+++ b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
@@ -152,8 +152,9 @@
 
 
     @Override
-    public boolean updateServerList(Collection<InetSocketAddress> serverAddresses, 
-        InetSocketAddress currentHost) {
+    public synchronized boolean updateServerList(
+            Collection<InetSocketAddress> serverAddresses,
+            InetSocketAddress currentHost) {
         // Resolve server addresses and shuffle them
         List<InetSocketAddress> resolvedList = resolveAndShuffle(serverAddresses);
         if (resolvedList.isEmpty()) {
@@ -162,74 +163,106 @@
         }
         // Check if client's current server is in the new list of servers
         boolean myServerInNewConfig = false;
-        for (InetSocketAddress addr : resolvedList) {
-            if (addr.getPort() == currentHost.getPort() &&
-                    ((addr.getAddress()!=null && currentHost.getAddress()!=null &&
-                      addr.getAddress().equals(currentHost.getAddress()))
-                     || addr.getHostName().equals(currentHost.getHostName()))) {
-                   myServerInNewConfig = true;
-                   break;
-               }
+
+        InetSocketAddress myServer = currentHost;
+
+        // choose ""current"" server according to the client rebalancing algorithm
+        if (reconfigMode) {
+            myServer = next(0);
         }
 
-        synchronized(this) {
-            reconfigMode = true;
+        // if the client is not currently connected to any server
+        if (myServer == null) {
+            // reconfigMode = false (next shouldn't return null).
+            if (lastIndex >= 0) {
+                // take the last server to which we were connected
+                myServer = this.serverAddresses.get(lastIndex);
+            } else {
+                // take the first server on the list
+                myServer = this.serverAddresses.get(0);
+            }
+        }
 
-            newServers.clear();
-            oldServers.clear();
-            // Divide the new servers into oldServers that were in the previous list
-            // and newServers that were not in the previous list
-            for (InetSocketAddress resolvedAddress : resolvedList) {                
-                if (this.serverAddresses.contains(resolvedAddress)) {
-                    oldServers.add(resolvedAddress);
-                } else {
-                    newServers.add(resolvedAddress);
-                }
-            }        
+        for (InetSocketAddress addr : resolvedList) {
+            if (addr.getPort() == myServer.getPort()
+                    && ((addr.getAddress() != null
+                            && myServer.getAddress() != null && addr
+                            .getAddress().equals(myServer.getAddress())) || addr
+                            .getHostName().equals(myServer.getHostName()))) {
+                myServerInNewConfig = true;
+                break;
+            }
+        }
 
-            int numOld = oldServers.size();
-            int numNew = newServers.size();                        
+        reconfigMode = true;
 
-            // number of servers increased
-            if (numOld + numNew > this.serverAddresses.size()) {
-                if (myServerInNewConfig) {
-                    // my server is in new config, but load should be decreased.
-                    // Need to decide if this client
-                    // is moving to one of the new servers
-                    if (sourceOfRandomness.nextFloat() <= (1 - ((float) this.serverAddresses
-                            .size()) / (numOld + numNew))) {
-                        pNew = 1;
-                        pOld = 0;
-                    } else {
-                        // do nothing special - stay with the current server
-                        reconfigMode = false;
-                    }
-                } else {
-                    // my server is not in new config, and load on old servers must
-                    // be decreased, so connect to
-                    // one of the new servers
+        newServers.clear();
+        oldServers.clear();
+        // Divide the new servers into oldServers that were in the previous list
+        // and newServers that were not in the previous list
+        for (InetSocketAddress resolvedAddress : resolvedList) {
+            if (this.serverAddresses.contains(resolvedAddress)) {
+                oldServers.add(resolvedAddress);
+            } else {
+                newServers.add(resolvedAddress);
+            }
+        }
+
+        int numOld = oldServers.size();
+        int numNew = newServers.size();
+
+        // number of servers increased
+        if (numOld + numNew > this.serverAddresses.size()) {
+            if (myServerInNewConfig) {
+                // my server is in new config, but load should be decreased.
+                // Need to decide if this client
+                // is moving to one of the new servers
+                if (sourceOfRandomness.nextFloat() <= (1 - ((float) this.serverAddresses
+                        .size()) / (numOld + numNew))) {
                     pNew = 1;
                     pOld = 0;
-                }
-            } else { // number of servers stayed the same or decreased
-                if (myServerInNewConfig) {
-                    // my server is in new config, and load should be increased, so
-                    // stay with this server and do nothing special
-                    reconfigMode = false;
                 } else {
-                    pOld = ((float) (numOld * (this.serverAddresses.size() - (numOld + numNew))))
-                            / ((numOld + numNew) * (this.serverAddresses.size() - numOld));
-                    pNew = 1 - pOld;
+                    // do nothing special - stay with the current server
+                    reconfigMode = false;
                 }
+            } else {
+                // my server is not in new config, and load on old servers must
+                // be decreased, so connect to
+                // one of the new servers
+                pNew = 1;
+                pOld = 0;
             }
-
-            this.serverAddresses = resolvedList;    
-            currentIndexOld = -1;
-            currentIndexNew = -1; 
-            currentIndex = -1;
-            lastIndex = -1;                
-            return reconfigMode;
+        } else { // number of servers stayed the same or decreased
+            if (myServerInNewConfig) {
+                // my server is in new config, and load should be increased, so
+                // stay with this server and do nothing special
+                reconfigMode = false;
+            } else {
+                pOld = ((float) (numOld * (this.serverAddresses.size() - (numOld + numNew))))
+                        / ((numOld + numNew) * (this.serverAddresses.size() - numOld));
+                pNew = 1 - pOld;
+            }
         }
+
+        if (!reconfigMode) {
+            currentIndex = resolvedList.indexOf(getServerAtCurrentIndex());
+        } else {
+            currentIndex = -1;
+        }
+        this.serverAddresses = resolvedList;
+        currentIndexOld = -1;
+        currentIndexNew = -1;
+        lastIndex = currentIndex;
+        return reconfigMode;
+    }
+
+    public synchronized InetSocketAddress getServerAtIndex(int i) {
+    	if (i < 0 || i >= serverAddresses.size()) return null;
+    	return serverAddresses.get(i);
+    }
+    
+    public synchronized InetSocketAddress getServerAtCurrentIndex() {
+    	return getServerAtIndex(currentIndex);
     }
 
     public synchronized int size() {
@@ -279,7 +312,10 @@
         synchronized(this) {
             if (reconfigMode) {
                 addr = nextHostInReconfigMode();
-                if (addr != null) return addr;                
+                if (addr != null) {
+                	currentIndex = serverAddresses.indexOf(addr);
+                	return addr;                
+                }
                 //tried all servers and couldn't connect
                 reconfigMode = false;
                 needToSleep = (spinDelay > 0);
"
zookeeper,fc71a77591007be0053a6314eca3ebc22602dc3f,"ZOOKEEPER-1863. Race condition in commit processor leading to out of order request completion, xid mismatch on client. (fpj and Dutch T Meyer via camille)",2014.07.16 06:54:32,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
index f07e061..c6a94cb 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
@@ -77,30 +77,30 @@
     /**
      * Requests that we are holding until the commit comes in.
      */
-    private final LinkedBlockingQueue<Request> queuedRequests =
+    protected final LinkedBlockingQueue<Request> queuedRequests =
         new LinkedBlockingQueue<Request>();
 
     /**
      * Requests that have been committed.
      */
-    private final LinkedBlockingQueue<Request> committedRequests =
+    protected final LinkedBlockingQueue<Request> committedRequests =
         new LinkedBlockingQueue<Request>();
 
     /** Request for which we are currently awaiting a commit */
-    private final AtomicReference<Request> nextPending =
+    protected final AtomicReference<Request> nextPending =
         new AtomicReference<Request>();
     /** Request currently being committed (ie, sent off to next processor) */
     private final AtomicReference<Request> currentlyCommitting =
         new AtomicReference<Request>();
 
     /** The number of requests currently being processed */
-    private AtomicInteger numRequestsProcessing = new AtomicInteger(0);
+    protected AtomicInteger numRequestsProcessing = new AtomicInteger(0);
 
     RequestProcessor nextProcessor;
 
-    private volatile boolean stopped = true;
+    protected volatile boolean stopped = true;
     private long workerShutdownTimeoutMS;
-    private WorkerService workerPool;
+    protected WorkerService workerPool;
 
     /**
      * This flag indicates whether we need to wait for a response to come back from the
@@ -181,37 +181,7 @@
                  * came in for the pending request. We can only commit a
                  * request when there is no other request being processed.
                  */
-                if (!stopped && !isProcessingRequest() &&
-                    (request = committedRequests.poll()) != null) {
-                    /*
-                     * We match with nextPending so that we can move to the
-                     * next request when it is committed. We also want to
-                     * use nextPending because it has the cnxn member set
-                     * properly.
-                     */
-                    Request pending = nextPending.get();
-                    if (pending != null &&
-                        pending.sessionId == request.sessionId &&
-                        pending.cxid == request.cxid) {
-                        // we want to send our version of the request.
-                        // the pointer to the connection in the request
-                        pending.setHdr(request.getHdr());
-                        pending.setTxn(request.getTxn());
-                        pending.zxid = request.zxid;
-                        // Set currentlyCommitting so we will block until this
-                        // completes. Cleared by CommitWorkRequest after
-                        // nextProcessor returns.
-                        currentlyCommitting.set(pending);
-                        nextPending.set(null);
-                        sendToNextProcessor(pending);
-                    } else {
-                        // this request came from someone else so just
-                        // send the commit packet
-                        currentlyCommitting.set(request);
-                        sendToNextProcessor(request);
-                    }
-                }
-
+                processCommitted();
             }
         } catch (InterruptedException e) {
             LOG.warn(""Interrupted exception while waiting"", e);
@@ -221,6 +191,56 @@
         LOG.info(""CommitProcessor exited loop!"");
     }
 
+    /*
+     * Separated this method from the main run loop
+     * for test purposes (ZOOKEEPER-1863)
+     */
+    protected void processCommitted() {
+        Request request;
+
+        if (!stopped && !isProcessingRequest() &&
+                (committedRequests.peek() != null)) {
+
+            /*
+             * ZOOKEEPER-1863: continue only if there is no new request
+             * waiting in queuedRequests or it is waiting for a
+             * commit. 
+             */
+            if ( !isWaitingForCommit() && !queuedRequests.isEmpty()) {
+                return;
+            }
+            request = committedRequests.poll();
+
+            /*
+             * We match with nextPending so that we can move to the
+             * next request when it is committed. We also want to
+             * use nextPending because it has the cnxn member set
+             * properly.
+             */
+            Request pending = nextPending.get();
+            if (pending != null &&
+                pending.sessionId == request.sessionId &&
+                pending.cxid == request.cxid) {
+                // we want to send our version of the request.
+                // the pointer to the connection in the request
+                pending.setHdr(request.getHdr());
+                pending.setTxn(request.getTxn());
+                pending.zxid = request.zxid;
+                // Set currentlyCommitting so we will block until this
+                // completes. Cleared by CommitWorkRequest after
+                // nextProcessor returns.
+                currentlyCommitting.set(pending);
+                nextPending.set(null);
+                sendToNextProcessor(pending);
+            } else {
+                // this request came from someone else so just
+                // send the commit packet
+                currentlyCommitting.set(request);
+                sendToNextProcessor(request);
+            }
+        }      
+    }
+
     @Override
     public void start() {
         int numCores = Runtime.getRuntime().availableProcessors();
"
zookeeper,194be4b88e22c017e5649204afa5296128bfbcb5,ZOOKEEPER-1222. getACL should only call DataTree.copyStat when passed in stat is not null (Michi Mutsuzaki via rakeshr),2014.07.09 03:18:31,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 36eed9e..7a060c1 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -1791,6 +1791,8 @@
      *                a comma separated list of new membership (non-incremental reconfiguration)
      * @param fromConfig
      *                version of the current configuration (optional - causes reconfiguration to throw an exception if configuration is no longer current)
+     * @param stat the stat of /zookeeper/config znode will be copied to this
+     *             parameter if not null.
      * @return new configuration
      * @throws InterruptedException If the server transaction is interrupted.
      * @throws KeeperException If the server signals an error with a non-zero error code.     
@@ -1805,7 +1807,9 @@
         if (r.getErr() != 0) {
             throw KeeperException.create(KeeperException.Code.get(r.getErr()), """");
         }
-        DataTree.copyStat(response.getStat(), stat);
+        if (stat != null) {
+            DataTree.copyStat(response.getStat(), stat);
+        }
         return response.getData();
     }
 
@@ -1940,7 +1944,8 @@
      * @param path
      *                the given path for the node
      * @param stat
-     *                the stat of the node will be copied to this parameter.
+     *                the stat of the node will be copied to this parameter if
+     *                not null.
      * @return the ACL array of the given node.
      * @throws InterruptedException If the server transaction is interrupted.
      * @throws KeeperException If the server signals an error with a non-zero error code.
@@ -1964,7 +1969,9 @@
             throw KeeperException.create(KeeperException.Code.get(r.getErr()),
                     clientPath);
         }
-        DataTree.copyStat(response.getStat(), stat);
+        if (stat != null) {
+            DataTree.copyStat(response.getStat(), stat);
+        }
         return response.getAcl();
     }
 
"
zookeeper,5a6535bf410ed223aac075241045ccd807b17b81,ZOOKEEPER-1810. Add version to FLE notifications for trunk Germán Blanco via michim),2014.07.08 12:25:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 5749bdd..e2f0a2e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -95,6 +95,13 @@
 
     static public class Notification {
         /*
+         * Format version, introduced in 3.4.6
+         */
+
+        public final static int CURRENTVERSION = 0x2;
+        int version;
+
+        /*
          * Proposed leader
          */
         long leader;
@@ -125,9 +132,9 @@
          */
         long peerEpoch;
     }
-    
+
     static byte[] dummyData = new byte[0];
-    
+
     /**
      * Messages that a peer wants to send to other peers.
      * These messages can be both Notifications and Acks
@@ -142,16 +149,15 @@
                 long electionEpoch,
                 ServerState state,
                 long sid,
-                long peerEpoch,                
+                long peerEpoch,
                 byte[] configData) {
 
-
             this.leader = leader;
             this.zxid = zxid;
             this.electionEpoch = electionEpoch;
             this.state = state;
             this.sid = sid;
-            this.peerEpoch = peerEpoch;            
+            this.peerEpoch = peerEpoch;
             this.configData = configData;
         }
 
@@ -184,7 +190,7 @@
          * Used to send a QuorumVerifier (configuration info)
          */
         byte[] configData = dummyData;
-        
+
         /*
          * Leader epoch
          */
@@ -201,7 +207,7 @@
      * spawns a new thread.
      */
 
-    private class Messenger {
+    protected class Messenger {
 
         /**
          * Receives messages from instance of QuorumCnxManager on
@@ -223,78 +229,91 @@
                 Message response;
                 while (!stop) {
                     // Sleeps on receive
-                    try{
+                    try {
                         response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);
                         if(response == null) continue;
-                        
+
                         // The current protocol and two previous generations all send at least 28 bytes
                         if (response.buffer.capacity() < 28) {
                             LOG.error(""Got a short response: "" + response.buffer.capacity());
                             continue;
                         }
-                        
+
                         // this is the backwardCompatibility mode in place before ZK-107
                         // It is for a version of the protocol in which we didn't send peer epoch
-                        // With peer epoch the message became 36 bytes
+                        // With peer epoch and version the message became 40 bytes
                         boolean backCompatibility28 = (response.buffer.capacity() == 28);
-                        
-                        // ZK-107 sends the configuration info in every message.
-                        // So messages are 36 bytes + size of configuration info 
-                        // (variable length, shoulld be at the end of the message).
-                        boolean backCompatibility36 = (response.buffer.capacity() == 36);
 
+                        // this is the backwardCompatibility mode for no version information
+                        boolean backCompatibility40 = (response.buffer.capacity() == 40);
+                        
                         response.buffer.clear();
+
+                        // Instantiate Notification and set its attributes
+                        Notification n = new Notification();
+
                         int rstate = response.buffer.getInt();
                         long rleader = response.buffer.getLong();
                         long rzxid = response.buffer.getLong();
                         long relectionEpoch = response.buffer.getLong();
                         long rpeerepoch;
-                        
-                        if(!backCompatibility28){
-                           rpeerepoch = response.buffer.getLong();
-                        } else {
-                            if(LOG.isInfoEnabled()){
-                                LOG.info(""Backward compatibility mode (28 bits), server id: "" + response.sid);
+
+                        int version = 0x0;
+                        if (!backCompatibility28) {
+                            rpeerepoch = response.buffer.getLong();
+                            if (!backCompatibility40) {
+                                /*
+                                 * Version added in 3.4.6
+                                 */
+                                
+                                version = response.buffer.getInt();
+                            } else {
+                                LOG.info(""Backward compatibility mode (36 bits), server id: {}"", response.sid);
                             }
+                        } else {
+                            LOG.info(""Backward compatibility mode (28 bits), server id: {}"", response.sid);
                             rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);
                         }
-                        
+
                         QuorumVerifier rqv = null;
-                        
-                        // check if we have more than 36 bytes. If so extract config info from message.
-                        if(!backCompatibility28 && !backCompatibility36){
-                           byte b[] = new byte[response.buffer.remaining()];
-                           response.buffer.get(b);
+
+                        // check if we have a version that includes config. If so extract config info from message.
+                        if (version > 0x1) {
+                            int configLength = response.buffer.getInt();
+                            byte b[] = new byte[configLength];
+
+                            response.buffer.get(b);
                                                        
-                           synchronized(self){                             
-                               try {
-                                   rqv = self.configFromString(new String(b));
-                                   QuorumVerifier curQV = self.getQuorumVerifier();
-                                   if (rqv.getVersion() > curQV.getVersion()) {
-                                       LOG.info(self.getId() + "" Received version: "" + Long.toHexString(rqv.getVersion()) + "" my version: "" + Long.toHexString(self.getQuorumVerifier().getVersion()));
-                                       self.processReconfig(rqv, null, null, false);
-                                       if (!rqv.equals(curQV)) {
-                                           LOG.info(""restarting leader election"");
-                                           self.shuttingDownLE = true;
-                                           self.getElectionAlg().shutdown();
-                                           break;
+                            synchronized(self) {
+                                try {
+                                    rqv = self.configFromString(new String(b));
+                                    QuorumVerifier curQV = self.getQuorumVerifier();
+                                    if (rqv.getVersion() > curQV.getVersion()) {
+                                        LOG.info(""{} Received version: {} my version: {}"", self.getId(),
+                                                Long.toHexString(rqv.getVersion()),
+                                                Long.toHexString(self.getQuorumVerifier().getVersion()));
+                                        self.processReconfig(rqv, null, null, false);
+                                        if (!rqv.equals(curQV)) {
+                                            LOG.info(""restarting leader election"");
+                                            self.shuttingDownLE = true;
+                                            self.getElectionAlg().shutdown();
+                                            
+                                            break;
                                        }
-                                   }           
-                               } catch (IOException e) {                         
-                                   LOG.error(""Something went wrong while processing config received from "" + response.sid);
+                                    }
+                                } catch (IOException e) {
+                                    LOG.error(""Something went wrong while processing config received from {}"", response.sid);
                                } catch (ConfigException e) {
-                                   LOG.error(""Something went wrong while processing config received from "" + response.sid);
-                               } 
-                          }                                                       
+                                   LOG.error(""Something went wrong while processing config received from {}"", response.sid);
+                               }
+                            }                          
                         } else {
-                            if(LOG.isInfoEnabled()){
-                                LOG.info(""Backward compatibility mode (before reconfig), server id: "" + response.sid);
-                            }
+                            LOG.info(""Backward compatibility mode (before reconfig), server id: {}"", response.sid);
                         }
                        
                         /*
-                         * If it is from a non-voting server (such as an observer or 
-                         * a non-voting follower), respond right away. 
+                         * If it is from a non-voting server (such as an observer or
+                         * a non-voting follower), respond right away.
                          */
                         if(!self.getVotingView().containsKey(response.sid)){
                             Vote current = self.getCurrentVote();
@@ -331,17 +350,18 @@
                             case 3:
                                 ackstate = QuorumPeer.ServerState.OBSERVING;
                                 break;
+                            default:
+                                continue;
                             }
 
-                            // Instantiate Notification and set its attributes
-                            Notification n = new Notification();
                             n.leader = rleader;
                             n.zxid = rzxid;
                             n.electionEpoch = relectionEpoch;
                             n.state = ackstate;
-                            n.sid = response.sid;                            
+                            n.sid = response.sid;
                             n.peerEpoch = rpeerepoch;
-                            n.qv = rqv;                              
+                            n.version = version;
+                            n.qv = rqv;
                             /*
                              * Print notification info
                              */
@@ -383,14 +403,14 @@
                                 Vote current = self.getCurrentVote();
                                 if(ackstate == QuorumPeer.ServerState.LOOKING){
                                     if(LOG.isDebugEnabled()){
-                                        LOG.debug(""Sending new notification. My id =  "" +
-                                                self.getId() + "" recipient="" +
-                                                response.sid + "" zxid=0x"" +
-                                                Long.toHexString(current.getZxid()) +
-                                                "" leader="" + current.getId() + "" config version = "" + 
+                                        LOG.debug(""Sending new notification. My id ={} recipient={} zxid=0x{} leader={} config version = {}"",
+                                                self.getId(),
+                                                response.sid,
+                                                Long.toHexString(current.getZxid()),
+                                                current.getId(),
                                                 Long.toHexString(self.getQuorumVerifier().getVersion()));
                                     }
-                                    
+
                                     QuorumVerifier qv = self.getQuorumVerifier();
                                     ToSend notmsg = new ToSend(
                                             ToSend.mType.notification,
@@ -399,7 +419,7 @@
                                             current.getElectionEpoch(),
                                             self.getPeerState(),
                                             response.sid,
-                                            current.getPeerEpoch(), 
+                                            current.getPeerEpoch(),
                                             qv.toString().getBytes());
                                     sendqueue.offer(notmsg);
                                 }
@@ -414,9 +434,6 @@
             }
         }
 
-    
-  
-
         /**
          * This worker simply dequeues a message to send and
          * and queues it on the manager's queue.
@@ -451,21 +468,13 @@
              *
              * @param m     message to send
              */
-            private void process(ToSend m) {
-                byte requestBytes[] = new byte[36 + m.configData.length];
-                ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);
-
-                /*
-                 * Building notification packet to send
-                 */
-
-                requestBuffer.clear();
-                requestBuffer.putInt(m.state.ordinal());
-                requestBuffer.putLong(m.leader);
-                requestBuffer.putLong(m.zxid);
-                requestBuffer.putLong(m.electionEpoch);
-                requestBuffer.putLong(m.peerEpoch);
-                requestBuffer.put(m.configData);
+            void process(ToSend m) {
+                ByteBuffer requestBuffer = buildMsg(m.state.ordinal(),
+                                                    m.leader,
+                                                    m.zxid,
+                                                    m.electionEpoch,
+                                                    m.peerEpoch,
+                                                    m.configData);
 
                 manager.toSend(m.sid, requestBuffer);
 
@@ -474,6 +483,8 @@
 
         WorkerSender ws;
         WorkerReceiver wr;
+        Thread wsThread = null;
+        Thread wrThread = null;
 
         /**
          * Constructor of class Messenger.
@@ -484,17 +495,23 @@
 
             this.ws = new WorkerSender(manager);
 
-            Thread t = new Thread(this.ws,
+            this.wsThread = new Thread(this.ws,
                     ""WorkerSender[myid="" + self.getId() + ""]"");
-            t.setDaemon(true);
-            t.start();
+            this.wsThread.setDaemon(true);
 
             this.wr = new WorkerReceiver(manager);
 
-            t = new Thread(this.wr,
+            this.wrThread = new Thread(this.wr,
                     ""WorkerReceiver[myid="" + self.getId() + ""]"");
-            t.setDaemon(true);
-            t.start();
+            this.wrThread.setDaemon(true);
+        }
+
+        /**
+         * Starts instances of WorkerSender and WorkerReceiver
+         */
+        void start(){
+            this.wsThread.start();
+            this.wrThread.start();
         }
 
         /**
@@ -522,6 +539,55 @@
         return logicalclock;
     }
 
+    static ByteBuffer buildMsg(int state,
+            long leader,
+            long zxid,
+            long electionEpoch,
+            long epoch) {
+        byte requestBytes[] = new byte[40];
+        ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);
+
+        /*
+         * Building notification packet to send, this is called directly only in tests
+         */
+
+        requestBuffer.clear();
+        requestBuffer.putInt(state);
+        requestBuffer.putLong(leader);
+        requestBuffer.putLong(zxid);
+        requestBuffer.putLong(electionEpoch);
+        requestBuffer.putLong(epoch);
+        requestBuffer.putInt(0x1);
+
+        return requestBuffer;
+    }
+
+    static ByteBuffer buildMsg(int state,
+            long leader,
+            long zxid,
+            long electionEpoch,
+            long epoch,
+            byte[] configData) {
+        byte requestBytes[] = new byte[44 + configData.length];
+        ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);
+
+        /*
+         * Building notification packet to send
+         */
+
+        requestBuffer.clear();
+        requestBuffer.putInt(state);
+        requestBuffer.putLong(leader);
+        requestBuffer.putLong(zxid);
+        requestBuffer.putLong(electionEpoch);
+        requestBuffer.putLong(epoch);
+        requestBuffer.putInt(Notification.CURRENTVERSION);
+        requestBuffer.putInt(configData.length);
+        requestBuffer.put(configData);
+
+        return requestBuffer;
+    }
+
     /**
      * Constructor of FastLeaderElection. It takes two parameters, one
      * is the QuorumPeer object that instantiated this object, and the other
@@ -557,12 +623,17 @@
         this.messenger = new Messenger(manager);
     }
 
+    /**
+     * This method starts the sender and receiver threads.
+     */
+    public void start() {
+        this.messenger.start();
+    }
+
     private void leaveInstance(Vote v) {
         if(LOG.isDebugEnabled()){
-            LOG.debug(""About to leave FLE instance: leader=""
-                + v.getId() + "", zxid=0x"" +
-                Long.toHexString(v.getZxid()) + "", my id="" + self.getId()
-                + "", my state="" + self.getPeerState());
+            LOG.debug(""About to leave FLE instance: leader={}, zxid=0x{}, my id={}, my state={}"",
+                v.getId(), Long.toHexString(v.getZxid()), self.getId(), self.getPeerState());
         }
         recvqueue.clear();
     }
@@ -582,7 +653,6 @@
         messenger.halt();
         LOG.debug(""FLE is down"");
     }
-    
 
     /**
      * Send notifications to all peers upon a change in our vote
@@ -608,14 +678,17 @@
     }
 
     private void printNotification(Notification n){
-        LOG.info(""Notification: "" + n.leader + "" (n.leader), 0x""
+        LOG.info(""Notification: ""
+                + Long.toHexString(n.version) + "" (message format version), ""
+                + n.leader + "" (n.leader), 0x""
                 + Long.toHexString(n.zxid) + "" (n.zxid), 0x""
                 + Long.toHexString(n.electionEpoch) + "" (n.round), "" + n.state
                 + "" (n.state), "" + n.sid + "" (n.sid), 0x""
                 + Long.toHexString(n.peerEpoch) + "" (n.peerEPoch), ""
-                + self.getPeerState() + "" (my state)"" + (n.qv!=null ? (Long.toHexString(n.qv.getVersion()) + "" (n.config version)""):""""));
+                + self.getPeerState() + "" (my state)""
+                + (n.qv!=null ? (Long.toHexString(n.qv.getVersion()) + "" (n.config version)""):""""));
     }
- 
+
 
     /**
      * Check if a pair (server id, zxid) succeeds our
@@ -630,7 +703,7 @@
         if(self.getQuorumVerifier().getWeight(newId) == 0){
             return false;
         }
-        
+
         /*
          * We return true if one of the following three cases hold:
          * 1- New epoch is higher
@@ -638,8 +711,8 @@
          * 3- New epoch is the same as current epoch, new zxid is the same
          *  as current zxid, but server id is higher.
          */
-        
-        return ((newEpoch > curEpoch) || 
+
+        return ((newEpoch > curEpoch) ||
                 ((newEpoch == curEpoch) &&
                 ((newZxid > curZxid) || ((newZxid == curZxid) && (newId > curId)))));
     }
@@ -700,7 +773,7 @@
             else if(votes.get(leader).getState() != ServerState.LEADING) predicate = false;
         } else if(logicalclock != electionEpoch) {
             predicate = false;
-        } 
+        }
 
         return predicate;
     }
@@ -776,7 +849,7 @@
         	}
         else return Long.MIN_VALUE;
     }
-    
+
     /**
      * Starts a new round of leader election. Whenever our QuorumPeer
      * changes its state to LOOKING, this method is invoked, and it
"
zookeeper,5a6535bf410ed223aac075241045ccd807b17b81,ZOOKEEPER-1810. Add version to FLE notifications for trunk Germán Blanco via michim),2014.07.08 12:25:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index c1ef8cd..a273a67 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -70,7 +70,7 @@
     // stale notifications to peers
     static final int SEND_CAPACITY = 1;
 
-    static final int PACKETMAXSIZE = 1024 * 1024; 
+    static final int PACKETMAXSIZE = 1024 * 512;
     /*
      * Maximum number of attempts to connect to a peer
      */
"
zookeeper,5a6535bf410ed223aac075241045ccd807b17b81,ZOOKEEPER-1810. Add version to FLE notifications for trunk Germán Blanco via michim),2014.07.08 12:25:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index b7d56f4..4ec1f9a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -810,7 +810,9 @@
             QuorumCnxManager.Listener listener = qcm.listener;
             if(listener != null){
                 listener.start();
-                le = new FastLeaderElection(this, qcm);
+                FastLeaderElection fle = new FastLeaderElection(this, qcm);
+                fle.start();
+                le = fle;
             } else {
                 LOG.error(""Null listener when initializing cnx manager"");
             }
"
zookeeper,5a6535bf410ed223aac075241045ccd807b17b81,ZOOKEEPER-1810. Add version to FLE notifications for trunk Germán Blanco via michim),2014.07.08 12:25:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Vote.java b/src/java/main/org/apache/zookeeper/server/quorum/Vote.java
index b374f1b..8152c66 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Vote.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Vote.java
@@ -23,7 +23,9 @@
 
 public class Vote {
     
-    public Vote(long id, long zxid) {
+    public Vote(long id,
+                    long zxid) {
+        this.version = 0x0;
         this.id = id;
         this.zxid = zxid;
         this.electionEpoch = -1;
@@ -31,7 +33,10 @@
         this.state = ServerState.LOOKING;
     }
     
-    public Vote(long id, long zxid, long peerEpoch) {
+    public Vote(long id,
+                    long zxid,
+                    long peerEpoch) {
+        this.version = 0x0;
         this.id = id;
         this.zxid = zxid;
         this.electionEpoch = -1;
@@ -39,7 +44,11 @@
         this.state = ServerState.LOOKING;
     }
 
-    public Vote(long id, long zxid, long electionEpoch, long peerEpoch) {
+    public Vote(long id,
+                    long zxid,
+                    long electionEpoch,
+                    long peerEpoch) {
+        this.version = 0x0;
         this.id = id;
         this.zxid = zxid;
         this.electionEpoch = electionEpoch;
@@ -47,7 +56,13 @@
         this.state = ServerState.LOOKING;
     }
     
-    public Vote(long id, long zxid, long electionEpoch, long peerEpoch, ServerState state) {
+    public Vote(int version,
+                    long id,
+                    long zxid,
+                    long electionEpoch,
+                    long peerEpoch,
+                    ServerState state) {
+        this.version = version;
         this.id = id;
         this.zxid = zxid;
         this.electionEpoch = electionEpoch;
@@ -55,6 +70,21 @@
         this.peerEpoch = peerEpoch;
     }
     
+    public Vote(long id,
+                    long zxid,
+                    long electionEpoch,
+                    long peerEpoch,
+                    ServerState state) {
+        this.id = id;
+        this.zxid = zxid;
+        this.electionEpoch = electionEpoch;
+        this.state = state;
+        this.peerEpoch = peerEpoch;
+        this.version = 0x0;
+    }
+
+    final private int version;
+
     final private long id;
     
     final private long zxid;
@@ -63,6 +93,10 @@
     
     final private long peerEpoch;
     
+    public int getVersion() {
+        return version;
+    }
+
     public long getId() {
         return id;
     }
@@ -91,7 +125,10 @@
             return false;
         }
         Vote other = (Vote) o;
-        return (id == other.id && zxid == other.zxid && electionEpoch == other.electionEpoch && peerEpoch == other.peerEpoch);
+        return (id == other.id
+                    && zxid == other.zxid
+                    && electionEpoch == other.electionEpoch
+                    && peerEpoch == other.peerEpoch);
 
     }
 
"
zookeeper,02bec21a44c022ec6f065c5ced17864e58fa1ae8,ZOOKEEPER-1835. dynamic configuration file renaming fails on Windows(Bruno Freudensprung via rakeshr),2014.07.04 11:19:59,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/common/AtomicFileOutputStream.java b/src/java/main/org/apache/zookeeper/common/AtomicFileOutputStream.java
index ecfcad7..26035bf 100644
--- a/src/java/main/org/apache/zookeeper/common/AtomicFileOutputStream.java
+++ b/src/java/main/org/apache/zookeeper/common/AtomicFileOutputStream.java
@@ -68,7 +68,7 @@
         boolean triedToClose = false, success = false;
         try {
             flush();
-            ((FileOutputStream) out).getChannel().force(true);
+            ((FileOutputStream) out).getFD().sync();
 
             triedToClose = true;
             super.close();
"
zookeeper,02bec21a44c022ec6f065c5ced17864e58fa1ae8,ZOOKEEPER-1835. dynamic configuration file renaming fails on Windows(Bruno Freudensprung via rakeshr),2014.07.04 11:19:59,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/common/AtomicFileWritingIdiom.java b/src/java/main/org/apache/zookeeper/common/AtomicFileWritingIdiom.java
new file mode 100644
index 0000000..441ea65
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/common/AtomicFileWritingIdiom.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.common;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+
+/*
+ *  Used to perform an atomic write into a file.
+ *  If there is a failure in the middle of the writing operation, 
+ *  the original file (if it exists) is left intact.
+ *  Based on the org.apache.zookeeper.server.quorum.QuorumPeer.writeLongToFile(...) idiom
+ *  using the HDFS AtomicFileOutputStream class.
+ */
+public class AtomicFileWritingIdiom {
+
+    public static interface OutputStreamStatement {
+
+        public void write(OutputStream os) throws IOException;
+
+    }
+
+    public static interface WriterStatement {
+
+        public void write(Writer os) throws IOException;
+
+    }
+
+    public AtomicFileWritingIdiom(File targetFile, OutputStreamStatement osStmt)  throws IOException {
+        this(targetFile, osStmt, null);
+    }
+
+    public AtomicFileWritingIdiom(File targetFile, WriterStatement wStmt)  throws IOException {
+        this(targetFile, null, wStmt);
+    }
+
+    private AtomicFileWritingIdiom(File targetFile, OutputStreamStatement osStmt, WriterStatement wStmt)  throws IOException {
+        AtomicFileOutputStream out = null;
+        boolean error = true;
+        try {
+            out = new AtomicFileOutputStream(targetFile);
+            if (wStmt == null) {
+                // execute output stream operation
+                osStmt.write(out);
+            } else {
+                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
+                // execute writer operation and flush
+                wStmt.write(bw);
+                bw.flush();
+            }
+            out.flush();
+            // everything went ok
+            error = false;
+        } finally {
+            // nothing interesting to do if out == null
+            if (out != null) {
+                if (error) {
+                    // worst case here the tmp file/resources(fd) are not cleaned up
+                    // and the caller will be notified (IOException)
+                    out.abort();
+                } else {
+                    // if the close operation (rename) fails we'll get notified.
+                    // worst case the tmp file may still exist
+                    IOUtils.closeStream(out);
+                }
+            }
+        }
+    }
+
+}
"
zookeeper,02bec21a44c022ec6f065c5ced17864e58fa1ae8,ZOOKEEPER-1835. dynamic configuration file renaming fails on Windows(Bruno Freudensprung via rakeshr),2014.07.04 11:19:59,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 2dac4ec..b7d56f4 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -28,6 +28,7 @@
 import java.io.OutputStreamWriter;
 import java.io.StringReader;
 import java.io.StringWriter;
+import java.io.Writer;
 import java.net.DatagramPacket;
 import java.net.DatagramSocket;
 import java.net.InetSocketAddress;
@@ -46,7 +47,8 @@
 
 import org.apache.zookeeper.KeeperException.NoNodeException;
 import org.apache.zookeeper.ZooDefs;
-import org.apache.zookeeper.common.AtomicFileOutputStream;
+import org.apache.zookeeper.common.AtomicFileWritingIdiom;
+import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;
 import org.apache.zookeeper.common.HostNameUtils;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
@@ -1488,30 +1490,14 @@
 	 * @param value the long value to write to the named file
 	 * @throws IOException if the file cannot be written atomically
 	 */
-    private void writeLongToFile(String name, long value) throws IOException {
+    private void writeLongToFile(String name, final long value) throws IOException {
         File file = new File(logFactory.getSnapDir(), name);
-        AtomicFileOutputStream out = new AtomicFileOutputStream(file);
-        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
-        boolean aborted = false;
-        try {
-            bw.write(Long.toString(value));
-            bw.flush();
-            
-            out.flush();
-        } catch (IOException e) {
-            LOG.error(""Failed to write new file "" + file, e);
-            // worst case here the tmp file/resources(fd) are not cleaned up
-            //   and the caller will be notified (IOException)
-            aborted = true;
-            out.abort();
-            throw e;
-        } finally {
-            if (!aborted) {
-                // if the close operation (rename) fails we'll get notified.
-                // worst case the tmp file may still exist
-                out.close();
+        new AtomicFileWritingIdiom(file, new WriterStatement() {
+            @Override
+            public void write(Writer bw) throws IOException {
+                bw.write(Long.toString(value));
             }
-        }
+        });
     }
 
     public long getCurrentEpoch() throws IOException {
"
zookeeper,02bec21a44c022ec6f065c5ced17864e58fa1ae8,ZOOKEEPER-1835. dynamic configuration file renaming fails on Windows(Bruno Freudensprung via rakeshr),2014.07.04 11:19:59,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 09e54a5..366908d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -26,6 +26,8 @@
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.io.OutputStream;
+import java.io.Writer;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.Collections;
@@ -36,8 +38,9 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.slf4j.MDC;
-
-
+import org.apache.zookeeper.common.AtomicFileWritingIdiom;
+import org.apache.zookeeper.common.AtomicFileWritingIdiom.OutputStreamStatement;
+import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
 import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
@@ -299,74 +302,55 @@
      * @param qv
      */
     public static void writeDynamicConfig(String dynamicConfigFilename, String configFileStr, 
-            boolean configBackwardCompatibilityMode, QuorumVerifier qv) throws IOException {                             
-        FileOutputStream outConfig = null;
-       try {
-           byte b[] = qv.toString().getBytes();                                            
-           if (configBackwardCompatibilityMode) {
-               dynamicConfigFilename = configFileStr + "".dynamic"";
-           }
-           String tmpFilename = dynamicConfigFilename + "".tmp"";
-           outConfig = new FileOutputStream(tmpFilename);
-           
-           outConfig.write(b);
-           outConfig.close();
-           File curFile = new File(dynamicConfigFilename);
-           File tmpFile = new File(tmpFilename);
-           if (!tmpFile.renameTo(curFile)) {
-               throw new IOException(""renaming "" + tmpFile.toString() + "" to "" + curFile.toString() + "" failed!"");
-           }
-       } finally{
-           if (outConfig!=null) { 
-               outConfig.close();
-           }
-       }
-       // the following is for users who run without a dynamic config file (old config file)
-       // if the configuration changes (reconfiguration executes), we create a dynamic config
-       // file, remove all the dynamic definitions from the config file and add a pointer
-       // to the config file. The dynamic config file's name will be the same as the config file's
-       // with "".dynamic"" appended to it
+            boolean configBackwardCompatibilityMode, final QuorumVerifier qv) throws IOException {
+
+        if (configBackwardCompatibilityMode) {
+            dynamicConfigFilename = configFileStr + "".dynamic"";
+        }
+        final String actualDynamicConfigFilename = dynamicConfigFilename;
+        new AtomicFileWritingIdiom(new File(actualDynamicConfigFilename), new OutputStreamStatement() {
+            @Override
+            public void write(OutputStream outConfig) throws IOException {
+                byte b[] = qv.toString().getBytes();
+                outConfig.write(b);
+            }
+        });
+        // the following is for users who run without a dynamic config file (old config file)
+        // if the configuration changes (reconfiguration executes), we create a dynamic config
+        // file, remove all the dynamic definitions from the config file and add a pointer
+        // to the config file. The dynamic config file's name will be the same as the config file's
+        // with "".dynamic"" appended to it
        
         if (configBackwardCompatibilityMode) {
-           BufferedWriter out = null;
-               try {
-                   File configFile = (new VerifyingFileFactory.Builder(LOG)
-                       .warnForRelativePath()
-                       .failForNonExistingPath()
-                       .build()).create(configFileStr);
-                       
-                   Properties cfg = new Properties();
-                   FileInputStream in = new FileInputStream(configFile);
-                   try {
-                       cfg.load(in);
-                   } finally {
-                       in.close();
-                   }
-                   String tmpFilename = configFileStr + "".tmp"";                    
-                   FileWriter fstream = new FileWriter(tmpFilename);
-                   out = new BufferedWriter(fstream);                 
+               File configFile = (new VerifyingFileFactory.Builder(LOG)
+                   .warnForRelativePath()
+                   .failForNonExistingPath()
+                   .build()).create(configFileStr);
                    
-                   for (Entry<Object, Object> entry : cfg.entrySet()) {
-                       String key = entry.getKey().toString().trim();
-                       String value = entry.getValue().toString().trim();    
-                       if (!key.startsWith(""server."") && !key.startsWith(""group"") 
-                               && !key.startsWith(""weight"") && !key.equals(""clientPort"") && !key.equals(""clientPortAddress"")){
-                           out.write(key.concat(""="").concat(value).concat(""\n""));
-                       }
-                   }                      
-                   out.write(""dynamicConfigFile="".concat(dynamicConfigFilename).concat(""\n""));
-                   out.close();
-                   File tmpFile = new File(tmpFilename);
-                   if (!tmpFile.renameTo(configFile)) {
-                       throw new IOException(""renaming "" + tmpFile.toString() + "" to "" + configFile.toString() + "" failed!"");
-                   }
-               } finally{
-                   if (out!=null) {
-                           out.close();
-                   }
+               final Properties cfg = new Properties();
+               FileInputStream in = new FileInputStream(configFile);
+               try {
+                   cfg.load(in);
+               } finally {
+                   in.close();
                }
-           }
-   } 
+               new AtomicFileWritingIdiom(new File(configFileStr), new WriterStatement() {
+                   @Override
+                   public void write(Writer out) throws IOException {
+                       for (Entry<Object, Object> entry : cfg.entrySet()) {
+                           String key = entry.getKey().toString().trim();
+                           String value = entry.getValue().toString().trim();    
+                           if (!key.startsWith(""server."") && !key.startsWith(""group"") 
+                                   && !key.startsWith(""weight"") && !key.equals(""clientPort"") && !key.equals(""clientPortAddress"")){
+                               out.write(key.concat(""="").concat(value).concat(""\n""));
+                           }
+                       }                      
+                       out.write(""dynamicConfigFile="".concat(actualDynamicConfigFilename).concat(""\n""));
+                    
+                   }
+               });
+          }
+    } 
     public static void deleteFile(String filename){        
        File f = new File(filename);
        if (f.exists()) {
"
zookeeper,6abd85938f450587ec1c8973176261fb60a6838b,ZOOKEEPER-1900,2014.07.01 02:11:54,Alexander Shraer,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 598cb23..6e1ee18 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -378,6 +378,11 @@
         try {
             itr = new FileTxnIterator(this.logDir, zxid);
             PositionInputStream input = itr.inputStream;
+            if(input == null) {
+                throw new IOException(""No log files found to truncate! This could "" +
+                        ""happen if you still have snapshots from an old setup or "" +
+                        ""log files were deleted accidentally or dataLogDir was changed in zoo.cfg."");
+            }
             long pos = input.getPosition();
             // now, truncate at the current position
             RandomAccessFile raf=new RandomAccessFile(itr.logFile,""rw"");
"
zookeeper,6abd85938f450587ec1c8973176261fb60a6838b,ZOOKEEPER-1900,2014.07.01 02:11:54,Alexander Shraer,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
index 8c55443..2ca8d20 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
@@ -82,7 +82,7 @@
                     readPacket(qp);
                     processPacket(qp);
                 }
-            } catch (IOException e) {
+            } catch (Exception e) {
                 LOG.warn(""Exception when observing the leader"", e);
                 try {
                     sock.close();
"
zookeeper,8cfb9a0efa5c8934eb3c95ca69566c718a37d9ca,ZOOKEEPER-1576. Zookeeper cluster - failed to connect to cluster if one of the    provided IPs causes java.net.UnknownHostException (Edward Ribeiro via camille),2014.06.28 06:47:49,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/client/HostProvider.java b/src/java/main/org/apache/zookeeper/client/HostProvider.java
index a07af7e..c47fd82 100644
--- a/src/java/main/org/apache/zookeeper/client/HostProvider.java
+++ b/src/java/main/org/apache/zookeeper/client/HostProvider.java
@@ -67,6 +67,6 @@
      * @param currentHost the host to which this client is currently connected
      * @return true if changing connections is necessary for load-balancing, false otherwise  
      */
-	boolean updateServerList(Collection<InetSocketAddress> serverAddresses, InetSocketAddress currentHost)
-			throws UnknownHostException;
+    boolean updateServerList(Collection<InetSocketAddress> serverAddresses,
+        InetSocketAddress currentHost);
 }
"
zookeeper,8cfb9a0efa5c8934eb3c95ca69566c718a37d9ca,ZOOKEEPER-1576. Zookeeper cluster - failed to connect to cluster if one of the    provided IPs causes java.net.UnknownHostException (Edward Ribeiro via camille),2014.06.28 06:47:49,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
index 54c5d44..92bdf0f 100644
--- a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
+++ b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
@@ -68,12 +68,10 @@
      * 
      * @param serverAddresses
      *            possibly unresolved ZooKeeper server addresses
-     * @throws UnknownHostException
      * @throws IllegalArgumentException
      *             if serverAddresses is empty or resolves to an empty list
      */
-    public StaticHostProvider(Collection<InetSocketAddress> serverAddresses)
-            throws UnknownHostException {
+    public StaticHostProvider(Collection<InetSocketAddress> serverAddresses) {
        sourceOfRandomness = new Random(System.currentTimeMillis() ^ this.hashCode());
 
         this.serverAddresses = resolveAndShuffle(serverAddresses);
@@ -92,12 +90,11 @@
      * @param serverAddresses
      *            possibly unresolved ZooKeeper server addresses
      * @param randomnessSeed a seed used to initialize sourceOfRandomnes
-     * @throws UnknownHostException
      * @throws IllegalArgumentException
      *             if serverAddresses is empty or resolves to an empty list
      */
-    public StaticHostProvider(Collection<InetSocketAddress> serverAddresses, long randomnessSeed)
-            throws UnknownHostException {
+    public StaticHostProvider(Collection<InetSocketAddress> serverAddresses,
+        long randomnessSeed) {
         sourceOfRandomness = new Random(randomnessSeed);
 
         this.serverAddresses = resolveAndShuffle(serverAddresses);
@@ -109,18 +106,22 @@
         lastIndex = -1;              
     }
 
-    private List<InetSocketAddress> resolveAndShuffle(Collection<InetSocketAddress> serverAddresses)
-            throws UnknownHostException {
+    private List<InetSocketAddress> resolveAndShuffle(Collection<InetSocketAddress> serverAddresses) {
         List<InetSocketAddress> tmpList = new ArrayList<InetSocketAddress>(serverAddresses.size());       
         for (InetSocketAddress address : serverAddresses) {
-            InetAddress ia = address.getAddress();
-            InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():
-                    address.getHostName());
-            for (InetAddress resolvedAddress : resolvedAddresses) {
-                tmpList.add(new InetSocketAddress(InetAddress.getByAddress(
-                                HostNameUtils.getHostString(address),
-                                resolvedAddress.getAddress()),
-                                address.getPort()));
+            try {
+                InetAddress ia = address.getAddress();
+                String addr = (ia != null) ? ia.getHostAddress() :
+                                             address.getHostName();
+                InetAddress resolvedAddresses[] = InetAddress.getAllByName(addr);
+                for (InetAddress resolvedAddress : resolvedAddresses) {
+                    tmpList.add(new InetSocketAddress(InetAddress.getByAddress(
+                                    HostNameUtils.getHostString(address),
+                                    resolvedAddress.getAddress()),
+                                    address.getPort()));
+                }
+            } catch (UnknownHostException ex) {
+                LOG.warn(""No IP address found for server: {}"", address, ex);
             }
         }
         Collections.shuffle(tmpList, sourceOfRandomness);
@@ -151,7 +152,8 @@
 
 
     @Override
-    public boolean updateServerList(Collection<InetSocketAddress> serverAddresses, InetSocketAddress currentHost) throws UnknownHostException {        
+    public boolean updateServerList(Collection<InetSocketAddress> serverAddresses, 
+        InetSocketAddress currentHost) {
         // Resolve server addresses and shuffle them
         List<InetSocketAddress> resolvedList = resolveAndShuffle(serverAddresses);
         if (resolvedList.isEmpty()) {
"
zookeeper,7e262c717d4b99972278ee1e112bdd81dd171c02,ZOOKEEPER-1870. flakey test in StandaloneDisabledTest.startSingleServerTest (Helen Hastings via fpj),2014.06.25 22:04:27,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index d8ba7c2..5749bdd 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -277,6 +277,7 @@
                                            LOG.info(""restarting leader election"");
                                            self.shuttingDownLE = true;
                                            self.getElectionAlg().shutdown();
+                                           break;
                                        }
                                    }           
                                } catch (IOException e) {                         
@@ -573,6 +574,8 @@
     volatile boolean stop;
     public void shutdown(){
         stop = true;
+        proposedLeader = -1;
+        proposedZxid = -1;
         LOG.debug(""Shutting down connection manager"");
         manager.halt();
         LOG.debug(""Shutting down messenger"");
@@ -713,7 +716,7 @@
         proposedEpoch = epoch;
     }
 
-    synchronized Vote getVote(){
+    synchronized public Vote getVote(){
         return new Vote(proposedLeader, proposedZxid, proposedEpoch);
     }
 
"
zookeeper,7e262c717d4b99972278ee1e112bdd81dd171c02,ZOOKEEPER-1870. flakey test in StandaloneDisabledTest.startSingleServerTest (Helen Hastings via fpj),2014.06.25 22:04:27,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 4770a3c..c1ef8cd 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -457,6 +457,12 @@
         LOG.debug(""Halting listener"");
         listener.halt();
         
+        // Wait for the listener to terminate.
+        try {
+            listener.join();
+        } catch (InterruptedException ex) {
+            LOG.warn(""Got interrupted before joining the listener"", ex);
+        }
         softHalt();
     }
    
@@ -551,22 +557,19 @@
                         numRetries = 0;
                     }
                 } catch (IOException e) {
-                    if ( !shutdown ) {
-                        LOG.error(""Exception while listening"", e);
+                    if (shutdown) {
+                        break;
                     }
+                    LOG.error(""Exception while listening"", e);
                     numRetries++;
                     try {
                         ss.close();
                         Thread.sleep(1000);
                     } catch (IOException ie) {
-                        if ( !shutdown ) {
-                            LOG.error(""Error closing server socket"", ie);
-                        }
+                        LOG.error(""Error closing server socket"", ie);
                     } catch (InterruptedException ie) {
-                        if ( !shutdown ) {
-                            LOG.error(""Interrupted while sleeping. "" +
-                                ""Ignoring exception"", ie);
-                        }
+                        LOG.error(""Interrupted while sleeping. "" +
+                            ""Ignoring exception"", ie);
                     }
                 }
             }
@@ -576,9 +579,17 @@
                         + ""I won't be able to participate in leader ""
                         + ""election any longer: ""
                         + self.getElectionAddress());
+            } else if (ss != null) {
+                // Clean up for shutdown.
+                try {
+                    ss.close();
+                } catch (IOException ie) {
+                    // Don't log an error for shutdown.
+                    LOG.debug(""Error closing server socket"", ie);
+                }
             }
         }
-        
+
         /**
          * Halts this listener thread.
          */
"
zookeeper,7e262c717d4b99972278ee1e112bdd81dd171c02,ZOOKEEPER-1870. flakey test in StandaloneDisabledTest.startSingleServerTest (Helen Hastings via fpj),2014.06.25 22:04:27,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 2d53f68..0ec6e67 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -1269,6 +1269,7 @@
         if (qvOLD == null || !qvOLD.equals(qvNEW)) {
             LOG.warn(""Restarting Leader Election"");
             getElectionAlg().shutdown();
+            shuttingDownLE = false;
             startLeaderElection();
         }           
     }
"
zookeeper,7a929407de4704f6ed27958075caddc6cb3f6508,ZOOKEEPER-1659. Add JMX support for dynamic reconfiguration (Rakesh R via michim),2014.06.05 05:07:23,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java b/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
index 03f3f06..d200c50 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerBean.java
@@ -18,6 +18,7 @@
 
 package org.apache.zookeeper.server.quorum;
 
+import org.apache.zookeeper.common.HostNameUtils;
 
 /**
  * Implementation of the local peer MBean interface.
@@ -76,4 +77,32 @@
     public int getElectionType() {
         return peer.getElectionType();
     }
+
+    public String getElectionAddress() {
+        return HostNameUtils.getHostString(peer.getElectionAddress()) + "":""
+                + peer.getElectionAddress().getPort();
+    }
+
+    public String getClientAddress() {
+        return HostNameUtils.getHostString(peer.getClientAddress()) + "":""
+                + peer.getClientAddress().getPort();
+    }
+
+    public String getLearnerType(){
+        return peer.getLearnerType().toString();
+    }
+
+    public long getConfigVersion(){
+        return peer.getQuorumVerifier().getVersion();
+    }
+
+    @Override
+    public String getQuorumSystemInfo() {
+        return peer.getQuorumVerifier().toString();
+    }
+
+    @Override
+    public boolean isPartOfEnsemble() {
+        return peer.getView().containsKey(peer.getId());
+    }
 }
"
zookeeper,7a929407de4704f6ed27958075caddc6cb3f6508,ZOOKEEPER-1659. Add JMX support for dynamic reconfiguration (Rakesh R via michim),2014.06.05 05:07:23,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerMXBean.java b/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerMXBean.java
index eedf308..b2ad8db 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerMXBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LocalPeerMXBean.java
@@ -74,4 +74,34 @@
      * @return the election type
      */
     public int getElectionType();
+
+    /**
+     * @return the election address
+     */
+    public String getElectionAddress();
+
+    /**
+     * @return the client address
+     */
+    public String getClientAddress();
+
+    /**
+     * @return the learner type
+     */
+    public String getLearnerType();
+
+    /**
+     * @return the config version
+     */
+    public long getConfigVersion();
+
+    /**
+     * @return the quorum system information
+     */
+    public String getQuorumSystemInfo();
+
+    /**
+     * @return true if quorum peer is part of the ensemble, false otherwise
+     */
+    public boolean isPartOfEnsemble();
 }
"
zookeeper,7a929407de4704f6ed27958075caddc6cb3f6508,ZOOKEEPER-1659. Add JMX support for dynamic reconfiguration (Rakesh R via michim),2014.06.05 05:07:23,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index caf47e0..2d53f68 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -95,7 +95,7 @@
 
     private QuorumBean jmxQuorumBean;
     LocalPeerBean jmxLocalPeerBean;
-    private Set<RemotePeerBean> jmxRemotePeerBean;
+    private Map<Long, RemotePeerBean> jmxRemotePeerBean;
     LeaderElectionBean jmxLeaderElectionBean;
     private QuorumCnxManager qcm;
 
@@ -585,7 +585,7 @@
     public QuorumPeer() {
         super(""QuorumPeer"");
         quorumStats = new QuorumStats(this);
-        jmxRemotePeerBean = new HashSet<RemotePeerBean>();
+        jmxRemotePeerBean = new HashMap<Long, RemotePeerBean>();
     }
 
 
@@ -872,10 +872,10 @@
                         jmxLocalPeerBean = null;
                     }
                 } else {
-                    p = new RemotePeerBean(s);
-                    jmxRemotePeerBean.add((RemotePeerBean) p);
+                    RemotePeerBean rBean = new RemotePeerBean(s);
                     try {
-                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);
+                        MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);
+                        jmxRemotePeerBean.put(s.id, rBean);
                     } catch (Exception e) {
                         LOG.warn(""Failed to register with JMX"", e);
                     }
@@ -1005,7 +1005,7 @@
             instance.unregister(jmxQuorumBean);
             instance.unregister(jmxLocalPeerBean);
 
-            for (RemotePeerBean remotePeerBean : jmxRemotePeerBean) {
+            for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {
                 instance.unregister(remotePeerBean);
             }
 
@@ -1557,9 +1557,11 @@
        initConfigInZKDatabase();
 
        if (prevQV.getVersion() < qv.getVersion() && !prevQV.equals(qv)) {
+           Map<Long, QuorumServer> newMembers = qv.getAllMembers();
+           updateRemotePeerMXBeans(newMembers);
            if (restartLE) restartLeaderElection(prevQV, qv);
 
-           QuorumServer myNewQS = qv.getAllMembers().get(getId());
+           QuorumServer myNewQS = newMembers.get(getId());
            if (myNewQS != null && myNewQS.clientAddr != null
                    && !myNewQS.clientAddr.equals(oldClientAddr)) {
                cnxnFactory.reconfigure(myNewQS.clientAddr);
@@ -1588,7 +1590,41 @@
        return false;
 
    }
-    
+
+    private void updateRemotePeerMXBeans(Map<Long, QuorumServer> newMembers) {
+        Set<Long> existingMembers = new HashSet<Long>(newMembers.keySet());
+        existingMembers.retainAll(jmxRemotePeerBean.keySet());
+        for (Long id : existingMembers) {
+            RemotePeerBean rBean = jmxRemotePeerBean.get(id);
+            rBean.setQuorumServer(newMembers.get(id));
+        }
+
+        Set<Long> joiningMembers = new HashSet<Long>(newMembers.keySet());
+        joiningMembers.removeAll(jmxRemotePeerBean.keySet());
+        joiningMembers.remove(getId()); // remove self as it is local bean
+        for (Long id : joiningMembers) {
+            QuorumServer qs = newMembers.get(id);
+            RemotePeerBean rBean = new RemotePeerBean(qs);
+            try {
+                MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);
+                jmxRemotePeerBean.put(qs.id, rBean);
+            } catch (Exception e) {
+                LOG.warn(""Failed to register with JMX"", e);
+            }
+        }
+
+        Set<Long> leavingMembers = new HashSet<Long>(jmxRemotePeerBean.keySet());
+        leavingMembers.removeAll(newMembers.keySet());
+        for (Long id : leavingMembers) {
+            RemotePeerBean rBean = jmxRemotePeerBean.remove(id);
+            try {
+                MBeanRegistry.getInstance().unregister(rBean);
+            } catch (Exception e) {
+                LOG.warn(""Failed to unregister with JMX"", e);
+            }
+        }
+    }
+
    private boolean updateLearnerType(QuorumVerifier newQV) {        
        //check if I'm an observer in new config
        if (newQV.getObservingMembers().containsKey(getId())) {
"
zookeeper,7a929407de4704f6ed27958075caddc6cb3f6508,ZOOKEEPER-1659. Add JMX support for dynamic reconfiguration (Rakesh R via michim),2014.06.05 05:07:23,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java b/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java
index 5841f6c..a5af465 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerBean.java
@@ -18,8 +18,8 @@
 
 package org.apache.zookeeper.server.quorum;
 
+import org.apache.zookeeper.common.HostNameUtils;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
-import org.apache.zookeeper.server.quorum.QuorumPeer;
 
 /**
  * A remote peer bean only provides limited information about the remote peer,
@@ -31,6 +31,11 @@
     public RemotePeerBean(QuorumPeer.QuorumServer peer){
         this.peer=peer;
     }
+
+    public void setQuorumServer(QuorumPeer.QuorumServer peer) {
+        this.peer = peer;
+    }
+
     public String getName() {
         return ""replica.""+peer.id;
     }
@@ -42,4 +47,17 @@
         return peer.addr.getHostName()+"":""+peer.addr.getPort();
     }
 
+    public String getElectionAddress() {
+        return HostNameUtils.getHostString(peer.electionAddr) + "":""
+                + peer.electionAddr.getPort();
+    }
+
+    public String getClientAddress() {
+        return HostNameUtils.getHostString(peer.clientAddr) + "":""
+                + peer.clientAddr.getPort();
+    }
+
+    public String getLearnerType() {
+        return peer.type.toString();
+    }
 }
"
zookeeper,7a929407de4704f6ed27958075caddc6cb3f6508,ZOOKEEPER-1659. Add JMX support for dynamic reconfiguration (Rakesh R via michim),2014.06.05 05:07:23,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerMXBean.java b/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerMXBean.java
index 1d2ec6b..35d4d08 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerMXBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/RemotePeerMXBean.java
@@ -30,4 +30,19 @@
      * @return IP address of the quorum peer 
      */
     public String getQuorumAddress();
+
+    /**
+     * @return the election address
+     */
+    public String getElectionAddress();
+
+    /**
+     * @return the client address
+     */
+    public String getClientAddress();
+
+    /**
+     * @return the learner type
+     */
+    public String getLearnerType();
 }
"
zookeeper,2e72f47750f3b97e9441fdb30b82dd3914a04ac5,ZOOKEEPER-1699. Forgot to add a new file.,2014.05.22 02:48:37,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/SyncedLearnerTracker.java b/src/java/main/org/apache/zookeeper/server/quorum/SyncedLearnerTracker.java
new file mode 100644
index 0000000..3482fcb
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/quorum/SyncedLearnerTracker.java
@@ -0,0 +1,82 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+
+import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
+
+public class SyncedLearnerTracker {
+
+    protected ArrayList<QuorumVerifierAcksetPair> qvAcksetPairs = 
+                new ArrayList<QuorumVerifierAcksetPair>();
+
+    public void addQuorumVerifier(QuorumVerifier qv) {
+        qvAcksetPairs.add(new QuorumVerifierAcksetPair(qv,
+                new HashSet<Long>(qv.getVotingMembers().size())));
+    }
+
+    public boolean addAck(Long sid) {
+        boolean change = false;
+        for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {
+            if (qvAckset.getQuorumVerifier().getVotingMembers().containsKey(sid)) {
+                qvAckset.getAckset().add(sid);
+                change = true;
+            }
+        }
+        return change;
+    }
+
+    public boolean hasAllQuorums() {
+        for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {
+            if (!qvAckset.getQuorumVerifier().containsQuorum(qvAckset.getAckset()))
+                return false;
+        }
+        return true;
+    }
+        
+    public String ackSetsToString(){
+        StringBuilder sb = new StringBuilder();
+            
+        for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {
+            sb.append(qvAckset.getAckset().toString()).append("","");
+        }
+            
+        return sb.substring(0, sb.length()-1);
+    }
+
+    public static class QuorumVerifierAcksetPair {
+        private final QuorumVerifier qv;
+        private final HashSet<Long> ackset;
+
+        public QuorumVerifierAcksetPair(QuorumVerifier qv, HashSet<Long> ackset) {                
+            this.qv = qv;
+            this.ackset = ackset;
+        }
+
+        public QuorumVerifier getQuorumVerifier() {
+            return this.qv;
+        }
+
+        public HashSet<Long> getAckset() {
+            return this.ackset;
+        }
+    }
+}
"
zookeeper,a8e0d7ba7d9797be3aa021fe23d5aef52ef39b91,ZOOKEEPER-1699. Leader should timeout and give up leadership when losing quorum of last proposed configuration (Alexander Shraer via michim),2014.05.21 06:42:51,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 31922bf..ec1c16e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -62,69 +62,14 @@
         LOG.info(""TCP NoDelay set to: "" + nodelay);
     }
 
-    static public class Proposal {
+    static public class Proposal  extends SyncedLearnerTracker {
         public QuorumPacket packet;
-
-        private ArrayList<QuorumVerifierAcksetPair> qvAcksetPairs = new ArrayList<QuorumVerifierAcksetPair>();
-
         public Request request;
 
         @Override
         public String toString() {
             return packet.getType() + "", "" + packet.getZxid() + "", "" + request;
         }
-
-        public void addQuorumVerifier(QuorumVerifier qv) {
-            qvAcksetPairs.add(new QuorumVerifierAcksetPair(qv,
-                    new HashSet<Long>(qv.getVotingMembers().size())));
-        }
-
-        public boolean addAck(Long sid) {
-            boolean change = false;
-            for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {
-                if (qvAckset.getQuorumVerifier().getVotingMembers().containsKey(sid)) {
-                    qvAckset.getAckset().add(sid);
-                    change = true;
-                }
-            }
-            return change;
-        }
-
-        public boolean hasAllQuorums() {
-            for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {
-                if (!qvAckset.getQuorumVerifier().containsQuorum(qvAckset.getAckset()))
-                    return false;
-            }
-            return true;
-        }
-        
-        public String ackSetsToString(){
-            StringBuilder sb = new StringBuilder();
-            
-            for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {
-                sb.append(qvAckset.getAckset().toString()).append("","");
-            }
-            
-            return sb.substring(0, sb.length()-1);
-        }
-
-        public static class QuorumVerifierAcksetPair {
-            private final QuorumVerifier _qv;
-            private final HashSet<Long> _ackset;
-
-            public QuorumVerifierAcksetPair(QuorumVerifier qv, HashSet<Long> ackset) {                
-                _qv = qv;
-                _ackset = ackset;
-            }
-
-            public QuorumVerifier getQuorumVerifier() {
-                return _qv;
-            }
-
-            public HashSet<Long> getAckset() {
-                return _ackset;
-            }
-        }
     }
 
     final LeaderZooKeeperServer zk;
@@ -585,34 +530,53 @@
             boolean tickSkip = true;
 
             while (true) {
-                Thread.sleep(self.tickTime / 2);
-                if (!tickSkip) {
-                    self.tick++;
-                }
-                HashSet<Long> syncedSet = new HashSet<Long>();
-
-                // lock on the followers when we use it.
-                syncedSet.add(self.getId());
-
-                for (LearnerHandler f : getLearners()) {
-                    // Synced set is used to check we have a supporting quorum, so only
-                    // PARTICIPANT, not OBSERVER, learners should be used
-                    if (f.synced() && self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) {
-                        syncedSet.add(f.getSid());
+                synchronized (this) {
+                    long start = System.currentTimeMillis();
+                    long cur = start;
+                    long end = start + self.tickTime / 2;
+                    while (cur < end) {
+                        wait(end - cur);
+                        cur = System.currentTimeMillis();
                     }
+
+                    if (!tickSkip) {
+                        self.tick++;
+                    }
+
+                    // We use an instance of SyncedLearnerTracker to
+                    // track synced learners to make sure we still have a
+                    // quorum of current (and potentially next pending) view.
+                    SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();
+                    syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());
+                    if (self.getLastSeenQuorumVerifier() != null
+                            && self.getLastSeenQuorumVerifier().getVersion() > self
+                                    .getQuorumVerifier().getVersion()) {
+                        syncedAckSet.addQuorumVerifier(self
+                                .getLastSeenQuorumVerifier());
+                    }
+
+                    syncedAckSet.addAck(self.getId());
+
+                    for (LearnerHandler f : getLearners()) {
+                        if (f.synced()) {
+                            syncedAckSet.addAck(f.getSid());
+                        }
+                    }
+
+                    if (!tickSkip && !syncedAckSet.hasAllQuorums()) {
+                        // Lost quorum of last committed and/or last proposed
+                        // config, shutdown
+                        shutdown(""Not sufficient followers synced, only synced with sids: [ ""
+                                + syncedAckSet.ackSetsToString() + "" ]"");
+                        // make sure the order is the same!
+                        // the leader goes to looking
+                        return;
+                    }
+                    tickSkip = !tickSkip;
+                }
+                for (LearnerHandler f : getLearners()) {
                     f.ping();
                 }
-
-              if (!tickSkip && !self.getQuorumVerifier().containsQuorum(syncedSet)) {
-                  //if (!tickSkip && syncedCount < self.quorumPeers.size() / 2) {
-                  // Lost quorum, shutdown
-                  shutdown(""Not sufficient followers synced, only synced with sids: [ ""
-                          + getSidSetString(syncedSet) + "" ]"");
-                  // make sure the order is the same!
-                  // the leader goes to looking
-                  return;
-              }
-              tickSkip = !tickSkip;
             }
         } finally {
             zk.unregisterJMX(this);
"
zookeeper,903ce8dff71fb53de27ba2c16563e4ed43bf504e,ZOOKEEPER-1214. QuorumPeer should unregister only its previsously registered MBeans instead of use MBeanRegistry.unregisterAll() method. (César Álvarez Núñez via michim),2014.05.18 12:49:06,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java b/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java
index 895b818..600431e 100644
--- a/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java
+++ b/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java
@@ -19,7 +19,10 @@
 package org.apache.zookeeper.jmx;
 
 import java.lang.management.ManagementFactory;
+import java.util.Collection;
 import java.util.Map;
+import java.util.Set;
+import java.util.HashSet;
 import java.util.concurrent.ConcurrentHashMap;
 
 import javax.management.JMException;
@@ -42,12 +45,11 @@
     
     private static MBeanRegistry instance = new MBeanRegistry(); 
     
+    private final Object LOCK = new Object();
+    
     private Map<ZKMBeanInfo, String> mapBean2Path =
         new ConcurrentHashMap<ZKMBeanInfo, String>();
     
-    private Map<String, ZKMBeanInfo> mapName2Bean =
-        new ConcurrentHashMap<String, ZKMBeanInfo>();
-
     private MBeanServer mBeanServer;
 
     public static MBeanRegistry getInstance() {
@@ -93,9 +95,10 @@
             return;
         ObjectName oname = makeObjectName(path, bean);
         try {
-            mBeanServer.registerMBean(bean, oname);
-            mapBean2Path.put(bean, path);
-            mapName2Bean.put(bean.getName(), bean);
+            synchronized (LOCK) {
+                mBeanServer.registerMBean(bean, oname);
+                mapBean2Path.put(bean, path);
+            }
         } catch (JMException e) {
             LOG.warn(""Failed to register MBean "" + bean.getName());
             throw e;
@@ -107,49 +110,45 @@
      * @param path
      * @param bean
      */
-    private void unregister(String path,ZKMBeanInfo bean) throws JMException {
+    private void unregister(String path,ZKMBeanInfo bean) throws JMException  {
         if(path==null)
             return;
         if (!bean.isHidden()) {
-            try {
-                mBeanServer.unregisterMBean(makeObjectName(path, bean));
-            } catch (JMException e) {
-                LOG.warn(""Failed to unregister MBean "" + bean.getName());
-                throw e;
+            final ObjectName objName = makeObjectName(path, bean);
+            if (LOG.isInfoEnabled()) {
+                LOG.info(""Unregister MBean [{}]"", objName);
+            }
+            synchronized (LOCK) {
+               mBeanServer.unregisterMBean(objName);
             }
         }        
     }
     
     /**
+     * @return a {@link Collection} with the {@link ZKMBeanInfo} instances not
+     *         unregistered. Mainly for testing purposes.
+     */
+    public Set<ZKMBeanInfo> getRegisteredBeans() {
+        return new HashSet<ZKMBeanInfo>(mapBean2Path.keySet());
+    }
+
+    /**
      * Unregister MBean.
      * @param bean
      */
     public void unregister(ZKMBeanInfo bean) {
         if(bean==null)
             return;
-        String path=mapBean2Path.get(bean);
+        String path = mapBean2Path.remove(bean);
         try {
             unregister(path,bean);
         } catch (JMException e) {
-            LOG.warn(""Error during unregister"", e);
+            LOG.warn(""Error during unregister of [{}]"", bean.getName(), e);
+        } catch (Throwable t) {
+            LOG.error(""Unexpected exception during unregister of [{}]. It should be reviewed and fixed."", bean.getName(), t);
         }
-        mapBean2Path.remove(bean);
-        mapName2Bean.remove(bean.getName());
     }
-    /**
-     * Unregister all currently registered MBeans
-     */
-    public void unregisterAll() {
-        for(Map.Entry<ZKMBeanInfo,String> e: mapBean2Path.entrySet()) {
-            try {
-                unregister(e.getValue(), e.getKey());
-            } catch (JMException e1) {
-                LOG.warn(""Error during unregister"", e1);
-            }
-        }
-        mapBean2Path.clear();
-        mapName2Bean.clear();
-    }
+
     /**
      * Generate a filesystem-like path.
      * @param prefix path prefix
"
zookeeper,903ce8dff71fb53de27ba2c16563e4ed43bf504e,ZOOKEEPER-1214. QuorumPeer should unregister only its previsously registered MBeans instead of use MBeanRegistry.unregisterAll() method. (César Álvarez Núñez via michim),2014.05.18 12:49:06,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index abde6c4..caf47e0 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -93,10 +93,11 @@
 public class QuorumPeer extends ZooKeeperThread implements QuorumStats.Provider {
     private static final Logger LOG = LoggerFactory.getLogger(QuorumPeer.class);
 
-    QuorumBean jmxQuorumBean;
+    private QuorumBean jmxQuorumBean;
     LocalPeerBean jmxLocalPeerBean;
+    private Set<RemotePeerBean> jmxRemotePeerBean;
     LeaderElectionBean jmxLeaderElectionBean;
-    QuorumCnxManager qcm = null;
+    private QuorumCnxManager qcm;
 
     /* ZKDatabase is a top level member of quorumpeer
      * which will be used in all the zookeeperservers
@@ -584,6 +585,7 @@
     public QuorumPeer() {
         super(""QuorumPeer"");
         quorumStats = new QuorumStats(this);
+        jmxRemotePeerBean = new HashSet<RemotePeerBean>();
     }
 
 
@@ -871,6 +873,7 @@
                     }
                 } else {
                     p = new RemotePeerBean(s);
+                    jmxRemotePeerBean.add((RemotePeerBean) p);
                     try {
                         MBeanRegistry.getInstance().register(p, jmxQuorumBean);
                     } catch (Exception e) {
@@ -998,13 +1001,17 @@
             }
         } finally {
             LOG.warn(""QuorumPeer main thread exited"");
-            try {
-                MBeanRegistry.getInstance().unregisterAll();
-            } catch (Exception e) {
-                LOG.warn(""Failed to unregister with JMX"", e);
+            MBeanRegistry instance = MBeanRegistry.getInstance();
+            instance.unregister(jmxQuorumBean);
+            instance.unregister(jmxLocalPeerBean);
+
+            for (RemotePeerBean remotePeerBean : jmxRemotePeerBean) {
+                instance.unregister(remotePeerBean);
             }
+
             jmxQuorumBean = null;
             jmxLocalPeerBean = null;
+            jmxRemotePeerBean = null;
         }
     }
 
"
zookeeper,3f8cc1b8a6c754b992aec568b8e71b84f956ecdf,ZOOKEEPER-1797. PurgeTxnLog may delete data logs during roll (Rakesh R via michim),2014.05.18 10:01:55,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
index 35ed069..244ea1b 100644
--- a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
@@ -24,9 +24,7 @@
 import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
 
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
 import org.apache.zookeeper.server.persistence.Util;
@@ -47,10 +45,16 @@
         System.out.println(""\tcount -- the number of old snaps/logs you want to keep"");
         System.exit(1);
     }
-    
+
+    private static final String PREFIX_SNAPSHOT = ""snapshot"";
+    private static final String PREFIX_LOG = ""log"";
+
     /**
-     * purges the snapshot and logs keeping the last num snapshots 
-     * and the corresponding logs.
+     * Purges the snapshot and logs keeping the last num snapshots and the
+     * corresponding logs. If logs are rolling or a new snapshot is created
+     * during this process, these newest N snapshots or any data logs will be
+     * excluded from current purging cycle.
+     *
      * @param dataDir the dir that has the logs
      * @param snapDir the dir that has the snapshots
      * @param num the number of snapshots to keep
@@ -62,38 +66,41 @@
         }
 
         FileTxnSnapLog txnLog = new FileTxnSnapLog(dataDir, snapDir);
-        
-        // found any valid recent snapshots?
-        
-        // files to exclude from deletion
-        Set<File> exc=new HashSet<File>();
+
         List<File> snaps = txnLog.findNRecentSnapshots(num);
-        if (snaps.size() == 0) 
+        retainNRecentSnapshots(txnLog, snaps);
+    }
+
+    // VisibleForTesting
+    static void retainNRecentSnapshots(FileTxnSnapLog txnLog, List<File> snaps) {
+        // found any valid recent snapshots?
+        if (snaps.size() == 0)
             return;
         File snapShot = snaps.get(snaps.size() -1);
-        for (File f: snaps) {
-            exc.add(f);
-        }
-        long zxid = Util.getZxidFromName(snapShot.getName(),""snapshot"");
-        exc.addAll(Arrays.asList(txnLog.getSnapshotLogs(zxid)));
+        final long leastZxidToBeRetain = Util.getZxidFromName(
+                snapShot.getName(), PREFIX_SNAPSHOT);
 
-        final Set<File> exclude=exc;
         class MyFileFilter implements FileFilter{
             private final String prefix;
             MyFileFilter(String prefix){
                 this.prefix=prefix;
             }
             public boolean accept(File f){
-                if(!f.getName().startsWith(prefix) || exclude.contains(f))
+                if(!f.getName().startsWith(prefix + "".""))
                     return false;
+                long fZxid = Util.getZxidFromName(f.getName(), prefix);
+                if (fZxid >= leastZxidToBeRetain) {
+                    return false;
+                }
                 return true;
             }
         }
         // add all non-excluded log files
-        List<File> files=new ArrayList<File>(
-                Arrays.asList(txnLog.getDataDir().listFiles(new MyFileFilter(""log.""))));
+        List<File> files = new ArrayList<File>(Arrays.asList(txnLog
+                .getDataDir().listFiles(new MyFileFilter(PREFIX_LOG))));
         // add all non-excluded snapshot files to the deletion list
-        files.addAll(Arrays.asList(txnLog.getSnapDir().listFiles(new MyFileFilter(""snapshot.""))));
+        files.addAll(Arrays.asList(txnLog.getSnapDir().listFiles(
+                new MyFileFilter(PREFIX_SNAPSHOT))));
         // remove the old files
         for(File f: files)
         {
"
zookeeper,0252993977bb42940aae2088f29a5e4898bcf3da,ZOOKEEPER-1864. quorumVerifier is null when creating a QuorumPeerConfig from parsing a Properties object (Michi Mutsuzaki via rakeshr),2014.05.17 20:23:25,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 7ce36bb..09e54a5 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -115,21 +115,12 @@
             FileInputStream in = new FileInputStream(configFile);
             try {
                 cfg.load(in);
+                configFileStr = path;
             } finally {
                 in.close();
             }
             
             parseProperties(cfg);
-            
-            // backward compatibility - dynamic configuration in the same file as static configuration params
-            // see writeDynamicConfig() - we change the config file to new format if reconfig happens
-            if (dynamicConfigFileStr == null) {
-                configBackwardCompatibilityMode = true;
-                configFileStr = path;                
-                quorumVerifier = parseDynamicConfig(cfg, electionAlg, true, configBackwardCompatibilityMode);
-                checkValidity();                
-            }
-
         } catch (IOException e) {
             throw new ConfigException(""Error processing "" + path, e);
         } catch (IllegalArgumentException e) {
@@ -288,6 +279,16 @@
             throw new IllegalArgumentException(
                     ""minSessionTimeout must not be larger than maxSessionTimeout"");
         }          
+
+        // backward compatibility - dynamic configuration in the same file as
+        // static configuration params see writeDynamicConfig() - we change the
+        // config file to new format if reconfig happens
+        if (dynamicConfigFileStr == null) {
+            configBackwardCompatibilityMode = true;
+            quorumVerifier = parseDynamicConfig(zkProp, electionAlg, true,
+                configBackwardCompatibilityMode);
+            checkValidity();
+        }
     }
     
     /**
"
zookeeper,85aac3dd0b1d925c20bacecc72c3da9940b296c7,ZOOKEEPER-1891. StaticHostProviderTest.testUpdateLoadBalancing times out (Michi Mutsuzaki via rakeshr),2014.05.10 19:42:44,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
index df30914..54c5d44 100644
--- a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
+++ b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
@@ -27,6 +27,7 @@
 import java.util.List;
 import java.util.Random;
 
+import org.apache.zookeeper.common.HostNameUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -116,18 +117,10 @@
             InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():
                     address.getHostName());
             for (InetAddress resolvedAddress : resolvedAddresses) {
-                // If hostName is null but the address is not, we can tell that
-                // the hostName is an literal IP address. Then we can set the host string as the hostname
-                // safely to avoid reverse DNS lookup.
-                // As far as i know, the only way to check if the hostName is null is use toString().
-                // Both the two implementations of InetAddress are final class, so we can trust the return value of
-                // the toString() method.
-                if (resolvedAddress.toString().startsWith(""/"") && resolvedAddress.getAddress() != null) {
-                    tmpList.add(new InetSocketAddress(InetAddress.getByAddress(address.getHostName(),
-                            resolvedAddress.getAddress()), address.getPort()));
-                } else {
-                    tmpList.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
-                }
+                tmpList.add(new InetSocketAddress(InetAddress.getByAddress(
+                                HostNameUtils.getHostString(address),
+                                resolvedAddress.getAddress()),
+                                address.getPort()));
             }
         }
         Collections.shuffle(tmpList, sourceOfRandomness);
"
zookeeper,6b77e2eff3c9f7958a6eeb79ea1654433b274e0e,ZOOKEEPER-1695. Inconsistent error code and type for new errors introduced by dynamic reconfiguration (Michi Mutsuzaki via rakeshr),2014.04.30 11:30:23,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/KeeperException.java b/src/java/main/org/apache/zookeeper/KeeperException.java
index 62f786a..a05f1ab 100644
--- a/src/java/main/org/apache/zookeeper/KeeperException.java
+++ b/src/java/main/org/apache/zookeeper/KeeperException.java
@@ -229,6 +229,20 @@
         public static final int UnknownSession= -12;
 
         /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#NEWCONFIGNOQUORUM}
+         * instead
+         */
+        @Deprecated
+        public static final int NewConfigNoQuorum = -13;
+
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#RECONFIGINPROGRESS}
+         * instead
+         */
+        @Deprecated
+        public static final int ReconfigInProgress= -14;
+
+        /**
          * @deprecated deprecated in 3.1.0, use {@link Code#APIERROR} instead
          */
         @Deprecated
@@ -292,13 +306,7 @@
         // public static final int SessionMoved = -118;       
         
         @Deprecated
-        public static final int NewConfigNoQuorum = -120;
-        
-        @Deprecated
-        public static final int ReconfigInProgress= -121;
-        
-        @Deprecated
-        public static final int EphemeralOnLocalSession = -122;
+        public static final int EphemeralOnLocalSession = -120;
 
     }
 
@@ -376,7 +384,7 @@
         /** Attempt to create ephemeral node on a local session */
         EPHEMERALONLOCALSESSION (EphemeralOnLocalSession),
         /** Attempts to remove a non-existing watcher */
-        NOWATCHER (-123);
+        NOWATCHER (-121);
 
         private static final Map<Integer,Code> lookup
             = new HashMap<Integer,Code>();
"
zookeeper,a1cd9204d298ca9b5b30c2f272d55b306c393271,ZOOKEEPER-1910. RemoveWatches wrongly removes the watcher if multiple watches    exists on a path (Rakesh R via camille),2014.04.29 09:23:58,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/ZooDefs.java b/src/java/main/org/apache/zookeeper/ZooDefs.java
index 2d8d55c..a4fc331 100644
--- a/src/java/main/org/apache/zookeeper/ZooDefs.java
+++ b/src/java/main/org/apache/zookeeper/ZooDefs.java
@@ -61,7 +61,9 @@
 
         public final int reconfig = 16;
 
-        public final int removeWatches = 17;
+        public final int checkWatches = 17;
+
+        public final int removeWatches = 18;
 
         public final int auth = 100;
 
"
zookeeper,a1cd9204d298ca9b5b30c2f272d55b306c393271,ZOOKEEPER-1910. RemoveWatches wrongly removes the watcher if multiple watches    exists on a path (Rakesh R via camille),2014.04.29 09:23:58,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 013d878..36eed9e 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -29,6 +29,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.jute.Record;
 import org.apache.zookeeper.AsyncCallback.ACLCallback;
 import org.apache.zookeeper.AsyncCallback.Children2Callback;
 import org.apache.zookeeper.AsyncCallback.ChildrenCallback;
@@ -50,6 +51,7 @@
 import org.apache.zookeeper.common.StringUtils;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.proto.CheckWatchesRequest;
 import org.apache.zookeeper.proto.Create2Request;
 import org.apache.zookeeper.proto.Create2Response;
 import org.apache.zookeeper.proto.CreateRequest;
@@ -2327,21 +2329,16 @@
     /**
      * For the given znode path, removes the specified watcher of given
      * watcherType.
-     * 
+     *
      * <p>
-     * If watcher is null, all watchers for the given path and watcherType will
-     * be removed. Otherwise only the specified watcher corresponding to the
-     * passed path and watcherType will be removed.
-     * <p>
-     * A successful call guarantees that, the removed watcher won't be
-     * triggered.
-     * <p>
-     * 
+     * Watcher shouldn't be null. A successful call guarantees that, the
+     * removed watcher won't be triggered.
+     * </p>
+     *
      * @param path
      *            - the path of the node
      * @param watcher
-     *            - a concrete watcher or null to remove all watchers for the
-     *            given path and watcherType
+     *            - a concrete watcher
      * @param watcherType
      *            - the type of watcher to be removed
      * @param local
@@ -2354,26 +2351,100 @@
      * @throws KeeperException
      *             if the server signals an error with a non-zero error code.
      * @throws IllegalArgumentException
-     *             if an invalid path is specified
-     * 
+     *             if any of the following is true:
+     *             <ul>
+     *             <li> {@code path} is invalid
+     *             <li> {@code watcher} is null
+     *             </ul>
+     *
      * @since 3.5.0
      */
     public void removeWatches(String path, Watcher watcher,
             WatcherType watcherType, boolean local)
             throws InterruptedException, KeeperException {
+        validateWatcher(watcher);
+        removeWatches(ZooDefs.OpCode.checkWatches, path, watcher,
+                watcherType, local);
+    }
+
+    /**
+     * The asynchronous version of removeWatches.
+     *
+     * @see #removeWatches
+     */
+    public void removeWatches(String path, Watcher watcher,
+            WatcherType watcherType, boolean local, VoidCallback cb, Object ctx) {
+        validateWatcher(watcher);
+        removeWatches(ZooDefs.OpCode.checkWatches, path, watcher,
+                watcherType, local, cb, ctx);
+    }
+
+    /**
+     * For the given znode path, removes all the registered watchers of given
+     * watcherType.
+     *
+     * <p>
+     * A successful call guarantees that, the removed watchers won't be
+     * triggered.
+     * </p>
+     *
+     * @param path
+     *            - the path of the node
+     * @param watcherType
+     *            - the type of watcher to be removed
+     * @param local
+     *            - whether watches can be removed locally when there is no
+     *            server connection
+     * @throws InterruptedException
+     *             if the server transaction is interrupted.
+     * @throws KeeperException.NoWatcher
+     *             if no watcher exists that match the specified parameters
+     * @throws KeeperException
+     *             if the server signals an error with a non-zero error code.
+     * @throws IllegalArgumentException
+     *             if an invalid {@code path} is specified
+     *
+     * @since 3.5.0
+     */
+    public void removeAllWatches(String path, WatcherType watcherType,
+            boolean local) throws InterruptedException, KeeperException {
+
+        removeWatches(ZooDefs.OpCode.removeWatches, path, null, watcherType,
+                local);
+    }
+
+    /**
+     * The asynchronous version of removeAllWatches.
+     *
+     * @see #removeAllWatches
+     */
+    public void removeAllWatches(String path, WatcherType watcherType,
+            boolean local, VoidCallback cb, Object ctx) {
+
+        removeWatches(ZooDefs.OpCode.removeWatches, path, null,
+                watcherType, local, cb, ctx);
+    }
+
+    private void validateWatcher(Watcher watcher) {
+        if (watcher == null) {
+            throw new IllegalArgumentException(
+                    ""Invalid Watcher, shouldn't be null!"");
+        }
+    }
+
+    private void removeWatches(int opCode, String path, Watcher watcher,
+            WatcherType watcherType, boolean local)
+            throws InterruptedException, KeeperException {
         PathUtils.validatePath(path);
         final String clientPath = path;
-        // Validating the existence of watcher.
-        watchManager.containsWatcher(clientPath, watcher, watcherType);
         final String serverPath = prependChroot(clientPath);
-
         WatchDeregistration wcb = new WatchDeregistration(clientPath, watcher,
                 watcherType, local, watchManager);
+
         RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.removeWatches);
-        RemoveWatchesRequest request = new RemoveWatchesRequest();
-        request.setPath(serverPath);
-        request.setType(watcherType.getIntValue());
+        h.setType(opCode);
+        Record request = getRemoveWatchesRequest(opCode, watcherType,
+                serverPath);
 
         ReplyHeader r = cnxn.submitRequest(h, request, null, null, wcb);
         if (r.getErr() != 0) {
@@ -2382,37 +2453,43 @@
         }
     }
 
-    /**
-     * The asynchronous version of removeWatches.
-     * 
-     * @see #removeWatches
-     */
-    public void removeWatches(String path, Watcher watcher,
+    private void removeWatches(int opCode, String path, Watcher watcher,
             WatcherType watcherType, boolean local, VoidCallback cb, Object ctx) {
+        PathUtils.validatePath(path);
         final String clientPath = path;
-        PathUtils.validatePath(clientPath);
-
-        // Validating the existence of watcher.
-        try {
-            watchManager.containsWatcher(clientPath, watcher, watcherType);
-        } catch (NoWatcherException nwe) {
-            LOG.error(""Failed to find watcher!"", nwe);
-            cb.processResult(nwe.code().intValue(), clientPath, ctx);
-            return;
-        }
-
         final String serverPath = prependChroot(clientPath);
         WatchDeregistration wcb = new WatchDeregistration(clientPath, watcher,
                 watcherType, local, watchManager);
+
         RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.removeWatches);
-        RemoveWatchesRequest request = new RemoveWatchesRequest();
-        request.setPath(serverPath);
-        request.setType(watcherType.getIntValue());
+        h.setType(opCode);
+        Record request = getRemoveWatchesRequest(opCode, watcherType,
+                serverPath);
+
         cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, clientPath,
                 serverPath, ctx, null, wcb);
     }
 
+    private Record getRemoveWatchesRequest(int opCode, WatcherType watcherType,
+            final String serverPath) {
+        Record request = null;
+        switch (opCode) {
+        case ZooDefs.OpCode.checkWatches:
+            CheckWatchesRequest chkReq = new CheckWatchesRequest();
+            chkReq.setPath(serverPath);
+            chkReq.setType(watcherType.getIntValue());
+            request = chkReq;
+            break;
+        case ZooDefs.OpCode.removeWatches:
+            RemoveWatchesRequest rmReq = new RemoveWatchesRequest();
+            rmReq.setPath(serverPath);
+            rmReq.setType(watcherType.getIntValue());
+            request = rmReq;
+            break;
+        }
+        return request;
+    }
+
     public States getState() {
         return cnxn.getState();
     }
"
zookeeper,a1cd9204d298ca9b5b30c2f272d55b306c393271,ZOOKEEPER-1910. RemoveWatches wrongly removes the watcher if multiple watches    exists on a path (Rakesh R via camille),2014.04.29 09:23:58,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/cli/RemoveWatchesCommand.java b/src/java/main/org/apache/zookeeper/cli/RemoveWatchesCommand.java
index e9908ff..f63cf0f 100644
--- a/src/java/main/org/apache/zookeeper/cli/RemoveWatchesCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/RemoveWatchesCommand.java
@@ -74,7 +74,7 @@
         boolean local = cl.hasOption(""l"");
 
         try {
-            zk.removeWatches(path, null, wtype, local);
+            zk.removeAllWatches(path, wtype, local);
         } catch (KeeperException.NoWatcherException ex) {
             err.println(ex.getMessage());
             return false;
"
zookeeper,a1cd9204d298ca9b5b30c2f272d55b306c393271,ZOOKEEPER-1910. RemoveWatches wrongly removes the watcher if multiple watches    exists on a path (Rakesh R via camille),2014.04.29 09:23:58,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index afaa6e0..f2a4f86 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -1365,9 +1365,29 @@
         }
     }
 
+    public boolean containsWatcher(String path, WatcherType type, Watcher watcher) {
+        boolean containsWatcher = false;
+        switch (type) {
+        case Children:
+            containsWatcher = this.childWatches.containsWatcher(path, watcher);
+            break;
+        case Data:
+            containsWatcher = this.dataWatches.containsWatcher(path, watcher);
+            break;
+        case Any:
+            if (this.childWatches.containsWatcher(path, watcher)) {
+                containsWatcher = true;
+            }
+            if (this.dataWatches.containsWatcher(path, watcher)) {
+                containsWatcher = true;
+            }
+            break;
+        }
+        return containsWatcher;
+    }
+
     public boolean removeWatch(String path, WatcherType type, Watcher watcher) {
         boolean removed = false;
-
         switch (type) {
         case Children:
             removed = this.childWatches.removeWatcher(path, watcher);
@@ -1384,7 +1404,6 @@
             }
             break;
         }
-
         return removed;
     }
 }
"
zookeeper,a1cd9204d298ca9b5b30c2f272d55b306c393271,ZOOKEEPER-1910. RemoveWatches wrongly removes the watcher if multiple watches    exists on a path (Rakesh R via camille),2014.04.29 09:23:58,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index d5fcb59..a97be4a 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -35,6 +35,7 @@
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.proto.CheckWatchesRequest;
 import org.apache.zookeeper.proto.Create2Response;
 import org.apache.zookeeper.proto.CreateResponse;
 import org.apache.zookeeper.proto.ExistsRequest;
@@ -394,6 +395,21 @@
                 rsp = new GetChildren2Response(children, stat);
                 break;
             }
+            case OpCode.checkWatches: {
+                lastOp = ""CHKW"";
+                CheckWatchesRequest checkWatches = new CheckWatchesRequest();
+                ByteBufferInputStream.byteBuffer2Record(request.request,
+                        checkWatches);
+                WatcherType type = WatcherType.fromInt(checkWatches.getType());
+                boolean containsWatcher = zks.getZKDatabase().containsWatcher(
+                        checkWatches.getPath(), type, cnxn);
+                if (!containsWatcher) {
+                    String msg = String.format(Locale.ENGLISH, ""%s (type: %s)"",
+                            new Object[] { checkWatches.getPath(), type });
+                    throw new KeeperException.NoWatcherException(msg);
+                }
+                break;
+            }
             case OpCode.removeWatches: {
                 lastOp = ""REMW"";
                 RemoveWatchesRequest removeWatches = new RemoveWatchesRequest();
@@ -402,13 +418,11 @@
                 WatcherType type = WatcherType.fromInt(removeWatches.getType());
                 boolean removed = zks.getZKDatabase().removeWatch(
                         removeWatches.getPath(), type, cnxn);
-
                 if (!removed) {
                     String msg = String.format(Locale.ENGLISH, ""%s (type: %s)"",
                             new Object[] { removeWatches.getPath(), type });
                     throw new KeeperException.NoWatcherException(msg);
                 }
-
                 break;
             }
             }
"
zookeeper,a1cd9204d298ca9b5b30c2f272d55b306c393271,ZOOKEEPER-1910. RemoveWatches wrongly removes the watcher if multiple watches    exists on a path (Rakesh R via camille),2014.04.29 09:23:58,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 354cbb2..8e8121f 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -838,6 +838,7 @@
             case OpCode.getChildren2:
             case OpCode.ping:
             case OpCode.setWatches:
+            case OpCode.checkWatches:
             case OpCode.removeWatches:
                 zks.sessionTracker.checkSession(request.sessionId,
                         request.getOwner());
"
zookeeper,a1cd9204d298ca9b5b30c2f272d55b306c393271,ZOOKEEPER-1910. RemoveWatches wrongly removes the watcher if multiple watches    exists on a path (Rakesh R via camille),2014.04.29 09:23:58,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/Request.java b/src/java/main/org/apache/zookeeper/server/Request.java
index 68d8f25..ee01dcf 100644
--- a/src/java/main/org/apache/zookeeper/server/Request.java
+++ b/src/java/main/org/apache/zookeeper/server/Request.java
@@ -150,6 +150,7 @@
         case OpCode.setData:
         case OpCode.setWatches:
         case OpCode.sync:
+        case OpCode.checkWatches:
         case OpCode.removeWatches:
             return true;
         default:
@@ -225,6 +226,8 @@
             return ""error"";
         case OpCode.reconfig:
            return ""reconfig"";
+        case OpCode.checkWatches:
+            return ""checkWatches"";
         case OpCode.removeWatches:
             return ""removeWatches"";
         default:
"
zookeeper,a1cd9204d298ca9b5b30c2f272d55b306c393271,ZOOKEEPER-1910. RemoveWatches wrongly removes the watcher if multiple watches    exists on a path (Rakesh R via camille),2014.04.29 09:23:58,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/WatchManager.java b/src/java/main/org/apache/zookeeper/server/WatchManager.java
index 1a8a7ea..39bf82e 100644
--- a/src/java/main/org/apache/zookeeper/server/WatchManager.java
+++ b/src/java/main/org/apache/zookeeper/server/WatchManager.java
@@ -169,6 +169,32 @@
         }
     }
 
+    /**
+     * Checks the specified watcher exists for the given path
+     *
+     * @param path
+     *            znode path
+     * @param watcher
+     *            watcher object reference
+     * @return true if the watcher exists, false otherwise
+     */
+    synchronized boolean containsWatcher(String path, Watcher watcher) {
+        HashSet<String> paths = watch2Paths.get(watcher);
+        if (paths == null || !paths.contains(path)) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Removes the specified watcher for the given path
+     *
+     * @param path
+     *            znode path
+     * @param watcher
+     *            watcher object reference
+     * @return true if the watcher successfully removed, false otherwise
+     */
     synchronized boolean removeWatcher(String path, Watcher watcher) {
         HashSet<String> paths = watch2Paths.get(watcher);
         if (paths == null || !paths.remove(path)) {
"
zookeeper,a1cd9204d298ca9b5b30c2f272d55b306c393271,ZOOKEEPER-1910. RemoveWatches wrongly removes the watcher if multiple watches    exists on a path (Rakesh R via camille),2014.04.29 09:23:58,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 0b51e52..91d6bce 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -588,6 +588,20 @@
     }
 
     /**
+     * Check whether the given watcher exists in datatree
+     *
+     * @param path
+     *            node to check watcher existence
+     * @param type
+     *            type of watcher
+     * @param watcher
+     *            watcher function
+     */
+    public boolean containsWatcher(String path, WatcherType type, Watcher watcher) {
+        return dataTree.containsWatcher(path, type, watcher);
+    }
+
+    /**
      * Remove watch from the datatree
      * 
      * @param path
"
zookeeper,a6bc130294da3c7473b3d215699b98fac1f2cd7f,ZOOKEEPER-1843. Oddity in ByteBufferInputStream skip (Bill Havanki via michim),2014.04.27 06:16:37,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/ByteBufferInputStream.java b/src/java/main/org/apache/zookeeper/server/ByteBufferInputStream.java
index e5ac120..48d4a8d 100644
--- a/src/java/main/org/apache/zookeeper/server/ByteBufferInputStream.java
+++ b/src/java/main/org/apache/zookeeper/server/ByteBufferInputStream.java
@@ -64,10 +64,10 @@
 
     @Override
     public long skip(long n) throws IOException {
-        long newPos = bb.position() + n;
-        if (newPos > bb.remaining()) {
-            n = bb.remaining();
+        if (n < 0L) {
+            return 0;
         }
+        n = Math.min(n, bb.remaining());
         bb.position(bb.position() + (int) n);
         return n;
     }
"
zookeeper,686dc0204c46081ddcc64d93c20b46803df56d84,ZOOKEEPER-1673. Zookeeper don't support cidr in expression in ACL with ip scheme (Craig Condit via michim),2014.04.26 06:40:28,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/IPAuthenticationProvider.java b/src/java/main/org/apache/zookeeper/server/auth/IPAuthenticationProvider.java
index 192dc06..6f2a81d 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/IPAuthenticationProvider.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/IPAuthenticationProvider.java
@@ -112,6 +112,21 @@
     }
 
     public boolean isValid(String id) {
-        return addr2Bytes(id) != null;
+        String parts[] = id.split(""/"", 2);
+        byte aclAddr[] = addr2Bytes(parts[0]);
+        if (aclAddr == null) {
+            return false;
+        }
+        if (parts.length == 2) {
+            try {
+                int bits = Integer.parseInt(parts[1]);
+                if (bits < 0 || bits > aclAddr.length * 8) {
+                    return false;
+                }
+            } catch (NumberFormatException e) {
+                return false;
+            }
+        }
+        return true;
     }
 }
"
zookeeper,5a882c303de74370c7e57a516b68d07260be9bc3,ZOOKEEPER-1909. removeWatches doesn't return NOWATCHER when there is no watch set (Raul Gutierrez Segales via rakeshr),2014.04.17 15:47:18,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index ad33163..013d878 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -196,7 +196,7 @@
         return cnxn.zooKeeperSaslClient;
     }
 
-    private final ZKWatchManager watchManager = new ZKWatchManager();
+    private final ZKWatchManager watchManager;
 
     List<String> getDataWatches() {
         synchronized(watchManager.dataWatches) {
@@ -374,7 +374,7 @@
             }
         }
 
-        private boolean removeWatches(Map<String, Set<Watcher>> pathVsWatcher,
+        protected boolean removeWatches(Map<String, Set<Watcher>> pathVsWatcher,
                 Watcher watcher, String path, boolean local, int rc,
                 Set<Watcher> removedWatchers) throws KeeperException {
             if (!local && rc != Code.OK.intValue()) {
@@ -707,6 +707,7 @@
         LOG.info(""Initiating client connection, connectString="" + connectString
                 + "" sessionTimeout="" + sessionTimeout + "" watcher="" + watcher);
 
+        watchManager = defaultWatchManager();
         watchManager.defaultWatcher = watcher;
 
         ConnectStringParser connectStringParser = new ConnectStringParser(
@@ -849,6 +850,7 @@
                 + "" sessionPasswd=""
                 + (sessionPasswd == null ? ""<null>"" : ""<hidden>""));
 
+        watchManager = defaultWatchManager();
         watchManager.defaultWatcher = watcher;
        
         ConnectStringParser connectStringParser = new ConnectStringParser(
@@ -867,6 +869,11 @@
         return new ZooKeeperTestable(this, cnxn);
     }
 
+    /* Useful for testing watch handling behavior */
+    protected ZKWatchManager defaultWatchManager() {
+        return new ZKWatchManager();
+    }
+
     /**
      * The session id for this ZooKeeper client instance. The value returned is
      * not valid until the client connects to a server and may change after a
"
zookeeper,5a882c303de74370c7e57a516b68d07260be9bc3,ZOOKEEPER-1909. removeWatches doesn't return NOWATCHER when there is no watch set (Raul Gutierrez Segales via rakeshr),2014.04.17 15:47:18,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 24cc8ff..afaa6e0 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -1365,18 +1365,26 @@
         }
     }
 
-    public void removeWatch(String path, WatcherType type, Watcher watcher) {
+    public boolean removeWatch(String path, WatcherType type, Watcher watcher) {
+        boolean removed = false;
+
         switch (type) {
         case Children:
-            this.childWatches.removeWatcher(path, watcher);
+            removed = this.childWatches.removeWatcher(path, watcher);
             break;
         case Data:
-            this.dataWatches.removeWatcher(path, watcher);
+            removed = this.dataWatches.removeWatcher(path, watcher);
             break;
         case Any:
-            this.childWatches.removeWatcher(path, watcher);
-            this.dataWatches.removeWatcher(path, watcher);
+            if (this.childWatches.removeWatcher(path, watcher)) {
+                removed = true;
+            }
+            if (this.dataWatches.removeWatcher(path, watcher)) {
+                removed = true;
+            }
             break;
         }
+
+        return removed;
     }
 }
"
zookeeper,5a882c303de74370c7e57a516b68d07260be9bc3,ZOOKEEPER-1909. removeWatches doesn't return NOWATCHER when there is no watch set (Raul Gutierrez Segales via rakeshr),2014.04.17 15:47:18,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index 521d7e9..d5fcb59 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -21,6 +21,7 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.List;
+import java.util.Locale;
 
 import org.apache.jute.Record;
 import org.slf4j.Logger;
@@ -399,8 +400,15 @@
                 ByteBufferInputStream.byteBuffer2Record(request.request,
                         removeWatches);
                 WatcherType type = WatcherType.fromInt(removeWatches.getType());
-                zks.getZKDatabase().removeWatch(removeWatches.getPath(), type,
-                        cnxn);
+                boolean removed = zks.getZKDatabase().removeWatch(
+                        removeWatches.getPath(), type, cnxn);
+
+                if (!removed) {
+                    String msg = String.format(Locale.ENGLISH, ""%s (type: %s)"",
+                            new Object[] { removeWatches.getPath(), type });
+                    throw new KeeperException.NoWatcherException(msg);
+                }
+
                 break;
             }
             }
"
zookeeper,5a882c303de74370c7e57a516b68d07260be9bc3,ZOOKEEPER-1909. removeWatches doesn't return NOWATCHER when there is no watch set (Raul Gutierrez Segales via rakeshr),2014.04.17 15:47:18,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/WatchManager.java b/src/java/main/org/apache/zookeeper/server/WatchManager.java
index 1313e15..1a8a7ea 100644
--- a/src/java/main/org/apache/zookeeper/server/WatchManager.java
+++ b/src/java/main/org/apache/zookeeper/server/WatchManager.java
@@ -169,19 +169,21 @@
         }
     }
 
-    synchronized void removeWatcher(String path, Watcher watcher) {
+    synchronized boolean removeWatcher(String path, Watcher watcher) {
         HashSet<String> paths = watch2Paths.get(watcher);
-        if (paths == null) {
-            return;
+        if (paths == null || !paths.remove(path)) {
+            return false;
         }
-        paths.remove(path);
+
         HashSet<Watcher> list = watchTable.get(path);
-        if (list == null) {
-            return;
+        if (list == null || !list.remove(watcher)) {
+            return false;
         }
-        list.remove(watcher);
+
         if (list.size() == 0) {
             watchTable.remove(path);
         }
+
+        return true;
     }
 }
"
zookeeper,5a882c303de74370c7e57a516b68d07260be9bc3,ZOOKEEPER-1909. removeWatches doesn't return NOWATCHER when there is no watch set (Raul Gutierrez Segales via rakeshr),2014.04.17 15:47:18,Rakesh Radhakrishnan,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index d0d84bd..0b51e52 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -597,7 +597,7 @@
      * @param watcher
      *            watcher function to remove
      */
-    public void removeWatch(String path, WatcherType type, Watcher watcher) {
-        dataTree.removeWatch(path, type, watcher);
+    public boolean removeWatch(String path, WatcherType type, Watcher watcher) {
+        return dataTree.removeWatch(path, type, watcher);
     }
 }
"
zookeeper,dcffe61b804ecf6bb007f475fa8d6447ee2bb0f6,ZOOKEEPER-1840. Server tries to connect to itself during dynamic reconfig (Alexander Shraer via michim),2014.04.16 16:06:54,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index a95e3a8..abde6c4 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -1252,7 +1252,7 @@
        if (qcm!=null && getQuorumVerifier()!=null && getLastSeenQuorumVerifier()!=null) {
            Map<Long, QuorumServer> committedView = getQuorumVerifier().getAllMembers();
            for (Entry<Long, QuorumServer> e: getLastSeenQuorumVerifier().getAllMembers().entrySet()){
-               if (!committedView.containsKey(e.getKey())) 
+               if (e.getKey() != getId() && !committedView.containsKey(e.getKey())) 
                    qcm.connectOne(e.getKey(), e.getValue().electionAddr);
            }
         }
"
zookeeper,4d7af83cbc0156cae23b145e85b60f270c241462,ZOOKEEPER-1897. ZK Shell/Cli not processing commands (stack via michim),2014.04.04 07:39:16,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index 1445d9a..0d8b475 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -340,6 +340,9 @@
                     executeLine(line);
                 }
             }
+        } else {
+            // Command line args non-null.  Run what was passed.
+            processCmd(cl);
         }
     }
 
"
zookeeper,256f95f52cd94b6b2e0b24bf69799d79b9011ffa,ZOOKEEPER-1725. Zookeeper Dynamic Conf writes out hostnames when IPs are supplied (Alexander Shraer via michim),2014.04.01 08:56:32,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 39e6b1a..8387d7d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -222,7 +222,7 @@
             StringWriter sw = new StringWriter();            
             //addr should never be null, but just to make sure
             if (addr !=null) { 
-                sw.append(addr.getHostName());
+                sw.append(HostNameUtils.getHostString(addr));
                 sw.append("":"");
                 sw.append(String.valueOf(addr.getPort()));
             }
"
zookeeper,bf399b1cbc94f6d90258be699a3c92525cecfa65,ZOOKEEPER-1894. ObserverTest.testObserver fails consistently. (michim via camille),2014.03.28 09:58:20,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/common/HostNameUtils.java b/src/java/main/org/apache/zookeeper/common/HostNameUtils.java
new file mode 100644
index 0000000..8b88778
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/common/HostNameUtils.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership.  The ASF
+ * licenses this file to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.zookeeper.common;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+
+/**
+ * A class with hostname related utility methods.
+ */
+public class HostNameUtils {
+
+    private HostNameUtils() {
+        // non instantiable and non inheritable
+    }
+
+    /**
+     * Returns the hostname or IP address of {@link java.net.InetSocketAddress}.
+     *
+     * This method returns the IP address if the
+     * {@link java.net.InetSocketAddress} was created with a literal IP address,
+     * and it doesn't perform a reverse DNS lookup. The goal of this method is
+     * to substitute {@link java.net.InetSocketAddress#getHostString()}, which
+     * is only available since Java 7.
+     *
+     * This method checks if the input InetSocketAddress was constructed with a
+     * literal IP address by calling toString() on the underlying
+     * {@link java.net.InetAddress}. It returns a string with the form
+     * ""hostname/literal IP address"", and the hostname part is empty if the
+     * input {@link java.net.InetSocketAddress} was created with an IP address.
+     * There are 2 implementations of {@link java.net.InetAddress},
+     * {@link java.net.Inet4Address} and {@link java.net.Inet6Address}, and both
+     * classes are final, so we can trust the return value of the toString()
+     * method.
+     *
+     * @return the hostname or IP address of {@link java.net.InetSocketAddress}.
+     * @see java.net.InetSocketAddress#getHostString()
+     */
+    public static String getHostString(InetSocketAddress socketAddress) {
+        InetAddress address = socketAddress.getAddress();
+        return (address != null && address.toString().startsWith(""/"")) ?
+               address.getHostAddress() :
+               socketAddress.getHostName();
+    }
+}
"
zookeeper,bf399b1cbc94f6d90258be699a3c92525cecfa65,ZOOKEEPER-1894. ObserverTest.testObserver fails consistently. (michim via camille),2014.03.28 09:58:20,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 6561ccc..39e6b1a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -47,6 +47,7 @@
 import org.apache.zookeeper.KeeperException.NoNodeException;
 import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.common.AtomicFileOutputStream;
+import org.apache.zookeeper.common.HostNameUtils;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
 import org.apache.zookeeper.server.DataNode;
@@ -233,7 +234,9 @@
             else if (type == LearnerType.PARTICIPANT) sw.append("":participant"");            
             if (clientAddr!=null){
                 sw.append("";"");
-                sw.append(clientAddr.getHostName() + "":"" + String.valueOf(clientAddr.getPort()));
+                sw.append(HostNameUtils.getHostString(clientAddr));
+                sw.append("":"");
+                sw.append(String.valueOf(clientAddr.getPort()));
             }
             return sw.toString();       
         }
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 42a1ffa..6daa81e 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -80,6 +80,7 @@
 import org.apache.zookeeper.proto.SetWatches;
 import org.apache.zookeeper.proto.WatcherEvent;
 import org.apache.zookeeper.server.ByteBufferInputStream;
+import org.apache.zookeeper.server.ZooKeeperThread;
 import org.apache.zookeeper.server.ZooTrace;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -418,13 +419,6 @@
 
     private Object eventOfDeath = new Object();
 
-    private final static UncaughtExceptionHandler uncaughtExceptionHandler = new UncaughtExceptionHandler() {
-        @Override
-        public void uncaughtException(Thread t, Throwable e) {
-            LOG.error(""from "" + t.getName(), e);
-        }
-    };
-
     private static class WatcherSetEventPair {
         private final Set<Watcher> watchers;
         private final WatchedEvent event;
@@ -446,7 +440,7 @@
         return name + suffix;
     }
 
-    class EventThread extends Thread {
+    class EventThread extends ZooKeeperThread {
         private final LinkedBlockingQueue<Object> waitingEvents =
             new LinkedBlockingQueue<Object>();
 
@@ -461,7 +455,6 @@
 
         EventThread() {
             super(makeThreadName(""-EventThread""));
-            setUncaughtExceptionHandler(uncaughtExceptionHandler);
             setDaemon(true);
         }
 
@@ -817,7 +810,7 @@
      * This class services the outgoing request queue and generates the heart
      * beats. It also spawns the ReadThread.
      */
-    class SendThread extends Thread {
+    class SendThread extends ZooKeeperThread {
         private long lastPingSentNs;
         private final ClientCnxnSocket clientCnxnSocket;
         private Random r = new Random(System.nanoTime());        
@@ -946,7 +939,6 @@
             super(makeThreadName(""-SendThread()""));
             state = States.CONNECTING;
             this.clientCnxnSocket = clientCnxnSocket;
-            setUncaughtExceptionHandler(uncaughtExceptionHandler);
             setDaemon(true);
         }
 
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
index 7610e31..6e057a5 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
@@ -118,7 +118,7 @@
      * of code shared by the AcceptThread (which selects on the listen socket)
      * and SelectorThread (which selects on client connections) classes.
      */
-    private abstract class AbstractSelectThread extends Thread {
+    private abstract class AbstractSelectThread extends ZooKeeperThread {
         protected final Selector selector;
 
         public AbstractSelectThread(String name) throws IOException {
@@ -561,7 +561,7 @@
      * This thread is responsible for closing stale connections so that
      * connections on which no session is established are properly expired.
      */
-    private class ConnectionExpirerThread extends Thread {
+    private class ConnectionExpirerThread extends ZooKeeperThread {
         ConnectionExpirerThread() {
             super(""ConnnectionExpirer"");
         }
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index a155b9b..e58fc61 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -22,7 +22,6 @@
 import java.io.IOException;
 import java.io.StringReader;
 import java.nio.ByteBuffer;
-import java.util.Arrays;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -32,7 +31,6 @@
 import java.util.Map;
 import java.util.Properties;
 import java.util.Locale;
-import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.LinkedBlockingQueue;
 
@@ -89,7 +87,8 @@
  * outstandingRequests, so that it can take into account transactions that are
  * in the queue to be applied when generating a transaction.
  */
-public class PrepRequestProcessor extends Thread implements RequestProcessor {
+public class PrepRequestProcessor extends ZooKeeperCriticalThread implements
+        RequestProcessor {
     private static final Logger LOG = LoggerFactory.getLogger(PrepRequestProcessor.class);
 
     static boolean skipACL;
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
index 6570a7d..c971b89 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
@@ -36,7 +36,8 @@
  * period. Sessions are thus expired in batches made up of sessions that expire
  * in a given interval.
  */
-public class SessionTrackerImpl extends Thread implements SessionTracker {
+public class SessionTrackerImpl extends ZooKeeperCriticalThread implements
+        SessionTracker {
     private static final Logger LOG = LoggerFactory.getLogger(SessionTrackerImpl.class);
 
     protected final ConcurrentHashMap<Long, SessionImpl> sessionsById =
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index 33a519a..6948b29 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -44,7 +44,8 @@
  *             be null. This change the semantic of txnlog on the observer
  *             since it only contains committed txns.
  */
-public class SyncRequestProcessor extends Thread implements RequestProcessor {
+public class SyncRequestProcessor extends ZooKeeperCriticalThread implements
+        RequestProcessor {
     private static final Logger LOG = LoggerFactory.getLogger(SyncRequestProcessor.class);
     private final ZooKeeperServer zks;
     private final LinkedBlockingQueue<Request> queuedRequests =
@@ -128,7 +129,7 @@
                             if (snapInProcess != null && snapInProcess.isAlive()) {
                                 LOG.warn(""Too busy to snap, skipping"");
                             } else {
-                                snapInProcess = new Thread(""Snapshot Thread"") {
+                                snapInProcess = new ZooKeeperThread(""Snapshot Thread"") {
                                         public void run() {
                                             try {
                                                 zks.takeSnapshot();
@@ -161,9 +162,9 @@
                 }
             }
         } catch (Throwable t) {
-            LOG.error(""Severe unrecoverable error, exiting"", t);
+            super.handleException(this.getName(), t);
+        } finally{
             running = false;
-            System.exit(11);
         }
         LOG.info(""SyncRequestProcessor exited!"");
     }
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/WorkerService.java b/src/java/main/org/apache/zookeeper/server/WorkerService.java
index adff470..c55ff48 100644
--- a/src/java/main/org/apache/zookeeper/server/WorkerService.java
+++ b/src/java/main/org/apache/zookeeper/server/WorkerService.java
@@ -130,14 +130,23 @@
                 workRequest.cleanup();
             }
         } else {
-            scheduledWorkRequest.run();
+            // When there is no worker thread pool, do the work directly
+            // and wait for its completion
+            scheduledWorkRequest.start();
+            try {
+                scheduledWorkRequest.join();
+            } catch (InterruptedException e) {
+                LOG.warn(""Unexpected exception"", e);
+                Thread.currentThread().interrupt();
+            }
         }
     }
 
-    private class ScheduledWorkRequest implements Runnable {
+    private class ScheduledWorkRequest extends ZooKeeperThread {
         private final WorkRequest workRequest;
 
         ScheduledWorkRequest(WorkRequest workRequest) {
+            super(""ScheduledWorkRequest"");
             this.workRequest = workRequest;
         }
 
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperCriticalThread.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperCriticalThread.java
new file mode 100644
index 0000000..138d22e
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperCriticalThread.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Represents critical thread. When there is an uncaught exception thrown by the
+ * thread this will exit the system.
+ */
+public class ZooKeeperCriticalThread extends ZooKeeperThread {
+    private static final Logger LOG = LoggerFactory
+            .getLogger(ZooKeeperCriticalThread.class);
+    private static final int DEFAULT_EXIT_CODE = 1;
+
+    public ZooKeeperCriticalThread(String threadName) {
+        super(threadName);
+    }
+
+    /**
+     * This will be used by the uncaught exception handler and make the system
+     * exit.
+     * 
+     * @param thName
+     *            - thread name
+     * @param e
+     *            - exception object
+     */
+    @Override
+    protected void handleException(String thName, Throwable e) {
+        LOG.error(""Severe unrecoverable error, from thread : {}"", thName, e);
+        System.exit(DEFAULT_EXIT_CODE);
+    }
+}
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperThread.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperThread.java
new file mode 100644
index 0000000..5f11ebc
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperThread.java
@@ -0,0 +1,57 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * This is the main class for catching all the uncaught exceptions thrown by the
+ * threads.
+ */
+public class ZooKeeperThread extends Thread {
+
+    private static final Logger LOG = LoggerFactory
+            .getLogger(ZooKeeperThread.class);
+
+    private UncaughtExceptionHandler uncaughtExceptionalHandler = new UncaughtExceptionHandler() {
+
+        @Override
+        public void uncaughtException(Thread t, Throwable e) {
+            handleException(t.getName(), e);
+        }
+    };
+
+    public ZooKeeperThread(String threadName) {
+        super(threadName);
+        setUncaughtExceptionHandler(uncaughtExceptionalHandler);
+    }
+
+    /**
+     * This will be used by the uncaught exception handler and just log a
+     * warning message and return.
+     * 
+     * @param thName
+     *            - thread name
+     * @param e
+     *            - exception object
+     */
+    protected void handleException(String thName, Throwable e) {
+        LOG.warn(""Exception occured from thread {}"", thName, e);
+    }
+}
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
index 8ba12c5..d54edc2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
@@ -39,6 +39,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.zookeeper.jmx.MBeanRegistry;
+import org.apache.zookeeper.server.ZooKeeperThread;
 import org.apache.zookeeper.server.quorum.Election;
 import org.apache.zookeeper.server.quorum.Vote;
 import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
@@ -206,12 +207,13 @@
         final ConcurrentHashMap<Long, Semaphore> ackMutex;
         final ConcurrentHashMap<InetSocketAddress, ConcurrentHashMap<Long, Long>> addrChallengeMap;
 
-        class WorkerReceiver implements Runnable {
+        class WorkerReceiver extends ZooKeeperThread {
 
             DatagramSocket mySocket;
             Messenger myMsg;
 
             WorkerReceiver(DatagramSocket s, Messenger msg) {
+                super(""WorkerReceiver-"" + s.getRemoteSocketAddress());
                 mySocket = s;
                 myMsg = msg;
             }
@@ -397,7 +399,7 @@
             }
         }
 
-        class WorkerSender implements Runnable {
+        class WorkerSender extends ZooKeeperThread {
 
             Random rand;
             int maxAttempts;
@@ -408,6 +410,7 @@
              */
 
             WorkerSender(int attempts) {
+                super(""WorkerSender"");
                 maxAttempts = attempts;
                 rand = new Random(java.lang.Thread.currentThread().getId()
                         + System.currentTimeMillis());
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
index f45e871..f07e061 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
@@ -28,6 +28,7 @@
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.RequestProcessor;
 import org.apache.zookeeper.server.WorkerService;
+import org.apache.zookeeper.server.ZooKeeperCriticalThread;
 
 /**
  * This RequestProcessor matches the incoming committed requests with the
@@ -62,7 +63,8 @@
  * The current implementation solves the third constraint by simply allowing no
  * read requests to be processed in parallel with write requests.
  */
-public class CommitProcessor extends Thread implements RequestProcessor {
+public class CommitProcessor extends ZooKeeperCriticalThread implements
+        RequestProcessor {
     private static final Logger LOG = LoggerFactory.getLogger(CommitProcessor.class);
 
     /** Default: numCores */
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 9876c3d..d8ba7c2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -28,6 +28,7 @@
 import java.util.concurrent.TimeUnit;
 
 import org.apache.zookeeper.jmx.MBeanRegistry;
+import org.apache.zookeeper.server.ZooKeeperThread;
 import org.apache.zookeeper.server.quorum.QuorumCnxManager.Message;
 import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
 import org.apache.zookeeper.server.quorum.QuorumPeer.ServerState;
@@ -207,11 +208,12 @@
          * method run(), and processes such messages.
          */
 
-        class WorkerReceiver implements Runnable {
+        class WorkerReceiver extends ZooKeeperThread  {
             volatile boolean stop;
             QuorumCnxManager manager;
 
             WorkerReceiver(QuorumCnxManager manager) {
+                super(""WorkerReceiver"");
                 this.stop = false;
                 this.manager = manager;
             }
@@ -419,11 +421,12 @@
          * and queues it on the manager's queue.
          */
 
-        class WorkerSender implements Runnable {
+        class WorkerSender extends ZooKeeperThread {
             volatile boolean stop;
             QuorumCnxManager manager;
 
             WorkerSender(QuorumCnxManager manager){
+                super(""WorkerSender"");
                 this.stop = false;
                 this.manager = manager;
             }
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
index 79b2b05..30f24d6 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
@@ -25,6 +25,7 @@
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.RequestProcessor;
+import org.apache.zookeeper.server.ZooKeeperCriticalThread;
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.txn.ErrorTxn;
 import org.slf4j.Logger;
@@ -34,7 +35,7 @@
  * This RequestProcessor forwards any requests that modify the state of the
  * system to the Leader.
  */
-public class FollowerRequestProcessor extends Thread implements
+public class FollowerRequestProcessor extends ZooKeeperCriticalThread implements
         RequestProcessor {
     private static final Logger LOG = LoggerFactory.getLogger(FollowerRequestProcessor.class);
 
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index e8c9183..31922bf 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -21,7 +21,6 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.net.BindException;
-import java.net.InetSocketAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketAddress;
@@ -44,10 +43,10 @@
 import org.apache.zookeeper.server.FinalRequestProcessor;
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.RequestProcessor;
+import org.apache.zookeeper.server.ZooKeeperThread;
 import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
 import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
 import org.apache.zookeeper.server.util.ZxidUtils;
-import org.apache.zookeeper.server.ZooKeeperServer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -388,9 +387,13 @@
 
     private final Proposal newLeaderProposal = new Proposal();
 
-    class LearnerCnxAcceptor extends Thread{
+    class LearnerCnxAcceptor extends ZooKeeperThread {
         private volatile boolean stop = false;
 
+        public LearnerCnxAcceptor() {
+            super(""LearnerCnxAcceptor-"" + ss.getLocalSocketAddress());
+        }
+
         @Override
         public void run() {
             try {
@@ -459,7 +462,6 @@
             // Start thread that waits for connection requests from
             // new followers.
             cnxAcceptor = new LearnerCnxAcceptor();
-            cnxAcceptor.setName(""LearnerCnxAcceptor-"" + ss.getLocalSocketAddress());
             cnxAcceptor.start();
 
             long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index 0caffd3..4810f07 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -41,6 +41,7 @@
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.TxnLogProposalIterator;
 import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.ZooKeeperThread;
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.server.quorum.Leader.Proposal;
 import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
@@ -55,7 +56,7 @@
  * learner. All communication with a learner is handled by this
  * class.
  */
-public class LearnerHandler extends Thread {
+public class LearnerHandler extends ZooKeeperThread {
     private static final Logger LOG = LoggerFactory.getLogger(LearnerHandler.class);
 
     protected final Socket sock;
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
index a9857ca..195e106 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
@@ -28,6 +28,7 @@
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.server.RequestProcessor;
 import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.server.ZooKeeperCriticalThread;
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.txn.ErrorTxn;
 
@@ -35,7 +36,7 @@
  * This RequestProcessor forwards any requests that modify the state of the
  * system to the Leader.
  */
-public class ObserverRequestProcessor extends Thread implements
+public class ObserverRequestProcessor extends ZooKeeperCriticalThread implements
         RequestProcessor {
     private static final Logger LOG = LoggerFactory.getLogger(ObserverRequestProcessor.class);
 
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 82484b2..4770a3c 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -34,6 +34,8 @@
 import java.util.concurrent.TimeUnit;
 import java.util.NoSuchElementException;
 import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.zookeeper.server.ZooKeeperThread;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -509,10 +511,16 @@
     /**
      * Thread to listen on some port
      */
-    public class Listener extends Thread {
+    public class Listener extends ZooKeeperThread {
 
         volatile ServerSocket ss = null;
 
+        public Listener() {
+            // During startup of thread, thread name will be overridden to
+            // specific election address
+            super(""ListenerThread"");
+        }
+
         /**
          * Sleeps on accept().
          */
@@ -592,7 +600,7 @@
      * soon as there is one available. If connection breaks, then opens a new
      * one.
      */
-    class SendWorker extends Thread {
+    class SendWorker extends ZooKeeperThread {
         Long sid;
         Socket sock;
         RecvWorker recvWorker;
@@ -746,7 +754,7 @@
      * Thread to receive messages. Instance waits on a socket read. If the
      * channel breaks, then removes itself from the pool of receivers.
      */
-    class RecvWorker extends Thread {
+    class RecvWorker extends ZooKeeperThread {
         Long sid;
         Socket sock;
         volatile boolean running = true;
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index a60cf87..11b68e3 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -53,6 +53,7 @@
 import org.apache.zookeeper.server.ServerCnxnFactory;
 import org.apache.zookeeper.server.ZKDatabase;
 import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.ZooKeeperThread;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
 import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
 import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
@@ -88,7 +89,7 @@
  *
  * The request for the current leader will consist solely of an xid: int xid;
  */
-public class QuorumPeer extends Thread implements QuorumStats.Provider {
+public class QuorumPeer extends ZooKeeperThread implements QuorumStats.Provider {
     private static final Logger LOG = LoggerFactory.getLogger(QuorumPeer.class);
 
     QuorumBean jmxQuorumBean;
@@ -448,7 +449,7 @@
      *
      */
     @Deprecated
-    class ResponderThread extends Thread {
+    class ResponderThread extends ZooKeeperThread {
         ResponderThread() {
             super(""ResponderThread"");
         }
"
zookeeper,a6e8a13a2da6df08f4426cc4f623ec5c76078ba9,ZOOKEEPER-602. log all exceptions not caught by ZK threads (Rakesh R via michim),2014.03.23 12:12:56,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
index e9d5ddd..18617b8 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
@@ -26,6 +26,7 @@
 import org.apache.zookeeper.proto.ReplyHeader;
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.RequestProcessor;
+import org.apache.zookeeper.server.ZooKeeperCriticalThread;
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.server.quorum.Leader.XidRolloverException;
@@ -38,7 +39,8 @@
  * OpCode.getData, OpCode.exists) through to the next processor, but drops
  * state-changing operations (e.g. OpCode.create, OpCode.setData).
  */
-public class ReadOnlyRequestProcessor extends Thread implements RequestProcessor {
+public class ReadOnlyRequestProcessor extends ZooKeeperCriticalThread implements
+        RequestProcessor {
 
     private static final Logger LOG = LoggerFactory.getLogger(ReadOnlyRequestProcessor.class);
 
"
zookeeper,7799dea8f39a0696fd2871f56764f21f0d43b8cb,ZOOKEEPER-1440. Spurious log error messages when QuorumCnxManager is shutting down (Jordan Zimmerman via michim),2014.03.13 06:44:20,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index a2e7dc6..82484b2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -545,15 +545,19 @@
                 } catch (IOException e) {
                     if ( !shutdown ) {
                         LOG.error(""Exception while listening"", e);
-                        numRetries++;
-                        try {
-                            ss.close();
-                            Thread.sleep(1000);
-                        } catch (IOException ie) {
+                    }
+                    numRetries++;
+                    try {
+                        ss.close();
+                        Thread.sleep(1000);
+                    } catch (IOException ie) {
+                        if ( !shutdown ) {
                             LOG.error(""Error closing server socket"", ie);
-                        } catch (InterruptedException ie) {
+                        }
+                    } catch (InterruptedException ie) {
+                        if ( !shutdown ) {
                             LOG.error(""Interrupted while sleeping. "" +
-                                      ""Ignoring exception"", ie);
+                                ""Ignoring exception"", ie);
                         }
                     }
                 }
"
zookeeper,6aaa3b23f708fbbd1c04f58646ba27cb70831e27," ZOOKEEPER-1755. Concurrent operations of four letter 'dump' ephemeral    command and killSession causing NPE (Rakesh R via camille)",2014.02.19 10:31:53,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index b53aec2..24cc8ff 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -1275,9 +1275,11 @@
             pwriter.print(""0x"" + Long.toHexString(k));
             pwriter.println("":"");
             HashSet<String> tmp = ephemerals.get(k);
-            synchronized (tmp) {
-                for (String path : tmp) {
-                    pwriter.println(""\t"" + path);
+            if (tmp != null) {
+                synchronized (tmp) {
+                    for (String path : tmp) {
+                        pwriter.println(""\t"" + path);
+                    }
                 }
             }
         }
"
zookeeper,d88a04ffdfa37cb80f4a8adf2d205d9a36b27840,ZOOKEEPER-1861. ConcurrentHashMap isn't used properly in QuorumCnxManager (Ted Yu via camille),2014.02.14 09:34:30,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 5925112..a2e7dc6 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -207,10 +207,8 @@
                 vsw.finish();
             
             senderWorkerMap.put(sid, sw);
-            if (!queueSendMap.containsKey(sid)) {
-                queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
+            queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(
                         SEND_CAPACITY));
-            }
             
             sw.start();
             rw.start();
@@ -304,10 +302,8 @@
             
             senderWorkerMap.put(sid, sw);
             
-            if (!queueSendMap.containsKey(sid)) {
-                queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
+            queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(
                         SEND_CAPACITY));
-            }
             
             sw.start();
             rw.start();
@@ -335,19 +331,13 @@
              /*
               * Start a new connection if doesn't have one already.
               */
-             if (!queueSendMap.containsKey(sid)) {
-                 ArrayBlockingQueue<ByteBuffer> bq = new ArrayBlockingQueue<ByteBuffer>(
-                         SEND_CAPACITY);
-                 queueSendMap.put(sid, bq);
-                 addToSendQueue(bq, b);
-
+             ArrayBlockingQueue<ByteBuffer> bq = new ArrayBlockingQueue<ByteBuffer>(
+                SEND_CAPACITY);
+             ArrayBlockingQueue<ByteBuffer> oldq = queueSendMap.putIfAbsent(sid, bq);
+             if (oldq != null) {
+                 addToSendQueue(oldq, b);
              } else {
-                 ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
-                 if(bq != null){
-                     addToSendQueue(bq, b);
-                 } else {
-                     LOG.error(""No queue for server "" + sid);
-                 }
+                 addToSendQueue(bq, b);
              }
              connectOne(sid);
                 
"
zookeeper,5d00c83b2a94bf40477651d9b0176e2d7d07012a,ZOOKEEPER-1844. TruncateTest fails on windows (Rakesh R via fpj),2014.02.13 01:00:09,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/TxnLogProposalIterator.java b/src/java/main/org/apache/zookeeper/server/TxnLogProposalIterator.java
index 3456e8d..0796935 100644
--- a/src/java/main/org/apache/zookeeper/server/TxnLogProposalIterator.java
+++ b/src/java/main/org/apache/zookeeper/server/TxnLogProposalIterator.java
@@ -95,6 +95,20 @@
         throw new UnsupportedOperationException();
     }
 
+    /**
+     * Close the files and release the resources which are used for iterating
+     * transaction records
+     */
+    public void close() {
+        if(itr != null){
+            try {
+                itr.close();
+            } catch (IOException ioe) {
+                LOG.warn(""Error closing file iterator"", ioe);
+            }
+        }
+    }
+
     private TxnLogProposalIterator() {
     }
 
"
zookeeper,5d00c83b2a94bf40477651d9b0176e2d7d07012a,ZOOKEEPER-1844. TruncateTest fails on windows (Rakesh R via fpj),2014.02.13 01:00:09,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 98b2767..d0d84bd 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -307,6 +307,7 @@
                     && (itr.getHeader().getZxid() > startZxid)) {
                 LOG.warn(""Unable to find proposals from txnlog for zxid: ""
                         + startZxid);
+                itr.close();
                 return TxnLogProposalIterator.EMPTY_ITERATOR;
             }
 
@@ -315,11 +316,19 @@
                 if (txnSize > sizeLimit) {
                     LOG.info(""Txnlog size: "" + txnSize + "" exceeds sizeLimit: ""
                             + sizeLimit);
+                    itr.close();
                     return TxnLogProposalIterator.EMPTY_ITERATOR;
                 }
             }
         } catch (IOException e) {
             LOG.error(""Unable to read txnlog from disk"", e);
+            try {
+                if (itr != null) {
+                    itr.close();
+                }
+            } catch (IOException ioe) {
+                LOG.warn(""Error closing file iterator"", ioe);
+            }
             return TxnLogProposalIterator.EMPTY_ITERATOR;
         }
         return new TxnLogProposalIterator(itr);
"
zookeeper,5d00c83b2a94bf40477651d9b0176e2d7d07012a,ZOOKEEPER-1844. TruncateTest fails on windows (Rakesh R via fpj),2014.02.13 01:00:09,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index d2a8761..598cb23 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -286,9 +286,10 @@
         // if a log file is more recent we must scan it to find
         // the highest zxid
         long zxid = maxLog;
+        TxnIterator itr = null;
         try {
             FileTxnLog txn = new FileTxnLog(logDir);
-            TxnIterator itr = txn.read(maxLog);
+            itr = txn.read(maxLog);
             while (true) {
                 if(!itr.next())
                     break;
@@ -297,10 +298,22 @@
             }
         } catch (IOException e) {
             LOG.warn(""Unexpected exception"", e);
+        } finally {
+            close(itr);
         }
         return zxid;
     }
 
+    private void close(TxnIterator itr) {
+        if (itr != null) {
+            try {
+                itr.close();
+            } catch (IOException ioe) {
+                LOG.warn(""Error closing file iterator"", ioe);
+            }
+        }
+    }
+
     /**
      * commit the logs. make sure that evertyhing hits the
      * disk
@@ -361,17 +374,22 @@
      * @return true if successful false if not
      */
     public boolean truncate(long zxid) throws IOException {
-        FileTxnIterator itr = new FileTxnIterator(this.logDir, zxid);
-        PositionInputStream input = itr.inputStream;
-        long pos = input.getPosition();
-        // now, truncate at the current position
-        RandomAccessFile raf=new RandomAccessFile(itr.logFile,""rw"");
-        raf.setLength(pos);
-        raf.close();
-        while(itr.goToNextLog()) {
-            if (!itr.logFile.delete()) {
-                LOG.warn(""Unable to truncate "" + itr.logFile);
+        FileTxnIterator itr = null;
+        try {
+            itr = new FileTxnIterator(this.logDir, zxid);
+            PositionInputStream input = itr.inputStream;
+            long pos = input.getPosition();
+            // now, truncate at the current position
+            RandomAccessFile raf=new RandomAccessFile(itr.logFile,""rw"");
+            raf.setLength(pos);
+            raf.close();
+            while(itr.goToNextLog()) {
+                if (!itr.logFile.delete()) {
+                    LOG.warn(""Unable to truncate {}"", itr.logFile);
+                }
             }
+        } finally {
+            close(itr);
         }
         return true;
     }
@@ -700,7 +718,9 @@
          * and release the resources.
          */
         public void close() throws IOException {
-            inputStream.close();
+            if (inputStream != null) {
+                inputStream.close();
+            }
         }
     }
 
"
zookeeper,5d00c83b2a94bf40477651d9b0176e2d7d07012a,ZOOKEEPER-1844. TruncateTest fails on windows (Rakesh R via fpj),2014.02.13 01:00:09,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index aed8137..c9a06d7 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -162,30 +162,36 @@
         TxnIterator itr = txnLog.read(dt.lastProcessedZxid+1);
         long highestZxid = dt.lastProcessedZxid;
         TxnHeader hdr;
-        while (true) {
-            // iterator points to
-            // the first valid txn when initialized
-            hdr = itr.getHeader();
-            if (hdr == null) {
-                //empty logs
-                return dt.lastProcessedZxid;
+        try {
+            while (true) {
+                // iterator points to
+                // the first valid txn when initialized
+                hdr = itr.getHeader();
+                if (hdr == null) {
+                    //empty logs
+                    return dt.lastProcessedZxid;
+                }
+                if (hdr.getZxid() < highestZxid && highestZxid != 0) {
+                    LOG.error(""{}(higestZxid) > {}(next log) for type {}"",
+                            new Object[] { highestZxid, hdr.getZxid(),
+                                    hdr.getType() });
+                } else {
+                    highestZxid = hdr.getZxid();
+                }
+                try {
+                    processTransaction(hdr,dt,sessions, itr.getTxn());
+                } catch(KeeperException.NoNodeException e) {
+                   throw new IOException(""Failed to process transaction type: "" +
+                         hdr.getType() + "" error: "" + e.getMessage(), e);
+                }
+                listener.onTxnLoaded(hdr, itr.getTxn());
+                if (!itr.next())
+                    break;
             }
-            if (hdr.getZxid() < highestZxid && highestZxid != 0) {
-                LOG.error(highestZxid + ""(higestZxid) > ""
-                        + hdr.getZxid() + ""(next log) for type ""
-                        + hdr.getType());
-            } else {
-                highestZxid = hdr.getZxid();
+        } finally {
+            if (itr != null) {
+                itr.close();
             }
-            try {
-                processTransaction(hdr,dt,sessions, itr.getTxn());
-            } catch(KeeperException.NoNodeException e) {
-               throw new IOException(""Failed to process transaction type: "" +
-                     hdr.getType() + "" error: "" + e.getMessage(), e);
-            }
-            listener.onTxnLoaded(hdr, itr.getTxn());
-            if (!itr.next())
-                break;
         }
         return highestZxid;
     }
"
zookeeper,5d00c83b2a94bf40477651d9b0176e2d7d07012a,ZOOKEEPER-1844. TruncateTest fails on windows (Rakesh R via fpj),2014.02.13 01:00:09,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index f0b17fb..0caffd3 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -39,6 +39,7 @@
 import org.apache.zookeeper.KeeperException.SessionExpiredException;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.server.TxnLogProposalIterator;
 import org.apache.zookeeper.server.ZKDatabase;
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.server.quorum.Leader.Proposal;
@@ -729,6 +730,11 @@
                                                          null, maxCommittedLog);
                     needSnap = false;
                 }
+                // closing the resources
+                if (txnLogItr instanceof TxnLogProposalIterator) {
+                    TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;
+                    txnProposalItr.close();
+                }
             } else {
                 LOG.warn(""Unhandled scenario for peer sid: "" +  getSid());
             }
"
zookeeper,2c7fbbecd7122815aa6072096be7c5737d04a670,"ZOOKEEPER-1811. The ZooKeeperSaslClient service name principal is hardcoded to ""zookeeper"" (Harsh J via phunt)",2014.02.11 06:25:49,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index c1c58f1..42a1ffa 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -93,6 +93,9 @@
 public class ClientCnxn {
     private static final Logger LOG = LoggerFactory.getLogger(ClientCnxn.class);
 
+    private static final String ZK_SASL_CLIENT_USERNAME =
+        ""zookeeper.sasl.client.username"";
+
     /** This controls whether automatic watch resetting is enabled.
      * Clients automatically reset watches during session reconnect, this
      * option allows the client to turn off this behavior by setting
@@ -1067,7 +1070,11 @@
                     ""("" + addr.getHostName() + "":"" + addr.getPort() + "")""));
             if (ZooKeeperSaslClient.isEnabled()) {
                 try {
-                    zooKeeperSaslClient = new ZooKeeperSaslClient(""zookeeper/""+addr.getHostName());
+                    String principalUserName = System.getProperty(
+                            ZK_SASL_CLIENT_USERNAME, ""zookeeper"");
+                    zooKeeperSaslClient =
+                        new ZooKeeperSaslClient(
+                                principalUserName+""/""+addr.getHostName());
                 } catch (LoginException e) {
                     // An authentication error occurred when the SASL client tried to initialize:
                     // for Kerberos this means that the client failed to authenticate with the KDC.
"
zookeeper,523a776780c0af1d15e60667ac3e2532c3779380,"ZOOKEEPER-1573. Unable to load database due to missing parent node (Vinayakumar B via phunt, fpj)",2014.02.11 05:50:54,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 68fe701..aed8137 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -256,20 +256,15 @@
         }
 
         /**
-         * This should never happen. A NONODE can never show up in the
-         * transaction logs. This is more indicative of a corrupt transaction
-         * log. Refer ZOOKEEPER-1333 for more info.
+         * Snapshots are lazily created. So when a snapshot is in progress,
+         * there is a chance for later transactions to make into the
+         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS
+         * errors could occur. It should be safe to ignore these.
          */
         if (rc.err != Code.OK.intValue()) {
-            if (hdr.getType() == OpCode.create && rc.err == Code.NONODE.intValue()) {
-                int lastSlash = rc.path.lastIndexOf('/');
-                String parentName = rc.path.substring(0, lastSlash);
-                LOG.error(""Parent {} missing for {}"", parentName, rc.path);
-                throw new KeeperException.NoNodeException(parentName);
-            } else {
-                LOG.debug(""Ignoring processTxn failure hdr: "" + hdr.getType() +
-                        "" : error: "" + rc.err);
-            }
+            LOG.debug(
+                    ""Ignoring processTxn failure hdr: {}, error: {}, path: {}"",
+                    hdr.getType(), rc.err, rc.path);
         }
     }
 
"
zookeeper,f7c7765b6c4e2b9f69af9d80b63bee5daf2df90f,ZOOKEEPER-1860. Async versions of reconfig don't actually throw KeeperException nor InterruptedException (Raul Gutierrez Segales via phunt),2014.01.14 07:34:05,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 64bd46d..05dff42 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -1638,7 +1638,8 @@
      * @see #reconfig
      *      
      **/
-    public void reconfig(String joiningServers, String leavingServers, String newMembers, long fromConfig, DataCallback cb, Object ctx) throws KeeperException, InterruptedException
+    public void reconfig(String joiningServers, String leavingServers,
+        String newMembers, long fromConfig, DataCallback cb, Object ctx)
     {
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.reconfig);       
@@ -1654,7 +1655,9 @@
      * @see #reconfig
      *
      */
-    public void reconfig(List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig, DataCallback cb, Object ctx) throws KeeperException, InterruptedException
+    public void reconfig(List<String> joiningServers,
+        List<String> leavingServers, List<String> newMembers, long fromConfig,
+        DataCallback cb, Object ctx)
     {
         reconfig(StringUtils.joinStrings(joiningServers, "",""), 
         		StringUtils.joinStrings(leavingServers, "",""), 
"
zookeeper,310f890ff8c4e4977204fb0dd8443bbe6ba3c7a1,"ZOOKEEPER-1179. NettyServerCnxn does not properly close socket on    4 letter word requests (Rakesh R, Germán Blanco via fpj)",2013.12.27 23:57:20,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index 851fe9e..b4bdc82 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -215,7 +215,7 @@
     @Override
     public void sendBuffer(ByteBuffer sendBuffer) {
         if (sendBuffer == ServerCnxnFactory.closeConn) {
-            channel.close();
+            close();
             return;
         }
         channel.write(wrappedBuffer(sendBuffer));
"
zookeeper,59ecde5ed38f0c6701d818841446793214cf702e,"ZOOKEEPER-1388. Client side 'PathValidation' is missing for the multi-transaction api. (Rakesh R via marshallm, phunt)",2013.12.18 01:55:29,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/CreateMode.java b/src/java/main/org/apache/zookeeper/CreateMode.java
index 6e9c89a..d87f410 100644
--- a/src/java/main/org/apache/zookeeper/CreateMode.java
+++ b/src/java/main/org/apache/zookeeper/CreateMode.java
@@ -83,8 +83,10 @@
         case 3: return CreateMode.EPHEMERAL_SEQUENTIAL ;
 
         default:
-            LOG.error(""Received an invalid flag value to convert to a CreateMode"");
-            throw new KeeperException.BadArgumentsException(); 
+            String errMsg = ""Received an invalid flag value: "" + flag
+                    + "" to convert to a CreateMode"";
+            LOG.error(errMsg);
+            throw new KeeperException.BadArgumentsException(errMsg);
         }
     }
 }
"
zookeeper,59ecde5ed38f0c6701d818841446793214cf702e,"ZOOKEEPER-1388. Client side 'PathValidation' is missing for the multi-transaction api. (Rakesh R via marshallm, phunt)",2013.12.18 01:55:29,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/Op.java b/src/java/main/org/apache/zookeeper/Op.java
index 6330717..97d3d7b 100644
--- a/src/java/main/org/apache/zookeeper/Op.java
+++ b/src/java/main/org/apache/zookeeper/Op.java
@@ -18,6 +18,7 @@
 package org.apache.zookeeper;
 
 import org.apache.jute.Record;
+import org.apache.zookeeper.common.PathUtils;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.proto.CheckVersionRequest;
 import org.apache.zookeeper.proto.CreateRequest;
@@ -161,6 +162,18 @@
      */
     abstract Op withChroot(String addRootPrefix);
 
+    /**
+     * Performs client path validations.
+     * 
+     * @throws IllegalArgumentException
+     *             if an invalid path is specified
+     * @throws KeeperException.BadArgumentsException
+     *             if an invalid create mode flag is specified
+     */
+    void validate() throws KeeperException {
+        PathUtils.validatePath(path);
+    }
+
     //////////////////
     // these internal classes are public, but should not generally be referenced.
     //
@@ -221,6 +234,12 @@
         Op withChroot(String path) {
             return new Create(path, data, acl, flags);
         }
+
+        @Override
+        void validate() throws KeeperException {
+            CreateMode createMode = CreateMode.fromFlag(flags);
+            PathUtils.validatePath(getPath(), createMode.isSequential());
+        }
     }
 
     public static class Delete extends Op {
"
zookeeper,59ecde5ed38f0c6701d818841446793214cf702e,"ZOOKEEPER-1388. Client side 'PathValidation' is missing for the multi-transaction api. (Rakesh R via marshallm, phunt)",2013.12.18 01:55:29,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index a3a7926..64bd46d 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -1108,10 +1108,14 @@
      * partially succeeded if this exception is thrown.
      * @throws KeeperException If the operation could not be completed
      * due to some error in doing one of the specified ops.
+     * @throws IllegalArgumentException if an invalid path is specified
      *
      * @since 3.4.0
      */
     public List<OpResult> multi(Iterable<Op> ops) throws InterruptedException, KeeperException {
+        for (Op op : ops) {
+            op.validate();
+        }
         return multiInternal(generateMultiTransaction(ops));
     }
 
@@ -1121,9 +1125,45 @@
      * @see #multi(Iterable)
      */
     public void multi(Iterable<Op> ops, MultiCallback cb, Object ctx) {
+        List<OpResult> results = validatePath(ops);
+        if (results.size() > 0) {
+            cb.processResult(KeeperException.Code.BADARGUMENTS.intValue(),
+                    null, ctx, results);
+            return;
+        }
         multiInternal(generateMultiTransaction(ops), cb, ctx);
     }
 
+    private List<OpResult> validatePath(Iterable<Op> ops) {
+        List<OpResult> results = new ArrayList<OpResult>();
+        boolean error = false;
+        for (Op op : ops) {
+            try {
+                op.validate();
+            } catch (IllegalArgumentException iae) {
+                LOG.error(""IllegalArgumentException: "" + iae.getMessage());
+                ErrorResult err = new ErrorResult(
+                        KeeperException.Code.BADARGUMENTS.intValue());
+                results.add(err);
+                error = true;
+                continue;
+            } catch (KeeperException ke) {
+                LOG.error(""KeeperException: "" + ke.getMessage());
+                ErrorResult err = new ErrorResult(ke.code().intValue());
+                results.add(err);
+                error = true;
+                continue;
+            }
+            ErrorResult err = new ErrorResult(
+                    KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());
+            results.add(err);
+        }
+        if (false == error) {
+            results.clear();
+        }
+        return results;
+    }
+
     private MultiTransactionRecord generateMultiTransaction(Iterable<Op> ops) {
         // reconstructing transaction with the chroot prefix
         List<Op> transaction = new ArrayList<Op>();
"
zookeeper,f271dac9f994770ef3ae389484f2d1519cc9f259,ZOOKEEPER-1622. session ids will be negative in the year 2022 (Eric Newton via phunt),2013.12.16 15:29:50,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
index d2ea7ca..6570a7d 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
@@ -75,7 +75,7 @@
      */
     public static long initializeNextSession(long id) {
         long nextSid = 0;
-        nextSid = (System.currentTimeMillis() << 24) >> 8;
+        nextSid = (System.currentTimeMillis() << 24) >>> 8;
         nextSid =  nextSid | (id <<56);
         return nextSid;
     }
"
zookeeper,32d900b1d439f1ef52c69185e5bc6f73d272ed0b,ZOOKEEPER-1839. Deadlock in NettyServerCnxn (Rakesh R via michim),2013.12.16 13:18:47,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index 0774da9..851fe9e 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -108,12 +108,12 @@
                             .getRemoteAddress()).getAddress());
                 s.remove(this);
             }
-    
-            if (channel.isOpen()) {
-                channel.close();
-            }
-            factory.unregisterConnection(this);
         }
+
+        if (channel.isOpen()) {
+            channel.close();
+        }
+        factory.unregisterConnection(this);
     }
 
     @Override
"
zookeeper,32d900b1d439f1ef52c69185e5bc6f73d272ed0b,ZOOKEEPER-1839. Deadlock in NettyServerCnxn (Rakesh R via michim),2013.12.16 13:18:47,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
index e0613c5..6b8d2a6 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
@@ -261,20 +261,22 @@
             LOG.debug(""closeAll()"");
         }
 
+        NettyServerCnxn[] allCnxns = null;
         synchronized (cnxns) {
-            // got to clear all the connections that we have in the selector
-            for (NettyServerCnxn cnxn : cnxns.toArray(new NettyServerCnxn[cnxns.size()])) {
-                try {
-                    cnxn.close();
-                } catch (Exception e) {
-                    LOG.warn(""Ignoring exception closing cnxn sessionid 0x""
-                            + Long.toHexString(cnxn.getSessionId()), e);
-                }
+            allCnxns = cnxns.toArray(new NettyServerCnxn[cnxns.size()]);
+        }
+        // got to clear all the connections that we have in the selector
+        for (NettyServerCnxn cnxn : allCnxns) {
+            try {
+                cnxn.close();
+            } catch (Exception e) {
+                LOG.warn(""Ignoring exception closing cnxn sessionid 0x""
+                                + Long.toHexString(cnxn.getSessionId()), e);
             }
         }
         if (LOG.isDebugEnabled()) {
-            LOG.debug(""allChannels size:"" + allChannels.size()
-                    + "" cnxns size:"" + cnxns.size());
+            LOG.debug(""allChannels size:"" + allChannels.size() + "" cnxns size:""
+                    + allCnxns.length);
         }
     }
 
@@ -283,17 +285,18 @@
         if (LOG.isDebugEnabled()) {
             LOG.debug(""closeSession sessionid:0x"" + sessionId);
         }
-
+        NettyServerCnxn[] allCnxns = null;
         synchronized (cnxns) {
-            for (NettyServerCnxn cnxn : cnxns.toArray(new NettyServerCnxn[cnxns.size()])) {
-                if (cnxn.getSessionId() == sessionId) {
-                    try {
-                        cnxn.close();
-                    } catch (Exception e) {
-                        LOG.warn(""exception during session close"", e);
-                    }
-                    break;
+            allCnxns = cnxns.toArray(new NettyServerCnxn[cnxns.size()]);
+        }
+        for (NettyServerCnxn cnxn : allCnxns) {
+            if (cnxn.getSessionId() == sessionId) {
+                try {
+                    cnxn.close();
+                } catch (Exception e) {
+                    LOG.warn(""exception during session close"", e);
                 }
+                break;
             }
         }
     }
"
zookeeper,cdee4002b4b7d14413a5ed447dbbd146c5a99eee,ZOOKEEPER-1382. Zookeeper server holds onto dead/expired session ids in the watch data structures   (Germán Blanco and Michael Morello via camille),2013.12.12 03:22:04,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 2611ecc..e02753f 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -302,11 +302,18 @@
     }
 
     /**
+     * Only used in order to allow testing
+     */
+    protected boolean isSocketOpen() {
+        return sock.isOpen();
+    }
+
+    /**
      * Handles read/write IO on connection.
      */
     void doIO(SelectionKey k) throws InterruptedException {
         try {
-            if (sock.isOpen() == false) {
+            if (isSocketOpen() == false) {
                 LOG.warn(""trying to do i/o on a null socket for session:0x""
                          + Long.toHexString(sessionId));
 
"
zookeeper,cdee4002b4b7d14413a5ed447dbbd146c5a99eee,ZOOKEEPER-1382. Zookeeper server holds onto dead/expired session ids in the watch data structures   (Germán Blanco and Michael Morello via camille),2013.12.12 03:22:04,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index adbd0cb..fe3f742 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -606,6 +606,7 @@
                         + "" with negotiated timeout "" + cnxn.getSessionTimeout()
                         + "" for client ""
                         + cnxn.getRemoteSocketAddress());
+                cnxn.enableRecv();
             } else {
 
                 LOG.info(""Invalid session 0x""
@@ -616,7 +617,6 @@
                 cnxn.sendBuffer(ServerCnxnFactory.closeConn);
             }
 
-            cnxn.enableRecv();
         } catch (Exception e) {
             LOG.warn(""Exception while establishing session, closing"", e);
             cnxn.close();
"
zookeeper,dd31b9d9c5fdc608e269dd2f9b38d12afbecbef0,"ZOOKEEPER-1798. Fix race condition in testNormalObserverRun (Part 2) (thawan, fpj via thawan)",2013.11.14 13:34:42,Thawan Kooburat,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java
index 73c2035..5bbbbe2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java
@@ -134,4 +134,12 @@
     public String getState() {
         return ""observer"";
     };    
+
+    @Override
+    public void shutdown() {
+        super.shutdown();
+        if (syncRequestProcessorEnabled && syncProcessor != null) {
+            syncProcessor.shutdown();
+        }
+    }
 }
"
zookeeper,6ce15c7bcf685a111fcd049953382409898ec0c9,ZOOKEEPER-1812. ZooInspector reconnection always fails if first connection fails (Benjamin Jaton via phunt),2013.11.12 15:33:32,Patrick D. Hunt,"diff --git a/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java b/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java
index 880dfdc..8c3b5e8 100644
--- a/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java
+++ b/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java
@@ -174,12 +174,14 @@
                 }
                 ((ZooKeeperRetry) this.zooKeeper).setRetryLimit(10);
                 connected = ((ZooKeeperRetry) this.zooKeeper).testConnection();
-                return connected;
             }
         } catch (Exception e) {
+            connected = false;
             e.printStackTrace();
         }
-        connected = false;
+        if (!connected){
+        	disconnect();
+        }
         return connected;
     }
 
"
zookeeper,c56db03e686ab805821896486717123ed84e38a1,ZOOKEEPER-1783. Distinguish initial configuration from first established configuration (shralex via breed),2013.11.07 14:41:50,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 021ddc2..9876c3d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -266,19 +266,22 @@
                                                        
                            synchronized(self){                             
                                try {
-                                   rqv = self.configFromString(new String(b));                                             
-                                   if (rqv.getVersion() > self.getQuorumVerifier().getVersion()) {
+                                   rqv = self.configFromString(new String(b));
+                                   QuorumVerifier curQV = self.getQuorumVerifier();
+                                   if (rqv.getVersion() > curQV.getVersion()) {
                                        LOG.info(self.getId() + "" Received version: "" + Long.toHexString(rqv.getVersion()) + "" my version: "" + Long.toHexString(self.getQuorumVerifier().getVersion()));
                                        self.processReconfig(rqv, null, null, false);
-                                       LOG.info(""restarting leader election"");
-                                       self.shuttingDownLE = true;
-                                       self.getElectionAlg().shutdown();
+                                       if (!rqv.equals(curQV)) {
+                                           LOG.info(""restarting leader election"");
+                                           self.shuttingDownLE = true;
+                                           self.getElectionAlg().shutdown();
+                                       }
                                    }           
                                } catch (IOException e) {                         
                                    LOG.error(""Something went wrong while processing config received from "" + response.sid);
                                } catch (ConfigException e) {
                                    LOG.error(""Something went wrong while processing config received from "" + response.sid);
-							   } 
+                               } 
                           }                                                       
                         } else {
                             if(LOG.isInfoEnabled()){
"
zookeeper,c56db03e686ab805821896486717123ed84e38a1,ZOOKEEPER-1783. Distinguish initial configuration from first established configuration (shralex via breed),2013.11.07 14:41:50,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 48509bb..e8c9183 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -479,6 +479,37 @@
                         + Long.toHexString(newLeaderProposal.packet.getZxid()));
             }
 
+            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();
+            QuorumVerifier curQV = self.getQuorumVerifier();
+            if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {
+                // This was added in ZOOKEEPER-1783. The initial config has version 0 (not explicitly
+                // specified by the user; the lack of version in a config file is interpreted as version=0). 
+                // As soon as a config is established we would like to increase its version so that it
+                // takes presedence over other initial configs that were not established (such as a config
+                // of a server trying to join the ensemble, which may be a partial view of the system, not the full config). 
+                // We chose to set the new version to the one of the NEWLEADER message. However, before we can do that
+                // there must be agreement on the new version, so we can only change the version when sending/receiving UPTODATE,
+                // not when sending/receiving NEWLEADER. In other words, we can't change curQV here since its the committed quorum verifier, 
+                // and there's still no agreement on the new version that we'd like to use. Instead, we use 
+                // lastSeenQuorumVerifier which is being sent with NEWLEADER message
+                // so its a good way to let followers know about the new version. (The original reason for sending 
+                // lastSeenQuorumVerifier with NEWLEADER is so that the leader completes any potentially uncommitted reconfigs
+                // that it finds before starting to propose operations. Here we're reusing the same code path for 
+                // reaching consensus on the new version number.)
+                
+                // It is important that this is done before the leader executes waitForEpochAck,
+                // so before LearnerHandlers return from their waitForEpochAck
+                // hence before they construct the NEWLEADER message containing
+                // the last-seen-quorumverifier of the leader, which we change below
+               try {
+                   QuorumVerifier newQV = self.configFromString(curQV.toString());
+                   newQV.setVersion(zk.getZxid());
+                   self.setLastSeenQuorumVerifier(newQV, true);    
+               } catch (Exception e) {
+                   throw new IOException(e);
+               }
+            }
+            
             newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());
             if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()){
                newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());
"
zookeeper,c56db03e686ab805821896486717123ed84e38a1,ZOOKEEPER-1783. Distinguish initial configuration from first established configuration (shralex via breed),2013.11.07 14:41:50,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 148f1ba..78e9520 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -918,6 +918,11 @@
                         };
                         try {
                             roZkMgr.start();
+                            reconfigFlagClear();
+                            if (shuttingDownLE) {
+                                shuttingDownLE = false;
+                                startLeaderElection();
+                            }
                             setCurrentVote(makeLEStrategy().lookForLeader());
                         } catch (Exception e) {
                             LOG.warn(""Unexpected exception"", e);
@@ -1292,14 +1297,23 @@
        if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion()))
            lastSeenQuorumVerifier = qv;
         if (writeToDisk) {
-            try {
-                QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, configFilename, configBackwardCompatibility, qv);
-                if (configBackwardCompatibility) {
-                    dynamicConfigFilename = configFilename + "".dynamic"";
-                    configBackwardCompatibility = false;
+                // we need to write the dynamic config file. Either it already exists
+                // or we have the old-style config file and we're in the backward compatibility mode,
+                // so we'll create the dynamic config file for the first time now
+                if (dynamicConfigFilename !=null || (configFilename !=null && configBackwardCompatibility)) { 
+                try {
+                    QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, configFilename, configBackwardCompatibility, qv);
+                    if (configBackwardCompatibility) {
+                        dynamicConfigFilename = configFilename + "".dynamic"";
+                        configBackwardCompatibility = false;
+                    }
+                } catch(IOException e){
+                    LOG.error(""Error closing file: "", e.getMessage());     
                 }
-            } catch(IOException e){
-                LOG.error(""Error closing file: "", e.getMessage());     
+            } else {
+                LOG.error(""writeToDisk == true but dynamicConfigFilename == null, configFilename ""
+                          + (configFilename == null ? ""== null"": ""!=null"")
+                          + "" and configBackwardCompatibility == "" + configBackwardCompatibility);
             }
         }
 
@@ -1529,7 +1543,7 @@
        // for Learner):
        initConfigInZKDatabase();
 
-       if (prevQV.getVersion() < qv.getVersion()) {
+       if (prevQV.getVersion() < qv.getVersion() && !prevQV.equals(qv)) {
            if (restartLE) restartLeaderElection(prevQV, qv);
 
            QuorumServer myNewQS = qv.getAllMembers().get(getId());
@@ -1545,12 +1559,10 @@
                leaderChange = updateVote(suggestedLeaderId, zxid);
            } else {
                long currentLeaderId = getCurrentVote().getId();
-               InetSocketAddress currentLeaderAddr = prevQV.getVotingMembers()
-                       .get(currentLeaderId).addr;
-               leaderChange = (!qv.getVotingMembers().containsKey(
-                       currentLeaderId))
-                       || (!qv.getVotingMembers().get(currentLeaderId).addr
-                               .equals(currentLeaderAddr));
+               QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);
+               QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);
+               leaderChange = (myleaderInCurQV == null || myleaderInCurQV.addr == null || 
+                               myleaderInNewQV == null || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));
                // we don't have a designated leader - need to go into leader
                // election
                reconfigFlagClear();
"
zookeeper,293386c3be43fcd98754ac476385e399b426c02b,"ZOOKEEPER-1798. Fix race condition in testNormalObserverRun (thawan, fpj via thawan)",2013.10.25 03:41:12,Thawan Kooburat,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index 8d709b0..33a519a 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -193,8 +193,15 @@
             if(running){
                 this.join();
             }
+            if (!toFlush.isEmpty()) {
+                flush(toFlush);
+            }
         } catch(InterruptedException e) {
             LOG.warn(""Interrupted while wating for "" + this + "" to finish"");
+        } catch (IOException e) {
+            LOG.warn(""Got IO exception during shutdown"");
+        } catch (RequestProcessorException e) {
+            LOG.warn(""Got request processor exception during shutdown"");
         }
         if (nextProcessor != null) {
             nextProcessor.shutdown();
"
zookeeper,4fe97763c2e765c5140071906f7f70d0727abb5d,"ZOOKEEPER-1499. clientPort config changes not backwards-compatible (Alexander Shraer via phunt, breed)",2013.10.24 14:21:13,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 9350292..148f1ba 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -172,7 +172,7 @@
                 }
 
                 // is client_config a host:port or just a port
-                String hostname = (clientParts.length == 2) ? clientParts[0] : serverParts[0];
+                String hostname = (clientParts.length == 2) ? clientParts[0] : ""0.0.0.0"";
                 try {
                     clientAddr = new InetSocketAddress(hostname,
                             Integer.parseInt(clientParts[clientParts.length - 1]));
"
zookeeper,ec36884c2d49e4256f1d439efce3347c0a92800c,"ZOOKEEPER-1667. Watch event isn't handled correctly when a client reestablish to a server (jacky007, fpj via fpj)",2013.10.22 19:54:44,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 9b9cb80..9a72055 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -1295,56 +1295,37 @@
             DataNode node = getNode(path);
             WatchedEvent e = null;
             if (node == null) {
-                e = new WatchedEvent(EventType.NodeDeleted,
-                        KeeperState.SyncConnected, path);
-            } else if (node.stat.getCzxid() > relativeZxid) {
-                e = new WatchedEvent(EventType.NodeCreated,
-                        KeeperState.SyncConnected, path);
+                watcher.process(new WatchedEvent(EventType.NodeDeleted, 
+                            KeeperState.SyncConnected, path));
             } else if (node.stat.getMzxid() > relativeZxid) {
-                e = new WatchedEvent(EventType.NodeDataChanged,
-                        KeeperState.SyncConnected, path);
-            }
-            if (e == null) {
-                this.dataWatches.addWatch(path, watcher);
+                watcher.process(new WatchedEvent(EventType.NodeDataChanged, 
+                            KeeperState.SyncConnected, path));
             } else {
-                watcher.process(e);
-            }
-        }
+                this.dataWatches.addWatch(path, watcher);
+            }    
+        }    
         for (String path : existWatches) {
             DataNode node = getNode(path);
-            WatchedEvent e = null;
-            if (node == null) {
-                // This is the case when the watch was registered
-            } else if (node.stat.getMzxid() > relativeZxid) {
-                e = new WatchedEvent(EventType.NodeDataChanged,
-                        KeeperState.SyncConnected, path);
+            if (node != null) {
+                watcher.process(new WatchedEvent(EventType.NodeCreated, 
+                            KeeperState.SyncConnected, path));
             } else {
-                e = new WatchedEvent(EventType.NodeCreated,
-                        KeeperState.SyncConnected, path);
-            }
-            if (e == null) {
                 this.dataWatches.addWatch(path, watcher);
-            } else {
-                watcher.process(e);
-            }
-        }
+            }    
+        }    
         for (String path : childWatches) {
             DataNode node = getNode(path);
-            WatchedEvent e = null;
             if (node == null) {
-                e = new WatchedEvent(EventType.NodeDeleted,
-                        KeeperState.SyncConnected, path);
+                watcher.process(new WatchedEvent(EventType.NodeDeleted, 
+                            KeeperState.SyncConnected, path));
             } else if (node.stat.getPzxid() > relativeZxid) {
-                e = new WatchedEvent(EventType.NodeChildrenChanged,
-                        KeeperState.SyncConnected, path);
-            }
-            if (e == null) {
-                this.childWatches.addWatch(path, watcher);
+                watcher.process(new WatchedEvent(EventType.NodeChildrenChanged, 
+                            KeeperState.SyncConnected, path));
             } else {
-                watcher.process(e);
-            }
-        }
-    }
+                this.childWatches.addWatch(path, watcher);
+            }    
+        }    
+    }    
 
      /**
       * This method sets the Cversion and Pzxid for the specified node to the
"
zookeeper,c6ee0139d58250ac07ddfa3692c9adec488339bf,ZOOKEEPER-1732. ZooKeeper server unable to join established ensemble (German Blanco via fpj),2013.10.22 06:36:55,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 5e14ec8..021ddc2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -67,6 +67,14 @@
      */
 
     final static int maxNotificationInterval = 60000;
+    
+    /**
+     * This value is passed to the methods that check the quorum
+     * majority of an established ensemble for those values that
+     * should not be taken into account in the comparison 
+     * (electionEpoch and zxid). 
+     */
+    final static int IGNOREVALUE = -1;
 
     /**
      * Connection manager. Fast leader election uses TCP for
@@ -382,7 +390,7 @@
                                             ToSend.mType.notification,
                                             current.getId(),
                                             current.getZxid(),
-                                            logicalclock,
+                                            current.getElectionEpoch(),
                                             self.getPeerState(),
                                             response.sid,
                                             current.getPeerEpoch(), 
@@ -919,15 +927,25 @@
                             }
                         }
 
-                        /**
+                        /*
                          * Before joining an established ensemble, verify that
                          * a majority are following the same leader.
+                         * Only peer epoch is used to check that the votes come
+                         * from the same ensemble. This is because there is at
+                         * least one corner case in which the ensemble can be
+                         * created with inconsistent zxid and election epoch
+                         * info. However, given that only one ensemble can be
+                         * running at a single point in time and that each 
+                         * epoch is used only once, using only the epoch to 
+                         * compare the votes is sufficient.
+                         * 
+                         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732
                          */
-                        outofelection.put(n.sid, new Vote(n.leader, n.zxid,
-                                n.electionEpoch, n.peerEpoch, n.state));
+                        outofelection.put(n.sid, new Vote(n.leader, 
+                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));
                         if (termPredicate(outofelection, new Vote(n.leader,
-                                n.zxid, n.electionEpoch, n.peerEpoch, n.state))
-                                && checkLeader(outofelection, n.leader, n.electionEpoch)) {
+                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state))
+                                && checkLeader(outofelection, n.leader, IGNOREVALUE)) {
                             synchronized(this){
                                 logicalclock = n.electionEpoch;
                                 self.setPeerState((n.leader == self.getId()) ?
"
zookeeper,c6ee0139d58250ac07ddfa3692c9adec488339bf,ZOOKEEPER-1732. ZooKeeper server unable to join established ensemble (German Blanco via fpj),2013.10.22 06:36:55,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index d3717b0..48509bb 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -1242,6 +1242,15 @@
         }
         
         zk.startup();
+        /*
+         * Update the election vote here to ensure that all members of the
+         * ensemble report the same vote to new servers that start up and
+         * send leader election notifications to the ensemble.
+         * 
+         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732
+         */
+        self.updateElectionVote(getEpoch());
+
         zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());
     }
 
"
zookeeper,c6ee0139d58250ac07ddfa3692c9adec488339bf,ZOOKEEPER-1732. ZooKeeper server unable to join established ensemble (German Blanco via fpj),2013.10.22 06:36:55,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 8449db4..46211fd 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -495,6 +495,15 @@
         writePacket(ack, true);
         sock.setSoTimeout(self.tickTime * self.syncLimit);
         zk.startup();
+        /*
+         * Update the election vote here to ensure that all members of the
+         * ensemble report the same vote to new servers that start up and
+         * send leader election notifications to the ensemble.
+         * 
+         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732
+         */
+        self.updateElectionVote(newEpoch);
+
         // We need to log the stuff that came in between the snapshot and the uptodate
         if (zk instanceof FollowerZooKeeperServer) {
             FollowerZooKeeperServer fzk = (FollowerZooKeeperServer)zk;
"
zookeeper,c6ee0139d58250ac07ddfa3692c9adec488339bf,ZOOKEEPER-1732. ZooKeeper server unable to join established ensemble (German Blanco via fpj),2013.10.22 06:36:55,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 65a66a0..9350292 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -1605,4 +1605,22 @@
        }
        return false;
    }
+ 
+    /**
+     * Updates leader election info to avoid inconsistencies when
+     * a new server tries to join the ensemble.
+     * 
+     * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732
+     */
+    protected void updateElectionVote(long newEpoch) {
+        Vote currentVote = getCurrentVote();
+        if (currentVote != null) {
+            setCurrentVote(new Vote(currentVote.getId(),
+                currentVote.getZxid(),
+                currentVote.getElectionEpoch(),
+                newEpoch,
+                currentVote.getState()));
+        }
+    }
+
 }
"
zookeeper,2cfb6cc4a2f78c35d6cd9d840c7b28d31f4ff80a,ZOOKEEPER-1610. Some classes are using == or != to compare Long/String objects instead of .equals() (Edward Ribeiro via phunt),2013.10.12 04:18:14,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index aa1e66f..dbc1080 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -330,10 +330,10 @@
         if (saslClient.isComplete()) {
             // GSSAPI: server sends a final packet after authentication succeeds
             // or fails.
-            if ((serverToken == null) && (saslClient.getMechanismName() == ""GSSAPI""))
+            if ((serverToken == null) && (saslClient.getMechanismName().equals(""GSSAPI"")))
                 gotLastPacket = true;
             // non-GSSAPI: no final packet from server.
-            if (saslClient.getMechanismName() != ""GSSAPI"") {
+            if (!saslClient.getMechanismName().equals(""GSSAPI"")) {
                 gotLastPacket = true;
             }
             // SASL authentication is completed, successfully or not:
"
zookeeper,2cfb6cc4a2f78c35d6cd9d840c7b28d31f4ff80a,ZOOKEEPER-1610. Some classes are using == or != to compare Long/String objects instead of .equals() (Edward Ribeiro via phunt),2013.10.12 04:18:14,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
index 7bc1c3f..b03081a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
@@ -103,15 +103,15 @@
            if (qso == null || !qs.equals(qso)) return false;
        }
        for (Long sid: serverWeight.keySet()){
-           if (serverWeight.get(sid) != qm.serverWeight.get(sid))
+           if (!serverWeight.get(sid).equals(qm.serverWeight.get(sid)))
                return false;
        }
        for (Long sid: groupWeight.keySet()){
-           if (groupWeight.get(sid) != qm.groupWeight.get(sid))
+           if (!groupWeight.get(sid).equals(qm.groupWeight.get(sid)))
                return false;
        }
        for (Long sid: serverGroup.keySet()){
-           if (serverGroup.get(sid) != qm.serverGroup.get(sid))
+           if (!serverGroup.get(sid).equals(qm.serverGroup.get(sid)))
                return false;
        }
        return true;
"
zookeeper,51cd9ed37bea20aeb10c8c80ad3279bbca6f5582,ZOOKEEPER-1624. PrepRequestProcessor abort multi-operation incorrectly. (thawan via camille),2013.10.11 03:06:17,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 39bb1eb..3c72643 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -215,6 +215,25 @@
                 if (cr != null) {
                     pendingChangeRecords.put(path, cr);
                 }
+
+                /*
+                 * ZOOKEEPER-1624 - We need to store for parent's ChangeRecord
+                 * of the parent node of a request. So that if this is a
+                 * sequential node creation request, rollbackPendingChanges()
+                 * can restore previous parent's ChangeRecord correctly.
+                 *
+                 * Otherwise, sequential node name generation will be incorrect
+                 * for a subsequent request.
+                 */
+                int lastSlash = path.lastIndexOf('/');
+                if (lastSlash == -1 || path.indexOf('\0') != -1) {
+                    continue;
+                }
+                String parentPath = path.substring(0, lastSlash);
+                ChangeRecord parentCr = getRecordForPath(parentPath);
+                if (parentCr != null) {
+                    pendingChangeRecords.put(parentPath, parentCr);
+                }
             } catch (KeeperException.NoNodeException e) {
                 // ignore this one
             }
"
zookeeper,28246a44ef4653515708937fc2a9c5d51baa0937,"ZOOKEEPER-1781. ZooKeeper Server fails if snapCount is set to 1 (Takashi Ohnishi via phunt, breed)",2013.10.08 08:35:20,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 2c78b81..2a17cb9 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -668,7 +668,14 @@
     public static int getSnapCount() {
         String sc = System.getProperty(""zookeeper.snapCount"");
         try {
-            return Integer.parseInt(sc);
+            int snapCount = Integer.parseInt(sc);
+
+            // snapCount must be 2 or more. See org.apache.zookeeper.server.SyncRequestProcessor
+            if( snapCount < 2 ) {
+                LOG.warn(""SnapCount should be 2 or more. Now, snapCount is reset to 2"");
+                snapCount = 2;
+            }
+            return snapCount;
         } catch (Exception e) {
             return 100000;
         }
"
zookeeper,adedc7a421c723f1427cd0034953e1826587d9bb,"ZOOKEEPER-1551. Observers ignore txns that come after snapshot and UPTODATE (thawan, fpj via thawan)",2013.10.08 04:08:55,Thawan Kooburat,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 4a8af6e..d3717b0 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -1110,13 +1110,16 @@
                         .getZxid(), null, null);
                 handler.queuePacket(qp);
             }
-            List<Long>zxids = new ArrayList<Long>(outstandingProposals.keySet());
-            Collections.sort(zxids);
-            for (Long zxid: zxids) {
-                if (zxid <= lastSeenZxid) {
-                    continue;
+            // Only participant need to get outstanding proposals
+            if (handler.getLearnerType() == LearnerType.PARTICIPANT) {
+                List<Long>zxids = new ArrayList<Long>(outstandingProposals.keySet());
+                Collections.sort(zxids);
+                for (Long zxid: zxids) {
+                    if (zxid <= lastSeenZxid) {
+                        continue;
+                    }
+                    handler.queuePacket(outstandingProposals.get(zxid).packet);
                 }
-                handler.queuePacket(outstandingProposals.get(zxid).packet);
             }
         }
         if (handler.getLearnerType() == LearnerType.PARTICIPANT) {
"
zookeeper,adedc7a421c723f1427cd0034953e1826587d9bb,"ZOOKEEPER-1551. Observers ignore txns that come after snapshot and UPTODATE (thawan, fpj via thawan)",2013.10.08 04:08:55,Thawan Kooburat,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 46ec517..ea50753 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -418,25 +418,42 @@
                     }
                     break;
                 case Leader.INFORM:
-                case Leader.INFORMANDACTIVATE: 
-                    TxnHeader hdr = new TxnHeader();
-                    Record txn;
+                case Leader.INFORMANDACTIVATE:
+                    PacketInFlight packet = new PacketInFlight();
+                    packet.hdr = new TxnHeader();
+
                     if (qp.getType() == Leader.COMMITANDACTIVATE) {
-                       ByteBuffer buffer = ByteBuffer.wrap(qp.getData());    
-                       long suggestedLeaderId = buffer.getLong();                      
+                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());
+                        long suggestedLeaderId = buffer.getLong();
                         byte[] remainingdata = new byte[buffer.remaining()];
                         buffer.get(remainingdata);
-                        txn = SerializeUtils.deserializeTxn(remainingdata, hdr);
-                       QuorumVerifier qv = self.configFromString(new String(((SetDataTxn)txn).getData()));
-                       boolean majorChange =
-                               self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);
+                        packet.rec = SerializeUtils.deserializeTxn(remainingdata, packet.hdr);
+                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn)packet.rec).getData()));
+                        boolean majorChange =
+                                self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);
                         if (majorChange) {
-                           throw new Exception(""changes proposed in reconfig"");
+                            throw new Exception(""changes proposed in reconfig"");
                         }
                     } else {
-                       txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);
+                        packet.rec = SerializeUtils.deserializeTxn(qp.getData(), packet.hdr);
+                        // Log warning message if txn comes out-of-order
+                        if (packet.hdr.getZxid() != lastQueued + 1) {
+                            LOG.warn(""Got zxid 0x""
+                                    + Long.toHexString(packet.hdr.getZxid())
+                                    + "" expected 0x""
+                                    + Long.toHexString(lastQueued + 1));
+                        }
+                        lastQueued = packet.hdr.getZxid();
                     }
-                    zk.processTxn(hdr, txn);
+
+                    if (!snapshotTaken) {
+                        // Apply to db directly if we haven't taken the snapshot
+                        zk.processTxn(packet.hdr, packet.rec);
+                    } else {
+                        packetsNotCommitted.add(packet);
+                        packetsCommitted.add(qp.getZxid());
+                    }
+
                     break;                
                 case Leader.UPTODATE:
                     LOG.info(""Learner received UPTODATE message"");                                      
@@ -486,6 +503,30 @@
             for(Long zxid: packetsCommitted) {
                 fzk.commit(zxid);
             }
+        } else if (zk instanceof ObserverZooKeeperServer) {
+            // Similar to follower, we need to log requests between the snapshot
+            // and UPTODATE
+            ObserverZooKeeperServer ozk = (ObserverZooKeeperServer) zk;
+            for (PacketInFlight p : packetsNotCommitted) {
+                Long zxid = packetsCommitted.peekFirst();
+                if (p.hdr.getZxid() != zxid) {
+                    // log warning message if there is no matching commit
+                    // old leader send outstanding proposal to observer
+                    LOG.warn(""Committing "" + Long.toHexString(zxid)
+                            + "", but next proposal is ""
+                            + Long.toHexString(p.hdr.getZxid()));
+                    continue;
+                }
+                packetsCommitted.remove();
+                Request request = new Request(null, p.hdr.getClientId(),
+                        p.hdr.getCxid(), p.hdr.getType(), null, null);
+                request.setTxn(p.rec);
+                request.setHdr(p.hdr);
+                ozk.commitRequest(request);
+            }
+        } else {
+            // New server type need to handle in-flight packets
+            throw new UnsupportedOperationException(""Unknown server type"");
         }
     }
     
"
zookeeper,adedc7a421c723f1427cd0034953e1826587d9bb,"ZOOKEEPER-1551. Observers ignore txns that come after snapshot and UPTODATE (thawan, fpj via thawan)",2013.10.08 04:08:55,Thawan Kooburat,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index c53305d..ccb6092 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -407,7 +407,7 @@
      * Enables/Disables sync request processor. This option is enabled
      * by default and is to be used with observers.
      */
-    protected boolean syncEnabled;
+    protected boolean syncEnabled = true;
 
     /**
      * The current tick
"
zookeeper,7033e577a54e1df2a766e1cd59836c7c837e6e74,ZOOKEEPER-1770. NullPointerException in SnapshotFormatter (Germán Blanco via phunt),2013.10.02 08:45:22,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/SnapshotFormatter.java b/src/java/main/org/apache/zookeeper/server/SnapshotFormatter.java
index 865dfbd..0ecab73 100644
--- a/src/java/main/org/apache/zookeeper/server/SnapshotFormatter.java
+++ b/src/java/main/org/apache/zookeeper/server/SnapshotFormatter.java
@@ -87,7 +87,11 @@
         synchronized(n) { // keep findbugs happy
             System.out.println(name);
             printStat(n.stat);
-            System.out.println(""  dataLength = "" + n.data.length);
+            if (n.data != null) {
+                System.out.println(""  dataLength = "" + n.data.length);
+            } else {
+                System.out.println(""  no data"");
+            }
             children = n.getChildren();
         }
         if (children != null) {
"
zookeeper,4e82aebecc6338b5668742c87ebd0d913c08410c,ZOOKEEPER-1769. ZooInspector can't display node data/metadata/ACLs (Benjamin Jaton via phunt),2013.10.01 14:56:21,Patrick D. Hunt,"diff --git a/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/ZooInspector.java b/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/ZooInspector.java
index 27ed1bd..6f22380 100644
--- a/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/ZooInspector.java
+++ b/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/ZooInspector.java
@@ -33,6 +33,9 @@
  * 
  */
 public class ZooInspector {
+	
+	public static IconResource iconResource;
+	
     /**
      * @param args
      *            - not used. The value of these parameters will have no effect
@@ -43,8 +46,9 @@
             UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
             JFrame frame = new JFrame(""ZooInspector"");
             frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+            iconResource = new IconResource();
             final ZooInspectorPanel zooInspectorPanel = new ZooInspectorPanel(
-                    new ZooInspectorManagerImpl(), new IconResource());
+                    new ZooInspectorManagerImpl(), iconResource);
             frame.addWindowListener(new WindowAdapter() {
                 @Override
                 public void windowClosed(WindowEvent e) {
"
zookeeper,4e82aebecc6338b5668742c87ebd0d913c08410c,ZOOKEEPER-1769. ZooInspector can't display node data/metadata/ACLs (Benjamin Jaton via phunt),2013.10.01 14:56:21,Patrick D. Hunt,"diff --git a/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/gui/nodeviewer/NodeViewerData.java b/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/gui/nodeviewer/NodeViewerData.java
index 25bd1b6..9ca3a02 100644
--- a/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/gui/nodeviewer/NodeViewerData.java
+++ b/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/gui/nodeviewer/NodeViewerData.java
@@ -30,6 +30,7 @@
 import javax.swing.JToolBar;
 import javax.swing.SwingWorker;
 
+import org.apache.zookeeper.inspector.ZooInspector;
 import org.apache.zookeeper.inspector.gui.IconResource;
 import org.apache.zookeeper.inspector.logger.LoggerFactory;
 import org.apache.zookeeper.inspector.manager.ZooInspectorNodeManager;
@@ -43,7 +44,7 @@
     private final JToolBar toolbar;
     private String selectedNode;
 
-    public NodeViewerData(IconResource iconResource) {
+    public NodeViewerData() {
         this.setLayout(new BorderLayout());
         this.dataArea = new JTextPane();
         this.toolbar = new JToolBar();
@@ -53,7 +54,7 @@
                 .setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
         this.add(scroller, BorderLayout.CENTER);
         this.add(this.toolbar, BorderLayout.NORTH);
-        JButton saveButton = new JButton(iconResource.get(IconResource.ICON_SAVE,""""));
+        JButton saveButton = new JButton(ZooInspector.iconResource.get(IconResource.ICON_SAVE,""""));
         saveButton.addActionListener(new ActionListener() {
 
             public void actionPerformed(ActionEvent e) {
"
zookeeper,4e82aebecc6338b5668742c87ebd0d913c08410c,ZOOKEEPER-1769. ZooInspector can't display node data/metadata/ACLs (Benjamin Jaton via phunt),2013.10.01 14:56:21,Patrick D. Hunt,"diff --git a/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java b/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java
index e30e317..fbacb7e 100644
--- a/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java
+++ b/src/contrib/zooinspector/src/java/org/apache/zookeeper/inspector/manager/ZooInspectorManagerImpl.java
@@ -84,7 +84,7 @@
     public static final String DATA_ENCRYPTION_MANAGER = ""encryptionManager"";
 
     private static final File defaultNodeViewersFile = new File(
-            ""./config/defaultNodeVeiwers.cfg"");
+            ""./config/defaultNodeViewers.cfg"");
     private static final File defaultConnectionFile = new File(
             ""./config/defaultConnectionSettings.cfg"");
 
"
zookeeper,85a22cac6e5059896d2ad7d273198621fed33174,ZOOKEEPER-1696. Fail to run zookeeper client on Weblogic application server. (Jeffrey Zhong via mahade,2013.09.28 08:24:37,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index d45071e..aa1e66f 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -80,6 +80,7 @@
     private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperSaslClient.class);
     private static Login login = null;
     private SaslClient saslClient;
+    private boolean isSASLConfigured = true;
 
     private byte[] saslToken = new byte[0];
 
@@ -113,12 +114,17 @@
         String clientSection = System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, ""Client"");
         // Note that 'Configuration' here refers to javax.security.auth.login.Configuration.
         AppConfigurationEntry entries[] = null;
-        SecurityException securityException = null;
+        RuntimeException runtimeException = null;
         try {
             entries = Configuration.getConfiguration().getAppConfigurationEntry(clientSection);
         } catch (SecurityException e) {
             // handle below: might be harmless if the user doesn't intend to use JAAS authentication.
-            securityException = e;
+            runtimeException = e;
+        } catch (IllegalArgumentException e) {
+            // third party customized getAppConfigurationEntry could throw IllegalArgumentException when JAAS
+            // configuration isn't set. We can reevaluate whether to catch RuntimeException instead when more 
+            // different types of RuntimeException found
+            runtimeException = e;
         }
         if (entries != null) {
             this.configStatus = ""Will attempt to SASL-authenticate using Login Context section '"" + clientSection + ""'"";
@@ -131,11 +137,11 @@
             if (explicitClientSection != null) {
                 // If the user explicitly overrides the default Login Context, they probably expected SASL to
                 // succeed. But if we got here, SASL failed.
-                if (securityException != null) {
+                if (runtimeException != null) {
                     throw new LoginException(""Zookeeper client cannot authenticate using the "" + explicitClientSection +
                             "" section of the supplied JAAS configuration: '"" +
                             System.getProperty(Environment.JAAS_CONF_KEY) + ""' because of a "" +
-                            ""SecurityException: "" + securityException);
+                            ""RuntimeException: "" + runtimeException);
                 } else {
                     throw new LoginException(""Client cannot SASL-authenticate because the specified JAAS configuration "" +
                             ""section '"" + explicitClientSection + ""' could not be found."");
@@ -144,21 +150,22 @@
                 // The user did not override the default context. It might be that they just don't intend to use SASL,
                 // so log at INFO, not WARN, since they don't expect any SASL-related information.
                 String msg = ""Will not attempt to authenticate using SASL "";
-                if (securityException != null) {
-                    msg += ""("" + securityException.getLocalizedMessage() + "")"";
+                if (runtimeException != null) {
+                    msg += ""("" + runtimeException + "")"";
                 } else {
                     msg += ""(unknown error)"";
                 }
                 this.configStatus = msg;
+                this.isSASLConfigured = false;
             }
             if (System.getProperty(Environment.JAAS_CONF_KEY)  != null) {
                 // Again, the user explicitly set something SASL-related, so they probably expected SASL to succeed.
-                if (securityException != null) {
+                if (runtimeException != null) {
                     throw new LoginException(""Zookeeper client cannot authenticate using the '"" +
                             System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, ""Client"") +
                             ""' section of the supplied JAAS configuration: '"" +
                             System.getProperty(Environment.JAAS_CONF_KEY) + ""' because of a "" +
-                            ""SecurityException: "" + securityException);
+                            ""RuntimeException: "" + runtimeException);
                 } else {
                     throw new LoginException(""No JAAS configuration section named '"" +
                             System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, ""Client"") +
@@ -168,7 +175,7 @@
             }
         }
     }
-
+    
     /**
      * @return informational message indicating the current configuration status.
      */
@@ -528,6 +535,9 @@
     }
 
     public boolean clientTunneledAuthenticationInProgress() {
+    	if (!isSASLConfigured) {
+    	    return false;
+        } 
         // TODO: Rather than checking a disjunction here, should be a single member
         // variable or method in this class to determine whether the client is
         // configured to use SASL. (see also ZOOKEEPER-1455).
"
zookeeper,eb1cb72922b1e974eadb8936df965d630261bd47,ZOOKEEPER-87. Follower does not shut itself down if its too far behind the leader. (German Blanco via fpj),2013.09.26 21:05:47,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index af6d3b4..f664353 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -92,6 +92,63 @@
     final LinkedBlockingQueue<QuorumPacket> queuedPackets =
         new LinkedBlockingQueue<QuorumPacket>();
 
+    /**
+     * This class controls the time that the Leader has been
+     * waiting for acknowledgement of a proposal from this Learner.
+     * If the time is above syncLimit, the connection will be closed.
+     * It keeps track of only one proposal at a time, when the ACK for
+     * that proposal arrives, it switches to the last proposal received
+     * or clears the value if there is no pending proposal.
+     */
+    private class SyncLimitCheck {
+        private boolean started = false;
+        private long currentZxid = 0;
+        private long currentTime = 0;
+        private long nextZxid = 0;
+        private long nextTime = 0;
+
+        public synchronized void start() {
+            started = true;
+        }
+
+        public synchronized void updateProposal(long zxid, long time) {
+            if (!started) {
+                return;
+            }
+            if (currentTime == 0) {
+                currentTime = time;
+                currentZxid = zxid;
+            } else {
+                nextTime = time;
+                nextZxid = zxid;
+            }
+        }
+
+        public synchronized void updateAck(long zxid) {
+             if (currentZxid == zxid) {
+                 currentTime = nextTime;
+                 currentZxid = nextZxid;
+                 nextTime = 0;
+                 nextZxid = 0;
+             } else if (nextZxid == zxid) {
+                 LOG.warn(""ACK for "" + zxid + "" received before ACK for "" + currentZxid + ""!!!!"");
+                 nextTime = 0;
+                 nextZxid = 0;
+             }
+        }
+
+        public synchronized boolean check(long time) {
+            if (currentTime == 0) {
+                return true;
+            } else {
+                long msDelay = (time - currentTime) / 1000000;
+                return (msDelay < (leader.self.tickTime * leader.self.syncLimit));
+            }
+        }
+    };
+
+    private SyncLimitCheck syncLimitCheck = new SyncLimitCheck();
+
     private BinaryInputArchive ia;
 
     private BinaryOutputArchive oa;
@@ -171,6 +228,9 @@
                 if (p.getType() == Leader.PING) {
                     traceMask = ZooTrace.SERVER_PING_TRACE_MASK;
                 }
+                if (p.getType() == Leader.PROPOSAL) {
+                    syncLimitCheck.updateProposal(p.getZxid(), System.nanoTime());
+                }
                 if (LOG.isTraceEnabled()) {
                     ZooTrace.logQuorumPacket(LOG, traceMask, 'o', p);
                 }
@@ -396,6 +456,8 @@
             	LOG.debug(""Received NEWLEADER-ACK message from "" + sid);   
             }
             leader.waitForNewLeaderAck(getSid(), qp.getZxid(), getLearnerType());
+
+            syncLimitCheck.start();
             
             // now that the ack has been processed expect the syncLimit
             sock.setSoTimeout(leader.self.tickTime * leader.self.syncLimit);
@@ -441,6 +503,7 @@
                             LOG.debug(""Received ACK from Observer  "" + this.sid);
                         }
                     }
+                    syncLimitCheck.updateAck(qp.getZxid());
                     leader.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());
                     break;
                 case Leader.PING:
@@ -822,12 +885,16 @@
             return;
         }
         long id;
-        synchronized(leader) {
-            id = leader.lastProposed;
+        if (syncLimitCheck.check(System.nanoTime())) {
+            synchronized(leader) {
+                id = leader.lastProposed;
+            }
+            QuorumPacket ping = new QuorumPacket(Leader.PING, id, null, null);
+            queuePacket(ping);
+        } else {
+            LOG.warn(""Closing connection to peer due to transaction timeout."");
+            shutdown();
         }
-        QuorumPacket ping = new QuorumPacket(Leader.PING, id,
-                null, null);
-        queuePacket(ping);
     }
 
     /**
"
zookeeper,8e29703235388d3e46de1c0c0517c94e929b7c6c,ZOOKEEPER-1696. Fail to run zookeeper client on Weblogic application server. (Jeffrey Zhong via mahade.,2013.09.26 09:00:43,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index d45071e..8c7d26e 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -80,6 +80,7 @@
     private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperSaslClient.class);
     private static Login login = null;
     private SaslClient saslClient;
+    private boolean isSASLConfigured = true;
 
     private byte[] saslToken = new byte[0];
 
@@ -104,7 +105,7 @@
     }
 
     public ZooKeeperSaslClient(final String serverPrincipal)
-            throws LoginException {
+            throws LoginException {    	
         /**
          * ZOOKEEPER-1373: allow system property to specify the JAAS
          * configuration section that the zookeeper client should use.
@@ -113,12 +114,12 @@
         String clientSection = System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, ""Client"");
         // Note that 'Configuration' here refers to javax.security.auth.login.Configuration.
         AppConfigurationEntry entries[] = null;
-        SecurityException securityException = null;
+        RuntimeException runtimeException = null;
         try {
             entries = Configuration.getConfiguration().getAppConfigurationEntry(clientSection);
-        } catch (SecurityException e) {
+        } catch (RuntimeException e) {
             // handle below: might be harmless if the user doesn't intend to use JAAS authentication.
-            securityException = e;
+            runtimeException = e;
         }
         if (entries != null) {
             this.configStatus = ""Will attempt to SASL-authenticate using Login Context section '"" + clientSection + ""'"";
@@ -131,11 +132,11 @@
             if (explicitClientSection != null) {
                 // If the user explicitly overrides the default Login Context, they probably expected SASL to
                 // succeed. But if we got here, SASL failed.
-                if (securityException != null) {
+                if (runtimeException != null) {
                     throw new LoginException(""Zookeeper client cannot authenticate using the "" + explicitClientSection +
                             "" section of the supplied JAAS configuration: '"" +
                             System.getProperty(Environment.JAAS_CONF_KEY) + ""' because of a "" +
-                            ""SecurityException: "" + securityException);
+                            ""RuntimeException: "" + runtimeException);
                 } else {
                     throw new LoginException(""Client cannot SASL-authenticate because the specified JAAS configuration "" +
                             ""section '"" + explicitClientSection + ""' could not be found."");
@@ -144,21 +145,22 @@
                 // The user did not override the default context. It might be that they just don't intend to use SASL,
                 // so log at INFO, not WARN, since they don't expect any SASL-related information.
                 String msg = ""Will not attempt to authenticate using SASL "";
-                if (securityException != null) {
-                    msg += ""("" + securityException.getLocalizedMessage() + "")"";
+                if (runtimeException != null) {
+                    msg += ""("" + runtimeException.getLocalizedMessage() + "")"";
                 } else {
                     msg += ""(unknown error)"";
                 }
                 this.configStatus = msg;
+                this.isSASLConfigured = false;
             }
             if (System.getProperty(Environment.JAAS_CONF_KEY)  != null) {
                 // Again, the user explicitly set something SASL-related, so they probably expected SASL to succeed.
-                if (securityException != null) {
+                if (runtimeException != null) {
                     throw new LoginException(""Zookeeper client cannot authenticate using the '"" +
                             System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, ""Client"") +
                             ""' section of the supplied JAAS configuration: '"" +
                             System.getProperty(Environment.JAAS_CONF_KEY) + ""' because of a "" +
-                            ""SecurityException: "" + securityException);
+                            ""RuntimeException: "" + runtimeException);
                 } else {
                     throw new LoginException(""No JAAS configuration section named '"" +
                             System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, ""Client"") +
@@ -168,7 +170,7 @@
             }
         }
     }
-
+    
     /**
      * @return informational message indicating the current configuration status.
      */
@@ -528,6 +530,9 @@
     }
 
     public boolean clientTunneledAuthenticationInProgress() {
+    	if (!isSASLConfigured) {
+    	    return false;
+        } 
         // TODO: Rather than checking a disjunction here, should be a single member
         // variable or method in this class to determine whether the client is
         // configured to use SASL. (see also ZOOKEEPER-1455).
"
zookeeper,000b7dfa2fd3339af95870b95c1e12acc8313cf6,"ZOOKEEPER-1753. ClientCnxn is not properly releasing the resources, which are used to ping RwServer (Rakesh R via fpj)",2013.09.18 22:14:07,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 668e8a3..9587ce4 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1161,25 +1161,40 @@
             LOG.info(""Checking server "" + addr + "" for being r/w."" +
                     "" Timeout "" + pingRwTimeout);
 
+            Socket sock = null;
+            BufferedReader br = null;
             try {
-                Socket sock = new Socket(addr.getHostName(), addr.getPort());
+                sock = new Socket(addr.getHostName(), addr.getPort());
                 sock.setSoLinger(false, -1);
                 sock.setSoTimeout(1000);
                 sock.setTcpNoDelay(true);
                 sock.getOutputStream().write(""isro"".getBytes());
                 sock.getOutputStream().flush();
                 sock.shutdownOutput();
-                BufferedReader br = new BufferedReader(
+                br = new BufferedReader(
                         new InputStreamReader(sock.getInputStream()));
                 result = br.readLine();
-                sock.close();
-                br.close();
             } catch (ConnectException e) {
                 // ignore, this just means server is not up
             } catch (IOException e) {
                 // some unexpected error, warn about it
                 LOG.warn(""Exception while seeking for r/w server "" +
                         e.getMessage(), e);
+            } finally {
+                if (sock != null) {
+                    try {
+                        sock.close();
+                    } catch (IOException e) {
+                        LOG.warn(""Unexpected exception"", e);
+                    }
+                }
+                if (br != null) {
+                    try {
+                        br.close();
+                    } catch (IOException e) {
+                        LOG.warn(""Unexpected exception"", e);
+                    }
+                }
             }
 
             if (""rw"".equals(result)) {
"
zookeeper,885bac190a4e2cb34949fc9f3182200e95fa8d62,ZOOKEEPER-1657. Increased CPU usage by unnecessary SASL checks (Philip K. Warren via fpj),2013.09.18 19:58:32,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index edacce5..668e8a3 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -979,19 +979,21 @@
 
             setName(getName().replaceAll(""\\(.*\\)"",
                     ""("" + addr.getHostName() + "":"" + addr.getPort() + "")""));
-            try {
-                zooKeeperSaslClient = new ZooKeeperSaslClient(""zookeeper/""+addr.getHostName());
-            } catch (LoginException e) {
-                // An authentication error occurred when the SASL client tried to initialize:
-                // for Kerberos this means that the client failed to authenticate with the KDC.
-                // This is different from an authentication error that occurs during communication
-                // with the Zookeeper server, which is handled below.
-                LOG.warn(""SASL configuration failed: "" + e + "" Will continue connection to Zookeeper server without ""
-                  + ""SASL authentication, if Zookeeper server allows it."");
-                eventThread.queueEvent(new WatchedEvent(
-                  Watcher.Event.EventType.None,
-                  Watcher.Event.KeeperState.AuthFailed, null));
-                saslLoginFailed = true;
+            if (ZooKeeperSaslClient.isEnabled()) {
+                try {
+                    zooKeeperSaslClient = new ZooKeeperSaslClient(""zookeeper/""+addr.getHostName());
+                } catch (LoginException e) {
+                    // An authentication error occurred when the SASL client tried to initialize:
+                    // for Kerberos this means that the client failed to authenticate with the KDC.
+                    // This is different from an authentication error that occurs during communication
+                    // with the Zookeeper server, which is handled below.
+                    LOG.warn(""SASL configuration failed: "" + e + "" Will continue connection to Zookeeper server without ""
+                      + ""SASL authentication, if Zookeeper server allows it."");
+                    eventThread.queueEvent(new WatchedEvent(
+                      Watcher.Event.EventType.None,
+                      Watcher.Event.KeeperState.AuthFailed, null));
+                    saslLoginFailed = true;
+                }
             }
             logStartConnect(addr);
 
@@ -1263,18 +1265,23 @@
         }
 
         public boolean clientTunneledAuthenticationInProgress() {
-            // 1. SASL login failed.
+            // 1. SASL client is disabled.
+            if (!ZooKeeperSaslClient.isEnabled()) {
+                return false;
+            }
+
+            // 2. SASL login failed.
             if (saslLoginFailed == true) {
                 return false;
             }
 
-            // 2. SendThread has not created the authenticating object yet,
+            // 3. SendThread has not created the authenticating object yet,
             // therefore authentication is (at the earliest stage of being) in progress.
             if (zooKeeperSaslClient == null) {
                 return true;
             }
 
-            // 3. authenticating object exists, so ask it for its progress.
+            // 4. authenticating object exists, so ask it for its progress.
             return zooKeeperSaslClient.clientTunneledAuthenticationInProgress();
         }
 
"
zookeeper,885bac190a4e2cb34949fc9f3182200e95fa8d62,ZOOKEEPER-1657. Increased CPU usage by unnecessary SASL checks (Philip K. Warren via fpj),2013.09.18 19:58:32,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index 434fb8d..d45071e 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -62,6 +62,21 @@
  */
 public class ZooKeeperSaslClient {
     public static final String LOGIN_CONTEXT_NAME_KEY = ""zookeeper.sasl.clientconfig"";
+    public static final String ENABLE_CLIENT_SASL_KEY = ""zookeeper.sasl.client"";
+    public static final String ENABLE_CLIENT_SASL_DEFAULT = ""true"";
+
+    /**
+     * Returns true if the SASL client is enabled. By default, the client
+     * is enabled but can be disabled by setting the system property
+     * <code>zookeeper.sasl.client</code> to <code>false</code>. See
+     * ZOOKEEPER-1657 for more information.
+     *
+     * @return If the SASL client is enabled.
+     */
+    public static boolean isEnabled() {
+        return Boolean.valueOf(System.getProperty(ENABLE_CLIENT_SASL_KEY, ENABLE_CLIENT_SASL_DEFAULT));
+    }
+
     private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperSaslClient.class);
     private static Login login = null;
     private SaslClient saslClient;
"
zookeeper,a00d174d986386b19b0bf285918b06f2fcf55a2f,ZOOKEEPER-1751. ClientCnxn#run could miss the second ping or connection get dropped before a ping. (Jeffrey Zhong via mahadev),2013.09.18 11:08:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index dc0782d..edacce5 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1016,6 +1016,7 @@
             clientCnxnSocket.updateLastSendAndHeard();
             int to;
             long lastPingRwServer = System.currentTimeMillis();
+            final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds
             while (state.isAlive()) {
                 try {
                     if (!clientCnxnSocket.isConnected()) {
@@ -1072,9 +1073,12 @@
                                         + Long.toHexString(sessionId));
                     }
                     if (state.isConnected()) {
-                        int timeToNextPing = readTimeout / 2
-                                - clientCnxnSocket.getIdleSend();
-                        if (timeToNextPing <= 0) {
+                    	//1000(1 second) is to prevent race condition missing to send the second ping
+                    	//also make sure not to send too many pings when readTimeout is small 
+                        int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - 
+                        		((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);
+                        //send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL
+                        if (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {
                             sendPing();
                             clientCnxnSocket.updateLastSend();
                         } else {
"
zookeeper,67dd6fc9df3d33e40570095b52cd6858621c3ae0,ZOOKEEPER-1754. Read-only server allows to create znode (Rakesh R via fpj),2013.09.18 08:14:04,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
index cb4fedb..e9d5ddd 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
@@ -28,7 +28,6 @@
 import org.apache.zookeeper.server.RequestProcessor;
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.ZooTrace;
-import org.apache.zookeeper.server.RequestProcessor.RequestProcessorException;
 import org.apache.zookeeper.server.quorum.Leader.XidRolloverException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -78,6 +77,7 @@
                 switch (request.type) {
                 case OpCode.sync:
                 case OpCode.create:
+                case OpCode.create2:
                 case OpCode.delete:
                 case OpCode.setData:
                 case OpCode.reconfig:
"
zookeeper,46cbf07c4e6da3d9897ecc2373f9a0996ed730d2," ZOOKEEPER-1664. Kerberos auth doesn't work with native platform GSS integration. (Boaz Kelmer via camille)    ",2013.09.12 05:44:15,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index 6087e99..434fb8d 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -18,23 +18,11 @@
 
 package org.apache.zookeeper.client;
 
-import org.apache.zookeeper.AsyncCallback;
-import org.apache.zookeeper.ClientCnxn;
-import org.apache.zookeeper.Login;
-import org.apache.zookeeper.Watcher.Event.KeeperState;
-import org.apache.zookeeper.ZooDefs;
-import org.apache.zookeeper.Environment;
-import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.proto.GetSASLRequest;
-import org.apache.zookeeper.proto.SetSASLResponse;
-import org.apache.zookeeper.server.auth.KerberosName;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.IOException;
 import java.security.Principal;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
+
 import javax.security.auth.Subject;
 import javax.security.auth.callback.Callback;
 import javax.security.auth.callback.CallbackHandler;
@@ -50,6 +38,24 @@
 import javax.security.sasl.SaslClient;
 import javax.security.sasl.SaslException;
 
+import org.apache.zookeeper.AsyncCallback;
+import org.apache.zookeeper.ClientCnxn;
+import org.apache.zookeeper.Environment;
+import org.apache.zookeeper.Login;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.proto.GetSASLRequest;
+import org.apache.zookeeper.proto.SetSASLResponse;
+import org.apache.zookeeper.server.auth.KerberosName;
+import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSCredential;
+import org.ietf.jgss.GSSException;
+import org.ietf.jgss.GSSManager;
+import org.ietf.jgss.Oid;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * This class manages SASL authentication for the client. It
  * allows ClientCnxn to authenticate using SASL with a Zookeeper server.
@@ -213,6 +219,33 @@
                 return saslClient;
             }
             else { // GSSAPI.
+            	boolean usingNativeJgss =
+            			Boolean.getBoolean(""sun.security.jgss.native"");
+            	if (usingNativeJgss) {
+            		// http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html
+            		// """"""
+            		// In addition, when performing operations as a particular
+            		// Subject, e.g. Subject.doAs(...) or Subject.doAsPrivileged(...),
+            		// the to-be-used GSSCredential should be added to Subject's
+            		// private credential set. Otherwise, the GSS operations will
+            		// fail since no credential is found.
+            		// """"""
+            		try {
+            			GSSManager manager = GSSManager.getInstance();
+            			Oid krb5Mechanism = new Oid(""1.2.840.113554.1.2.2"");
+            			GSSCredential cred = manager.createCredential(null,
+            					GSSContext.DEFAULT_LIFETIME,
+            					krb5Mechanism,
+            					GSSCredential.INITIATE_ONLY);
+            			subject.getPrivateCredentials().add(cred);
+            			if (LOG.isDebugEnabled()) {
+            				LOG.debug(""Added private credential to subject: "" + cred);
+            			}
+            		} catch (GSSException ex) {
+            			LOG.warn(""Cannot add private credential to subject; "" +
+            					""authentication at the server may fail"", ex);
+            		}
+            	}
                 final Object[] principals = subject.getPrincipals().toArray();
                 // determine client principal from subject.
                 final Principal clientPrincipal = (Principal)principals[0];
@@ -237,7 +270,7 @@
                     return saslClient;
                 }
                 catch (Exception e) {
-                    LOG.error(""Error creating SASL client:"" + e);
+                	LOG.error(""Exception while trying to create SASL client"", e);
                     e.printStackTrace();
                     return null;
                 }
"
zookeeper,46cbf07c4e6da3d9897ecc2373f9a0996ed730d2," ZOOKEEPER-1664. Kerberos auth doesn't work with native platform GSS integration. (Boaz Kelmer via camille)    ",2013.09.12 05:44:15,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperSaslServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperSaslServer.java
index e3221a3..71870ce 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperSaslServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperSaslServer.java
@@ -21,13 +21,21 @@
 import java.security.Principal;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+
 import javax.security.auth.Subject;
 import javax.security.sasl.Sasl;
 import javax.security.sasl.SaslException;
 import javax.security.sasl.SaslServer;
+
 import org.apache.zookeeper.Login;
+import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSCredential;
+import org.ietf.jgss.GSSException;
+import org.ietf.jgss.GSSManager;
+import org.ietf.jgss.GSSName;
+import org.ietf.jgss.Oid;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class ZooKeeperSaslServer {
     public static final String LOGIN_CONTEXT_NAME_KEY = ""zookeeper.sasl.serverconfig"";
@@ -68,9 +76,40 @@
                         final String mech = ""GSSAPI"";   // TODO: should depend on zoo.cfg specified mechs, but if subject is non-null, it can be assumed to be GSSAPI.
 
                         LOG.debug(""serviceHostname is '""+ serviceHostname + ""'"");
-                        LOG.debug(""servicePrincipalName is ""+ servicePrincipalName + ""'"");
-                        LOG.debug(""SASL mechanism(mech) is ""+ mech +""'"");
+                        LOG.debug(""servicePrincipalName is '""+ servicePrincipalName + ""'"");
+                        LOG.debug(""SASL mechanism(mech) is '""+ mech +""'"");
 
+                        boolean usingNativeJgss =
+                        		Boolean.getBoolean(""sun.security.jgss.native"");
+                        if (usingNativeJgss) {
+                        	// http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html
+                        	// """"""
+                        	// In addition, when performing operations as a particular
+                        	// Subject, e.g. Subject.doAs(...) or
+                        	// Subject.doAsPrivileged(...), the to-be-used
+                        	// GSSCredential should be added to Subject's
+                        	// private credential set. Otherwise, the GSS operations
+                        	// will fail since no credential is found.
+                        	// """"""
+                        	try {
+                        		GSSManager manager = GSSManager.getInstance();
+                        		Oid krb5Mechanism = new Oid(""1.2.840.113554.1.2.2"");
+                        		GSSName gssName = manager.createName(
+                        				servicePrincipalName + ""@"" + serviceHostname,
+                        				GSSName.NT_HOSTBASED_SERVICE);
+                        		GSSCredential cred = manager.createCredential(gssName,
+                        				GSSContext.DEFAULT_LIFETIME,
+                        				krb5Mechanism,
+                        				GSSCredential.ACCEPT_ONLY);
+                        		subject.getPrivateCredentials().add(cred);
+                        		if (LOG.isDebugEnabled()) {
+                        			LOG.debug(""Added private credential to subject: "" + cred);
+                        		}
+                        	} catch (GSSException ex) {
+                        		LOG.warn(""Cannot add private credential to subject; "" +
+                        				""clients authentication may fail"", ex);
+                        	}
+                        }
                         try {
                             return Subject.doAs(subject,new PrivilegedExceptionAction<SaslServer>() {
                                 public SaslServer run() {
@@ -94,8 +133,8 @@
                             e.printStackTrace();
                         }
                     }
-                    catch (Exception e) {
-                        LOG.error(""server principal name/hostname determination error: "" + e);
+                    catch (IndexOutOfBoundsException e) {
+                        LOG.error(""server principal name/hostname determination error: "", e);
                     }
                 }
                 else {
@@ -106,7 +145,7 @@
                         return saslServer;
                     }
                     catch (SaslException e) {
-                        LOG.error(""Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation: "" + e);
+                        LOG.error(""Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation"", e);
                     }
                 }
             }
"
zookeeper,12878387483a4084c5a3beafbfae0172a44e5dcf,ZOOKEEPER-1750 Race condition producing NPE in NIOServerCnxn.toString (Rakesh R via michim),2013.09.10 07:37:13,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 2094b1a..96529ad 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -31,7 +31,6 @@
 import java.nio.channels.SocketChannel;
 import java.util.List;
 import java.util.Queue;
-import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -63,7 +62,7 @@
 
     private final NIOServerCnxnFactory factory;
 
-    private SocketChannel sock;
+    private final SocketChannel sock;
 
     private final SelectorThread selectorThread;
 
@@ -139,7 +138,7 @@
             * a tight while loop
             */
            if (bb != ServerCnxnFactory.closeConn) {
-               if (sock != null) {
+               if (sock.isOpen()) {
                    sock.configureBlocking(true);
                    sock.write(bb);
                }
@@ -307,7 +306,7 @@
      */
     void doIO(SelectionKey k) throws InterruptedException {
         try {
-            if (sock == null) {
+            if (sock.isOpen() == false) {
                 LOG.warn(""trying to do i/o on a null socket for session:0x""
                          + Long.toHexString(sessionId));
 
@@ -993,7 +992,7 @@
      * Close resources associated with the sock of this cnxn.
      */
     private void closeSock() {
-        if (sock == null) {
+        if (sock.isOpen() == false) {
             return;
         }
 
@@ -1003,14 +1002,13 @@
                         "" which had sessionid 0x"" + Long.toHexString(sessionId) :
                         "" (no session established for client)""));
         closeSock(sock);
-        sock = null;
     }
 
     /**
      * Close resources associated with a sock.
      */
     public static void closeSock(SocketChannel sock) {
-        if (sock == null) {
+        if (sock.isOpen() == false) {
             return;
         }
 
@@ -1152,14 +1150,14 @@
 
     @Override
     public InetSocketAddress getRemoteSocketAddress() {
-        if (sock == null) {
+        if (sock.isOpen() == false) {
             return null;
         }
         return (InetSocketAddress) sock.socket().getRemoteSocketAddress();
     }
 
     public InetAddress getSocketAddress() {
-        if (sock == null) {
+        if (sock.isOpen() == false) {
             return null;
         }
         return sock.socket().getInetAddress();
"
zookeeper,62dcea67c7a3d12bdb5fa014936f465fadb1e3df,ZOOKEEPER-1448. Node+Quota creation in transaction log can crash leader startup (Botond Hejj via fpj),2013.09.06 06:50:08,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/common/PathTrie.java b/src/java/main/org/apache/zookeeper/common/PathTrie.java
index 2857592..73053e0 100644
--- a/src/java/main/org/apache/zookeeper/common/PathTrie.java
+++ b/src/java/main/org/apache/zookeeper/common/PathTrie.java
@@ -281,4 +281,13 @@
         }
         return sb.toString();
     }
+
+    /**
+     * clear all nodes
+     */
+    public void clear() {
+        for(String child : rootNode.getChildren()) {
+            rootNode.deleteChild(child);
+        }
+    }
 }
"
zookeeper,62dcea67c7a3d12bdb5fa014936f465fadb1e3df,ZOOKEEPER-1448. Node+Quota creation in transaction log can crash leader startup (Botond Hejj via fpj),2013.09.06 06:50:08,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 66e2888..9b9cb80 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -1209,6 +1209,7 @@
     public void deserialize(InputArchive ia, String tag) throws IOException {
         deserializeList(longKeyMap, ia);
         nodes.clear();
+        pTrie.clear();
         String path = ia.readString(""path"");
         while (!""/"".equals(path)) {
             DataNode node = new DataNode();
"
zookeeper,15c32d197968fe41d194ef11f665508ff39ed5d7,"ZOOKEEPER-1379. 'printwatches, redo, history and connect '. client commands always print usage. This is not necessary (edward via fpj)",2013.09.03 06:04:12,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index f82fa36..e369c38 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -663,14 +663,15 @@
         if(cliCmd != null) {
             cliCmd.setZk(zk);
             watch = cliCmd.parse(args).exec();
-            } else {
-                usage();
-            }
+        } else if (!commandMap.containsKey(cmd)) {
+             usage();
+        }
+
         } catch (ParseException ex) {
             System.err.println(ex.getMessage());
-                usage();
+            usage();
             return false;
-            }
+        }
         return watch;
     }
-        }
+}
"
zookeeper,b40bb0b4622bb4e1eca6331b2b3b4fc271742dc9,"ZOOKEEPER-1702. ZooKeeper client may write operation packets before receiving successful response to connection request, can cause TCP RST (Chris Nauroth via phunt)",2013.07.02 07:54:25,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
index fbb0284..f979c03 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
@@ -139,6 +139,17 @@
                     // to attempt SASL authentication), or in either doIO() or
                     // in doTransport() if not.
                     disableWrite();
+                } else if (!initialized && p != null && !p.bb.hasRemaining()) {
+                    // On initial connection, write the complete connect request
+                    // packet, but then disable further writes until after
+                    // receiving a successful connection response.  If the
+                    // session is expired, then the server sends the expiration
+                    // response and immediately closes its end of the socket.  If
+                    // the client is simultaneously writing on its end, then the
+                    // TCP stack may choose to abort with RST, in which case the
+                    // client would never receive the session expired event.  See
+                    // http://docs.oracle.com/javase/6/docs/technotes/guides/net/articles/connection_release.html
+                    disableWrite();
                 } else {
                     // Just in case
                     enableWrite();
"
zookeeper,d9ad361538f52ca8122b9aad8a8378892572a87e,ZOOKEEPER-1642. Leader loading database twice (fpj via camille),2013.05.17 01:49:11,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index f1e2e3e..2c78b81 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -230,7 +230,31 @@
      *  Restore sessions and data
      */
     public void loadData() throws IOException, InterruptedException {
-        setZxid(zkDb.loadDataBase());
+        /*
+         * When a new leader starts executing Leader#lead, it 
+         * invokes this method. The database, however, has been
+         * initialized before running leader election so that
+         * the server could pick its zxid for its initial vote.
+         * It does it by invoking QuorumPeer#getLastLoggedZxid.
+         * Consequently, we don't need to initialize it once more
+         * and avoid the penalty of loading it a second time. Not 
+         * reloading it is particularly important for applications
+         * that host a large database.
+         * 
+         * The following if block checks whether the database has
+         * been initialized or not. Note that this method is
+         * invoked by at least one other method: 
+         * ZooKeeperServer#startdata.
+         *  
+         * See ZOOKEEPER-1642 for more detail.
+         */
+        if(zkDb.isInitialized()){
+            setZxid(zkDb.getDataTreeLastProcessedZxid());
+        }
+        else {
+            setZxid(zkDb.loadDataBase());
+        }
+        
         // Clean up dead sessions
         LinkedList<Long> deadSessions = new LinkedList<Long>();
         for (Long session : zkDb.getSessions()) {
"
zookeeper,e1574fad8afabd0df5ff9433c5d968679c3d6f1d,ZOOKEEPER-1697. large snapshots can cause continuous quorum failure   (phunt via fpj),2013.05.11 22:35:13,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index ef763c2..3b253d9 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -64,8 +64,12 @@
 
     final Leader leader;
 
-    long tickOfLastAck;
-
+    /** Deadline for receiving the next ack. If we are bootstrapping then
+     * it's based on the initLimit, if we are done bootstrapping it's based
+     * on the syncLimit. Once the deadline is past this learner should
+     * be considered no longer ""sync'd"" with the leader. */
+    volatile long tickOfNextAckDeadline;
+    
     /**
      * ZooKeeper server identifier of this learner
      */
@@ -104,7 +108,7 @@
     public String toString() {
         StringBuilder sb = new StringBuilder();
         sb.append(""LearnerHandler "").append(sock);
-        sb.append("" tickOfLastAck:"").append(tickOfLastAck());
+        sb.append("" tickOfNextAckDeadline:"").append(tickOfNextAckDeadline());
         sb.append("" synced?:"").append(synced());
         sb.append("" queuedPacketLength:"").append(queuedPackets.size());
         return sb.toString();
@@ -233,6 +237,9 @@
     @Override
     public void run() {
         try {
+            tickOfNextAckDeadline = leader.self.tick
+                    + leader.self.initLimit + leader.self.syncLimit;
+
             ia = BinaryInputArchive.getArchive(new BufferedInputStream(sock
                     .getInputStream()));
             bufferedOutput = new BufferedOutputStream(sock.getOutputStream());
@@ -468,7 +475,7 @@
                 LOG.error(""Next packet was supposed to be an ACK"");
                 return;
             }
-            LOG.debug(""Received NEWLEADER-ACK message from "" + sid);   
+            LOG.info(""Received NEWLEADER-ACK message from "" + sid);
             leader.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());
             
             // now that the ack has been processed expect the syncLimit
@@ -500,7 +507,7 @@
                 if (LOG.isTraceEnabled()) {
                     ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);
                 }
-                tickOfLastAck = leader.self.tick;
+                tickOfNextAckDeadline = leader.self.tick + leader.self.syncLimit;
 
 
                 ByteBuffer bb;
@@ -615,8 +622,8 @@
         leader.removeLearnerHandler(this);
     }
 
-    public long tickOfLastAck() {
-        return tickOfLastAck;
+    public long tickOfNextAckDeadline() {
+        return tickOfNextAckDeadline;
     }
 
     /**
@@ -638,6 +645,6 @@
 
     public boolean synced() {
         return isAlive()
-        && tickOfLastAck >= leader.self.tick - leader.self.syncLimit;
+        && leader.self.tick <= tickOfNextAckDeadline;
     }
 }
"
zookeeper,e1574fad8afabd0df5ff9433c5d968679c3d6f1d,ZOOKEEPER-1697. large snapshots can cause continuous quorum failure   (phunt via fpj),2013.05.11 22:35:13,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 9a8a33e..4831cd6 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -406,7 +406,7 @@
     /**
      * The current tick
      */
-    protected int tick;
+    protected volatile int tick;
 
     /**
      * @deprecated As of release 3.4.0, this class has been deprecated, since
"
zookeeper,52cf2242c993bb27c3305899ab86c2807ac269fc,"ZOOKEEPER-1411. Consolidate membership management, distinguish between static and dynamic configuration parameters. A small bug fix.",2013.04.02 08:01:06,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 328d3be..211701a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -225,7 +225,7 @@
                 snapRetainCount = Integer.parseInt(value);
             } else if (key.equals(""autopurge.purgeInterval"")) {
                 purgeInterval = Integer.parseInt(value);
-            } else if ((key.startsWith(""server."") || key.startsWith(""group"") || key.startsWith(""weight"")) && zkProp.entrySet().contains(""dynamicConfigFile"")){                
+            } else if ((key.startsWith(""server."") || key.startsWith(""group"") || key.startsWith(""weight"")) && zkProp.containsKey(""dynamicConfigFile"")){                
                throw new ConfigException(""parameter: "" + key + "" must be in a separate dynamic config file"");
             } else {
                 System.setProperty(""zookeeper."" + key, value);
"
zookeeper,0312b95b80af898d20c1d77b254832fb32d109f0,"ZOOKEEPER-1672. zookeeper client does not accept ""-members"" option in reconfig command (Xiaoshuang Wang via phunt)",2013.03.20 15:17:41,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java b/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java
index 0dfb839..30d0cf2 100644
--- a/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/ReconfigCommand.java
@@ -85,7 +85,7 @@
         members = null;
         Parser parser = new PosixParser();
         cl = parser.parse(options, cmdArgs);
-        if (!cl.hasOption(""file"") && !cl.hasOption(""add"") && !cl.hasOption(""remove"")) {
+        if (!(cl.hasOption(""file"") || cl.hasOption(""members"")) && !cl.hasOption(""add"") && !cl.hasOption(""remove"")) {
             throw new ParseException(getUsageStr());
         }
         if (cl.hasOption(""v"")) {
"
zookeeper,d9dae9ae9d46ef2a29c3457651a71e40969f7256,ZOOKEEPER-1628. Documented list of allowable characters in ZK doc not in line with code (Gabriel Reid via phunt),2013.01.25 16:08:28,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/common/PathUtils.java b/src/java/main/org/apache/zookeeper/common/PathUtils.java
index 12a6814..e479787 100644
--- a/src/java/main/org/apache/zookeeper/common/PathUtils.java
+++ b/src/java/main/org/apache/zookeeper/common/PathUtils.java
@@ -86,10 +86,10 @@
                     reason = ""relative paths not allowed @"" + i;
                     break;
                 }
-            } else if (c > '\u0000' && c < '\u001f'
-                    || c > '\u007f' && c < '\u009F'
-                    || c > '\ud800' && c < '\uf8ff'
-                    || c > '\ufff0' && c < '\uffff') {
+            } else if (c > '\u0000' && c <= '\u001f'
+                    || c >= '\u007f' && c <= '\u009F'
+                    || c >= '\ud800' && c <= '\uf8ff'
+                    || c >= '\ufff0' && c <= '\uffff') {
                 reason = ""invalid charater @"" + i;
                 break;
             }
"
zookeeper,620c7766fc99230460a248ba1aa1e17b772c418a,ZOOKEEPER-1620. NIOServerCnxnFactory (new code introduced in ZK-1504) opens selectors but never closes them (Thawan Kooburat via phunt),2013.01.25 15:46:16,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
index 9422538..73ee03f 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
@@ -132,6 +132,20 @@
             selector.wakeup();
         }
 
+        /**
+         * Close the selector. This should be called when the thread is about to
+         * exit and no operation is going to be performed on the Selector or
+         * SelectionKey
+         */
+        protected void closeSelector() {
+            try {
+                selector.close();
+            } catch (IOException e) {
+                LOG.warn(""ignored exception during selector close ""
+                        + e.getMessage());
+            }
+        }
+
         protected void cleanupSelectionKey(SelectionKey key) {
             if (key != null) {
                 try {
@@ -195,6 +209,7 @@
                     }
                 }
             } finally {
+                closeSelector();
                 // This will wake up the selector threads, and tell the
                 // worker thread pool to begin shutdown.
                 NIOServerCnxnFactory.this.stop();
@@ -391,6 +406,7 @@
                 }
                 updateQueue.clear();
             } finally {
+                closeSelector();
                 // This will wake up the accept thread and the other selector
                 // threads, and tell the worker thread pool to begin shutdown.
                 NIOServerCnxnFactory.this.stop();
"
zookeeper,bb857582bab316abea48588375df98de51df9115,ZOOKEEPER-1495. ZK client hangs when using a function not available on the server. (Skye W-M via phunt),2013.01.25 10:17:38,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/UnimplementedRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/UnimplementedRequestProcessor.java
new file mode 100644
index 0000000..aa58e63
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/UnimplementedRequestProcessor.java
@@ -0,0 +1,48 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.IOException;
+
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.proto.ReplyHeader;
+
+/**
+ * Manages the unknown requests (i.e. unknown OpCode), by:
+ * - sending back the KeeperException.UnimplementedException() error code to the client
+ * - closing the connection.
+ */
+public class UnimplementedRequestProcessor implements RequestProcessor {
+
+    public void processRequest(Request request) throws RequestProcessorException {
+        KeeperException ke = new KeeperException.UnimplementedException();
+        request.setException(ke);
+        ReplyHeader rh = new ReplyHeader(request.cxid, request.zxid, ke.code().intValue());
+        try {
+            request.cnxn.sendResponse(rh, null, ""response"");
+        } catch (IOException e) {
+            throw new RequestProcessorException(""Can't send the response"", e);
+        }
+
+        request.cnxn.sendCloseSession();
+    }
+
+    public void shutdown() {
+    }
+}
"
zookeeper,bb857582bab316abea48588375df98de51df9115,ZOOKEEPER-1495. ZK client hangs when using a function not available on the server. (Skye W-M via phunt),2013.01.25 10:17:38,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 14e754b..f1e2e3e 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -629,8 +629,8 @@
                     incInProcess();
                 }
             } else {
-                LOG.warn(""Dropping packet at server of type "" + si.type);
-                // if invalid packet drop the packet.
+                LOG.warn(""Received packet at server of unknown type "" + si.type);
+                new UnimplementedRequestProcessor().processRequest(si);
             }
         } catch (MissingSessionException e) {
             if (LOG.isDebugEnabled()) {
"
zookeeper,28c93eba0a198b34075d9aabd94aa73b0651aa76,ZOOKEEPER-1535. ZK Shell/Cli re-executes last command on exit (Edward Ribeiro via camille),2012.12.31 10:38:10,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index d21a140..f7532c3 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -337,11 +337,6 @@
                 }
             }
         }
-
-        boolean watch = processCmd(cl);
-        if (!watch) {
-            System.exit(0);
-        }
     }
 
     public void executeLine(String line)
"
zookeeper,dbde0aea20707b945b8852e91a69fe3ff116859f,ZOOKEEPER-1603. StaticHostProviderTest testUpdateClientMigrateOrNot hangs (Alexander Shraer via phunt),2012.12.20 14:50:19,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
index 83baeab..6ad4301 100644
--- a/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
+++ b/src/java/main/org/apache/zookeeper/client/StaticHostProvider.java
@@ -112,8 +112,9 @@
             throws UnknownHostException {
         List<InetSocketAddress> tmpList = new ArrayList<InetSocketAddress>(serverAddresses.size());       
         for (InetSocketAddress address : serverAddresses) {
-            InetAddress resolvedAddresses[] = InetAddress.getAllByName(address
-                    .getHostName());
+            InetAddress ia = address.getAddress();
+            InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():
+                    address.getHostName());
             for (InetAddress resolvedAddress : resolvedAddresses) {
                 tmpList.add(new InetSocketAddress(resolvedAddress
                         .getHostAddress(), address.getPort()));
@@ -155,13 +156,15 @@
                     ""A HostProvider may not be empty!"");
         }
         // Check if client's current server is in the new list of servers
-        boolean myServerInNewConfig = false;        
+        boolean myServerInNewConfig = false;
         for (InetSocketAddress addr : resolvedList) {
-            if (addr.getHostName().equals(currentHost.getHostName())
-                    && addr.getPort() == currentHost.getPort()) {
-                myServerInNewConfig = true;
-                break;
-            }
+            if (addr.getPort() == currentHost.getPort() &&
+                    ((addr.getAddress()!=null && currentHost.getAddress()!=null &&
+                      addr.getAddress().equals(currentHost.getAddress()))
+                     || addr.getHostName().equals(currentHost.getHostName()))) {
+                   myServerInNewConfig = true;
+                   break;
+               }
         }
 
         synchronized(this) {
"
zookeeper,ebc9340426143caf9b9452be4b93aae227abe5fc,ZOOKEEPER-1602. a change to QuorumPeerConfig's API broke compatibility with HBase (Alexander Shraer via phunt),2012.12.16 15:43:03,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index eacbd1b..ba611a9 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -28,6 +28,8 @@
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.util.Collections;
+import java.util.Map;
 import java.util.Properties;
 import java.util.Map.Entry;
 
@@ -488,6 +490,11 @@
         return quorumVerifier;
     }
 
+    public Map<Long,QuorumServer> getServers() {
+        // returns all configuration servers -- participants and observers
+        return Collections.unmodifiableMap(quorumVerifier.getAllMembers());
+    }
+
     public long getServerId() { return serverId; }
 
     public boolean isDistributed() { return (quorumVerifier!=null && quorumVerifier.getVotingMembers().size() > 1); }
"
zookeeper,c84f7ef14542dc1d3291e932932e6b6faf536944,"ZOOKEEPER-1387. Wrong epoch file created (Benjamin Busjaeger via breed, phunt)",2012.12.13 16:25:35,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 4e3a87d..9c17f5e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -612,7 +612,7 @@
             	LOG.info(ACCEPTED_EPOCH_FILENAME
             	        + "" not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation"",
             	        acceptedEpoch);
-            	writeLongToFile(CURRENT_EPOCH_FILENAME, acceptedEpoch);
+            	writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);
             }
             if (acceptedEpoch < currentEpoch) {
                 throw new IOException(""The current epoch, "" + ZxidUtils.zxidToString(currentEpoch) + "" is less than the accepted epoch, "" + ZxidUtils.zxidToString(acceptedEpoch));
"
zookeeper,df984c4c438971f1fea05d9d1cb00742c0eb64e7,"ZOOKEEPER-1513. ""Unreasonable length"" exception while starting a server (Skye W-M via phunt)",2012.12.12 15:46:25,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/jute/BinaryInputArchive.java b/src/java/main/org/apache/jute/BinaryInputArchive.java
index 8f329eb..6b2cb46 100644
--- a/src/java/main/org/apache/jute/BinaryInputArchive.java
+++ b/src/java/main/org/apache/jute/BinaryInputArchive.java
@@ -83,20 +83,15 @@
     	return new String(b, ""UTF8"");
     }
     
-    static public final int maxBuffer = determineMaxBuffer();
-    private static int determineMaxBuffer() {
-        String maxBufferString = System.getProperty(""jute.maxbuffer"");
-        try {
-            return Integer.parseInt(maxBufferString);
-        } catch(Exception e) {
-            return 0xfffff;
-        }
-        
-    }
+    static public final int maxBuffer = Integer.getInteger(""jute.maxbuffer"", 0xfffff);
+
     public byte[] readBuffer(String tag) throws IOException {
         int len = readInt(tag);
         if (len == -1) return null;
-        if (len < 0 || len > maxBuffer) {
+        // Since this is a rough sanity check, add some padding to maxBuffer to
+        // make up for extra fields, etc. (otherwise e.g. clients may be able to
+        // write buffers larger than we can read from disk!)
+        if (len < 0 || len > maxBuffer + 1024) {
             throw new IOException(""Unreasonable length = "" + len);
         }
         byte[] arr = new byte[len];
"
zookeeper,395b5effc712bb8d960ab0f2c2ee6f6fdb47140c,ZOOKEEPER-1474. Cannot build Zookeeper with IBM Java: use of Sun MXBean classes (Adalberto Medeiros via phunt),2012.11.28 16:43:26,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 0fd56b6..eade1d6 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -23,8 +23,6 @@
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.Writer;
-import java.lang.management.ManagementFactory;
-import java.lang.management.OperatingSystemMXBean;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
@@ -51,7 +49,7 @@
 import org.apache.zookeeper.server.quorum.Leader;
 import org.apache.zookeeper.server.quorum.LeaderZooKeeperServer;
 import org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer;
-import com.sun.management.UnixOperatingSystemMXBean;
+import org.apache.zookeeper.server.util.OSMXBean;
 
 /**
  * This class handles communication with clients using NIO. There is one per
@@ -760,12 +758,10 @@
             print(""ephemerals_count"", zkdb.getDataTree().getEphemeralsCount());
             print(""approximate_data_size"", zkdb.getDataTree().approximateDataSize());
 
-            OperatingSystemMXBean osMbean = ManagementFactory.getOperatingSystemMXBean();
-            if(osMbean != null && osMbean instanceof UnixOperatingSystemMXBean) {
-                UnixOperatingSystemMXBean unixos = (UnixOperatingSystemMXBean)osMbean;
-
-                print(""open_file_descriptor_count"", unixos.getOpenFileDescriptorCount());
-                print(""max_file_descriptor_count"", unixos.getMaxFileDescriptorCount());
+            OSMXBean osMbean = new OSMXBean();
+            if (osMbean != null && osMbean.getUnix() == true) {
+                print(""open_file_descriptor_count"", osMbean.getOpenFileDescriptorCount());
+                print(""max_file_descriptor_count"", osMbean.getMaxFileDescriptorCount());
             }
 
             if(stats.getServerState().equals(""leader"")) {
"
zookeeper,395b5effc712bb8d960ab0f2c2ee6f6fdb47140c,ZOOKEEPER-1474. Cannot build Zookeeper with IBM Java: use of Sun MXBean classes (Adalberto Medeiros via phunt),2012.11.28 16:43:26,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index 33b6104..ec63c04 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -25,8 +25,6 @@
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.Writer;
-import java.lang.management.ManagementFactory;
-import java.lang.management.OperatingSystemMXBean;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
@@ -49,14 +47,13 @@
 import org.apache.zookeeper.server.quorum.Leader;
 import org.apache.zookeeper.server.quorum.LeaderZooKeeperServer;
 import org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer;
+import org.apache.zookeeper.server.util.OSMXBean;
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.buffer.ChannelBuffers;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFuture;
 import org.jboss.netty.channel.MessageEvent;
 
-import com.sun.management.UnixOperatingSystemMXBean;
-
 public class NettyServerCnxn extends ServerCnxn {
     Logger LOG = LoggerFactory.getLogger(NettyServerCnxn.class);
     Channel channel;
@@ -571,14 +568,12 @@
             print(""ephemerals_count"", zkdb.getDataTree().getEphemeralsCount());
             print(""approximate_data_size"", zkdb.getDataTree().approximateDataSize());
 
-            OperatingSystemMXBean osMbean = ManagementFactory.getOperatingSystemMXBean();
-            if(osMbean != null && osMbean instanceof UnixOperatingSystemMXBean) {
-                UnixOperatingSystemMXBean unixos = (UnixOperatingSystemMXBean)osMbean;
-
-                print(""open_file_descriptor_count"", unixos.getOpenFileDescriptorCount());
-                print(""max_file_descriptor_count"", unixos.getMaxFileDescriptorCount());
+            OSMXBean osMbean = new OSMXBean();
+            if (osMbean != null && osMbean.getUnix() == true) {
+                print(""open_file_descriptor_count"", osMbean.getOpenFileDescriptorCount());
+                print(""max_file_descriptor_count"", osMbean.getMaxFileDescriptorCount());
             }
-
+          
             if(stats.getServerState().equals(""leader"")) {
                 Leader leader = ((LeaderZooKeeperServer)zkServer).getLeader();
 
"
zookeeper,395b5effc712bb8d960ab0f2c2ee6f6fdb47140c,ZOOKEEPER-1474. Cannot build Zookeeper with IBM Java: use of Sun MXBean classes (Adalberto Medeiros via phunt),2012.11.28 16:43:26,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/util/OSMXBean.java b/src/java/main/org/apache/zookeeper/server/util/OSMXBean.java
new file mode 100644
index 0000000..b22824d
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/util/OSMXBean.java
@@ -0,0 +1,182 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.OperatingSystemMXBean;
+import java.lang.management.RuntimeMXBean;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.lang.reflect.Method;
+
+/**
+ * This class is a wrapper for the implementation of
+ * com.sun.management.UnixOperatingSystemMXBean
+ * It will decide to use the sun api or its own implementation
+ * depending on the runtime (vendor) used.
+ */
+public class OSMXBean
+{
+    static final Logger LOG = LoggerFactory.getLogger(OSMXBean.class);
+
+    private OperatingSystemMXBean osMbean;
+
+    private static final boolean ibmvendor =
+        System.getProperty(""java.vendor"").contains(""IBM"");
+    private static final boolean windows = 
+        System.getProperty(""os.name"").startsWith(""Windows"");
+    private static final boolean linux =
+        System.getProperty(""os.name"").startsWith(""Linux"");
+
+    /**
+     * Constructor. Get the running Operating System instance
+     */
+    public OSMXBean () {
+        this.osMbean = ManagementFactory.getOperatingSystemMXBean();
+    }
+ 
+    /**
+     * Check if the OS is unix. If using the IBM java runtime, this
+     * will only work for linux.
+     * 
+     * @return whether this is unix or not.
+     */
+    public boolean getUnix() {
+        if (windows) {
+            return false;
+        }
+        return (ibmvendor ? linux : true);
+    }
+
+    /**
+     * Load the implementation of UnixOperatingSystemMXBean for sun jvm
+     * and runs the desired method. 
+     * @param mBeanMethodName : method to run from the interface UnixOperatingSystemMXBean
+     * @return the method result
+     */
+    private Long getOSUnixMXBeanMethod (String mBeanMethodName)
+    {
+        Object unixos;
+        Class<?> classRef;
+        Method mBeanMethod;
+
+        try {
+            classRef = Class.forName(""com.sun.management.UnixOperatingSystemMXBean"");
+            if (classRef.isInstance(osMbean)) {
+                mBeanMethod = classRef.getDeclaredMethod(mBeanMethodName,
+                new Class[0]);
+                unixos = classRef.cast(osMbean);
+                return (Long)mBeanMethod.invoke(unixos);
+            }
+        } catch(Exception e) {
+            LOG.warn(""Not able to load class or method for com.sun.managment.UnixOperatingSystemMXBean."", e);
+        }
+        return null;
+    }
+
+    /**
+     * Get the number of opened filed descriptor for the runtime jvm.
+     * If sun java, it will use the com.sun.management interfaces.
+     * Otherwise, this methods implements it (linux only).  
+     * @return number of open file descriptors for the jvm
+     */
+    public long getOpenFileDescriptorCount() 
+    {
+        Long ofdc;
+    
+        if (!ibmvendor) {
+            ofdc = getOSUnixMXBeanMethod(""getOpenFileDescriptorCount"");
+            return (ofdc != null ? ofdc.longValue () : -1);
+        }
+        
+        try {
+            //need to get the PID number of the process first
+            RuntimeMXBean rtmbean = ManagementFactory.getRuntimeMXBean();
+            String rtname = rtmbean.getName();
+            String[] pidhost = rtname.split(""@"");
+
+            //using linux bash commands to retrieve info
+            Process p = Runtime.getRuntime().exec(
+                    new String[] { ""bash"", ""-c"",
+                    ""ls /proc/"" + pidhost[0] + ""/fdinfo | wc -l"" });
+            InputStream in = p.getInputStream();
+            BufferedReader output = new BufferedReader(
+                    new InputStreamReader(in));
+
+            try {
+                String openFileDesCount;
+                if ((openFileDesCount = output.readLine()) != null) {
+                    return Long.parseLong(openFileDesCount);
+                }
+            } finally {
+                if (output != null) {
+                    output.close();
+                }
+            }
+        } catch (IOException ie) {
+            LOG.warn(""Not able to get the number of open file descriptors"", ie);
+        }
+        return -1;
+    }
+
+    /**
+     * Get the number of the maximum file descriptors the system can use.
+     * If sun java, it will use the com.sun.management interfaces.
+     * Otherwise, this methods implements it (linux only).  
+     * @return max number of file descriptors the operating system can use.
+     */
+    public long getMaxFileDescriptorCount()
+    {
+        Long mfdc;
+
+        if (!ibmvendor) {
+            mfdc = getOSUnixMXBeanMethod(""getMaxFileDescriptorCount"");
+            return (mfdc != null ? mfdc.longValue () : -1);
+        }
+        
+        try {
+            //using linux bash commands to retrieve info
+            Process p = Runtime.getRuntime().exec(
+                    new String[] { ""bash"", ""-c"", ""ulimit -n"" });
+            InputStream in = p.getInputStream();
+            BufferedReader output = new BufferedReader(
+                    new InputStreamReader(in));
+
+            try {
+                String maxFileDesCount;
+                if ((maxFileDesCount = output.readLine()) != null) {
+                    return Long.parseLong(maxFileDesCount);
+                }
+            } finally {
+                if (output != null) {
+                    output.close();
+                }
+            }
+        } catch (IOException ie) {
+            LOG.warn(""Not able to get the max number of file descriptors"", ie);
+        }
+        return -1;
+    }  
+}
"
zookeeper,6e5a25670346ddf5e4bc3b1598f8ec5e52699c09,ZOOKEEPER-1560 Zookeeper client hangs on creation of large nodes (Skye Wanderman-Milne via phunt),2012.11.01 02:24:54,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
index 70d8538..fbb0284 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
@@ -26,16 +26,16 @@
 import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
 import java.nio.channels.SocketChannel;
-import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.ListIterator;
 import java.util.Set;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.ClientCnxn.EndOfStreamException;
 import org.apache.zookeeper.ClientCnxn.Packet;
 import org.apache.zookeeper.ZooDefs.OpCode;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class ClientCnxnSocketNIO extends ClientCnxnSocket {
     private static final Logger LOG = LoggerFactory
@@ -104,83 +104,85 @@
             }
         }
         if (sockKey.isWritable()) {
-            LinkedList<Packet> pending = new LinkedList<Packet>();
-            Packet p = null;
             synchronized(outgoingQueue) {
-                p = findSendablePacket(outgoingQueue,
+                Packet p = findSendablePacket(outgoingQueue,
                         cnxn.sendThread.clientTunneledAuthenticationInProgress());
 
                 if (p != null) {
-                    outgoingQueue.removeFirstOccurrence(p);
                     updateLastSend();
-                    if ((p.requestHeader != null) &&
-                            (p.requestHeader.getType() != OpCode.ping) &&
-                            (p.requestHeader.getType() != OpCode.auth)) {
-                        p.requestHeader.setXid(cnxn.getXid());
+                    // If we already started writing p, p.bb will already exist
+                    if (p.bb == null) {
+                        if ((p.requestHeader != null) &&
+                                (p.requestHeader.getType() != OpCode.ping) &&
+                                (p.requestHeader.getType() != OpCode.auth)) {
+                            p.requestHeader.setXid(cnxn.getXid());
+                        }
+                        p.createBB();
                     }
-                    p.createBB();
-                    ByteBuffer pbb = p.bb;
-                    sock.write(pbb);
-                    if (!pbb.hasRemaining()) {
+                    sock.write(p.bb);
+                    if (!p.bb.hasRemaining()) {
                         sentCount++;
+                        outgoingQueue.removeFirstOccurrence(p);
                         if (p.requestHeader != null
                                 && p.requestHeader.getType() != OpCode.ping
                                 && p.requestHeader.getType() != OpCode.auth) {
-                            pending.add(p);
+                            synchronized (pendingQueue) {
+                                pendingQueue.add(p);
+                            }
                         }
                     }
-                } else {
-                    // No suitable packet to send: turn off write interest flag.
+                }
+                if (outgoingQueue.isEmpty()) {
+                    // No more packets to send: turn off write interest flag.
                     // Will be turned on later by a later call to enableWrite(),
                     // from within ZooKeeperSaslClient (if client is configured
                     // to attempt SASL authentication), or in either doIO() or
                     // in doTransport() if not.
                     disableWrite();
+                } else {
+                    // Just in case
+                    enableWrite();
                 }
             }
-            synchronized(pendingQueue) {
-                pendingQueue.addAll(pending);
-            }
-
         }
     }
 
     private Packet findSendablePacket(LinkedList<Packet> outgoingQueue,
                                       boolean clientTunneledAuthenticationInProgress) {
         synchronized (outgoingQueue) {
-            if (!outgoingQueue.isEmpty()) {
-                if (clientTunneledAuthenticationInProgress) {
-                    Packet p = null;
-                    // Since client's authentication with server is in progress,
-                    // send only the null-header packet queued by primeConnection().
-                    // This packet must be sent so that the SASL authentication process
-                    // can proceed, but all other packets should wait until
-                    // SASL authentication completes.
-                    Iterator<Packet> iter = outgoingQueue.listIterator();
-                    while(iter.hasNext()) {
-                        p = iter.next();
-                        if (p.requestHeader == null) {
-                            // We've found the priming-packet.
-                            return p;
-                        } else {
-                            // Non-priming packet: defer it until later, leaving it in the queue
-                            // until authentication completes.
-                            if (LOG.isDebugEnabled()) {
-                                LOG.debug(""deferring non-priming packet: "" + p +
-                                        ""until SASL authentication completes."");
-                            }
-                        }
-                    }
-                    // no sendable packet found.
-                    return null;
+            if (outgoingQueue.isEmpty()) {
+                return null;
+            }
+            if (outgoingQueue.getFirst().bb != null // If we've already starting sending the first packet, we better finish
+                || !clientTunneledAuthenticationInProgress) {
+                return outgoingQueue.getFirst();
+            }
+
+            // Since client's authentication with server is in progress,
+            // send only the null-header packet queued by primeConnection().
+            // This packet must be sent so that the SASL authentication process
+            // can proceed, but all other packets should wait until
+            // SASL authentication completes.
+            ListIterator<Packet> iter = outgoingQueue.listIterator();
+            while (iter.hasNext()) {
+                Packet p = iter.next();
+                if (p.requestHeader == null) {
+                    // We've found the priming-packet. Move it to the beginning of the queue.
+                    iter.remove();
+                    outgoingQueue.add(0, p);
+                    return p;
                 } else {
-                    // Tunnelled authentication is not in progress: just
-                    // send the first packet in the queue.
-                    return outgoingQueue.getFirst();
+                    // Non-priming packet: defer it until later, leaving it in the queue
+                    // until authentication completes.
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""deferring non-priming packet: "" + p +
+                                ""until SASL authentication completes."");
+                    }
                 }
             }
+            // no sendable packet found.
+            return null;
         }
-        return null;
     }
 
     @Override
"
zookeeper,8c6155afb6df604ff59fa4e4148a809c0740d3b6,ZOOKEEPER-1550. ZooKeeperSaslClient does not finish anonymous login on OpenJDK (Eugene Koontz via mahadev),2012.09.29 01:32:19,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/Login.java b/src/java/main/org/apache/zookeeper/Login.java
index 32f00bc..1b4f00a 100644
--- a/src/java/main/org/apache/zookeeper/Login.java
+++ b/src/java/main/org/apache/zookeeper/Login.java
@@ -270,6 +270,10 @@
         return subject;
     }
 
+    public String getLoginContextName() {
+        return loginContextName;
+    }
+
     private synchronized LoginContext login(final String loginContextName) throws LoginException {
         if (loginContextName == null) {
             throw new LoginException(""loginContext name (JAAS file section header) was null. "" +
"
zookeeper,8c6155afb6df604ff59fa4e4148a809c0740d3b6,ZOOKEEPER-1550. ZooKeeperSaslClient does not finish anonymous login on OpenJDK (Eugene Koontz via mahadev),2012.09.29 01:32:19,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index f58d418..4a16dd3 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -23,6 +23,7 @@
 import org.apache.zookeeper.client.ConnectStringParser;
 import org.apache.zookeeper.client.HostProvider;
 import org.apache.zookeeper.client.StaticHostProvider;
+import org.apache.zookeeper.client.ZooKeeperSaslClient;
 import org.apache.zookeeper.common.PathUtils;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
@@ -94,6 +95,10 @@
         Environment.logEnv(""Client environment:"", LOG);
     }
 
+    public ZooKeeperSaslClient getSaslClient() {
+        return cnxn.zooKeeperSaslClient;
+    }
+
     private final ZKWatchManager watchManager = new ZKWatchManager();
 
     List<String> getDataWatches() {
"
zookeeper,8c6155afb6df604ff59fa4e4148a809c0740d3b6,ZOOKEEPER-1550. ZooKeeperSaslClient does not finish anonymous login on OpenJDK (Eugene Koontz via mahadev),2012.09.29 01:32:19,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index 4ce5477..6087e99 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -76,10 +76,10 @@
         return saslState;
     }
 
-    private String loginContext;
-
     public String getLoginContext() {
-      return loginContext;
+        if (login != null)
+            return login.getLoginContextName();
+        return null;
     }
 
     public ZooKeeperSaslClient(final String serverPrincipal)
@@ -193,7 +193,6 @@
                 if (LOG.isDebugEnabled()) {
                     LOG.debug(""JAAS loginContext is: "" + loginContext);
                 }
-                this.loginContext = loginContext;
                 // note that the login object is static: it's shared amongst all zookeeper-related connections.
                 // createSaslClient() must be declared synchronized so that login is initialized only once.
                 login = new Login(loginContext, new ClientCallbackHandler(null));
@@ -485,9 +484,14 @@
         // variable or method in this class to determine whether the client is
         // configured to use SASL. (see also ZOOKEEPER-1455).
         try {
-            if ((System.getProperty(Environment.JAAS_CONF_KEY) != null) ||
-                (javax.security.auth.login.Configuration.getConfiguration() != null)) {
-                // Client is configured to use SASL.
+  	    if ((System.getProperty(Environment.JAAS_CONF_KEY) != null) ||
+              ((javax.security.auth.login.Configuration.getConfiguration() != null) &&
+                  (javax.security.auth.login.Configuration.getConfiguration().
+                       getAppConfigurationEntry(System.
+                       getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY,""Client"")) 
+                           != null))) {
+                // Client is configured to use a valid login Configuration, so
+                // authentication is either in progress, successful, or failed.
 
                 // 1. Authentication hasn't finished yet: we must wait for it to do so.
                 if ((isComplete() == false) &&
"
zookeeper,0b62693cc5f86fc64ecbecebc419f2dd5fc37fdb,ZOOKEEPER-1540. ZOOKEEPER-1411 breaks backwards compatibility (Andrew Ferguson via breed),2012.09.25 14:13:27,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 60e87d3..eacbd1b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -446,7 +446,7 @@
                        && clientPortAddress.getPort()!=qs.clientAddr.getPort())) 
                throw new ConfigException(""client address for this server (id = "" + serverId + "") in static config file is "" + clientPortAddress + "" is different from client address found in dynamic file: "" + qs.clientAddr);                    
            } 
-            if (qs!=null) clientPortAddress = qs.clientAddr;                       
+            if (qs!=null && qs.clientAddr != null) clientPortAddress = qs.clientAddr;                       
             
             // Warn about inconsistent peer type
             LearnerType roleByServersList = quorumVerifier.getObservingMembers().containsKey(serverId) ? LearnerType.OBSERVER
"
zookeeper,0aefdaa7b7d70dc3b1dbf69a0ce2a660d7f362e8,ZOOKEEPER-1238. Linger time should be -1 for Netty sockets. (Skye W-M via henryr),2012.09.25 08:57:20,Henry Robinson,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
index 32692e2..eec2f2a 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
@@ -249,7 +249,8 @@
         bootstrap.setOption(""reuseAddress"", true);
         // child channels
         bootstrap.setOption(""child.tcpNoDelay"", true);
-        bootstrap.setOption(""child.soLinger"", 2);
+        /* set socket linger to off, so that socket close does not block */
+        bootstrap.setOption(""child.soLinger"", -1);
 
         bootstrap.getPipeline().addLast(""servercnxnfactory"", channelHandler);
     }
"
zookeeper,139d1d9c4b78424708b01f239211ed83e9279fc6,ZOOKEEPER-1496. Ephemeral node not getting cleared even after client has exited. (Rakesh R via mahadev),2012.09.17 16:53:10,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
index cbae57a..31f2785 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
@@ -150,7 +150,7 @@
                 set = sessionSets.remove(nextExpirationTime);
                 if (set != null) {
                     for (SessionImpl s : set.sessions) {
-                        sessionsById.remove(s.sessionId);
+                        setSessionClosing(s.sessionId);
                         expirer.expire(s);
                     }
                 }
@@ -170,7 +170,8 @@
                     + Long.toHexString(sessionId) + "" with timeout "" + timeout);
         }
         SessionImpl s = sessionsById.get(sessionId);
-        if (s == null) {
+        // Return false, if the session doesn't exists or marked as closing
+        if (s == null || s.isClosing()) {
             return false;
         }
         long expireTime = roundToInterval(System.currentTimeMillis() + timeout);
@@ -212,7 +213,11 @@
                     + Long.toHexString(sessionId));
         }
         if (s != null) {
-            sessionSets.get(s.tickTime).sessions.remove(s);
+            SessionSet set = sessionSets.get(s.tickTime);
+            // Session expiration has been removing the sessions   
+            if(set != null){
+                set.sessions.remove(s);
+            }
         }
     }
 
@@ -266,7 +271,7 @@
 
     synchronized public void setOwner(long id, Object owner) throws SessionExpiredException {
         SessionImpl session = sessionsById.get(id);
-        if (session == null) {
+        if (session == null || session.isClosing()) {
             throw new KeeperException.SessionExpiredException();
         }
         session.owner = owner;
"
zookeeper,987635edac8aa374a04ea130dfd81a03a635bf0d,ZOOKEEPER-1437. Client uses session before SASL authentication complete (Eugene Koontz via mahadev),2012.09.10 03:24:07,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 9627c43..c239328 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -64,11 +64,11 @@
 import org.apache.zookeeper.proto.GetChildren2Response;
 import org.apache.zookeeper.proto.GetChildrenResponse;
 import org.apache.zookeeper.proto.GetDataResponse;
+import org.apache.zookeeper.proto.GetSASLRequest;
 import org.apache.zookeeper.proto.ReplyHeader;
 import org.apache.zookeeper.proto.RequestHeader;
 import org.apache.zookeeper.proto.SetACLResponse;
 import org.apache.zookeeper.proto.SetDataResponse;
-import org.apache.zookeeper.proto.SetSASLResponse;
 import org.apache.zookeeper.proto.SetWatches;
 import org.apache.zookeeper.proto.WatcherEvent;
 import org.apache.zookeeper.server.ByteBufferInputStream;
@@ -251,6 +251,8 @@
 
         WatchRegistration watchRegistration;
 
+        public boolean readOnly;
+
         /** Convenience ctor */
         Packet(RequestHeader requestHeader, ReplyHeader replyHeader,
                Record request, Record response,
@@ -267,7 +269,11 @@
             this.replyHeader = replyHeader;
             this.request = request;
             this.response = response;
+            this.readOnly = readOnly;
+            this.watchRegistration = watchRegistration;
+        }
 
+        public void createBB() {
             try {
                 ByteArrayOutputStream baos = new ByteArrayOutputStream();
                 BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
@@ -289,8 +295,6 @@
             } catch (IOException e) {
                 LOG.warn(""Ignoring unexpected exception"", e);
             }
-
-            this.watchRegistration = watchRegistration;
         }
 
         @Override
@@ -380,12 +384,6 @@
 
     }
 
-    // used by ZooKeeperSaslClient.queueSaslPacket().
-    public void queuePacket(RequestHeader h, ReplyHeader r, Record request,
-            Record response, AsyncCallback cb) {
-        queuePacket(h,r,request,response, cb, null, null, this, null);
-    }
-
     /**
      * tests use this to check on reset of watches
      * @return if the auto reset of watches are disabled
@@ -553,17 +551,6 @@
                       } else {
                           cb.processResult(rc, clientPath, p.ctx, null);
                       }
-                  } else if (p.cb instanceof ZooKeeperSaslClient.ServerSaslResponseCallback) {
-                      ZooKeeperSaslClient.ServerSaslResponseCallback cb = (ZooKeeperSaslClient.ServerSaslResponseCallback) p.cb;
-                      SetSASLResponse rsp = (SetSASLResponse) p.response;
-                      // TODO : check rc (== 0, etc) as with other packet types.
-                      cb.processResult(rc,null,p.ctx,rsp.getToken(),null);
-                      ClientCnxn clientCnxn = (ClientCnxn)p.ctx;
-                      if ((clientCnxn == null) || (clientCnxn.zooKeeperSaslClient == null) ||
-                              (clientCnxn.zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.FAILED)) {
-                          queueEvent(new WatchedEvent(EventType.None,
-                                  KeeperState.AuthFailed, null));
-                      }
                   } else if (p.response instanceof GetDataResponse) {
                       DataCallback cb = (DataCallback) p.cb;
                       GetDataResponse rsp = (GetDataResponse) p.response;
@@ -777,6 +764,18 @@
                 eventThread.queueEvent( we );
                 return;
             }
+
+            // If SASL authentication is currently in progress, construct and
+            // send a response packet immediately, rather than queuing a
+            // response as with other packets.
+            if (clientTunneledAuthenticationInProgress()) {
+                GetSASLRequest request = new GetSASLRequest();
+                request.deserialize(bbia,""token"");
+                zooKeeperSaslClient.respondToServer(request.getToken(),
+                  ClientCnxn.this);
+                return;
+            }
+
             Packet packet;
             synchronized (pendingQueue) {
                 if (pendingQueue.size() == 0) {
@@ -923,6 +922,10 @@
 
         private int pingRwTimeout = minPingRwTimeout;
 
+        // Set to true if and only if constructor of ZooKeeperSaslClient
+        // throws a LoginException: see startConnect() below.
+        private boolean saslLoginFailed = false;
+
         private void startConnect() throws IOException {
             if(!isFirstConnect){
                 try {
@@ -946,11 +949,16 @@
             try {
                 zooKeeperSaslClient = new ZooKeeperSaslClient(""zookeeper/""+addr.getHostName());
             } catch (LoginException e) {
+                // An authentication error occurred when the SASL client tried to initialize:
+                // for Kerberos this means that the client failed to authenticate with the KDC.
+                // This is different from an authentication error that occurs during communication
+                // with the Zookeeper server, which is handled below.
                 LOG.warn(""SASL configuration failed: "" + e + "" Will continue connection to Zookeeper server without ""
-                        + ""SASL authentication, if Zookeeper server allows it."");
+                  + ""SASL authentication, if Zookeeper server allows it."");
                 eventThread.queueEvent(new WatchedEvent(
-                        Watcher.Event.EventType.None,
-                        Watcher.Event.KeeperState.AuthFailed, null));
+                  Watcher.Event.EventType.None,
+                  Watcher.Event.KeeperState.AuthFailed, null));
+                saslLoginFailed = true;
             }
             logStartConnect(addr);
 
@@ -987,21 +995,35 @@
                     }
 
                     if (state.isConnected()) {
-                        if ((zooKeeperSaslClient != null) && (zooKeeperSaslClient.isFailed() != true) && (zooKeeperSaslClient.isComplete() != true)) {
-                            try {
-                                zooKeeperSaslClient.initialize(ClientCnxn.this);
+                        // determine whether we need to send an AuthFailed event.
+                        if (zooKeeperSaslClient != null) {
+                            boolean sendAuthEvent = false;
+                            if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {
+                                try {
+                                    zooKeeperSaslClient.initialize(ClientCnxn.this);
+                                } catch (SaslException e) {
+                                   LOG.error(""SASL authentication with Zookeeper Quorum member failed: "" + e);
+                                    state = States.AUTH_FAILED;
+                                    sendAuthEvent = true;
+                                }
                             }
-                            catch (SaslException e) {
-                                LOG.error(""SASL authentication with Zookeeper Quorum member failed: "" + e);
-                                state = States.AUTH_FAILED;
-                                eventThread.queueEvent(new WatchedEvent(
-                                        Watcher.Event.EventType.None,
-                                        KeeperState.AuthFailed,null));
+                            KeeperState authState = zooKeeperSaslClient.getKeeperState();
+                            if (authState != null) {
+                                if (authState == KeeperState.AuthFailed) {
+                                    // An authentication error occurred during authentication with the Zookeeper Server.
+                                    state = States.AUTH_FAILED;
+                                    sendAuthEvent = true;
+                                } else {
+                                    if (authState == KeeperState.SaslAuthenticated) {
+                                        sendAuthEvent = true;
+                                    }
+                                }
                             }
-                            if (zooKeeperSaslClient.readyToSendSaslAuthEvent()) {
+
+                            if (sendAuthEvent == true) {
                                 eventThread.queueEvent(new WatchedEvent(
-                                  Watcher.Event.EventType.None,
-                                  Watcher.Event.KeeperState.SaslAuthenticated, null));
+                                      Watcher.Event.EventType.None,
+                                      authState,null));
                             }
                         }
                         to = readTimeout - clientCnxnSocket.getIdleRecv();
@@ -1022,7 +1044,6 @@
                         if (timeToNextPing <= 0) {
                             sendPing();
                             clientCnxnSocket.updateLastSend();
-                            clientCnxnSocket.enableWrite();
                         } else {
                             if (timeToNextPing < to) {
                                 to = timeToNextPing;
@@ -1044,8 +1065,7 @@
                         to = Math.min(to, pingRwTimeout - idlePingRwServer);
                     }
 
-                    clientCnxnSocket.doTransport(to, pendingQueue, outgoingQueue);
-
+                    clientCnxnSocket.doTransport(to, pendingQueue, outgoingQueue, ClientCnxn.this);
                 } catch (Throwable e) {
                     if (closing) {
                         if (LOG.isDebugEnabled()) {
@@ -1204,6 +1224,26 @@
         void testableCloseSocket() throws IOException {
             clientCnxnSocket.testableCloseSocket();
         }
+
+        public boolean clientTunneledAuthenticationInProgress() {
+            // 1. SASL login failed.
+            if (saslLoginFailed == true) {
+                return false;
+            }
+
+            // 2. SendThread has not created the authenticating object yet,
+            // therefore authentication is (at the earliest stage of being) in progress.
+            if (zooKeeperSaslClient == null) {
+                return true;
+            }
+
+            // 3. authenticating object exists, so ask it for its progress.
+            return zooKeeperSaslClient.clientTunneledAuthenticationInProgress();
+        }
+
+        public void sendPacket(Packet p) throws IOException {
+            clientCnxnSocket.sendPacket(p);
+        }
     }
 
     /**
@@ -1250,7 +1290,11 @@
 
     private volatile States state = States.NOT_CONNECTED;
 
-    synchronized private int getXid() {
+    /*
+     * getXid() is called externally by ClientCnxnNIO::doIO() when packets are sent from the outgoingQueue to
+     * the server. Thus, getXid() must be public.
+     */
+    synchronized public int getXid() {
         return xid++;
     }
 
@@ -1268,15 +1312,37 @@
         return r;
     }
 
+    public void enableWrite() {
+        sendThread.getClientCnxnSocket().enableWrite();
+    }
+
+    public void sendPacket(Record request, Record response, AsyncCallback cb, int opCode)
+    throws IOException {
+        // Generate Xid now because it will be sent immediately,
+        // by call to sendThread.sendPacket() below.
+        int xid = getXid();
+        RequestHeader h = new RequestHeader();
+        h.setXid(xid);
+        h.setType(opCode);
+
+        ReplyHeader r = new ReplyHeader();
+        r.setXid(xid);
+
+        Packet p = new Packet(h, r, request, response, null, false);
+        p.cb = cb;
+        sendThread.sendPacket(p);
+    }
+
     Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
             Record response, AsyncCallback cb, String clientPath,
             String serverPath, Object ctx, WatchRegistration watchRegistration)
     {
         Packet packet = null;
+
+        // Note that we do not generate the Xid for the packet yet. It is
+        // generated later at send-time, by an implementation of ClientCnxnSocket::doIO(),
+        // where the packet is actually sent.
         synchronized (outgoingQueue) {
-            if (h.getType() != OpCode.ping && h.getType() != OpCode.auth) {
-                h.setXid(getXid());
-            }
             packet = new Packet(h, r, request, response, watchRegistration);
             packet.cb = cb;
             packet.ctx = ctx;
"
zookeeper,987635edac8aa374a04ea130dfd81a03a635bf0d,ZOOKEEPER-1437. Client uses session before SASL authentication complete (Eugene Koontz via mahadev),2012.09.10 03:24:07,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
index 269f8e8..5ca0ba7 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
@@ -160,11 +160,15 @@
 
     abstract void enableWrite();
 
+    abstract void disableWrite();
+
     abstract void enableReadWriteOnly();
 
     abstract void doTransport(int waitTimeOut, List<Packet> pendingQueue,
-            LinkedList<Packet> outgoingQueue) throws IOException,
-            InterruptedException;
+            LinkedList<Packet> outgoingQueue, ClientCnxn cnxn)
+            throws IOException, InterruptedException;
 
     abstract void testableCloseSocket() throws IOException;
+
+    abstract void sendPacket(Packet p) throws IOException;
 }
"
zookeeper,987635edac8aa374a04ea130dfd81a03a635bf0d,ZOOKEEPER-1437. Client uses session before SASL authentication complete (Eugene Koontz via mahadev),2012.09.10 03:24:07,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
index 87a5fe5..70d8538 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
@@ -26,6 +26,7 @@
 import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
 import java.nio.channels.SocketChannel;
+import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
@@ -62,7 +63,8 @@
      * @throws InterruptedException
      * @throws IOException
      */
-    void doIO(List<Packet> pendingQueue, LinkedList<Packet> outgoingQueue) throws InterruptedException, IOException {
+    void doIO(List<Packet> pendingQueue, LinkedList<Packet> outgoingQueue, ClientCnxn cnxn)
+      throws InterruptedException, IOException {
         SocketChannel sock = (SocketChannel) sockKey.channel();
         if (sock == null) {
             throw new IOException(""Socket is null!"");
@@ -83,7 +85,10 @@
                 } else if (!initialized) {
                     readConnectResult();
                     enableRead();
-                    if (!outgoingQueue.isEmpty()) {
+                    if (findSendablePacket(outgoingQueue,
+                            cnxn.sendThread.clientTunneledAuthenticationInProgress()) != null) {
+                        // Since SASL authentication has completed (if client is configured to do so),
+                        // outgoing packets waiting in the outgoingQueue can now be sent.
                         enableWrite();
                     }
                     lenBuffer.clear();
@@ -100,28 +105,84 @@
         }
         if (sockKey.isWritable()) {
             LinkedList<Packet> pending = new LinkedList<Packet>();
-            synchronized (outgoingQueue) {
-                if (!outgoingQueue.isEmpty()) {
+            Packet p = null;
+            synchronized(outgoingQueue) {
+                p = findSendablePacket(outgoingQueue,
+                        cnxn.sendThread.clientTunneledAuthenticationInProgress());
+
+                if (p != null) {
+                    outgoingQueue.removeFirstOccurrence(p);
                     updateLastSend();
-                    ByteBuffer pbb = outgoingQueue.getFirst().bb;
+                    if ((p.requestHeader != null) &&
+                            (p.requestHeader.getType() != OpCode.ping) &&
+                            (p.requestHeader.getType() != OpCode.auth)) {
+                        p.requestHeader.setXid(cnxn.getXid());
+                    }
+                    p.createBB();
+                    ByteBuffer pbb = p.bb;
                     sock.write(pbb);
                     if (!pbb.hasRemaining()) {
                         sentCount++;
-                        Packet p = outgoingQueue.removeFirst();
                         if (p.requestHeader != null
                                 && p.requestHeader.getType() != OpCode.ping
                                 && p.requestHeader.getType() != OpCode.auth) {
                             pending.add(p);
                         }
                     }
+                } else {
+                    // No suitable packet to send: turn off write interest flag.
+                    // Will be turned on later by a later call to enableWrite(),
+                    // from within ZooKeeperSaslClient (if client is configured
+                    // to attempt SASL authentication), or in either doIO() or
+                    // in doTransport() if not.
+                    disableWrite();
                 }
             }
             synchronized(pendingQueue) {
                 pendingQueue.addAll(pending);
             }
+
         }
     }
 
+    private Packet findSendablePacket(LinkedList<Packet> outgoingQueue,
+                                      boolean clientTunneledAuthenticationInProgress) {
+        synchronized (outgoingQueue) {
+            if (!outgoingQueue.isEmpty()) {
+                if (clientTunneledAuthenticationInProgress) {
+                    Packet p = null;
+                    // Since client's authentication with server is in progress,
+                    // send only the null-header packet queued by primeConnection().
+                    // This packet must be sent so that the SASL authentication process
+                    // can proceed, but all other packets should wait until
+                    // SASL authentication completes.
+                    Iterator<Packet> iter = outgoingQueue.listIterator();
+                    while(iter.hasNext()) {
+                        p = iter.next();
+                        if (p.requestHeader == null) {
+                            // We've found the priming-packet.
+                            return p;
+                        } else {
+                            // Non-priming packet: defer it until later, leaving it in the queue
+                            // until authentication completes.
+                            if (LOG.isDebugEnabled()) {
+                                LOG.debug(""deferring non-priming packet: "" + p +
+                                        ""until SASL authentication completes."");
+                            }
+                        }
+                    }
+                    // no sendable packet found.
+                    return null;
+                } else {
+                    // Tunnelled authentication is not in progress: just
+                    // send the first packet in the queue.
+                    return outgoingQueue.getFirst();
+                }
+            }
+        }
+        return null;
+    }
+
     @Override
     void cleanup() {
         if (sockKey != null) {
@@ -205,7 +266,7 @@
     void registerAndConnect(SocketChannel sock, InetSocketAddress addr) 
     throws IOException {
         sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
-        boolean immediateConnect = sock.connect(addr);            
+        boolean immediateConnect = sock.connect(addr);
         if (immediateConnect) {
             sendThread.primeConnection();
         }
@@ -264,7 +325,8 @@
     }
     
     @Override
-    void doTransport(int waitTimeOut, List<Packet> pendingQueue, LinkedList<Packet> outgoingQueue )
+    void doTransport(int waitTimeOut, List<Packet> pendingQueue, LinkedList<Packet> outgoingQueue,
+                     ClientCnxn cnxn)
             throws IOException, InterruptedException {
         selector.select(waitTimeOut);
         Set<SelectionKey> selected;
@@ -284,15 +346,14 @@
                     sendThread.primeConnection();
                 }
             } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
-                doIO(pendingQueue, outgoingQueue);
+                doIO(pendingQueue, outgoingQueue, cnxn);
             }
         }
         if (sendThread.getZkState().isConnected()) {
             synchronized(outgoingQueue) {
-                if (!outgoingQueue.isEmpty()) {
+                if (findSendablePacket(outgoingQueue,
+                        cnxn.sendThread.clientTunneledAuthenticationInProgress()) != null) {
                     enableWrite();
-                } else {
-                    disableWrite();
                 }
             }
         }
@@ -314,7 +375,8 @@
         }
     }
 
-    private synchronized void disableWrite() {
+    @Override
+    public synchronized void disableWrite() {
         int i = sockKey.interestOps();
         if ((i & SelectionKey.OP_WRITE) != 0) {
             sockKey.interestOps(i & (~SelectionKey.OP_WRITE));
@@ -336,4 +398,17 @@
     Selector getSelector() {
         return selector;
     }
+
+    @Override
+    void sendPacket(Packet p) throws IOException {
+        SocketChannel sock = (SocketChannel) sockKey.channel();
+        if (sock == null) {
+            throw new IOException(""Socket is null!"");
+        }
+        p.createBB();
+        ByteBuffer pbb = p.bb;
+        sock.write(pbb);
+    }
+
+
 }
"
zookeeper,987635edac8aa374a04ea130dfd81a03a635bf0d,ZOOKEEPER-1437. Client uses session before SASL authentication complete (Eugene Koontz via mahadev),2012.09.10 03:24:07,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index 78ff277..4ce5477 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -21,17 +21,17 @@
 import org.apache.zookeeper.AsyncCallback;
 import org.apache.zookeeper.ClientCnxn;
 import org.apache.zookeeper.Login;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
 import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.Environment;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.proto.GetSASLRequest;
-import org.apache.zookeeper.proto.ReplyHeader;
-import org.apache.zookeeper.proto.RequestHeader;
 import org.apache.zookeeper.proto.SetSASLResponse;
 import org.apache.zookeeper.server.auth.KerberosName;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.IOException;
 import java.security.Principal;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
@@ -68,6 +68,7 @@
 
     private SaslState saslState = SaslState.INITIAL;
 
+    private boolean gotLastPacket = false;
     /** informational message indicating the current configuration status */
     private final String configStatus;
 
@@ -166,7 +167,7 @@
         public void processResult(int rc, String path, Object ctx, byte data[], Stat stat) {
             // processResult() is used by ClientCnxn's sendThread to respond to
             // data[] contains the Zookeeper Server's SASL token.
-            // ctx is the ZooKeeperSaslClient object. We use this object's prepareSaslResponseToServer() method
+            // ctx is the ZooKeeperSaslClient object. We use this object's respondToServer() method
             // to reply to the Zookeeper Server's SASL token
             ZooKeeperSaslClient client = ((ClientCnxn)ctx).zooKeeperSaslClient;
             if (client == null) {
@@ -181,7 +182,7 @@
                 usedata = new byte[0];
                 LOG.debug(""ServerSaslResponseCallback(): using empty data[] as server response (length=""+usedata.length+"")"");
             }
-            client.prepareSaslResponseToServer(usedata, (ClientCnxn)ctx);
+            client.respondToServer(usedata, (ClientCnxn)ctx);
         }
     }
 
@@ -242,38 +243,50 @@
                     return null;
                 }
             }
-        }
-        catch (LoginException e) {
+        } catch (LoginException e) {
+            // We throw LoginExceptions...
             throw e;
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
+            // ..but consume (with a log message) all other types of exceptions.
             LOG.error(""Exception while trying to create SASL client: "" + e);
             return null;
         }
     }
 
-    private void prepareSaslResponseToServer(byte[] serverToken, ClientCnxn cnxn) {
-        saslToken = serverToken;
-
+    public void respondToServer(byte[] serverToken, ClientCnxn cnxn) {
         if (saslClient == null) {
             LOG.error(""saslClient is unexpectedly null. Cannot respond to server's SASL message; ignoring."");
             return;
         }
 
-        LOG.debug(""saslToken (server) length: "" + saslToken.length);
         if (!(saslClient.isComplete())) {
             try {
-                saslToken = createSaslToken(saslToken);
+                saslToken = createSaslToken(serverToken);
                 if (saslToken != null) {
-                    LOG.debug(""saslToken (client) length: "" + saslToken.length);
-                    queueSaslPacket(saslToken, cnxn);
+                    sendSaslPacket(saslToken, cnxn);
                 }
             } catch (SaslException e) {
                 LOG.error(""SASL authentication failed using login context '"" +
-                this.getLoginContext() + ""'."");
+                        this.getLoginContext() + ""'."");
                 saslState = SaslState.FAILED;
+                gotLastPacket = true;
             }
         }
+
+        if (saslClient.isComplete()) {
+            // GSSAPI: server sends a final packet after authentication succeeds
+            // or fails.
+            if ((serverToken == null) && (saslClient.getMechanismName() == ""GSSAPI""))
+                gotLastPacket = true;
+            // non-GSSAPI: no final packet from server.
+            if (saslClient.getMechanismName() != ""GSSAPI"") {
+                gotLastPacket = true;
+            }
+            // SASL authentication is completed, successfully or not:
+            // enable the socket's writable flag so that any packets waiting for authentication to complete in
+            // the outgoing queue will be sent to the Zookeeper server.
+            cnxn.enableWrite();
+        }
     }
 
     private byte[] createSaslToken() throws SaslException {
@@ -284,6 +297,7 @@
     private byte[] createSaslToken(final byte[] saslToken) throws SaslException {
         if (saslToken == null) {
             // TODO: introspect about runtime environment (such as jaas.conf)
+            saslState = SaslState.FAILED;
             throw new SaslException(""Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null."");
         }
 
@@ -314,6 +328,7 @@
                     }
                     error += "" Zookeeper Client will go to AUTH_FAILED state."";
                     LOG.error(error);
+                    saslState = SaslState.FAILED;
                     throw new SaslException(error);
                 }
             }
@@ -324,51 +339,73 @@
         }
     }
 
-    private void queueSaslPacket(byte[] saslToken, ClientCnxn cnxn) {
-        LOG.debug(""ClientCnxn:sendSaslPacket:length=""+saslToken.length);
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.sasl);
+    private void sendSaslPacket(byte[] saslToken, ClientCnxn cnxn)
+      throws SaslException{
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""ClientCnxn:sendSaslPacket:length=""+saslToken.length);
+        }
+
         GetSASLRequest request = new GetSASLRequest();
         request.setToken(saslToken);
         SetSASLResponse response = new SetSASLResponse();
         ServerSaslResponseCallback cb = new ServerSaslResponseCallback();
-        ReplyHeader r = new ReplyHeader();
-        cnxn.queuePacket(h,r,request,response,cb);
-    }
-    
-    private void queueSaslPacket(ClientCnxn cnxn) throws SaslException {
-        queueSaslPacket(createSaslToken(), cnxn);
+
+        try {
+            cnxn.sendPacket(request,response,cb, ZooDefs.OpCode.sasl);
+        } catch (IOException e) {
+            throw new SaslException(""Failed to send SASL packet to server."",
+                e);
+        }
     }
 
-    // used by ClientCnxn to know when to emit SaslAuthenticated event.
-    // transitions internally from INTERMEDIATE to COMPLETE as a side effect if
-    // it's ready to emit this event.
-    public boolean readyToSendSaslAuthEvent() {
+    private void sendSaslPacket(ClientCnxn cnxn) throws SaslException {
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""ClientCnxn:sendSaslPacket:length=""+saslToken.length);
+        }
+        GetSASLRequest request = new GetSASLRequest();
+        request.setToken(createSaslToken());
+        SetSASLResponse response = new SetSASLResponse();
+        ServerSaslResponseCallback cb = new ServerSaslResponseCallback();
+        try {
+            cnxn.sendPacket(request,response,cb, ZooDefs.OpCode.sasl);
+        } catch (IOException e) {
+            throw new SaslException(""Failed to send SASL packet to server due "" +
+              ""to IOException:"", e);
+        }
+    }
+
+    // used by ClientCnxn to know whether to emit a SASL-related event: either AuthFailed or SaslAuthenticated,
+    // or none, if not ready yet. Sets saslState to COMPLETE as a side-effect.
+    public KeeperState getKeeperState() {
         if (saslClient != null) {
+            if (saslState == SaslState.FAILED) {
+              return KeeperState.AuthFailed;
+            }
             if (saslClient.isComplete()) {
                 if (saslState == SaslState.INTERMEDIATE) {
                     saslState = SaslState.COMPLETE;
-                    return true;
+                    return KeeperState.SaslAuthenticated;
                 }
             }
         }
-        else {
-            LOG.warn(""saslClient is null: client could not authenticate properly."");
-        }
-        return false;
+        // No event ready to emit yet.
+        return null;
     }
 
+    // Initialize the client's communications with the Zookeeper server by sending the server the first
+    // authentication packet.
     public void initialize(ClientCnxn cnxn) throws SaslException {
         if (saslClient == null) {
+            saslState = SaslState.FAILED;
             throw new SaslException(""saslClient failed to initialize properly: it's null."");
         }
         if (saslState == SaslState.INITIAL) {
             if (saslClient.hasInitialResponse()) {
-                queueSaslPacket(cnxn);
+                sendSaslPacket(cnxn);
             }
             else {
                 byte[] emptyToken = new byte[0];
-                queueSaslPacket(emptyToken, cnxn);
+                sendSaslPacket(emptyToken, cnxn);
             }
             saslState = SaslState.INTERMEDIATE;
         }
@@ -442,4 +479,44 @@
             }
         }
     }
+
+    public boolean clientTunneledAuthenticationInProgress() {
+        // TODO: Rather than checking a disjunction here, should be a single member
+        // variable or method in this class to determine whether the client is
+        // configured to use SASL. (see also ZOOKEEPER-1455).
+        try {
+            if ((System.getProperty(Environment.JAAS_CONF_KEY) != null) ||
+                (javax.security.auth.login.Configuration.getConfiguration() != null)) {
+                // Client is configured to use SASL.
+
+                // 1. Authentication hasn't finished yet: we must wait for it to do so.
+                if ((isComplete() == false) &&
+                    (isFailed() == false)) {
+                    return true;
+                }
+
+                // 2. SASL authentication has succeeded or failed..
+                if (isComplete() || isFailed()) {
+                    if (gotLastPacket == false) {
+                        // ..but still in progress, because there is a final SASL
+                        // message from server which must be received.
+                    return true;
+                    }
+                }
+            }
+            // Either client is not configured to use a tunnelled authentication
+            // scheme, or tunnelled authentication has completed (successfully or
+            // not), and all server SASL messages have been received.
+            return false;
+        } catch (SecurityException e) {
+            // Thrown if the caller does not have permission to retrieve the Configuration.
+            // In this case, simply returning false is correct.
+            if (LOG.isDebugEnabled() == true) {
+                LOG.debug(""Could not retrieve login configuration: "" + e);
+            }
+            return false;
+        }
+    }
+
+
 }
"
zookeeper,6b79710224533848b99c2a0297591d29c06583a0,ZOOKEEPER-1514. FastLeaderElection - leader ignores the round information when joining a quorum (flavio via henryr),2012.08.03 07:17:58,Henry Robinson,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 011b91a..5c30f59 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -442,7 +442,7 @@
      * Returns the current vlue of the logical clock counter
      */
     public long getLogicalClock(){
-    return logicalclock;
+        return logicalclock;
     }
 
     /**
@@ -621,7 +621,9 @@
         if(leader != self.getId()){
             if(votes.get(leader) == null) predicate = false;
             else if(votes.get(leader).getState() != ServerState.LEADING) predicate = false;
-        }
+        } else if(logicalclock != electionEpoch) {
+            predicate = false;
+        } 
 
         return predicate;
     }
@@ -724,7 +726,7 @@
 
             synchronized(this){
                 logicalclock++;
-                    updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());
+                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());
             }
 
             LOG.info(""New election. My id =  "" + self.getId() +
"
zookeeper,319190660ccc69544de1f36ade16be9c38b8d3e2,ZOOKEEPER-1521. LearnerHandler initLimit/syncLimit problems specifying follower socket timeout limits (phunt),2012.07.29 14:02:56,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 8c02322..4d09b43 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -298,7 +298,9 @@
                 while (!stop) {
                     try{
                         Socket s = ss.accept();
-                        s.setSoTimeout(self.tickTime * self.syncLimit);
+                        // start with the initLimit, once the ack is processed
+                        // in LearnerHandler switch to the syncLimit
+                        s.setSoTimeout(self.tickTime * self.initLimit);
                         s.setTcpNoDelay(nodelay);
                         LearnerHandler fh = new LearnerHandler(s, Leader.this);
                         fh.start();
"
zookeeper,319190660ccc69544de1f36ade16be9c38b8d3e2,ZOOKEEPER-1521. LearnerHandler initLimit/syncLimit problems specifying follower socket timeout limits (phunt),2012.07.29 14:02:56,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index f704bc2..ccb11e1 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -233,7 +233,6 @@
     @Override
     public void run() {
         try {
-            sock.setSoTimeout(leader.self.getTickTime()*leader.self.getInitLimit());
             ia = BinaryInputArchive.getArchive(new BufferedInputStream(sock
                     .getInputStream()));
             bufferedOutput = new BufferedOutputStream(sock.getOutputStream());
@@ -458,6 +457,9 @@
                 return;
             }
             leader.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());
+            
+            // now that the ack has been processed expect the syncLimit
+            sock.setSoTimeout(leader.self.tickTime * leader.self.syncLimit);
 
             /*
              * Wait until leader starts up
@@ -473,7 +475,6 @@
             //
             queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));
 
-
             while (true) {
                 qp = new QuorumPacket();
                 ia.readRecord(qp, ""packet"");
"
zookeeper,43eedab16b074f7b87da98ac0af60092bb0c52fd,ZOOKEEPER-1489. Data loss after truncate on transaction log (phunt),2012.07.18 06:25:11,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 2842803..d6c0c05 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -414,16 +414,23 @@
     }
 
     /**
-     * truncate the zkdatabase to this zxid
+     * Truncate the ZKDatabase to the specified zxid
      * @param zxid the zxid to truncate zk database to
-     * @return true if the truncate is succesful and false if not
+     * @return true if the truncate is successful and false if not
      * @throws IOException
      */
     public boolean truncateLog(long zxid) throws IOException {
         clear();
-        boolean truncated = this.snapLog.truncateLog(zxid);
+
+        // truncate the log
+        boolean truncated = snapLog.truncateLog(zxid);
+
+        if (!truncated) {
+            return false;
+        }
+
         loadDataBase();
-        return truncated;
+        return true;
     }
 
     /**
"
zookeeper,43eedab16b074f7b87da98ac0af60092bb0c52fd,ZOOKEEPER-1489. Data loss after truncate on transaction log (phunt),2012.07.18 06:25:11,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 39c91f6..4add8ce 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -47,12 +47,12 @@
 public class FileTxnSnapLog {
     //the direcotry containing the
     //the transaction logs
-    File dataDir;
+    private final File dataDir;
     //the directory containing the
     //the snapshot directory
-    File snapDir;
-    TxnLog txnLog;
-    SnapShot snapLog;
+    private final File snapDir;
+    private TxnLog txnLog;
+    private SnapShot snapLog;
     public final static int VERSION = 2;
     public final static String version = ""version-"";
 
@@ -81,6 +81,8 @@
      * @param snapDir the snapshot directory
      */
     public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {
+        LOG.debug(""Opening datadir:{} snapDir:{}"", dataDir, snapDir);
+
         this.dataDir = new File(dataDir, version + VERSION);
         this.snapDir = new File(snapDir, version + VERSION);
 
@@ -279,8 +281,22 @@
      * @throws IOException
      */
     public boolean truncateLog(long zxid) throws IOException {
-        FileTxnLog txnLog = new FileTxnLog(dataDir);
-        return txnLog.truncate(zxid);
+        // close the existing txnLog and snapLog
+        close();
+
+        // truncate it
+        FileTxnLog truncLog = new FileTxnLog(dataDir);
+        boolean truncated = truncLog.truncate(zxid);
+        truncLog.close();
+
+        // re-open the txnLog and snapLog
+        // I'd rather just close/reopen this object itself, however that 
+        // would have a big impact outside ZKDatabase as there are other
+        // objects holding a reference to this object.
+        txnLog = new FileTxnLog(dataDir);
+        snapLog = new FileSnap(snapDir);
+
+        return truncated;
     }
 
     /**
"
zookeeper,e2ad1053563537bd815dad63482b61bd34d5143d,ZOOKEEPER-1427. Writing to local files is done non-atomically (phunt),2012.07.18 06:19:38,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/common/AtomicFileOutputStream.java b/src/java/main/org/apache/zookeeper/common/AtomicFileOutputStream.java
new file mode 100644
index 0000000..ecfcad7
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/common/AtomicFileOutputStream.java
@@ -0,0 +1,115 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.common;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FilterOutputStream;
+import java.io.IOException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/*
+ * This code is originally from HDFS, see the similarly named files there
+ * in case of bug fixing, history, etc...
+ */
+
+/**
+ * A FileOutputStream that has the property that it will only show up at its
+ * destination once it has been entirely written and flushed to disk. While
+ * being written, it will use a .tmp suffix.
+ * 
+ * When the output stream is closed, it is flushed, fsynced, and will be moved
+ * into place, overwriting any file that already exists at that location.
+ * 
+ * <b>NOTE</b>: on Windows platforms, it will not atomically replace the target
+ * file - instead the target file is deleted before this one is moved into
+ * place.
+ */
+public class AtomicFileOutputStream extends FilterOutputStream {
+    private static final String TMP_EXTENSION = "".tmp"";
+
+    private final static Logger LOG = LoggerFactory
+            .getLogger(AtomicFileOutputStream.class);
+
+    private final File origFile;
+    private final File tmpFile;
+
+    public AtomicFileOutputStream(File f) throws FileNotFoundException {
+        // Code unfortunately must be duplicated below since we can't assign
+        // anything
+        // before calling super
+        super(new FileOutputStream(new File(f.getParentFile(), f.getName()
+                + TMP_EXTENSION)));
+        origFile = f.getAbsoluteFile();
+        tmpFile = new File(f.getParentFile(), f.getName() + TMP_EXTENSION)
+                .getAbsoluteFile();
+    }
+
+    @Override
+    public void close() throws IOException {
+        boolean triedToClose = false, success = false;
+        try {
+            flush();
+            ((FileOutputStream) out).getChannel().force(true);
+
+            triedToClose = true;
+            super.close();
+            success = true;
+        } finally {
+            if (success) {
+                boolean renamed = tmpFile.renameTo(origFile);
+                if (!renamed) {
+                    // On windows, renameTo does not replace.
+                    if (!origFile.delete() || !tmpFile.renameTo(origFile)) {
+                        throw new IOException(
+                                ""Could not rename temporary file "" + tmpFile
+                                        + "" to "" + origFile);
+                    }
+                }
+            } else {
+                if (!triedToClose) {
+                    // If we failed when flushing, try to close it to not leak
+                    // an FD
+                    IOUtils.closeStream(out);
+                }
+                // close wasn't successful, try to delete the tmp file
+                if (!tmpFile.delete()) {
+                    LOG.warn(""Unable to delete tmp file "" + tmpFile);
+                }
+            }
+        }
+    }
+
+    /**
+     * Close the atomic file, but do not ""commit"" the temporary file on top of
+     * the destination. This should be used if there is a failure in writing.
+     */
+    public void abort() {
+        try {
+            super.close();
+        } catch (IOException ioe) {
+            LOG.warn(""Unable to abort file "" + tmpFile, ioe);
+        }
+        if (!tmpFile.delete()) {
+            LOG.warn(""Unable to delete tmp file during abort "" + tmpFile);
+        }
+    }
+}
"
zookeeper,e2ad1053563537bd815dad63482b61bd34d5143d,ZOOKEEPER-1427. Writing to local files is done non-atomically (phunt),2012.07.18 06:19:38,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/common/IOUtils.java b/src/java/main/org/apache/zookeeper/common/IOUtils.java
new file mode 100644
index 0000000..16aea4e
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/common/IOUtils.java
@@ -0,0 +1,123 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.common;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.PrintStream;
+
+import org.slf4j.Logger;
+
+/*
+ * This code is originally from HDFS, see the similarly named files there
+ * in case of bug fixing, history, etc...
+ */
+
+public class IOUtils {
+    /**
+     * Closes the stream ignoring {@link IOException}. Must only be called in
+     * cleaning up from exception handlers.
+     * 
+     * @param stream
+     *            the Stream to close
+     */
+    public static void closeStream(Closeable stream) {
+        cleanup(null, stream);
+    }
+
+    /**
+     * Close the Closeable objects and <b>ignore</b> any {@link IOException} or
+     * null pointers. Must only be used for cleanup in exception handlers.
+     * 
+     * @param log
+     *            the log to record problems to at debug level. Can be null.
+     * @param closeables
+     *            the objects to close
+     */
+    public static void cleanup(Logger log, Closeable... closeables) {
+        for (Closeable c : closeables) {
+            if (c != null) {
+                try {
+                    c.close();
+                } catch (IOException e) {
+                    if (log != null) {
+                        log.warn(""Exception in closing "" + c, e);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Copies from one stream to another.
+     * 
+     * @param in
+     *            InputStrem to read from
+     * @param out
+     *            OutputStream to write to
+     * @param buffSize
+     *            the size of the buffer
+     * @param close
+     *            whether or not close the InputStream and OutputStream at the
+     *            end. The streams are closed in the finally clause.
+     */
+    public static void copyBytes(InputStream in, OutputStream out,
+            int buffSize, boolean close) throws IOException {
+        try {
+            copyBytes(in, out, buffSize);
+            if (close) {
+                out.close();
+                out = null;
+                in.close();
+                in = null;
+            }
+        } finally {
+            if (close) {
+                closeStream(out);
+                closeStream(in);
+            }
+        }
+    }
+
+    /**
+     * Copies from one stream to another.
+     * 
+     * @param in
+     *            InputStrem to read from
+     * @param out
+     *            OutputStream to write to
+     * @param buffSize
+     *            the size of the buffer
+     */
+    public static void copyBytes(InputStream in, OutputStream out, int buffSize)
+            throws IOException {
+        PrintStream ps = out instanceof PrintStream ? (PrintStream) out : null;
+        byte buf[] = new byte[buffSize];
+        int bytesRead = in.read(buf);
+        while (bytesRead >= 0) {
+            out.write(buf, 0, bytesRead);
+            if ((ps != null) && ps.checkError()) {
+                throw new IOException(""Unable to write to output stream."");
+            }
+            bytesRead = in.read(buf);
+        }
+    }
+
+}
"
zookeeper,e2ad1053563537bd815dad63482b61bd34d5143d,ZOOKEEPER-1427. Writing to local files is done non-atomically (phunt),2012.07.18 06:19:38,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 5062b7a..4e3a87d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -21,7 +21,6 @@
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
@@ -39,6 +38,7 @@
 import java.util.Map;
 import java.util.Properties;
 
+import org.apache.zookeeper.common.AtomicFileOutputStream;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
 import org.apache.zookeeper.server.ServerCnxnFactory;
@@ -1283,16 +1283,36 @@
 
     public static final String ACCEPTED_EPOCH_FILENAME = ""acceptedEpoch"";
 
+	/**
+	 * Write a long value to disk atomically. Either succeeds or an exception
+	 * is thrown.
+	 * @param name file name to write the long to
+	 * @param value the long value to write to the named file
+	 * @throws IOException if the file cannot be written atomically
+	 */
     private void writeLongToFile(String name, long value) throws IOException {
         File file = new File(logFactory.getSnapDir(), name);
-        FileOutputStream out = new FileOutputStream(file);
+        AtomicFileOutputStream out = new AtomicFileOutputStream(file);
         BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
+        boolean aborted = false;
         try {
             bw.write(Long.toString(value));
             bw.flush();
-            out.getFD().sync();
+            
+            out.flush();
+        } catch (IOException e) {
+            LOG.error(""Failed to write new file "" + file, e);
+            // worst case here the tmp file/resources(fd) are not cleaned up
+            //   and the caller will be notified (IOException)
+            aborted = true;
+            out.abort();
+            throw e;
         } finally {
-            bw.close();
+            if (!aborted) {
+                // if the close operation (rename) fails we'll get notified.
+                // worst case the tmp file may still exist
+                out.close();
+            }
         }
     }
 
"
zookeeper,72d9f30dca729058f645dc027b16c767abc0f479,ZOOKEEPER-1465. Cluster availability following new leader election      takes a long time with large datasets - is correlated to dataset size     (fpj and Thawan Kooburat via camille),2012.07.06 01:01:26,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index f1f4414..8c02322 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -881,7 +881,11 @@
             }
             if (ss.getCurrentEpoch() != -1) {
                 if (ss.isMoreRecentThan(leaderStateSummary)) {
-                    throw new IOException(""Follower is ahead of the leader"");
+                    throw new IOException(""Follower is ahead of the leader, leader summary: "" 
+                                                    + leaderStateSummary.getCurrentEpoch()
+                                                    + "" (current epoch), ""
+                                                    + leaderStateSummary.getLastZxid()
+                                                    + "" (last zxid)"");
                 }
                 electingFollowers.add(id);
             }
@@ -903,4 +907,50 @@
             }
         }
     }
+
+    /**
+     * Get string representation of a given packet type
+     * @param packetType
+     * @return string representing the packet type
+     */
+    public static String getPacketType(int packetType) {
+        switch (packetType) {
+        case DIFF:
+            return ""DIFF"";
+        case TRUNC:
+            return ""TRUNC"";
+        case SNAP:
+            return ""SNAP"";
+        case OBSERVERINFO:
+            return ""OBSERVERINFO"";
+        case NEWLEADER:
+            return ""NEWLEADER"";
+        case FOLLOWERINFO:
+            return ""FOLLOWERINFO"";
+        case UPTODATE:
+            return ""UPTODATE"";
+        case LEADERINFO:
+            return ""LEADERINFO"";
+        case ACKEPOCH:
+            return ""ACKEPOCH"";
+        case REQUEST:
+            return ""REQUEST"";
+        case PROPOSAL:
+            return ""PROPOSAL"";
+        case ACK:
+            return ""ACK"";
+        case COMMIT:
+            return ""COMMIT"";
+        case PING:
+            return ""PING"";
+        case REVALIDATE:
+            return ""REVALIDATE"";
+        case SYNC:
+            return ""SYNC"";
+        case INFORM:
+            return ""INFORM"";
+        default:
+            return ""UNKNOWN"";
+        }
+    }
 }
"
zookeeper,72d9f30dca729058f645dc027b16c767abc0f479,ZOOKEEPER-1465. Cluster availability following new leader election      takes a long time with large datasets - is correlated to dataset size     (fpj and Thawan Kooburat via camille),2012.07.06 01:01:26,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index 4fc1663..f704bc2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -342,6 +342,12 @@
                         // whether to expect a trunc or a diff
                         boolean firstPacket=true;
 
+                        // If we are here, we can use committedLog to sync with
+                        // follower. Then we only need to decide whether to
+                        // send trunc or not
+                        packetToSend = Leader.DIFF;
+                        zxidToSend = maxCommittedLog;
+
                         for (Proposal propose: proposals) {
                             // skip the proposals the peer already has
                             if (propose.packet.getZxid() <= peerLastZxid) {
@@ -356,17 +362,9 @@
                                     if (prevProposalZxid < peerLastZxid) {
                                         // send a trunc message before sending the diff
                                         packetToSend = Leader.TRUNC;
-                                        LOG.info(""Sending TRUNC"");
                                         zxidToSend = prevProposalZxid;
                                         updates = zxidToSend;
                                     }
-                                    else {
-                                        // Just send the diff
-                                        packetToSend = Leader.DIFF;
-                                        LOG.info(""Sending diff"");
-                                        zxidToSend = maxCommittedLog;
-                                    }
-
                                 }
                                 queuePacket(propose.packet);
                                 QuorumPacket qcommit = new QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),
@@ -385,19 +383,23 @@
                     } else {
                         LOG.warn(""Unhandled proposal scenario"");
                     }
+                } else if (peerLastZxid == leader.zk.getZKDatabase().getDataTreeLastProcessedZxid()) {
+                    // The leader may recently take a snapshot, so the committedLog
+                    // is empty. We don't need to send snapshot if the follow
+                    // is already sync with in-memory db.
+                    LOG.debug(""committedLog is empty but leader and follower ""
+                            + ""are in sync, zxid=0x{}"",
+                            Long.toHexString(peerLastZxid));
+                    packetToSend = Leader.DIFF;
+                    zxidToSend = peerLastZxid;
                 } else {
                     // just let the state transfer happen
                     LOG.debug(""proposals is empty"");
                 }               
 
+                LOG.info(""Sending "" + Leader.getPacketType(packetToSend));
                 leaderLastZxid = leader.startForwarding(this, updates);
-                if (peerLastZxid == leaderLastZxid) {
-                    LOG.debug(""Leader and follower are in sync, sending empty diff. zxid=0x{}"",
-                            Long.toHexString(leaderLastZxid));
-                    // We are in sync so we'll do an empty diff
-                    packetToSend = Leader.DIFF;
-                    zxidToSend = leaderLastZxid;
-                }
+
             } finally {
                 rl.unlock();
             }
"
zookeeper,79bc813ef687b9e05d85fa597d9b59303c7f7ded,ZOOKEEPER-1471. Jute generates invalid C++ code (Michi Mutsuzaki via phunt),2012.06.30 15:42:50,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/jute/compiler/JRecord.java b/src/java/main/org/apache/jute/compiler/JRecord.java
index 99b75ce..01ba298 100644
--- a/src/java/main/org/apache/jute/compiler/JRecord.java
+++ b/src/java/main/org/apache/jute/compiler/JRecord.java
@@ -99,7 +99,7 @@
     }
 
     public String genCppDecl(String fname) {
-        return ""  ""+mName+"" ""+fname+"";\n"";
+        return ""  ""+ getCppNameSpace() + ""::"" + mName+"" m""+fname+"";\n"";
     }
 
     public String genJavaReadMethod(String fname, String tag) {
@@ -320,9 +320,9 @@
             JField jf = i.next();
             String name = jf.getName();
             if (jf.getType() instanceof JBuffer) {
-                cc.write(""  a_.serialize(""+name+"",""+name+"".length(),\""""+jf.getTag()+""\"");\n"");
+                cc.write(""  a_.serialize(m""+name+"",m""+name+"".length(),\""""+jf.getTag()+""\"");\n"");
             } else {
-                cc.write(""  a_.serialize(""+name+"",\""""+jf.getTag()+""\"");\n"");
+                cc.write(""  a_.serialize(m""+name+"",\""""+jf.getTag()+""\"");\n"");
             }
             cc.write(""  bs_.reset(""+fIdx+"");\n"");
         }
@@ -337,9 +337,9 @@
             JField jf = i.next();
             String name = jf.getName();
             if (jf.getType() instanceof JBuffer) {
-                cc.write(""  { size_t len=0; a_.deserialize(""+name+"",len,\""""+jf.getTag()+""\"");}\n"");
+                cc.write(""  { size_t len=0; a_.deserialize(m""+name+"",len,\""""+jf.getTag()+""\"");}\n"");
             } else {
-                cc.write(""  a_.deserialize(""+name+"",\""""+jf.getTag()+""\"");\n"");
+                cc.write(""  a_.deserialize(m""+name+"",\""""+jf.getTag()+""\"");\n"");
             }
             cc.write(""  bs_.set(""+fIdx+"");\n"");
         }
@@ -353,7 +353,7 @@
             JField jf = (JField) i.next();
             JType type = jf.getType();
             if (type instanceof JRecord) {
-                cc.write(""  if (!""+jf.getName()+"".validate()) return false;\n"");
+                cc.write(""  if (!m""+jf.getName()+"".validate()) return false;\n"");
             }
         }
         cc.write(""  return true;\n"");
@@ -364,7 +364,7 @@
         for (Iterator<JField> i = mFields.iterator(); i.hasNext();) {
             JField jf = i.next();
             String name = jf.getName();
-            cc.write(""    && (""+name+"" < peer_.""+name+"")\n"");
+            cc.write(""    && (m""+name+"" < peer_.m""+name+"")\n"");
         }
         cc.write(""  );\n"");
         cc.write(""}\n"");
@@ -374,7 +374,7 @@
         for (Iterator<JField> i = mFields.iterator(); i.hasNext();) {
             JField jf = i.next();
             String name = jf.getName();
-            cc.write(""    && (""+name+"" == peer_.""+name+"")\n"");
+            cc.write(""    && (m""+name+"" == peer_.m""+name+"")\n"");
         }
         cc.write(""  );\n"");
         cc.write(""}\n"");
"
zookeeper,a17ca1544fabfa9fa93ba7d7da7efa7ce3b96efc,ZOOKEEPER-1236. Security uses proprietary Sun APIs (Adalberto Medeiros via phunt),2012.06.30 15:30:58,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/KerberosName.java b/src/java/main/org/apache/zookeeper/server/auth/KerberosName.java
index f5d0eb1..01d1f66 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/KerberosName.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/KerberosName.java
@@ -32,8 +32,8 @@
 import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import sun.security.krb5.Config;
-import sun.security.krb5.KrbException;
+
+import org.apache.zookeeper.server.util.KerberosUtil;
 
 /**
  * This class implements parsing and handling of Kerberos principal names. In 
@@ -79,17 +79,17 @@
   private static List<Rule> rules;
 
   private static String defaultRealm;
-  private static Config kerbConf;
   
   static {
     try {
-      kerbConf = Config.getInstance();
-      defaultRealm = kerbConf.getDefaultRealm();
-    } catch (KrbException ke) {
+      defaultRealm = KerberosUtil.getDefaultRealm();
+    } catch (Exception ke) {
       if ((System.getProperty(""zookeeper.requireKerberosConfig"") != null) &&
           (System.getProperty(""zookeeper.requireKerberosConfig"").equals(""true""))) {
         throw new IllegalArgumentException(""Can't get Kerberos configuration"",ke);
       }
+      else
+        defaultRealm="""";
     }
     try {
       // setConfiguration() will work even if the above try() fails due
"
zookeeper,a17ca1544fabfa9fa93ba7d7da7efa7ce3b96efc,ZOOKEEPER-1236. Security uses proprietary Sun APIs (Adalberto Medeiros via phunt),2012.06.30 15:30:58,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/util/KerberosUtil.java b/src/java/main/org/apache/zookeeper/server/util/KerberosUtil.java
new file mode 100644
index 0000000..1434ff0
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/util/KerberosUtil.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.util;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+public class KerberosUtil {
+
+  public static String getDefaultRealm() 
+      throws ClassNotFoundException, NoSuchMethodException, 
+      IllegalArgumentException, IllegalAccessException, 
+      InvocationTargetException {
+    Object kerbConf;
+    Class<?> classRef;
+    Method getInstanceMethod;
+    Method getDefaultRealmMethod;
+    if (System.getProperty(""java.vendor"").contains(""IBM"")) {
+      classRef = Class.forName(""com.ibm.security.krb5.internal.Config"");
+    } else {
+      classRef = Class.forName(""sun.security.krb5.Config"");
+    }
+    getInstanceMethod = classRef.getMethod(""getInstance"", new Class[0]);
+    kerbConf = getInstanceMethod.invoke(classRef, new Object[0]);
+    getDefaultRealmMethod = classRef.getDeclaredMethod(""getDefaultRealm"",
+         new Class[0]);
+    return (String)getDefaultRealmMethod.invoke(kerbConf, new Object[0]);
+  }
+}
"
zookeeper,51aba88122c95aa295beed3d23d57871c0567291,ZOOKEEPER-1466. QuorumCnxManager.shutdown missing synchronization. (Patrick Hunt via mahadev),2012.06.30 05:08:06,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index aba168e..595a4dd 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -112,7 +112,7 @@
      * Shutdown flag
      */
 
-    boolean shutdown = false;
+    volatile boolean shutdown = false;
 
     /*
      * Listener thread
"
zookeeper,21c9ae268fb11a0c7380e520e1eebe115fba7387,ZOOKEEPER-1440. Spurious log error messages when QuorumCnxManager is shutting down (Jordan Zimmerman via michim),2012.05.08 14:03:30,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index a69f362..aba168e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -493,16 +493,18 @@
                         numRetries = 0;
                     }
                 } catch (IOException e) {
-                    LOG.error(""Exception while listening"", e);
-                    numRetries++;
-                    try {
-                        ss.close();
-                        Thread.sleep(1000);
-                    } catch (IOException ie) {
-                        LOG.error(""Error closing server socket"", ie);
-                    } catch (InterruptedException ie) {
-                        LOG.error(""Interrupted while sleeping. "" +
-                                  ""Ignoring exception"", ie);
+                    if ( !shutdown ) {
+                        LOG.error(""Exception while listening"", e);
+                        numRetries++;
+                        try {
+                            ss.close();
+                            Thread.sleep(1000);
+                        } catch (IOException ie) {
+                            LOG.error(""Error closing server socket"", ie);
+                        } catch (InterruptedException ie) {
+                            LOG.error(""Interrupted while sleeping. "" +
+                                      ""Ignoring exception"", ie);
+                        }
                     }
                 }
             }
"
zookeeper,e5a51ead53813843ad8b9448845fd2332757c757,"ZOOKEEPER-1419. Leader election never settles for a 5-node cluster (flavio via camille)   ",2012.03.20 09:33:49,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 8e4e65e..3124e00 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -546,16 +546,24 @@
      * @param id    Server identifier
      * @param zxid  Last zxid observed by the issuer of this vote
      */
-    private boolean totalOrderPredicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch) {
+    protected boolean totalOrderPredicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch) {
         LOG.debug(""id: "" + newId + "", proposed id: "" + curId + "", zxid: 0x"" +
                 Long.toHexString(newZxid) + "", proposed zxid: 0x"" + Long.toHexString(curZxid));
         if(self.getQuorumVerifier().getWeight(newId) == 0){
             return false;
         }
         
+        /*
+         * We return true if one of the following three cases hold:
+         * 1- New epoch is higher
+         * 2- New epoch is the same as current epoch, but new zxid is higher
+         * 3- New epoch is the same as current epoch, new zxid is the same
+         *  as current zxid, but server id is higher.
+         */
+        
         return ((newEpoch > curEpoch) || 
-                ((newEpoch == curEpoch) && (newZxid > curZxid)) || 
-                ((newZxid == curZxid) && (newId > curId)));
+                ((newEpoch == curEpoch) &&
+                ((newZxid > curZxid) || ((newZxid == curZxid) && (newId > curId)))));
     }
 
     /**
"
zookeeper,9ab32ca0dfe9ba49a26c08560d39d444fd775e4a,ZOOKEEPER-1307. zkCli.sh is exiting when an Invalid ACL exception is thrown from setACL command through client (Kavita Sharma via phunt),2012.03.17 09:39:16,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 4f0815c..f58d418 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -1380,7 +1380,7 @@
         SetACLRequest request = new SetACLRequest();
         request.setPath(serverPath);
         if (acl != null && acl.size() == 0) {
-            throw new KeeperException.InvalidACLException();
+            throw new KeeperException.InvalidACLException(clientPath);
         }
         request.setAcl(acl);
         request.setVersion(version);
"
zookeeper,9ab32ca0dfe9ba49a26c08560d39d444fd775e4a,ZOOKEEPER-1307. zkCli.sh is exiting when an Invalid ACL exception is thrown from setACL command through client (Kavita Sharma via phunt),2012.03.17 09:39:16,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index 15d66f6..877e9d6 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -604,6 +604,14 @@
             System.err.println(""Node not empty: "" + e.getPath());
         } catch (KeeperException.NotReadOnlyException e) {
             System.err.println(""Not a read-only call: "" + e.getPath());
+        }catch (KeeperException.InvalidACLException  e) {
+            System.err.println(""Acl is not valid : ""+e.getPath());
+        }catch (KeeperException.NoAuthException  e) {
+            System.err.println(""Authentication is not valid : ""+e.getPath());
+        }catch (KeeperException.BadArgumentsException   e) {
+            System.err.println(""Arguments are not valid : ""+e.getPath());
+        }catch (KeeperException.BadVersionException e) {
+            System.err.println(""version No is not valid : ""+e.getPath());
         }
         return false;
     }
"
zookeeper,cbe58afeeccca6acd532968ddb32833ed65021b8,ZOOKEEPER-1344. ZooKeeper client multi-update command is not considering the Chroot request (Rakesh R via phunt),2012.03.17 09:31:16,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/Op.java b/src/java/main/org/apache/zookeeper/Op.java
index 3c3db2e..6330717 100644
--- a/src/java/main/org/apache/zookeeper/Op.java
+++ b/src/java/main/org/apache/zookeeper/Op.java
@@ -154,6 +154,12 @@
      * @return An appropriate Record structure.
      */
     public abstract Record toRequestRecord() ;
+    
+    /**
+     * Reconstructs the transaction with the chroot prefix.
+     * @return transaction with chroot.
+     */
+    abstract Op withChroot(String addRootPrefix);
 
     //////////////////
     // these internal classes are public, but should not generally be referenced.
@@ -210,6 +216,11 @@
         public Record toRequestRecord() {
             return new CreateRequest(getPath(), data, acl, flags);
         }
+
+        @Override
+        Op withChroot(String path) {
+            return new Create(path, data, acl, flags);
+        }
     }
 
     public static class Delete extends Op {
@@ -240,6 +251,11 @@
         public Record toRequestRecord() {
             return new DeleteRequest(getPath(), version);
         }
+
+        @Override
+        Op withChroot(String path) {
+            return new Delete(path, version);
+        }
     }
 
     public static class SetData extends Op {
@@ -272,6 +288,11 @@
         public Record toRequestRecord() {
             return new SetDataRequest(getPath(), data, version);
         }
+
+        @Override
+        Op withChroot(String path) {
+            return new SetData(path, data, version);
+        }
     }
 
     public static class Check extends Op {
@@ -301,5 +322,11 @@
         public Record toRequestRecord() {
             return new CheckVersionRequest(getPath(), version);
         }
+
+        @Override
+        Op withChroot(String path) {
+            return new Check(path, version);
+        }
     }
+
 }
"
zookeeper,cbe58afeeccca6acd532968ddb32833ed65021b8,ZOOKEEPER-1344. ZooKeeper client multi-update command is not considering the Chroot request (Rakesh R via phunt),2012.03.17 09:31:16,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/Transaction.java b/src/java/main/org/apache/zookeeper/Transaction.java
index c58e732..7e67b87 100644
--- a/src/java/main/org/apache/zookeeper/Transaction.java
+++ b/src/java/main/org/apache/zookeeper/Transaction.java
@@ -18,7 +18,7 @@
 package org.apache.zookeeper;
 
 import org.apache.zookeeper.data.ACL;
-
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -30,7 +30,7 @@
  */
 public class Transaction {
     private ZooKeeper zk;
-    private MultiTransactionRecord request = new MultiTransactionRecord();
+    private List<Op> ops = new ArrayList<Op>();
 
     protected Transaction(ZooKeeper zk) {
         this.zk = zk;
@@ -38,26 +38,26 @@
 
     public Transaction create(final String path, byte data[], List<ACL> acl,
                               CreateMode createMode) {
-        request.add(Op.create(path, data, acl, createMode.toFlag()));
+        ops.add(Op.create(path, data, acl, createMode.toFlag()));
         return this;
     }
 
     public Transaction delete(final String path, int version) {
-        request.add(Op.delete(path, version));
+        ops.add(Op.delete(path, version));
         return this;
     }
 
     public Transaction check(String path, int version) {
-        request.add(Op.check(path, version));
+        ops.add(Op.check(path, version));
         return this;
     }
 
     public Transaction setData(final String path, byte data[], int version) {
-        request.add(Op.setData(path, data, version));
+        ops.add(Op.setData(path, data, version));
         return this;
     }
 
     public List<OpResult> commit() throws InterruptedException, KeeperException {
-        return zk.multiInternal(request);
+        return zk.multi(ops);
     }
 }
"
zookeeper,cbe58afeeccca6acd532968ddb32833ed65021b8,ZOOKEEPER-1344. ZooKeeper client multi-update command is not considering the Chroot request (Rakesh R via phunt),2012.03.17 09:31:16,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 9fe7652..4f0815c 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -898,7 +898,22 @@
      * @since 3.4.0
      */
     public List<OpResult> multi(Iterable<Op> ops) throws InterruptedException, KeeperException {
-        return multiInternal(new MultiTransactionRecord(ops));
+        // reconstructing transaction with the chroot prefix
+        List<Op> transaction = new ArrayList<Op>();
+        for (Op op : ops) {
+            transaction.add(withRootPrefix(op));
+        }
+        return multiInternal(new MultiTransactionRecord(transaction));
+    }
+    
+    private Op withRootPrefix(Op op) {
+        if (null != op.getPath()) {
+            final String serverPath = prependChroot(op.getPath());
+            if (!op.getPath().equals(serverPath)) {
+                return op.withChroot(serverPath);
+            }
+        }
+        return op;
     }
 
     protected List<OpResult> multiInternal(MultiTransactionRecord request)
"
zookeeper,655b2e3f0a047d6b6db9e4cdb581a84a54f5366c,ZOOKEEPER-1412. java client watches inconsistently triggered on reconnect (phunt),2012.03.16 02:01:09,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 553bd58..5ec782e 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -660,6 +660,10 @@
 
     private volatile long lastZxid;
 
+    public long getLastZxid() {
+        return lastZxid;
+    }
+
     static class EndOfStreamException extends IOException {
         private static final long serialVersionUID = -5438877188796231422L;
 
"
zookeeper,655b2e3f0a047d6b6db9e4cdb581a84a54f5366c,ZOOKEEPER-1412. java client watches inconsistently triggered on reconnect (phunt),2012.03.16 02:01:09,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index ab517da..e8f7992 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -388,11 +388,12 @@
             err = Code.MARSHALLINGERROR;
         }
 
+        long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();
         ReplyHeader hdr =
-            new ReplyHeader(request.cxid, request.zxid, err.intValue());
+            new ReplyHeader(request.cxid, lastZxid, err.intValue());
 
         zks.serverStats().updateLatency(request.createTime);
-        cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,
+        cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp,
                     request.createTime, System.currentTimeMillis());
 
         try {
"
zookeeper,297517b5e1461400039aa7c4fdbbd246183a133f,ZOOKEEPER-1277. servers stop serving when lower 32bits of zxid roll over (phunt),2012.03.16 01:47:29,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 1d3c2d6..206c826 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -56,6 +56,7 @@
 import org.apache.zookeeper.server.ZooKeeperServer.ChangeRecord;
 import org.apache.zookeeper.server.auth.AuthenticationProvider;
 import org.apache.zookeeper.server.auth.ProviderRegistry;
+import org.apache.zookeeper.server.quorum.Leader.XidRolloverException;
 import org.apache.zookeeper.txn.CreateSessionTxn;
 import org.apache.zookeeper.txn.CreateTxn;
 import org.apache.zookeeper.txn.DeleteTxn;
@@ -130,6 +131,13 @@
             }
         } catch (InterruptedException e) {
             LOG.error(""Unexpected interruption"", e);
+        } catch (RequestProcessorException e) {
+            if (e.getCause() instanceof XidRolloverException) {
+                LOG.info(e.getCause().getMessage());
+            }
+            LOG.error(""Unexpected exception"", e);
+        } catch (Exception e) {
+            LOG.error(""Unexpected exception"", e);
         }
         LOG.info(""PrepRequestProcessor exited loop!"");
     }
@@ -292,7 +300,7 @@
      */
     protected void pRequest2Txn(int type, long zxid, Request request,
                                 Record record, boolean deserialize)
-        throws KeeperException, IOException
+        throws KeeperException, IOException, RequestProcessorException
     {
         request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, zks.getTime(), type));
 
@@ -473,7 +481,7 @@
      *
      * @param request
      */
-    protected void pRequest(Request request) {
+    protected void pRequest(Request request) throws RequestProcessorException {
         // LOG.info(""Prep>>> cxid = "" + request.cxid + "" type = "" +
         // request.type + "" id = 0x"" + Long.toHexString(request.sessionId));
         request.setHdr(null);
"
zookeeper,297517b5e1461400039aa7c4fdbbd246183a133f,ZOOKEEPER-1277. servers stop serving when lower 32bits of zxid roll over (phunt),2012.03.16 01:47:29,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/RequestProcessor.java b/src/java/main/org/apache/zookeeper/server/RequestProcessor.java
index 5eef02f..9c9e5bd 100644
--- a/src/java/main/org/apache/zookeeper/server/RequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/RequestProcessor.java
@@ -31,7 +31,14 @@
  * any RequestProcessors that it is connected to.
  */
 public interface RequestProcessor {
-    void processRequest(Request request);
+    @SuppressWarnings(""serial"")
+    public static class RequestProcessorException extends Exception {
+        public RequestProcessorException(String msg, Throwable t) {
+            super(msg, t);
+        }
+    }
+
+    void processRequest(Request request) throws RequestProcessorException;
 
     void shutdown();
 }
"
zookeeper,297517b5e1461400039aa7c4fdbbd246183a133f,ZOOKEEPER-1277. servers stop serving when lower 32bits of zxid roll over (phunt),2012.03.16 01:47:29,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index be287c0..b18650c 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -155,7 +155,9 @@
         LOG.info(""SyncRequestProcessor exited!"");
     }
 
-    private void flush(LinkedList<Request> toFlush) throws IOException {
+    private void flush(LinkedList<Request> toFlush)
+        throws IOException, RequestProcessorException
+    {
         if (toFlush.isEmpty())
             return;
 
"
zookeeper,297517b5e1461400039aa7c4fdbbd246183a133f,ZOOKEEPER-1277. servers stop serving when lower 32bits of zxid roll over (phunt),2012.03.16 01:47:29,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index d49f144..7bb7b2f 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -30,13 +30,12 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Random;
-import java.util.concurrent.ConcurrentHashMap;
+
+import javax.security.sasl.SaslException;
 
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.BinaryOutputArchive;
 import org.apache.jute.Record;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.Environment;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.Code;
@@ -54,6 +53,7 @@
 import org.apache.zookeeper.proto.RequestHeader;
 import org.apache.zookeeper.proto.SetSASLResponse;
 import org.apache.zookeeper.server.DataTree.ProcessTxnResult;
+import org.apache.zookeeper.server.RequestProcessor.RequestProcessorException;
 import org.apache.zookeeper.server.ServerCnxn.CloseRequestException;
 import org.apache.zookeeper.server.SessionTracker.Session;
 import org.apache.zookeeper.server.SessionTracker.SessionExpirer;
@@ -63,8 +63,9 @@
 import org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer;
 import org.apache.zookeeper.txn.CreateSessionTxn;
 import org.apache.zookeeper.txn.TxnHeader;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import javax.security.sasl.SaslException;
 
 /**
  * This class implements a simple standalone ZooKeeperServer. It sets up the
@@ -636,6 +637,8 @@
             if (LOG.isDebugEnabled()) {
                 LOG.debug(""Dropping request: "" + e.getMessage());
             }
+        } catch (RequestProcessorException e) {
+            LOG.error(""Unable to process request:"" + e.getMessage(), e);
         }
     }
 
"
zookeeper,297517b5e1461400039aa7c4fdbbd246183a133f,ZOOKEEPER-1277. servers stop serving when lower 32bits of zxid roll over (phunt),2012.03.16 01:47:29,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 2ff5326..3b7a7ea 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -409,6 +409,24 @@
                 Thread.sleep(self.tickTime);
                 self.tick++;
             }
+            
+            /**
+             * WARNING: do not use this for anything other than QA testing
+             * on a real cluster. Specifically to enable verification that quorum
+             * can handle the lower 32bit roll-over issue identified in
+             * ZOOKEEPER-1277. Without this option it would take a very long
+             * time (on order of a month say) to see the 4 billion writes
+             * necessary to cause the roll-over to occur.
+             * 
+             * This field allows you to override the zxid of the server. Typically
+             * you'll want to set it to something like 0xfffffff0 and then
+             * start the quorum, run some operations and see the re-election.
+             */
+            String initialZxid = System.getProperty(""zookeeper.testingonly.initialZxid"");
+            if (initialZxid != null) {
+                long zxid = Long.parseLong(initialZxid);
+                zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);
+            }
 
             if (!System.getProperty(""zookeeper.leaderServes"", ""yes"").equals(""no"")) {
                 self.cnxnFactory.setZooKeeperServer(zk);
@@ -614,7 +632,7 @@
          *
          * @see org.apache.zookeeper.server.RequestProcessor#processRequest(org.apache.zookeeper.server.Request)
          */
-        public void processRequest(Request request) {
+        public void processRequest(Request request) throws RequestProcessorException {
             next.processRequest(request);
             Proposal p = leader.toBeApplied.peek();
             if (p != null && p.request != null && p.request.zxid == request.zxid) {
@@ -693,6 +711,13 @@
     public long getEpoch(){
         return ZxidUtils.getEpochFromZxid(lastProposed);
     }
+    
+    @SuppressWarnings(""serial"")
+    public static class XidRolloverException extends Exception {
+        public XidRolloverException(String message) {
+            super(message);
+        }
+    }
 
     /**
      * create a proposal and send it out to all the members
@@ -700,7 +725,18 @@
      * @param request
      * @return the proposal that is queued to send to all the members
      */
-    public Proposal propose(Request request) {
+    public Proposal propose(Request request) throws XidRolloverException {
+        /**
+         * Address the rollover issue. All lower 32bits set indicate a new leader
+         * election. Force a re-election instead. See ZOOKEEPER-1277
+         */
+        if ((request.zxid & 0xffffffffL) == 0xffffffffL) {
+            String msg =
+                    ""zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start"";
+            shutdown(msg);
+            throw new XidRolloverException(msg);
+        }
+
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
         try {
"
zookeeper,297517b5e1461400039aa7c4fdbbd246183a133f,ZOOKEEPER-1277. servers stop serving when lower 32bits of zxid roll over (phunt),2012.03.16 01:47:29,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java
index 0eb25a8..7bb1bef 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java
@@ -18,11 +18,12 @@
 
 package org.apache.zookeeper.server.quorum;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.RequestProcessor;
 import org.apache.zookeeper.server.SyncRequestProcessor;
+import org.apache.zookeeper.server.quorum.Leader.XidRolloverException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * This RequestProcessor simply forwards requests to an AckRequestProcessor and
@@ -53,7 +54,7 @@
         syncProcessor.start();
     }
 
-    public void processRequest(Request request) {
+    public void processRequest(Request request) throws RequestProcessorException {
         // LOG.warn(""Ack>>> cxid = "" + request.cxid + "" type = "" +
         // request.type + "" id = "" + request.sessionId);
         // request.addRQRec("">prop"");
@@ -73,7 +74,11 @@
                 nextProcessor.processRequest(request);
             if (request.getHdr() != null) {
                 // We need to sync and get consensus on any transactions
-                zks.getLeader().propose(request);
+                try {
+                    zks.getLeader().propose(request);
+                } catch (XidRolloverException e) {
+                    throw new RequestProcessorException(e.getMessage(), e);
+                }
                 syncProcessor.processRequest(request);
             }
         }
"
zookeeper,297517b5e1461400039aa7c4fdbbd246183a133f,ZOOKEEPER-1277. servers stop serving when lower 32bits of zxid roll over (phunt),2012.03.16 01:47:29,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
index 8fd942b..267e420 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
@@ -28,6 +28,8 @@
 import org.apache.zookeeper.server.RequestProcessor;
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.ZooTrace;
+import org.apache.zookeeper.server.RequestProcessor.RequestProcessorException;
+import org.apache.zookeeper.server.quorum.Leader.XidRolloverException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -98,6 +100,13 @@
             }
         } catch (InterruptedException e) {
             LOG.error(""Unexpected interruption"", e);
+        } catch (RequestProcessorException e) {
+            if (e.getCause() instanceof XidRolloverException) {
+                LOG.info(e.getCause().getMessage());
+            }
+            LOG.error(""Unexpected exception"", e);
+        } catch (Exception e) {
+            LOG.error(""Unexpected exception"", e);
         }
         LOG.info(""ReadOnlyRequestProcessor exited loop!"");
     }
"
zookeeper,257a00aa97cd21c967ad620c3119a86295f1b794,ZOOKEEPER-1361. Leader.lead iterates over 'learners' set without proper synchronisation (henryr via camille),2012.02.27 11:41:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index eb61a29..0fd56b6 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -771,9 +771,9 @@
             if(stats.getServerState().equals(""leader"")) {
                 Leader leader = ((LeaderZooKeeperServer)zkServer).getLeader();
 
-                print(""followers"", leader.learners.size());
-                print(""synced_followers"", leader.forwardingFollowers.size());
-                print(""pending_syncs"", leader.pendingSyncs.size());
+                print(""followers"", leader.getLearners().size());
+                print(""synced_followers"", leader.getForwardingFollowers().size());
+                print(""pending_syncs"", leader.getNumPendingSyncs());
             }
         }
 
"
zookeeper,257a00aa97cd21c967ad620c3119a86295f1b794,ZOOKEEPER-1361. Leader.lead iterates over 'learners' set without proper synchronisation (henryr via camille),2012.02.27 11:41:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index 1d2034a..33b6104 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -582,9 +582,9 @@
             if(stats.getServerState().equals(""leader"")) {
                 Leader leader = ((LeaderZooKeeperServer)zkServer).getLeader();
 
-                print(""followers"", leader.learners.size());
-                print(""synced_followers"", leader.forwardingFollowers.size());
-                print(""pending_syncs"", leader.pendingSyncs.size());
+                print(""followers"", leader.getLearners().size());
+                print(""synced_followers"", leader.getForwardingFollowers().size());
+                print(""pending_syncs"", leader.getNumPendingSyncs());
             }
         }
 
"
zookeeper,257a00aa97cd21c967ad620c3119a86295f1b794,ZOOKEEPER-1361. Leader.lead iterates over 'learners' set without proper synchronisation (henryr via camille),2012.02.27 11:41:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 5979716..2ff5326 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -32,10 +32,10 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.jute.BinaryOutputArchive;
 import org.apache.zookeeper.server.FinalRequestProcessor;
@@ -79,22 +79,66 @@
     volatile LearnerCnxAcceptor cnxAcceptor = null;
 
     // list of all the followers
-    public final HashSet<LearnerHandler> learners =
+    private final HashSet<LearnerHandler> learners =
         new HashSet<LearnerHandler>();
 
+    /**
+     * Returns a copy of the current learner snapshot
+     */
+    public List<LearnerHandler> getLearners() {
+        synchronized (learners) {
+            return new ArrayList<LearnerHandler>(learners);
+        }
+    }
+
     // list of followers that are ready to follow (i.e synced with the leader)
-    public final HashSet<LearnerHandler> forwardingFollowers =
+    private final HashSet<LearnerHandler> forwardingFollowers =
         new HashSet<LearnerHandler>();
 
-    protected final HashSet<LearnerHandler> observingLearners =
+    /**
+     * Returns a copy of the current forwarding follower snapshot
+     */
+    public List<LearnerHandler> getForwardingFollowers() {
+        synchronized (forwardingFollowers) {
+            return new ArrayList<LearnerHandler>(forwardingFollowers);
+        }
+    }
+
+    private void addForwardingFollower(LearnerHandler lh) {
+        synchronized (forwardingFollowers) {
+            forwardingFollowers.add(lh);
+        }
+    }
+
+    private final HashSet<LearnerHandler> observingLearners =
         new HashSet<LearnerHandler>();
 
-    //Pending sync requests
-    public final HashMap<Long,List<LearnerSyncRequest>> pendingSyncs =
+    /**
+     * Returns a copy of the current observer snapshot
+     */
+    public List<LearnerHandler> getObservingLearners() {
+        synchronized (observingLearners) {
+            return new ArrayList<LearnerHandler>(observingLearners);
+        }
+    }
+
+    private void addObserverLearnerHandler(LearnerHandler lh) {
+        synchronized (observingLearners) {
+            observingLearners.add(lh);
+        }
+    }
+
+    // Pending sync requests. Must access under 'this' lock.
+    private final HashMap<Long,List<LearnerSyncRequest>> pendingSyncs =
         new HashMap<Long,List<LearnerSyncRequest>>();
 
+    synchronized public int getNumPendingSyncs() {
+        return pendingSyncs.size();
+    }
+
     //Follower counter
     final AtomicLong followerCounter = new AtomicLong(-1);
+
     /**
      * Adds peer to the leader.
      *
@@ -119,6 +163,9 @@
         synchronized (learners) {
             learners.remove(peer);
         }
+        synchronized (observingLearners) {
+            observingLearners.remove(peer);
+        }
     }
 
     boolean isLearnerSynced(LearnerHandler peer){
@@ -347,8 +394,10 @@
 
                     shutdown(""Waiting for a quorum of followers, only synced with: "" + ackToString);
                     HashSet<Long> followerSet = new HashSet<Long>();
-                    for(LearnerHandler f : learners)
+
+                    for(LearnerHandler f : getLearners()) {
                         followerSet.add(f.getSid());
+                    }
 
                     if (self.getQuorumVerifier().containsQuorum(followerSet)) {
                     //if (followers.size() >= self.quorumPeers.size() / 2) {
@@ -384,16 +433,16 @@
 
                 // lock on the followers when we use it.
                 syncedSet.add(self.getId());
-                synchronized (learners) {
-                    for (LearnerHandler f : learners) {
-                        // Synced set is used to check we have a supporting quorum, so only
-                        // PARTICIPANT, not OBSERVER, learners should be used
-                        if (f.synced() && f.getLearnerType() == LearnerType.PARTICIPANT) {
-                            syncedSet.add(f.getSid());
-                        }
-                        f.ping();
+
+                for (LearnerHandler f : getLearners()) {
+                    // Synced set is used to check we have a supporting quorum, so only
+                    // PARTICIPANT, not OBSERVER, learners should be used
+                    if (f.synced() && f.getLearnerType() == LearnerType.PARTICIPANT) {
+                        syncedSet.add(f.getSid());
                     }
+                    f.ping();
                 }
+
               if (!tickSkip && !self.getQuorumVerifier().containsQuorum(syncedSet)) {
                 //if (!tickSkip && syncedCount < self.quorumPeers.size() / 2) {
                     // Lost quorum, shutdown
@@ -602,10 +651,8 @@
      * send a packet to all observers
      */
     void sendObserverPacket(QuorumPacket qp) {
-        synchronized(observingLearners) {
-            for (LearnerHandler f : observingLearners) {
-                f.queuePacket(qp);
-            }
+        for (LearnerHandler f : getObservingLearners()) {
+            f.queuePacket(qp);
         }
     }
 
@@ -747,13 +794,9 @@
             }
         }
         if (handler.getLearnerType() == LearnerType.PARTICIPANT) {
-            synchronized (forwardingFollowers) {
-                forwardingFollowers.add(handler);
-            }
+            addForwardingFollower(handler);
         } else {
-            synchronized (observingLearners) {
-                observingLearners.add(handler);
-            }
+            addObserverLearnerHandler(handler);
         }
 
         return lastProposed;
"
zookeeper,257a00aa97cd21c967ad620c3119a86295f1b794,ZOOKEEPER-1361. Leader.lead iterates over 'learners' set without proper synchronisation (henryr via camille),2012.02.27 11:41:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderBean.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderBean.java
index 921b002..b5a3a10 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderBean.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderBean.java
@@ -44,7 +44,7 @@
     
     public String followerInfo() {
         StringBuilder sb = new StringBuilder();
-        for (LearnerHandler handler : leader.learners) {
+        for (LearnerHandler handler : leader.getLearners()) {
             sb.append(handler.toString()).append(""\n"");
         }
         return sb.toString();
"
zookeeper,257a00aa97cd21c967ad620c3119a86295f1b794,ZOOKEEPER-1361. Leader.lead iterates over 'learners' set without proper synchronisation (henryr via camille),2012.02.27 11:41:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 87620ed..21cd1eb 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -852,12 +852,8 @@
         List<String> l = new ArrayList<String>();
         synchronized (this) {
             if (leader != null) {
-                synchronized (leader.learners) {
-                    for (LearnerHandler fh :
-                        leader.learners)
-                    {
-                        if (fh.getSocket() == null)
-                            continue;
+                for (LearnerHandler fh : leader.getLearners()) {
+                    if (fh.getSocket() != null) {
                         String s = fh.getSocket().getRemoteSocketAddress().toString();
                         if (leader.isLearnerSynced(fh))
                             s += ""*"";
"
zookeeper,e657907115bc2bb53c72e7c696ff949e1db21a02,ZOOKEEPER-1338. class cast exceptions may be thrown by multi ErrorResult class (invalid equals) (phunt via mahadev),2012.02.06 19:13:40,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/OpResult.java b/src/java/main/org/apache/zookeeper/OpResult.java
index 514318f..45331d1 100644
--- a/src/java/main/org/apache/zookeeper/OpResult.java
+++ b/src/java/main/org/apache/zookeeper/OpResult.java
@@ -23,7 +23,7 @@
 /**
  * Encodes the result of a single part of a multiple operation commit.
  */
-public class OpResult {
+public abstract class OpResult {
     private int type;
 
     private OpResult(int type) {
@@ -61,10 +61,10 @@
         @Override
         public boolean equals(Object o) {
             if (this == o) return true;
-            if (!(o instanceof OpResult)) return false;
+            if (!(o instanceof CreateResult)) return false;
 
             CreateResult other = (CreateResult) o;
-            return getType() == other.getType() && path.equals(other.path);
+            return getType() == other.getType() && path.equals(other.getPath());
         }
 
         @Override
@@ -84,9 +84,9 @@
         @Override
         public boolean equals(Object o) {
             if (this == o) return true;
-            if (!(o instanceof OpResult)) return false;
+            if (!(o instanceof DeleteResult)) return false;
 
-            OpResult opResult = (OpResult) o;
+            DeleteResult opResult = (DeleteResult) o;
             return getType() == opResult.getType();
         }
 
@@ -115,7 +115,7 @@
         @Override
         public boolean equals(Object o) {
             if (this == o) return true;
-            if (!(o instanceof OpResult)) return false;
+            if (!(o instanceof SetDataResult)) return false;
 
             SetDataResult other = (SetDataResult) o;
             return getType() == other.getType() && stat.getMzxid() == other.stat.getMzxid();
@@ -138,7 +138,7 @@
         @Override
         public boolean equals(Object o) {
             if (this == o) return true;
-            if (!(o instanceof OpResult)) return false;
+            if (!(o instanceof CheckResult)) return false;
 
             CheckResult other = (CheckResult) o;
             return getType() == other.getType();
@@ -171,7 +171,7 @@
         @Override
         public boolean equals(Object o) {
             if (this == o) return true;
-            if (!(o instanceof OpResult)) return false;
+            if (!(o instanceof ErrorResult)) return false;
 
             ErrorResult other = (ErrorResult) o;
             return getType() == other.getType() && err == other.getErr();
"
zookeeper,477ebb005617d6bd9862aea59e84e85c5b4fbacf,ZOOKEEPER-1340. multi problem - typical user operations are generating ERROR level messages in the server (phunt via mahadev),2012.02.06 18:39:15,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 208d4bf..6df0b28 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -849,10 +849,10 @@
                     break;
             }
         } catch (KeeperException e) {
-             LOG.warn(""Failed: "" + debug, e);
-             rc.err = e.code().intValue();
+            LOG.debug(""Failed: "" + debug, e);
+            rc.err = e.code().intValue();
         } catch (IOException e) {
-            LOG.warn(""Failed:"" + debug, e);
+            LOG.debug(""Failed:"" + debug, e);
         }
         /*
          * A snapshot might be in progress while we are modifying the data
"
zookeeper,477ebb005617d6bd9862aea59e84e85c5b4fbacf,ZOOKEEPER-1340. multi problem - typical user operations are generating ERROR level messages in the server (phunt via mahadev),2012.02.06 18:39:15,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 871bd17..1d3c2d6 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -542,11 +542,12 @@
                             ke = e;
                             type = OpCode.error;
                             txn = new ErrorTxn(e.code().intValue());
-                            LOG.error("">>>> Got user-level KeeperException when processing ""
-                                    + request.toString()
+
+                            LOG.info(""Got user-level KeeperException when processing ""
+                                    + request.toString() + "" aborting remaining multi ops.""
                                     + "" Error Path:"" + e.getPath()
                                     + "" Error:"" + e.getMessage());
-                            LOG.error("">>>> ABORTING remaing MultiOp ops"");
+
                             request.setException(e);
 
                             /* Rollback change records from failed multi-op */
"
zookeeper,6465986efec9588492f55081778c6b7b09a114f4,ZOOKEEPER-1327. there are still remnants of hadoop urls. (Harsh J via mahadev),2012.02.06 18:06:27,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/KerberosName.java b/src/java/main/org/apache/zookeeper/server/auth/KerberosName.java
index 0700841..f5d0eb1 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/KerberosName.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/KerberosName.java
@@ -415,4 +415,4 @@
       System.out.println(""Name: "" + name + "" to "" + name.getShortName());
     }
   }
-}
\ No newline at end of file
+}
"
zookeeper,60ff341b8b2080c6ffae5be887a3897ca201aafb,"ZOOKEEPER-1336. javadoc for multi is confusing, references functionality that doesn't seem to exist. (phunt via mahadev)",2012.02.06 17:56:11,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/KeeperException.java b/src/java/main/org/apache/zookeeper/KeeperException.java
index 7c10d2c..2664411 100644
--- a/src/java/main/org/apache/zookeeper/KeeperException.java
+++ b/src/java/main/org/apache/zookeeper/KeeperException.java
@@ -482,6 +482,9 @@
      * If this exception was thrown by a multi-request then the (partial) results
      * and error codes can be retrieved using this getter.
      * @return A copy of the list of results from the operations in the multi-request.
+     * 
+     * @since 3.4.0
+     *
      */
     public List<OpResult> getResults() {
         return results != null ? new ArrayList<OpResult>(results) : null;
"
zookeeper,60ff341b8b2080c6ffae5be887a3897ca201aafb,"ZOOKEEPER-1336. javadoc for multi is confusing, references functionality that doesn't seem to exist. (phunt via mahadev)",2012.02.06 17:56:11,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/Transaction.java b/src/java/main/org/apache/zookeeper/Transaction.java
index b8dc660..c58e732 100644
--- a/src/java/main/org/apache/zookeeper/Transaction.java
+++ b/src/java/main/org/apache/zookeeper/Transaction.java
@@ -24,6 +24,9 @@
 /**
  * Provides a builder style interface for doing multiple updates.  This is
  * really just a thin layer on top of Zookeeper.multi().
+ *
+ * @since 3.4.0
+ *
  */
 public class Transaction {
     private ZooKeeper zk;
"
zookeeper,60ff341b8b2080c6ffae5be887a3897ca201aafb,"ZOOKEEPER-1336. javadoc for multi is confusing, references functionality that doesn't seem to exist. (phunt via mahadev)",2012.02.06 17:56:11,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index e82eaa0..9fe7652 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -871,22 +871,31 @@
     }
 
     /**
-     * Executes multiple Zookeeper operations or none of them.  On success, a list of results is returned.
-     * On failure, only a single exception is returned.  If you want more details, it may be preferable to
-     * use the alternative form of this method that lets you pass a list into which individual results are
-     * placed so that you can zero in on exactly which operation failed and why.
+     * Executes multiple ZooKeeper operations or none of them.
      * <p>
-     * The maximum allowable size of all of the data arrays in all of the setData operations in this single
-     * request is 1 MB (1,048,576 bytes).
-     * Requests larger than this will cause a KeeperExecption to be thrown.
-     * @param ops  An iterable that contains the operations to be done.  These should be created using the
-     * factory methods on Op.
-     * @see Op
-     * @return A list of results.
-     * @throws InterruptedException  If the operation was interrupted.  The operation may or may not have succeeded, but
-     * will not have partially succeeded if this exception is thrown.
-     * @throws KeeperException If the operation could not be completed due to some error in doing one of the specified
-     * ops.
+     * On success, a list of results is returned.
+     * On failure, an exception is raised which contains partial results and
+     * error details, see {@link KeeperException#getResults}
+     * <p>
+     * Note: The maximum allowable size of all of the data arrays in all of
+     * the setData operations in this single request is typically 1 MB
+     * (1,048,576 bytes). This limit is specified on the server via
+     * <a href=""http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#Unsafe+Options"">jute.maxbuffer</a>.
+     * Requests larger than this will cause a KeeperException to be
+     * thrown.
+     *
+     * @param ops An iterable that contains the operations to be done.
+     * These should be created using the factory methods on {@link Op}.
+     * @return A list of results, one for each input Op, the order of
+     * which exactly matches the order of the <code>ops</code> input
+     * operations.
+     * @throws InterruptedException If the operation was interrupted.
+     * The operation may or may not have succeeded, but will not have
+     * partially succeeded if this exception is thrown.
+     * @throws KeeperException If the operation could not be completed
+     * due to some error in doing one of the specified ops.
+     *
+     * @since 3.4.0
      */
     public List<OpResult> multi(Iterable<Op> ops) throws InterruptedException, KeeperException {
         return multiInternal(new MultiTransactionRecord(ops));
@@ -921,6 +930,15 @@
         return results;
     }
 
+    /**
+     * A Transaction is a thin wrapper on the {@link #multi} method
+     * which provides a builder object that can be used to construct
+     * and commit an atomic set of operations.
+     *
+     * @since 3.4.0
+     *
+     * @return a Transaction builder object
+     */
     public Transaction transaction() {
         return new Transaction(this);
     }
"
zookeeper,f910c936e37505a31ed8c140daa5bbee448c444f,ZOOKEEPER-1373. Hardcoded SASL login context name clashes with Hadoop security  configuration override. (Eugene Koontz and Thomas Weise via mahadev),2012.02.06 17:34:22,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 6c25e40..553bd58 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -941,20 +941,14 @@
 
             setName(getName().replaceAll(""\\(.*\\)"",
                     ""("" + addr.getHostName() + "":"" + addr.getPort() + "")""));
-
-            if (System.getProperty(""java.security.auth.login.config"") != null) {
-                try {
-                    zooKeeperSaslClient = new ZooKeeperSaslClient(ClientCnxn.this, ""zookeeper""+""/""+ addr.getHostName());
-                }
-                catch (LoginException e) {
-                    LOG.warn(""Zookeeper client cannot authenticate using the Client section of the supplied ""
-                      + ""configuration file: '"" + System.getProperty(""java.security.auth.login.config"")
-                      + ""'. Will continue connection to Zookeeper server without SASL authentication, if Zookeeper ""
-                      + ""server allows it."");
-                    eventThread.queueEvent(new WatchedEvent(
-                            Watcher.Event.EventType.None,
-                            KeeperState.AuthFailed, null));
-                }
+            try {
+                zooKeeperSaslClient = new ZooKeeperSaslClient(""zookeeper/""+addr.getHostName());
+            } catch (LoginException e) {
+                LOG.warn(""SASL authentication failed: "" + e + "" Will continue connection to Zookeeper server without ""
+                        + ""SASL authentication, if Zookeeper server allows it."");
+                eventThread.queueEvent(new WatchedEvent(
+                        Watcher.Event.EventType.None,
+                        Watcher.Event.KeeperState.AuthFailed, null));
             }
             clientCnxnSocket.connect(addr);
         }
@@ -981,9 +975,9 @@
                     }
 
                     if (state.isConnected()) {
-                        if ((zooKeeperSaslClient != null) && (zooKeeperSaslClient.isComplete() != true)) {
+                        if ((zooKeeperSaslClient != null) && (zooKeeperSaslClient.isFailed() != true) && (zooKeeperSaslClient.isComplete() != true)) {
                             try {
-                                zooKeeperSaslClient.initialize();
+                                zooKeeperSaslClient.initialize(ClientCnxn.this);
                             }
                             catch (SaslException e) {
                                 LOG.error(""SASL authentication with Zookeeper Quorum member failed: "" + e);
"
zookeeper,f910c936e37505a31ed8c140daa5bbee448c444f,ZOOKEEPER-1373. Hardcoded SASL login context name clashes with Hadoop security  configuration override. (Eugene Koontz and Thomas Weise via mahadev),2012.02.06 17:34:22,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/Login.java b/src/java/main/org/apache/zookeeper/Login.java
index 6d2a38c..32f00bc 100644
--- a/src/java/main/org/apache/zookeeper/Login.java
+++ b/src/java/main/org/apache/zookeeper/Login.java
@@ -33,7 +33,7 @@
 import javax.security.auth.callback.CallbackHandler;
 
 import org.apache.log4j.Logger;
-
+import org.apache.zookeeper.client.ZooKeeperSaslClient;
 import javax.security.auth.kerberos.KerberosTicket;
 import javax.security.auth.Subject;
 import java.util.Date;
@@ -273,7 +273,10 @@
     private synchronized LoginContext login(final String loginContextName) throws LoginException {
         if (loginContextName == null) {
             throw new LoginException(""loginContext name (JAAS file section header) was null. "" +
-                    ""Please check your java.security.login.auth.config setting."");
+                    ""Please check your java.security.login.auth.config (="" +
+                    System.getProperty(""java.security.login.auth.config"") +
+                    "") and your "" + ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY + ""(="" + 
+                    System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, ""Client"") + "")"");
         }
         LoginContext loginContext = new LoginContext(loginContextName,callbackHandler);
         loginContext.login();
"
zookeeper,f910c936e37505a31ed8c140daa5bbee448c444f,ZOOKEEPER-1373. Hardcoded SASL login context name clashes with Hadoop security  configuration override. (Eugene Koontz and Thomas Weise via mahadev),2012.02.06 17:34:22,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index 722538e..18f18e3 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -21,12 +21,12 @@
 import org.apache.zookeeper.AsyncCallback;
 import org.apache.zookeeper.ClientCnxn;
 import org.apache.zookeeper.Login;
+import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.proto.GetSASLRequest;
 import org.apache.zookeeper.proto.ReplyHeader;
 import org.apache.zookeeper.proto.RequestHeader;
 import org.apache.zookeeper.proto.SetSASLResponse;
-import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.server.auth.KerberosName;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -40,6 +40,8 @@
 import javax.security.auth.callback.NameCallback;
 import javax.security.auth.callback.PasswordCallback;
 import javax.security.auth.callback.UnsupportedCallbackException;
+import javax.security.auth.login.AppConfigurationEntry;
+import javax.security.auth.login.Configuration;
 import javax.security.auth.login.LoginException;
 import javax.security.sasl.AuthorizeCallback;
 import javax.security.sasl.RealmCallback;
@@ -52,12 +54,12 @@
  * allows ClientCnxn to authenticate using SASL with a Zookeeper server.
  */
 public class ZooKeeperSaslClient {
+    public static final String LOGIN_CONTEXT_NAME_KEY = ""zookeeper.sasl.clientconfig"";
     private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperSaslClient.class);
     private static Login login = null;
     private SaslClient saslClient;
 
     private byte[] saslToken = new byte[0];
-    private ClientCnxn cnxn;
 
     public enum SaslState {
         INITIAL,INTERMEDIATE,COMPLETE,FAILED
@@ -69,15 +71,87 @@
         return saslState;
     }
 
-    public ZooKeeperSaslClient(ClientCnxn cnxn, String serverPrincipal) throws LoginException {
-        this.cnxn = cnxn;
-        this.saslClient = createSaslClient(serverPrincipal);
+    private String loginContext;
+
+    public String getLoginContext() {
+      return loginContext;
+    }
+
+    public ZooKeeperSaslClient(final String serverPrincipal)
+            throws LoginException {
+        /**
+         * ZOOKEEPER-1373: allow system property to specify the JAAS
+         * configuration section that the zookeeper client should use.
+         * Default to ""Client"".
+         */
+        String clientSection = System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, ""Client"");
+        // Note that 'Configuration' here refers to javax.security.auth.login.Configuration.
+        AppConfigurationEntry entries[] = null;
+        SecurityException securityException = null;
+        try {
+            entries = Configuration.getConfiguration().getAppConfigurationEntry(clientSection);
+        } catch (SecurityException e) {
+            // handle below: might be harmless if the user doesn't intend to use JAAS authentication.
+            securityException = e;
+        }
+        if (entries != null) {
+            LOG.info(""Found Login Context section '"" + clientSection + ""': will use it to attempt to SASL-authenticate."");
+            this.saslClient = createSaslClient(serverPrincipal, clientSection);
+        } else {
+            // Handle situation of clientSection's being null: it might simply because the client does not intend to 
+            // use SASL, so not necessarily an error.
+            saslState = SaslState.FAILED;
+            String explicitClientSection = System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY);
+            if (explicitClientSection != null) {
+                // If the user explicitly overrides the default Login Context, they probably expected SASL to
+                // succeed. But if we got here, SASL failed.
+                if (securityException != null) {
+                    throw new LoginException(""Zookeeper client cannot authenticate using the "" + explicitClientSection +
+                            "" section of the supplied JAAS configuration: '"" +
+                            System.getProperty(""java.security.auth.login.config"") + ""' because of a "" +
+                            ""SecurityException: "" + securityException);
+                    
+                    
+                } else {
+                    throw new LoginException(""Client cannot SASL-authenticate because the specified JAAS configuration "" +
+                            ""section '"" + explicitClientSection + ""' could not be found."");
+                }
+            } else {
+                // The user did not override the default context. It might be that they just don't intend to use SASL,
+                // so log at INFO, not WARN, since they don't expect any SASL-related information.
+                if (securityException != null) {
+                    LOG.warn(""SecurityException: "" + securityException + "" occurred when trying to find JAAS configuration."");
+                }
+                LOG.info(""Client will not SASL-authenticate because the default JAAS configuration section 'Client' "" +
+                        ""could not be found. If you are not using SASL, you may ignore this. On the other hand, "" +
+                        ""if you expected SASL to work, please fix your JAAS configuration."");
+            }
+            if (System.getProperty(""java.security.auth.login.config"")  != null) {
+                // Again, the user explicitly set something SASL-related, so they probably expected SASL to succeed.
+                if (securityException != null) {
+                    throw new LoginException(""Zookeeper client cannot authenticate using the '"" +
+                            System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, ""Client"") +
+                            ""' section of the supplied JAAS configuration: '"" +
+                            System.getProperty(""java.security.auth.login.config"") + ""' because of a "" +
+                            ""SecurityException: "" + securityException);
+                } else {
+                    throw new LoginException(""No JAAS configuration section named '"" +
+                            System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, ""Client"") +
+                            ""' was found in specified JAAS configuration file: '"" +
+                            System.getProperty(""java.security.auth.login.config"") + ""'."");
+                }
+            }
+        }
     }
 
     public boolean isComplete() {
         return (saslState == SaslState.COMPLETE);
     }
 
+    public boolean isFailed() {
+        return (saslState == SaslState.FAILED);
+    }
+
     public static class ServerSaslResponseCallback implements AsyncCallback.DataCallback {
         public void processResult(int rc, String path, Object ctx, byte data[], Stat stat) {
             // processResult() is used by ClientCnxn's sendThread to respond to
@@ -97,16 +171,21 @@
                 usedata = new byte[0];
                 LOG.debug(""ServerSaslResponseCallback(): using empty data[] as server response (length=""+usedata.length+"")"");
             }
-            client.prepareSaslResponseToServer(usedata);
+            client.prepareSaslResponseToServer(usedata, (ClientCnxn)ctx);
         }
     }
 
-    synchronized private SaslClient createSaslClient(final String servicePrincipal) throws LoginException {
+    synchronized private SaslClient createSaslClient(final String servicePrincipal,
+                                                     final String loginContext) throws LoginException {
         try {
             if (login == null) {
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""JAAS loginContext is: "" + loginContext);
+                }
+                this.loginContext = loginContext;
                 // note that the login object is static: it's shared amongst all zookeeper-related connections.
                 // createSaslClient() must be declared synchronized so that login is initialized only once.
-                login = new Login(""Client"",new ClientCallbackHandler(null));
+                login = new Login(loginContext, new ClientCallbackHandler(null));
                 login.startThreadIfNeeded();
             }
             Subject subject = login.getSubject();
@@ -163,7 +242,7 @@
         }
     }
 
-    private void prepareSaslResponseToServer(byte[] serverToken) {
+    private void prepareSaslResponseToServer(byte[] serverToken, ClientCnxn cnxn) {
         saslToken = serverToken;
 
         if (saslClient == null) {
@@ -177,16 +256,17 @@
                 saslToken = createSaslToken(saslToken);
                 if (saslToken != null) {
                     LOG.debug(""saslToken (client) length: "" + saslToken.length);
-                    queueSaslPacket(saslToken);
+                    queueSaslPacket(saslToken, cnxn);
                 }
             } catch (SaslException e) {
-                LOG.error(""SASL authentication failed."");
+                LOG.error(""SASL authentication failed using login context '"" +
+                this.getLoginContext() + ""'."");
                 saslState = SaslState.FAILED;
             }
         }
     }
 
-    public byte[] createSaslToken() throws SaslException {
+    private byte[] createSaslToken() throws SaslException {
         saslState = SaslState.INTERMEDIATE;
         return createSaslToken(saslToken);
     }
@@ -234,7 +314,7 @@
         }
     }
 
-    public void queueSaslPacket(byte[] saslToken) {
+    private void queueSaslPacket(byte[] saslToken, ClientCnxn cnxn) {
         LOG.debug(""ClientCnxn:sendSaslPacket:length=""+saslToken.length);
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.sasl);
@@ -245,9 +325,9 @@
         ReplyHeader r = new ReplyHeader();
         cnxn.queuePacket(h,r,request,response,cb);
     }
-
-    public void queueSaslPacket() throws SaslException {
-        queueSaslPacket(createSaslToken());
+    
+    private void queueSaslPacket(ClientCnxn cnxn) throws SaslException {
+        queueSaslPacket(createSaslToken(), cnxn);
     }
 
     // used by ClientCnxn to know when to emit SaslAuthenticated event.
@@ -268,17 +348,17 @@
         return false;
     }
 
-    public void initialize() throws SaslException {
+    public void initialize(ClientCnxn cnxn) throws SaslException {
         if (saslClient == null) {
             throw new SaslException(""saslClient failed to initialize properly: it's null."");
         }
         if (saslState == SaslState.INITIAL) {
             if (saslClient.hasInitialResponse()) {
-                queueSaslPacket();
+                queueSaslPacket(cnxn);
             }
             else {
                 byte[] emptyToken = new byte[0];
-                queueSaslPacket(emptyToken);
+                queueSaslPacket(emptyToken, cnxn);
             }
             saslState = SaslState.INTERMEDIATE;
         }
"
zookeeper,73af50a8a91cee9d3d95a373df7ecb12825f5545,ZOOKEEPER-1367. Data inconsistencies and unexpired ephemeral nodes after cluster restart. (Benjamin Reed via mahadev),2012.01.31 15:45:45,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index 9721f7c..ab517da 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -54,6 +54,7 @@
 import org.apache.zookeeper.server.ZooKeeperServer.ChangeRecord;
 import org.apache.zookeeper.txn.CreateSessionTxn;
 import org.apache.zookeeper.txn.ErrorTxn;
+import org.apache.zookeeper.txn.TxnHeader;
 
 import org.apache.zookeeper.OpResult;
 import org.apache.zookeeper.OpResult.CheckResult;
@@ -107,20 +108,10 @@
                 }
             }
             if (request.getHdr() != null) {
-                rc = zks.getZKDatabase().processTxn(request.getHdr(), request.getTxn());
-                if (request.type == OpCode.createSession) {
-                    if (request.getTxn() instanceof CreateSessionTxn) {
-                        CreateSessionTxn cst = (CreateSessionTxn) request.getTxn();
-                        zks.sessionTracker.addSession(request.sessionId, cst
-                                .getTimeOut());
-                    } else {
-                        LOG.warn(""*****>>>>> Got ""
-                                + request.getTxn().getClass() + "" ""
-                                + request.getTxn().toString());
-                    }
-                } else if (request.type == OpCode.closeSession) {
-                    zks.sessionTracker.removeSession(request.sessionId);
-                }
+                TxnHeader hdr = request.getHdr();
+                Record txn = request.getTxn();
+                
+                rc = zks.processTxn(hdr, txn);
             }
             // do not add non quorum packets to the queue.
             if (Request.isQuorum(request.type)) {
"
zookeeper,73af50a8a91cee9d3d95a373df7ecb12825f5545,ZOOKEEPER-1367. Data inconsistencies and unexpired ephemeral nodes after cluster restart. (Benjamin Reed via mahadev),2012.01.31 15:45:45,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 14f8c8f..5dc97bf 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -53,6 +53,7 @@
 import org.apache.zookeeper.proto.ReplyHeader;
 import org.apache.zookeeper.proto.RequestHeader;
 import org.apache.zookeeper.proto.SetSASLResponse;
+import org.apache.zookeeper.server.DataTree.ProcessTxnResult;
 import org.apache.zookeeper.server.ServerCnxn.CloseRequestException;
 import org.apache.zookeeper.server.SessionTracker.Session;
 import org.apache.zookeeper.server.SessionTracker.SessionExpirer;
@@ -60,6 +61,9 @@
 import org.apache.zookeeper.server.auth.ProviderRegistry;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
 import org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer;
+import org.apache.zookeeper.txn.CreateSessionTxn;
+import org.apache.zookeeper.txn.TxnHeader;
+
 import javax.security.sasl.SaslException;
 
 /**
@@ -87,7 +91,6 @@
     protected int maxSessionTimeout = -1;
     protected SessionTracker sessionTracker;
     private FileTxnSnapLog txnLogFactory = null;
-    private ConcurrentHashMap<Long, Integer> sessionsWithTimeouts;
     private ZKDatabase zkDb;
     protected long hzxid = 0;
     public final static Exception ok = new Exception(""No prob"");
@@ -228,8 +231,7 @@
         // Clean up dead sessions
         LinkedList<Long> deadSessions = new LinkedList<Long>();
         for (Long session : zkDb.getSessions()) {
-            sessionsWithTimeouts = zkDb.getSessionWithTimeOuts();
-            if (sessionsWithTimeouts.get(session) == null) {
+            if (zkDb.getSessionWithTimeOuts().get(session) == null) {
                 deadSessions.add(session);
             }
         }
@@ -357,7 +359,10 @@
     }
 
     public void startup() {
-        createSessionTracker();
+        if (sessionTracker == null) {
+            createSessionTracker();
+        }
+        startSessionTracker();
         setupRequestProcessors();
 
         registerJMX();
@@ -380,6 +385,9 @@
     protected void createSessionTracker() {
         sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(),
                 tickTime, 1);
+    }
+    
+    protected void startSessionTracker() {
         ((SessionTrackerImpl)sessionTracker).start();
     }
 
@@ -918,4 +926,26 @@
         // wrap SASL response token to client inside a Response object.
         return new SetSASLResponse(responseToken);
     }
+    
+    public ProcessTxnResult processTxn(TxnHeader hdr, Record txn) {
+        ProcessTxnResult rc;
+        int opCode = hdr.getType();
+        long sessionId = hdr.getClientId();
+        rc = getZKDatabase().processTxn(hdr, txn);
+        if (opCode == OpCode.createSession) {
+            if (txn instanceof CreateSessionTxn) {
+                CreateSessionTxn cst = (CreateSessionTxn) txn;
+                sessionTracker.addSession(sessionId, cst
+                        .getTimeOut());
+            } else {
+                LOG.warn(""*****>>>>> Got ""
+                        + txn.getClass() + "" ""
+                        + txn.toString());
+            }
+        } else if (opCode == OpCode.closeSession) {
+            sessionTracker.removeSession(sessionId);
+        }
+        return rc;
+    }
+
 }
"
zookeeper,73af50a8a91cee9d3d95a373df7ecb12825f5545,ZOOKEEPER-1367. Data inconsistencies and unexpired ephemeral nodes after cluster restart. (Benjamin Reed via mahadev),2012.01.31 15:45:45,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
index 0b5d400..1d3704b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
@@ -74,9 +74,13 @@
     }
 
     @Override
-    protected void createSessionTracker() {
+    public void createSessionTracker() {
         sessionTracker = new SessionTrackerImpl(this, getZKDatabase().getSessionWithTimeOuts(),
                 tickTime, self.getId());
+    }
+    
+    @Override
+    protected void startSessionTracker() {
         ((SessionTrackerImpl)sessionTracker).start();
     }
 
"
zookeeper,73af50a8a91cee9d3d95a373df7ecb12825f5545,ZOOKEEPER-1367. Data inconsistencies and unexpired ephemeral nodes after cluster restart. (Benjamin Reed via mahadev),2012.01.31 15:45:45,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index f4a7731..e8d548b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -352,7 +352,8 @@
 
             }
             zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());
-                        
+            zk.createSessionTracker();            
+            
             long lastQueued = 0;
 
             // in V1.0 we take a snapshot when we get the NEWLEADER message, but in pre V1.0
@@ -383,7 +384,7 @@
                         if (pif.hdr.getZxid() != qp.getZxid()) {
                             LOG.warn(""Committing "" + qp.getZxid() + "", but next proposal is "" + pif.hdr.getZxid());
                         } else {
-                            zk.getZKDatabase().processTxn(pif.hdr, pif.rec);
+                            zk.processTxn(pif.hdr, pif.rec);
                             packetsNotCommitted.remove();
                         }
                     } else {
@@ -393,7 +394,7 @@
                 case Leader.INFORM:
                     TxnHeader hdr = new TxnHeader();
                     Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);
-                    zk.getZKDatabase().processTxn(hdr, txn);
+                    zk.processTxn(hdr, txn);
                     break;
                 case Leader.UPTODATE:
                     if (!snapshotTaken) { // true for the pre v1.0 case
"
zookeeper,73af50a8a91cee9d3d95a373df7ecb12825f5545,ZOOKEEPER-1367. Data inconsistencies and unexpired ephemeral nodes after cluster restart. (Benjamin Reed via mahadev),2012.01.31 15:45:45,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java
index 6f1ac47..1ff94c3 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java
@@ -69,12 +69,15 @@
     }    
     
     @Override
-    protected void createSessionTracker() {
+    public void createSessionTracker() {
         sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(),
                 self.getId());
     }
     
     @Override
+    protected void startSessionTracker() {}
+    
+    @Override
     protected void revalidateSession(ServerCnxn cnxn, long sessionId,
             int sessionTimeout) throws IOException {
         getLearner().validateSession(cnxn, sessionId, sessionTimeout);
"
zookeeper,568940921eb9c79e7f99d096970521c96cdf5588,ZOOKEEPER-973. bind() could fail on Leader because it does not setReuseAddress on its ServerSocket (Harsh J via phunt),2012.01.24 05:32:03,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 27a5d20..b1de09c 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -21,6 +21,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.net.BindException;
+import java.net.InetSocketAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketAddress;
@@ -131,7 +132,9 @@
     Leader(QuorumPeer self,LeaderZooKeeperServer zk) throws IOException {
         this.self = self;
         try {
-            ss = new ServerSocket(self.getQuorumAddress().getPort());
+            ss = new ServerSocket();
+            ss.setReuseAddress(true);
+            ss.bind(new InetSocketAddress(self.getQuorumAddress().getPort()));
         } catch (BindException e) {
             LOG.error(""Couldn't bind to port ""
                     + self.getQuorumAddress().getPort(), e);
"
zookeeper,06f28609b0c6b206d3b5dcb48895aad98607ddce,ZOOKEEPER-1294. One of the zookeeper server is not accepting any requests (Kavita Sharma via henryr),2012.01.14 08:28:41,Henry Robinson,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 466fb52..27a5d20 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -308,7 +308,7 @@
             cnxAcceptor.setName(""LearnerCnxAcceptor-"" + ss.getLocalSocketAddress());
             cnxAcceptor.start();
 
-            long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());            
+            long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());
 
             zk.setZxid(ZxidUtils.makeZxid(epoch, 0));
 
@@ -377,15 +377,15 @@
                 if (!tickSkip) {
                     self.tick++;
                 }
-                int syncedCount = 0;
                 HashSet<Long> syncedSet = new HashSet<Long>();
 
                 // lock on the followers when we use it.
                 syncedSet.add(self.getId());
                 synchronized (learners) {
                     for (LearnerHandler f : learners) {
-                        if (f.synced()) {
-                            syncedCount++;
+                        // Synced set is used to check we have a supporting quorum, so only
+                        // PARTICIPANT, not OBSERVER, learners should be used
+                        if (f.synced() && f.getLearnerType() == LearnerType.PARTICIPANT) {
                             syncedSet.add(f.getSid());
                         }
                         f.ping();
@@ -395,7 +395,7 @@
                 //if (!tickSkip && syncedCount < self.quorumPeers.size() / 2) {
                     // Lost quorum, shutdown
                   // TODO: message is wrong unless majority quorums used
-                    shutdown(""Only "" + syncedCount + "" followers, need ""
+                    shutdown(""Only "" + syncedSet.size() + "" followers, need ""
                             + (self.getVotingView().size() / 2));
                     // make sure the order is the same!
                     // the leader goes to looking
@@ -770,7 +770,7 @@
             }
             connectingFollowers.add(sid);
             QuorumVerifier verifier = self.getQuorumVerifier();
-            if (connectingFollowers.contains(self.getId()) && 
+            if (connectingFollowers.contains(self.getId()) &&
                                             verifier.containsQuorum(connectingFollowers)) {
                 waitingForNewEpoch = false;
                 self.setAcceptedEpoch(epoch);
"
zookeeper,1a556bd13b9a1e250ec2279fb3ba92dc9ba2d69c,ZOOKEEPER-1343. getEpochToPropose should check if lastAcceptedEpoch is greater or equal than epoch,2012.01.04 09:15:03,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 1af2f03..5c0c661 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -410,7 +410,7 @@
         }
     }
 
-	boolean isShutdown;
+    boolean isShutdown;
 
     /**
      * Close down all the LearnerHandlers
@@ -762,54 +762,54 @@
     }
 
     private final HashSet<Long> connectingFollowers = new HashSet<Long>();
-	public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException {
-		synchronized(connectingFollowers) {
-			if (!waitingForNewEpoch) {
-				return epoch;
-			}
-			if (lastAcceptedEpoch > epoch) {
-				epoch = lastAcceptedEpoch+1;
-			}
-			connectingFollowers.add(sid);
-			QuorumVerifier verifier = self.getQuorumVerifier();
-			if (connectingFollowers.contains(self.getId()) && verifier.containsQuorum(connectingFollowers)) 
-{
-				waitingForNewEpoch = false;
-				self.setAcceptedEpoch(epoch);
-				connectingFollowers.notifyAll();
-			} else {
-                   long start = System.currentTimeMillis();
-                   long cur = start;
+    public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException {
+        synchronized(connectingFollowers) {
+            if (!waitingForNewEpoch) {
+                return epoch;
+            }
+            if (lastAcceptedEpoch >= epoch) {
+                epoch = lastAcceptedEpoch+1;
+            }
+            connectingFollowers.add(sid);
+            QuorumVerifier verifier = self.getQuorumVerifier();
+            if (connectingFollowers.contains(self.getId()) && 
+                                            verifier.containsQuorum(connectingFollowers)) {
+                waitingForNewEpoch = false;
+                self.setAcceptedEpoch(epoch);
+                connectingFollowers.notifyAll();
+            } else {
+                long start = System.currentTimeMillis();
+                long cur = start;
                 long end = start + self.getInitLimit()*self.getTickTime();
                 while(waitingForNewEpoch && cur < end) {
                     connectingFollowers.wait(end - cur);
                     cur = System.currentTimeMillis();
                 }
-				if (waitingForNewEpoch) {
+                if (waitingForNewEpoch) {
                     throw new InterruptedException(""Timeout while waiting for epoch from quorum"");
-				}
-			}
-			return epoch;
-		}
-	}
+                }
+            }
+            return epoch;
+        }
+    }
 
-	private final HashSet<Long> electingFollowers = new HashSet<Long>();
-	private boolean electionFinished = false;
-	public void waitForEpochAck(long id, StateSummary ss) throws IOException, InterruptedException {
-		synchronized(electingFollowers) {
-			if (electionFinished) {
-				return;
-			}
-			if (ss.getCurrentEpoch() != -1) {
-				if (ss.isMoreRecentThan(leaderStateSummary)) {
-					throw new IOException(""Follower is ahead of the leader"");
-				}
-				electingFollowers.add(id);
-			}
-			QuorumVerifier verifier = self.getQuorumVerifier();
-			if (electingFollowers.contains(self.getId()) && verifier.containsQuorum(electingFollowers)) {
-				electionFinished = true;
-				electingFollowers.notifyAll();
+    private final HashSet<Long> electingFollowers = new HashSet<Long>();
+    private boolean electionFinished = false;
+    public void waitForEpochAck(long id, StateSummary ss) throws IOException, InterruptedException {
+        synchronized(electingFollowers) {
+            if (electionFinished) {
+                return;
+            }
+            if (ss.getCurrentEpoch() != -1) {
+                if (ss.isMoreRecentThan(leaderStateSummary)) {
+                    throw new IOException(""Follower is ahead of the leader"");
+                }
+                electingFollowers.add(id);
+            }
+            QuorumVerifier verifier = self.getQuorumVerifier();
+            if (electingFollowers.contains(self.getId()) && verifier.containsQuorum(electingFollowers)) {
+                electionFinished = true;
+                electingFollowers.notifyAll();
             } else {
                 long start = System.currentTimeMillis();
                 long cur = start;
@@ -820,8 +820,8 @@
                 }
                 if (!electionFinished) {
                     throw new InterruptedException(""Timeout while waiting for epoch to be acked by quorum"");
-				}
-			}
-		}
-	}
+                }
+            }
+        }
+    }
 }
"
zookeeper,00a6861f922b55cbfeec3eb928be2b57ddf99780,ZOOKEEPER-1089. zkServer.sh status does not work due to invalid option of nc (Roman Shaposhnik via phunt),2011.12.28 15:07:19,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java b/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
new file mode 100644
index 0000000..e41465a
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.client;
+
+import org.apache.log4j.Logger;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.Socket;
+
+public class FourLetterWordMain {
+    protected static final Logger LOG = Logger.getLogger(FourLetterWordMain.class);
+    
+    /**
+     * Send the 4letterword
+     * @param host the destination host
+     * @param port the destination port
+     * @param cmd the 4letterword
+     * @return server response
+     * @throws java.io.IOException
+     */
+    public static String send4LetterWord(String host, int port, String cmd)
+            throws IOException
+    {
+        LOG.info(""connecting to "" + host + "" "" + port);
+        Socket sock = new Socket(host, port);
+        BufferedReader reader = null;
+        try {
+            OutputStream outstream = sock.getOutputStream();
+            outstream.write(cmd.getBytes());
+            outstream.flush();
+            // this replicates NC - close the output stream before reading
+            sock.shutdownOutput();
+
+            reader =
+                    new BufferedReader(
+                            new InputStreamReader(sock.getInputStream()));
+            StringBuilder sb = new StringBuilder();
+            String line;
+            while((line = reader.readLine()) != null) {
+                sb.append(line + ""\n"");
+            }
+            return sb.toString();
+        } finally {
+            sock.close();
+            if (reader != null) {
+                reader.close();
+            }
+        }
+    }
+    
+    public static void main(String[] args)
+            throws IOException
+    {
+        if (args.length != 3) {
+            System.out.println(""Usage: FourLetterWordMain <host> <port> <cmd>"");
+        } else {
+            System.out.println(send4LetterWord(args[0], Integer.parseInt(args[1]), args[2]));
+        }
+    }
+}
"
zookeeper,c85f61aee240e03fdebb31ce094f5b7c07619e34,ZOOKEEPER-1333. NPE in FileTxnSnapLog when restarting a cluster. (Patrick Hunt via mahadev),2011.12.22 05:39:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index e73d1b3..208d4bf 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -20,6 +20,7 @@
 
 import java.io.IOException;
 import java.io.PrintWriter;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -30,21 +31,17 @@
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
-import java.nio.ByteBuffer;
-
 import org.apache.jute.Index;
 import org.apache.jute.InputArchive;
 import org.apache.jute.OutputArchive;
 import org.apache.jute.Record;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.KeeperException.Code;
+import org.apache.zookeeper.KeeperException.NoNodeException;
 import org.apache.zookeeper.Quotas;
 import org.apache.zookeeper.StatsTrack;
 import org.apache.zookeeper.WatchedEvent;
 import org.apache.zookeeper.Watcher;
-import org.apache.zookeeper.KeeperException.Code;
-import org.apache.zookeeper.KeeperException.NoNodeException;
 import org.apache.zookeeper.Watcher.Event;
 import org.apache.zookeeper.Watcher.Event.EventType;
 import org.apache.zookeeper.Watcher.Event.KeeperState;
@@ -54,15 +51,17 @@
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.data.StatPersisted;
+import org.apache.zookeeper.txn.CheckVersionTxn;
 import org.apache.zookeeper.txn.CreateTxn;
 import org.apache.zookeeper.txn.DeleteTxn;
 import org.apache.zookeeper.txn.ErrorTxn;
+import org.apache.zookeeper.txn.MultiTxn;
 import org.apache.zookeeper.txn.SetACLTxn;
 import org.apache.zookeeper.txn.SetDataTxn;
-import org.apache.zookeeper.txn.CheckVersionTxn;
 import org.apache.zookeeper.txn.Txn;
-import org.apache.zookeeper.txn.MultiTxn;
 import org.apache.zookeeper.txn.TxnHeader;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * This class maintains the tree data structure. It doesn't have any networking
@@ -757,6 +756,7 @@
                     debug = ""Set data transaction for ""
                             + setDataTxn.getPath()
                             + "" to new value="" + Arrays.toString(setDataTxn.getData());
+                    rc.path = setDataTxn.getPath();
                     rc.stat = setData(setDataTxn.getPath(), setDataTxn
                             .getData(), setDataTxn.getVersion(), header
                             .getZxid(), header.getTime());
@@ -765,6 +765,7 @@
                     SetACLTxn setACLTxn = (SetACLTxn) txn;
                     debug = ""Set ACL transaction for ""
                             + setACLTxn.getPath();
+                    rc.path = setACLTxn.getPath();
                     rc.stat = setACL(setACLTxn.getPath(), setACLTxn.getAcl(),
                             setACLTxn.getVersion());
                     break;
@@ -870,7 +871,8 @@
         if (rc.zxid > lastProcessedZxid) {
             lastProcessedZxid = rc.zxid;
         }
-        /**
+
+        /*
          * Snapshots are taken lazily. It can happen that the child
          * znodes of a parent are created after the parent
          * is serialized. Therefore, while replaying logs during restore, a
"
zookeeper,c85f61aee240e03fdebb31ce094f5b7c07619e34,ZOOKEEPER-1333. NPE in FileTxnSnapLog when restarting a cluster. (Patrick Hunt via mahadev),2011.12.22 05:39:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 2766ac2..77ee021 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -34,7 +34,6 @@
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;
 import org.apache.zookeeper.txn.CreateSessionTxn;
-import org.apache.zookeeper.txn.CreateTxn;
 import org.apache.zookeeper.txn.TxnHeader;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -150,7 +149,7 @@
                 processTransaction(hdr,dt,sessions, itr.getTxn());
             } catch(KeeperException.NoNodeException e) {
                throw new IOException(""Failed to process transaction type: "" +
-                     hdr.getType() + "" error: "" + e.getMessage());
+                     hdr.getType() + "" error: "" + e.getMessage(), e);
             }
             listener.onTxnLoaded(hdr, itr.getTxn());
             if (!itr.next())
@@ -197,20 +196,22 @@
             rc = dt.processTxn(hdr, txn);
         }
 
-              
-        if(rc.err !=  Code.OK.intValue()) {          
-            if(rc.err == Code.NONODE.intValue()) {
+        /**
+         * This should never happen. A NONODE can never show up in the 
+         * transaction logs. This is more indicative of a corrupt transaction
+         * log. Refer ZOOKEEPER-1333 for more info.
+         */
+        if (rc.err != Code.OK.intValue()) {          
+            if (hdr.getType() == OpCode.create && rc.err == Code.NONODE.intValue()) {
                 int lastSlash = rc.path.lastIndexOf('/');
                 String parentName = rc.path.substring(0, lastSlash);
-                LOG.error(""Failed to set parent cversion for: "" +
-                        parentName);
-                  throw new KeeperException.NoNodeException(parentName);
-            }
-            else {
+                LOG.error(""Parent {} missing for {}"", parentName, rc.path);
+                throw new KeeperException.NoNodeException(parentName);
+            } else {
                 LOG.debug(""Ignoring processTxn failure hdr: "" + hdr.getType() +
                         "" : error: "" + rc.err);
             }
-        }      
+        }
     }
 
     /**
"
zookeeper,e44601d1249ea70b5bfa514082c714640c6217dd,ZOOKEEPER-1269. Multi deserialization issues. (Camille Fournier via mahadev),2011.12.10 07:15:30,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 757a572..67866cf 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -872,6 +872,39 @@
         if (rc.zxid > lastProcessedZxid) {
             lastProcessedZxid = rc.zxid;
         }
+        /**
+         * Snapshots are taken lazily. It can happen that the child
+         * znodes of a parent are created after the parent
+         * is serialized. Therefore, while replaying logs during restore, a
+         * create might fail because the node was already
+         * created.
+         *
+         * After seeing this failure, we should increment
+         * the cversion of the parent znode since the parent was serialized
+         * before its children.
+         *
+         * Note, such failures on DT should be seen only during
+         * restore.
+         */
+        if (header.getType() == OpCode.create &&
+                rc.err == Code.NODEEXISTS.intValue()) {
+            LOG.debug(""Adjusting parent cversion for Txn: "" + header.getType() +
+                    "" path:"" + rc.path + "" err: "" + rc.err);
+            int lastSlash = rc.path.lastIndexOf('/');
+            String parentName = rc.path.substring(0, lastSlash);
+            CreateTxn cTxn = (CreateTxn)txn;
+            try {
+                setCversionPzxid(parentName, cTxn.getParentCVersion(),
+                        header.getZxid());
+            } catch (KeeperException.NoNodeException e) {
+                LOG.error(""Failed to set parent cversion for: "" +
+                      parentName, e);
+                rc.err = e.code().intValue();
+            }
+        } else if (rc.err != Code.OK.intValue()) {
+            LOG.debug(""Ignoring processTxn failure hdr: "" + header.getType() +
+                  "" : error: "" + rc.err);
+        }
         return rc;
     }
 
"
zookeeper,e44601d1249ea70b5bfa514082c714640c6217dd,ZOOKEEPER-1269. Multi deserialization issues. (Camille Fournier via mahadev),2011.12.10 07:15:30,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 938cf19..2766ac2 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -197,39 +197,20 @@
             rc = dt.processTxn(hdr, txn);
         }
 
-        /**
-         * Snapshots are taken lazily. It can happen that the child
-         * znodes of a parent are created after the parent
-         * is serialized. Therefore, while replaying logs during restore, a
-         * create might fail because the node was already
-         * created.
-         *
-         * After seeing this failure, we should increment
-         * the cversion of the parent znode since the parent was serialized
-         * before its children.
-         *
-         * Note, such failures on DT should be seen only during
-         * restore.
-         */
-        if (hdr.getType() == OpCode.create &&
-                rc.err == Code.NODEEXISTS.intValue()) {
-            LOG.debug(""Adjusting parent cversion for Txn: "" + hdr.getType() +
-                    "" path:"" + rc.path + "" err: "" + rc.err);
-            int lastSlash = rc.path.lastIndexOf('/');
-            String parentName = rc.path.substring(0, lastSlash);
-            CreateTxn cTxn = (CreateTxn)txn;
-            try {
-                dt.setCversionPzxid(parentName, cTxn.getParentCVersion(),
-                        hdr.getZxid());
-            } catch (KeeperException.NoNodeException e) {
+              
+        if(rc.err !=  Code.OK.intValue()) {          
+            if(rc.err == Code.NONODE.intValue()) {
+                int lastSlash = rc.path.lastIndexOf('/');
+                String parentName = rc.path.substring(0, lastSlash);
                 LOG.error(""Failed to set parent cversion for: "" +
-                      parentName, e);
-                throw e;
+                        parentName);
+                  throw new KeeperException.NoNodeException(parentName);
             }
-        } else if (rc.err != Code.OK.intValue()) {
-            LOG.debug(""Ignoring processTxn failure hdr: "" + hdr.getType() +
-                  "" : error: "" + rc.err);
-        }
+            else {
+                LOG.debug(""Ignoring processTxn failure hdr: "" + hdr.getType() +
+                        "" : error: "" + rc.err);
+            }
+        }      
     }
 
     /**
"
zookeeper,22e2d238cdae7ff77ae69bcad3876d2f0fd3dd84,ZOOKEEPER-1319. Missing data after restarting+expanding a cluster. (phunt and breed via mahadev),2011.12.10 04:03:26,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 7e00715..66db7d4 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -313,11 +313,9 @@
 
             zk.setZxid(ZxidUtils.makeZxid(epoch, 0));
 
-            /*
             synchronized(this){
                 lastProposed = zk.getZxid();
             }
-            */
 
             newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),
                     null, null);
"
zookeeper,fa9e821e91d5c007593f830dcc4553a3f05b1038,ZOOKEEPER-1208. Ephemeral node not removed after the client session is long gone. (phunt via camille),2011.11.15 04:18:39,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 36862d1..871bd17 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -438,7 +438,10 @@
                     for (String path2Delete : es) {
                         addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));
                     }
+
+                    zks.sessionTracker.setSessionClosing(request.sessionId);
                 }
+
                 LOG.info(""Processed session termination for sessionid: 0x""
                         + Long.toHexString(request.sessionId));
                 break;
"
zookeeper,fa9e821e91d5c007593f830dcc4553a3f05b1038,ZOOKEEPER-1208. Ephemeral node not removed after the client session is long gone. (phunt via camille),2011.11.15 04:18:39,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTracker.java b/src/java/main/org/apache/zookeeper/server/SessionTracker.java
index 8f9f68c..3535e1b 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTracker.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTracker.java
@@ -34,6 +34,7 @@
     public static interface Session {
         long getSessionId();
         int getTimeout();
+        boolean isClosing();
     }
     public static interface SessionExpirer {
         void expire(Session session);
@@ -53,6 +54,12 @@
     boolean touchSession(long sessionId, int sessionTimeout);
 
     /**
+     * Mark that the session is in the process of closing.
+     * @param sessionId
+     */
+    void setSessionClosing(long sessionId);
+
+    /**
      * 
      */
     void shutdown();
"
zookeeper,fa9e821e91d5c007593f830dcc4553a3f05b1038,ZOOKEEPER-1208. Ephemeral node not removed after the client session is long gone. (phunt via camille),2011.11.15 04:18:39,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
index e5042ea..cbae57a 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
@@ -57,16 +57,19 @@
             this.sessionId = sessionId;
             this.timeout = timeout;
             this.tickTime = expireTime;
+            isClosing = false;
         }
 
         final long sessionId;
         final int timeout;
         long tickTime;
+        boolean isClosing;
 
         Object owner;
 
         public long getSessionId() { return sessionId; }
         public int getTimeout() { return timeout; }
+        public boolean isClosing() { return isClosing; }
     }
 
     public static long initializeNextSession(long id) {
@@ -189,6 +192,17 @@
         return true;
     }
 
+    synchronized public void setSessionClosing(long sessionId) {
+        if (LOG.isTraceEnabled()) {
+            LOG.info(""Session closing: 0x"" + Long.toHexString(sessionId));
+        }
+        SessionImpl s = sessionsById.get(sessionId);
+        if (s == null) {
+            return;
+        }
+        s.isClosing = true;
+    }
+
     synchronized public void removeSession(long sessionId) {
         SessionImpl s = sessionsById.remove(sessionId);
         sessionsWithTimeout.remove(sessionId);
@@ -240,7 +254,7 @@
 
     synchronized public void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException {
         SessionImpl session = sessionsById.get(sessionId);
-        if (session == null) {
+        if (session == null || session.isClosing()) {
             throw new KeeperException.SessionExpiredException();
         }
         if (session.owner == null) {
"
zookeeper,fa9e821e91d5c007593f830dcc4553a3f05b1038,ZOOKEEPER-1208. Ephemeral node not removed after the client session is long gone. (phunt via camille),2011.11.15 04:18:39,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java
index d61c9c6..3182419 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java
@@ -89,4 +89,8 @@
     	// dup what we had before
     	pwriter.println(toString());
     }
+
+    public void setSessionClosing(long sessionId) {
+        // Nothing to do here.
+    }
 }
"
zookeeper,f8f15de5fe447409a2987262b8e878be224dab25,ZOOKEEPER-1264. FollowerResyncConcurrencyTest failing intermittently. ZOOKEEPER-1282. Learner.java not following Zab 1.0 protocol - setCurrentEpoch should be done upon receipt of NEWLEADER (before acking it) and not upon receipt of UPTODATE. ZOOKEEPER-1291. AcceptedEpoch not updated at leader before it proposes the epoch to followers.,2011.11.06 05:57:13,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index d238466..7e00715 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -309,8 +309,7 @@
             cnxAcceptor.start();
 
             readyToStart = true;
-            long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());
-            self.setAcceptedEpoch(epoch);
+            long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());            
 
             zk.setZxid(ZxidUtils.makeZxid(epoch, 0));
 
@@ -764,7 +763,7 @@
     }
 
     private final HashSet<Long> connectingFollowers = new HashSet<Long>();
-	public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException {
+	public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException {
 		synchronized(connectingFollowers) {
 			if (!waitingForNewEpoch) {
 				return epoch;
@@ -777,6 +776,7 @@
 			if (connectingFollowers.contains(self.getId()) && verifier.containsQuorum(connectingFollowers)) 
 {
 				waitingForNewEpoch = false;
+				self.setAcceptedEpoch(epoch);
 				connectingFollowers.notifyAll();
 			} else {
                    long start = System.currentTimeMillis();
"
zookeeper,f8f15de5fe447409a2987262b8e878be224dab25,ZOOKEEPER-1264. FollowerResyncConcurrencyTest failing intermittently. ZOOKEEPER-1282. Learner.java not following Zab 1.0 protocol - setCurrentEpoch should be done upon receipt of NEWLEADER (before acking it) and not upon receipt of UPTODATE. ZOOKEEPER-1291. AcceptedEpoch not updated at leader before it proposes the epoch to followers.,2011.11.06 05:57:13,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index a97a543..f4a7731 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -312,8 +312,10 @@
     protected void syncWithLeader(long newLeaderZxid) throws IOException, InterruptedException{
         QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);
         QuorumPacket qp = new QuorumPacket();
+        long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);
         
         readPacket(qp);   
+        LinkedList<Long> packetsCommitted = new LinkedList<Long>();
         LinkedList<PacketInFlight> packetsNotCommitted = new LinkedList<PacketInFlight>();
         synchronized (zk) {
             if (qp.getType() == Leader.DIFF) {
@@ -376,12 +378,16 @@
                     packetsNotCommitted.add(pif);
                     break;
                 case Leader.COMMIT:
-                    pif = packetsNotCommitted.peekFirst();
-                    if (pif.hdr.getZxid() != qp.getZxid()) {
-                        LOG.warn(""Committing "" + qp.getZxid() + "", but next proposal is "" + pif.hdr.getZxid());
+                    if (!snapshotTaken) {
+                        pif = packetsNotCommitted.peekFirst();
+                        if (pif.hdr.getZxid() != qp.getZxid()) {
+                            LOG.warn(""Committing "" + qp.getZxid() + "", but next proposal is "" + pif.hdr.getZxid());
+                        } else {
+                            zk.getZKDatabase().processTxn(pif.hdr, pif.rec);
+                            packetsNotCommitted.remove();
+                        }
                     } else {
-                        zk.getZKDatabase().processTxn(pif.hdr, pif.rec);
-                        packetsNotCommitted.remove();
+                        packetsCommitted.add(qp.getZxid());
                     }
                     break;
                 case Leader.INFORM:
@@ -390,28 +396,34 @@
                     zk.getZKDatabase().processTxn(hdr, txn);
                     break;
                 case Leader.UPTODATE:
-                    if (!snapshotTaken) {
+                    if (!snapshotTaken) { // true for the pre v1.0 case
                         zk.takeSnapshot();
+                        self.setCurrentEpoch(newEpoch);
                     }
                     self.cnxnFactory.setZooKeeperServer(zk);                
                     break outerLoop;
                 case Leader.NEWLEADER: // it will be NEWLEADER in v1.0
                     zk.takeSnapshot();
+                    self.setCurrentEpoch(newEpoch);
                     snapshotTaken = true;
                     writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);
                     break;
                 }
             }
         }
-        long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);
-        self.setCurrentEpoch(newEpoch);
         ack.setZxid(ZxidUtils.makeZxid(newEpoch, 0));
         writePacket(ack, true);
         sock.setSoTimeout(self.tickTime * self.syncLimit);
         zk.startup();
-        //We have to have a commit processor to do this
-        for(PacketInFlight p: packetsNotCommitted) {
-            ((FollowerZooKeeperServer)zk).logRequest(p.hdr, p.rec);
+        // We need to log the stuff that came in between the snapshot and the uptodate
+        if (zk instanceof FollowerZooKeeperServer) {
+            FollowerZooKeeperServer fzk = (FollowerZooKeeperServer)zk;
+            for(PacketInFlight p: packetsNotCommitted) {
+                fzk.logRequest(p.hdr, p.rec);
+            }
+            for(Long zxid: packetsCommitted) {
+                fzk.commit(zxid);
+            }
         }
     }
     
"
zookeeper,73674f77cc30b9b0ed36f0032193362363c54bdd,"ZOOKEEPER-1270. testEarlyLeaderAbandonment failing intermittently, quorum formed, no serving. (Flavio, Camille and Alexander Shraer via mahadev)",2011.11.05 15:29:01,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index a44f1ee..d238466 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -774,7 +774,8 @@
 			}
 			connectingFollowers.add(sid);
 			QuorumVerifier verifier = self.getQuorumVerifier();
-			if (verifier.containsQuorum(connectingFollowers)) {
+			if (connectingFollowers.contains(self.getId()) && verifier.containsQuorum(connectingFollowers)) 
+{
 				waitingForNewEpoch = false;
 				connectingFollowers.notifyAll();
 			} else {
@@ -807,7 +808,7 @@
 				electingFollowers.add(id);
 			}
 			QuorumVerifier verifier = self.getQuorumVerifier();
-			if (readyToStart && verifier.containsQuorum(electingFollowers)) {
+			if (electingFollowers.contains(self.getId()) && verifier.containsQuorum(electingFollowers)) {
 				electionFinished = true;
 				electingFollowers.notifyAll();
             } else {
"
zookeeper,736e27df12ffab4139aec95207c7fef1ca114509,ZOOKEEPER-1271. testEarlyLeaderAbandonment failing on solaris - clients not retrying connection (mahadev via phunt),2011.11.03 06:53:46,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
index 9216751..87a5fe5 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
@@ -181,23 +181,45 @@
             LOG.warn(""Ignoring exception during selector close"", e);
         }
     }
-
-    @Override
-    void connect(InetSocketAddress addr) throws IOException {
+    
+    /**
+     * create a socket channel.
+     * @return the created socket channel
+     * @throws IOException
+     */
+    SocketChannel createSock() throws IOException {
         SocketChannel sock;
         sock = SocketChannel.open();
         sock.configureBlocking(false);
         sock.socket().setSoLinger(false, -1);
         sock.socket().setTcpNoDelay(true);
-        try {            
-            sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
-            boolean immediateConnect = sock.connect(addr);
-            if (immediateConnect) {
-                sendThread.primeConnection();
-            }
-        } catch (IOException e) {
+        return sock;
+    }
+
+    /**
+     * register with the selection and connect
+     * @param sock the {@link SocketChannel} 
+     * @param addr the address of remote host
+     * @throws IOException
+     */
+    void registerAndConnect(SocketChannel sock, InetSocketAddress addr) 
+    throws IOException {
+        sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
+        boolean immediateConnect = sock.connect(addr);            
+        if (immediateConnect) {
+            sendThread.primeConnection();
+        }
+    }
+    
+    @Override
+    void connect(InetSocketAddress addr) throws IOException {
+        SocketChannel sock = createSock();
+        try {
+           registerAndConnect(sock, addr);
+      } catch (IOException e) {
             LOG.error(""Unable to open socket to "" + addr);
             sock.close();
+            throw e;
         }
         initialized = false;
 
"
zookeeper,aa786021bc3939ee79f8fde0a3fbcfbdeff69272,"ZOOKEEPER-1268. problems with read only mode, intermittent test failures and ERRORs in the log (phunt via mahadev)",2011.11.01 16:15:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index b677039..3bc9316 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -664,39 +664,53 @@
                 case LOOKING:
                     LOG.info(""LOOKING"");
 
-                    // Create read-only server but don't start it immediately
-                    final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);
+                    if (Boolean.getBoolean(""readonlymode.enabled"")) {
+                        LOG.info(""Attempting to start ReadOnlyZooKeeperServer"");
 
-                    // Instead of starting roZk immediately, wait some grace
-                    // period before we decide we're partitioned.
-                    //
-                    // Thread is used here because otherwise it would require
-                    // changes in each of election strategy classes which is
-                    // unnecessary code coupling.
-                    Thread roZkMgr = new Thread() {
-                        public void run() {
-                            try {
-                                // lower-bound grace period to 2 secs
-                                sleep(Math.max(2000, tickTime));
-                                if (ServerState.LOOKING.equals(getPeerState())) {
-                                    roZk.startup();
+                        // Create read-only server but don't start it immediately
+                        final ReadOnlyZooKeeperServer roZk =
+                            new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);
+    
+                        // Instead of starting roZk immediately, wait some grace
+                        // period before we decide we're partitioned.
+                        //
+                        // Thread is used here because otherwise it would require
+                        // changes in each of election strategy classes which is
+                        // unnecessary code coupling.
+                        Thread roZkMgr = new Thread() {
+                            public void run() {
+                                try {
+                                    // lower-bound grace period to 2 secs
+                                    sleep(Math.max(2000, tickTime));
+                                    if (ServerState.LOOKING.equals(getPeerState())) {
+                                        roZk.startup();
+                                    }
+                                } catch (InterruptedException e) {
+                                    LOG.info(""Interrupted while attempting to start ReadOnlyZooKeeperServer, not started"");
+                                } catch (Exception e) {
+                                    LOG.error(""FAILED to start ReadOnlyZooKeeperServer"", e);
                                 }
-                            } catch (Exception e) {
-                                LOG.error(""FAILED to start ReadOnlyZooKeeperServer"", e);
                             }
+                        };
+                        try {
+                            roZkMgr.start();
+                            setCurrentVote(makeLEStrategy().lookForLeader());
+                        } catch (Exception e) {
+                            LOG.warn(""Unexpected exception"", e);
+                            setPeerState(ServerState.LOOKING);
+                        } finally {
+                            // If the thread is in the the grace period, interrupt
+                            // to come out of waiting.
+                            roZkMgr.interrupt();
+                            roZk.shutdown();
                         }
-                    };
-                    try {
-                        roZkMgr.start();
-                        setCurrentVote(makeLEStrategy().lookForLeader());
-                    } catch (Exception e) {
-                        LOG.warn(""Unexpected exception"",e);
-                        setPeerState(ServerState.LOOKING);
-                    } finally {
-                        // If the thread is in the the grace period, interrupt
-                        // to come out of waiting.
-                        roZkMgr.interrupt();
-                        roZk.shutdown();
+                    } else {
+                        try {
+                            setCurrentVote(makeLEStrategy().lookForLeader());
+                        } catch (Exception e) {
+                            LOG.warn(""Unexpected exception"", e);
+                            setPeerState(ServerState.LOOKING);
+                        }                        
                     }
                     break;
                 case OBSERVING:
"
zookeeper,4ae2225de1a170f00d0ea961baa36e783a9f3741,ZOOKEEPER-1265. Normalize switch cases lists on request types (Thomas Koch via phunt),2011.10.29 01:37:43,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
index 2f77e9d..6003d48 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
@@ -67,7 +67,7 @@
     public void run() {
         ArrayList<Request> toProcess = new ArrayList<Request>();
         try {
-            Request nextPending = null;            
+            Request nextPending = null;
             while (!finished) {
                 for (Request request : toProcess) {
                     nextProcessor.processRequest(request);
@@ -118,6 +118,7 @@
                         case OpCode.delete:
                         case OpCode.setData:
                         case OpCode.multi:
+                        case OpCode.check:
                         case OpCode.setACL:
                         case OpCode.createSession:
                         case OpCode.closeSession:
@@ -163,7 +164,7 @@
         if (LOG.isDebugEnabled()) {
             LOG.debug(""Processing request:: "" + request);
         }
-        
+
         if (!finished) {
             queuedRequests.add(request);
             notifyAll();
"
zookeeper,4ae2225de1a170f00d0ea961baa36e783a9f3741,ZOOKEEPER-1265. Normalize switch cases lists on request types (Thomas Koch via phunt),2011.10.29 01:37:43,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
index a1c8ce2..129ebb6 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
@@ -67,7 +67,7 @@
                 // the request to the leader so that we are ready to receive
                 // the response
                 nextProcessor.processRequest(request);
-                
+
                 // We now ship the request to the leader. As with all
                 // other quorum operations, sync also follows this code
                 // path, but different from others, we need to keep track
@@ -85,6 +85,7 @@
                 case OpCode.createSession:
                 case OpCode.closeSession:
                 case OpCode.multi:
+                case OpCode.check:
                     zks.getFollower().request(request);
                     break;
                 }
"
zookeeper,4ae2225de1a170f00d0ea961baa36e783a9f3741,ZOOKEEPER-1265. Normalize switch cases lists on request types (Thomas Koch via phunt),2011.10.29 01:37:43,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
index e94414f..3c8df5e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
@@ -40,15 +40,15 @@
 
     RequestProcessor nextProcessor;
 
-    // We keep a queue of requests. As requests get submitted they are 
-    // stored here. The queue is drained in the run() method. 
+    // We keep a queue of requests. As requests get submitted they are
+    // stored here. The queue is drained in the run() method.
     LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
 
     boolean finished = false;
 
     /**
      * Constructor - takes an ObserverZooKeeperServer to associate with
-     * and the next processor to pass requests to after we're finished. 
+     * and the next processor to pass requests to after we're finished.
      * @param zks
      * @param nextProcessor
      */
@@ -75,7 +75,7 @@
                 // the request to the leader so that we are ready to receive
                 // the response
                 nextProcessor.processRequest(request);
-                
+
                 // We now ship the request to the leader. As with all
                 // other quorum operations, sync also follows this code
                 // path, but different from others, we need to keep track
@@ -93,6 +93,7 @@
                 case OpCode.createSession:
                 case OpCode.closeSession:
                 case OpCode.multi:
+                case OpCode.check:
                     zks.getObserver().request(request);
                     break;
                 }
@@ -104,7 +105,7 @@
     }
 
     /**
-     * Simply queue the request, which will be processed in FIFO order. 
+     * Simply queue the request, which will be processed in FIFO order.
      */
     public void processRequest(Request request) {
         if (!finished) {
"
zookeeper,4ae2225de1a170f00d0ea961baa36e783a9f3741,ZOOKEEPER-1265. Normalize switch cases lists on request types (Thomas Koch via phunt),2011.10.29 01:37:43,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
index 82d1468..8fd942b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java
@@ -41,13 +41,13 @@
 
     private static final Logger LOG = LoggerFactory.getLogger(ReadOnlyRequestProcessor.class);
 
-    private LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
+    private final LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
 
     private boolean finished = false;
 
-    private RequestProcessor nextProcessor;
+    private final RequestProcessor nextProcessor;
 
-    private ZooKeeperServer zks;
+    private final ZooKeeperServer zks;
 
     public ReadOnlyRequestProcessor(ZooKeeperServer zks, RequestProcessor nextProcessor) {
         super(""ReadOnlyRequestProcessor:"" + zks.getServerId());
@@ -79,7 +79,8 @@
                 case OpCode.delete:
                 case OpCode.setData:
                 case OpCode.setACL:
-
+                case OpCode.multi:
+                case OpCode.check:
                     ReplyHeader hdr = new ReplyHeader(request.cxid, zks.getZKDatabase()
                             .getDataTreeLastProcessedZxid(), Code.NOTREADONLY.intValue());
                     try {
"
zookeeper,2504f4fb30c84af2b46f033f72e51c1eee86caee,ZOOKEEPER-1220. ./zkCli.sh 'create' command is throwing ArrayIndexOutOfBoundsException (kavita sharma via phunt),2011.10.28 01:11:15,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index b75c59c..aaea00a 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -670,11 +670,13 @@
             return false;
         }
         
-        if (cmd.equals(""create"") && args.length >= 3) {
+        if (cmd.equals(""create"") && args.length >= 2) {
             int first = 0;
             CreateMode flags = CreateMode.PERSISTENT;
-            if ((args[1].equals(""-e"") && args[2].equals(""-s""))
-                    || (args[1]).equals(""-s"") && (args[2].equals(""-e""))) {
+            if ((args.length >= 3)
+                    && ((args[1].equals(""-e"") && args[2].equals(""-s"")) || (args[1])
+                            .equals(""-s"")
+                            && (args[2].equals(""-e"")))) {
                 first+=2;
                 flags = CreateMode.EPHEMERAL_SEQUENTIAL;
             } else if (args[1].equals(""-e"")) {
@@ -684,13 +686,24 @@
                 first++;
                 flags = CreateMode.PERSISTENT_SEQUENTIAL;
             }
-            if (args.length == first + 4) {
+            if (args.length >= first+2) {
+                path = args[first+1];
+            }
+            if(path==null)
+            {
+                usage();
+                return false;
+            }
+            byte[] data = null;
+            if (args.length >= first + 3) {
+                data = args[first + 2].getBytes();
+            }
+            if (args.length >= first + 4) {
                 acl = parseACLs(args[first+3]);
             }
-            path = args[first + 1];
-            String newPath = zk.create(path, args[first+2].getBytes(), acl,
-                    flags);
+            String newPath = zk.create(path, data, acl, flags);
             System.err.println(""Created "" + newPath);
+            return true;
         } else if (cmd.equals(""delete"") && args.length >= 2) {
             path = args[1];
             zk.delete(path, watch ? Integer.parseInt(args[2]) : -1);
"
zookeeper,a89d9b66ceba10bfb96787b59ef3e172bea0e1c6,ZOOKEEPER-1181. Fix problems with Kerberos TGT renewal. (Eugene Koontz via mahadev),2011.10.24 15:44:40,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/Login.java b/src/java/main/org/apache/zookeeper/Login.java
index de64d0d..294801a 100644
--- a/src/java/main/org/apache/zookeeper/Login.java
+++ b/src/java/main/org/apache/zookeeper/Login.java
@@ -36,8 +36,8 @@
 
 import javax.security.auth.kerberos.KerberosTicket;
 import javax.security.auth.Subject;
-import java.io.IOException;
 import java.util.Date;
+import java.util.Random;
 import java.util.Set;
 
 public class Login {
@@ -49,6 +49,11 @@
     // and try to renew the ticket.
     private static final float TICKET_RENEW_WINDOW = 0.80f;
 
+    /**
+     * Percentage of random jitter added to the renewal time
+     */
+    private static final float TICKET_RENEW_JITTER = 0.05f;
+
     // Regardless of TICKET_RENEW_WINDOW setting above and the ticket expiry time,
     // thread will not sleep between refresh attempts any less than 1 minute (60*1000 milliseconds = 1 minute).
     // Change the '1' to e.g. 5, to change this to 5 minutes.
@@ -58,6 +63,18 @@
     private Thread t = null;
     private boolean isKrbTicket = false;
     private boolean isUsingTicketCache = false;
+    private boolean isUsingKeytab = false;
+
+    /** Random number generator */
+    private static Random rng = new Random();
+
+    private LoginContext login = null;
+    private String loginContextName = null;
+    private String keytabFile = null;
+    private String principal = null;
+
+    private long lastLogin = 0;
+
     /**
      * LoginThread constructor. The constructor starts the thread used
      * to periodically re-login to the Kerberos Ticket Granting Server.
@@ -71,129 +88,170 @@
      *               Thrown if authentication fails.
      */
     public Login(final String loginContextName, CallbackHandler callbackHandler)
-      throws LoginException {
+            throws LoginException {
         this.callbackHandler = callbackHandler;
-        final LoginContext loginContext = login(loginContextName);
-        subject = loginContext.getSubject();
+        login = login(loginContextName);
+        this.loginContextName = loginContextName;
+        subject = login.getSubject();
         isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();
         AppConfigurationEntry entries[] = Configuration.getConfiguration().getAppConfigurationEntry(loginContextName);
         for (AppConfigurationEntry entry: entries) {
+            // there will only be a single entry, so this for() loop will only be iterated through once.
             if (entry.getOptions().get(""useTicketCache"") != null) {
                 String val = (String)entry.getOptions().get(""useTicketCache"");
                 if (val.equals(""true"")) {
                     isUsingTicketCache = true;
                 }
-                break;
             }
+            if (entry.getOptions().get(""keyTab"") != null) {
+                keytabFile = (String)entry.getOptions().get(""keyTab"");
+                isUsingKeytab = true;
+            }
+            if (entry.getOptions().get(""principal"") != null) {
+                principal = (String)entry.getOptions().get(""principal"");
+            }
+            break;
         }
-        if (isKrbTicket && isUsingTicketCache) {
-            // Refresh the Ticket Granting Ticket (TGT) cache periodically. How often to refresh is determined by the
-            // TGT's existing expiry date and the configured MIN_TIME_BEFORE_RELOGIN. For testing and development,
-            // you can decrease the interval of expiration of tickets (for example, to 3 minutes) by running :
-            //  ""modprinc -maxlife 3mins <principal>"" in kadmin.
-            t = new Thread(new Runnable() {
-                public void run() {
-                    LOG.info(""TGT refresh thread started."");
-                    while (true) {  // renewal thread's main loop. if it exits from here, thread will exit.
-                        KerberosTicket tgt = getTGT();
-                        long now = System.currentTimeMillis();
-                        long nextRefresh;
-                        Date nextRefreshDate;
-                        if (tgt == null) {
-                            nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;
-                            nextRefreshDate = new Date(nextRefresh);
-                            LOG.warn(""No TGT found: will try again at "" + nextRefreshDate);
-                        }
-                        else {
-                            // determine how long to sleep from looking at ticket's expiry.
-                            // We must not allow the ticket to expire, but we should take into consideration
-                            // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, except when
-                            // unless it would cause ticket expiration.
-                            nextRefresh = getRefreshTime(tgt);
-                            long expiry = tgt.getEndTime().getTime();
 
-                            if ((nextRefresh > expiry) ||
-                              ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {
-                                // expiry is before next scheduled refresh).
-                                LOG.info(""refreshing now because expiry is before next scheduled refresh time."");
-                                nextRefresh = now;
-                            }
-                            else {
-                                if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {
-                                    // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).
-                                    Date until = new Date(nextRefresh);
-                                    Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);
-                                    LOG.warn(""TGT refresh thread time adjusted from : "" + until + "" to : "" + newuntil + "" since ""
-                                      + ""the former is sooner than the minimum refresh interval (""
-                                      + MIN_TIME_BEFORE_RELOGIN / 1000 + "" seconds) from now."");
-                                }
-                                nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);
-                            }
-                            nextRefreshDate = new Date(nextRefresh);
-                            if (nextRefresh > expiry) {
-                                Date expiryDate = new Date(expiry);
-                                LOG.error(""next refresh: "" + nextRefreshDate + "" is later than expiry "" + expiryDate
-                                  + "". This may indicated a clock skew problem. Check that this host and the KDC's ""
-                                  + ""hosts' clocks are in sync."");
-                                return;
-                            }
-                        }
+        if (!isKrbTicket) {
+            // if no TGT, do not bother with ticket management.
+            return;
+        }
 
-                        if (now < nextRefresh) {
-                            Date until = new Date(nextRefresh);
-                            LOG.info(""TGT refresh thread sleeping until: "" + until.toString());
-                            try {
-                                Thread.sleep(nextRefresh - now);
-                            }
-                            catch (InterruptedException ie) {
-                                LOG.warn(""TGT renewal thread has been interrupted and will exit."");
-                                break;
-                            }
-                        }
-                        else {
-                            LOG.error(""nextRefresh:"" + nextRefreshDate + "" is in the past: exiting refresh thread. Check""
-                              + "" clock sync between this host and KDC - (KDC's clock is likely ahead of this host).""
-                              + "" Manual intervention will be required for this client to successfully authenticate."");
-                            // TODO: if we have a keytab, we can use that to re-initialize and avoid the need for
-                            // manual intervention.
+        // Refresh the Ticket Granting Ticket (TGT) periodically. How often to refresh is determined by the
+        // TGT's existing expiry date and the configured MIN_TIME_BEFORE_RELOGIN. For testing and development,
+        // you can decrease the interval of expiration of tickets (for example, to 3 minutes) by running :
+        //  ""modprinc -maxlife 3mins <principal>"" in kadmin.
+        t = new Thread(new Runnable() {
+            public void run() {
+                LOG.info(""TGT refresh thread started."");
+                while (true) {  // renewal thread's main loop. if it exits from here, thread will exit.
+                    KerberosTicket tgt = getTGT();
+                    long now = System.currentTimeMillis();
+                    long nextRefresh;
+                    Date nextRefreshDate;
+                    if (tgt == null) {
+                        nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;
+                        nextRefreshDate = new Date(nextRefresh);
+                        LOG.warn(""No TGT found: will try again at "" + nextRefreshDate);
+                    } else {
+                        nextRefresh = getRefreshTime(tgt);
+                        long expiry = tgt.getEndTime().getTime();
+                        Date expiryDate = new Date(expiry);
+                        if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {
+                            LOG.error(""The TGT cannot be renewed beyond the next expiry date: "" + expiryDate + ""."" +
+                                    ""This process will not be able to authenticate new SASL connections after that "" +
+                                    ""time (for example, it will not be authenticate a new connection with a Zookeeper "" +
+                                    ""Quorum member).  Ask your system administrator to either increase the "" +
+                                    ""'renew until' time by doing : 'modprinc -maxrenewlife "" + principal + ""' within "" +
+                                    ""kadmin, or instead, to generate a keytab for "" + principal + "". Because the TGT's "" +
+                                    ""expiry cannot be further extended by refreshing, exiting refresh thread now."");
                             return;
                         }
-
+                        // determine how long to sleep from looking at ticket's expiry.
+                        // We should not allow the ticket to expire, but we should take into consideration
+                        // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so
+                        // would cause ticket expiration.
+                        if ((nextRefresh > expiry) ||
+                                ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {
+                            // expiry is before next scheduled refresh).
+                            LOG.info(""refreshing now because expiry is before next scheduled refresh time."");
+                            nextRefresh = now;
+                        } else {
+                            if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {
+                                // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).
+                                Date until = new Date(nextRefresh);
+                                Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);
+                                LOG.warn(""TGT refresh thread time adjusted from : "" + until + "" to : "" + newuntil + "" since ""
+                                        + ""the former is sooner than the minimum refresh interval (""
+                                        + MIN_TIME_BEFORE_RELOGIN / 1000 + "" seconds) from now."");
+                            }
+                            nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);
+                        }
+                        nextRefreshDate = new Date(nextRefresh);
+                        if (nextRefresh > expiry) {
+                            LOG.error(""next refresh: "" + nextRefreshDate + "" is later than expiry "" + expiryDate
+                                    + "". This may indicate a clock skew problem. Check that this host and the KDC's ""
+                                    + ""hosts' clocks are in sync. Exiting refresh thread."");
+                            return;
+                        }
+                    }
+                    if (now < nextRefresh) {
+                        Date until = new Date(nextRefresh);
+                        LOG.info(""TGT refresh sleeping until: "" + until.toString());
+                        try {
+                            Thread.sleep(nextRefresh - now);
+                        } catch (InterruptedException ie) {
+                            LOG.warn(""TGT renewal thread has been interrupted and will exit."");
+                            break;
+                        }
+                    }
+                    else {
+                        LOG.error(""nextRefresh:"" + nextRefreshDate + "" is in the past: exiting refresh thread. Check""
+                                + "" clock sync between this host and KDC - (KDC's clock is likely ahead of this host).""
+                                + "" Manual intervention will be required for this client to successfully authenticate.""
+                                + "" Exiting refresh thread."");
+                        return;
+                    }
+                    if (isUsingTicketCache) {
                         String cmd = ""/usr/bin/kinit"";
                         if (System.getProperty(""zookeeper.kinit"") != null) {
                             cmd = System.getProperty(""zookeeper.kinit"");
                         }
                         String kinitArgs = ""-R"";
-                        try {
-                            Shell.execCommand(cmd,kinitArgs);
-                        }
-                        catch (Shell.ExitCodeException e) {
-                            LOG.error(""Could not renew TGT due to problem running shell command: '"" + cmd
-                              + "" "" + kinitArgs + ""'"" + ""; exception was:"" + e + "". Will try shell command again at: ""
-                              + nextRefreshDate);
-                        }
-                        catch (IOException e) {
-                            LOG.error(""Could not renew TGT due to problem running shell command: '"" + cmd
-                              + "" "" + kinitArgs + ""'; exception was:"" + e + "". Will try shell command again at: ""
-                              + nextRefreshDate);
-                        }
-                        try {
-                            reloginFromTicketCache(loginContextName, loginContext);
-                            LOG.debug(""renewed TGT successfully."");
-                        }
-                        catch (LoginException e) {
-                            LOG.error(""Could not renew TGT due to LoginException: "" + e + "".""
-                              + "" Will try again at: ""
-                              + nextRefreshDate);
+                        int retry = 1;
+                        while (retry >= 0) {
+                            try {
+                                LOG.debug(""running ticket cache refresh command: "" + cmd + "" "" + kinitArgs);
+                                Shell.execCommand(cmd, kinitArgs);
+                                break;
+                            } catch (Exception e) {
+                                if (retry > 0) {
+                                    --retry;
+                                    // sleep for 10 seconds
+                                    try {
+                                        Thread.sleep(10 * 1000);
+                                    } catch (InterruptedException ie) {
+                                        LOG.error(""Interrupted while renewing TGT, exiting Login thread"");
+                                        return;
+                                    }
+                                } else {
+                                    LOG.warn(""Could not renew TGT due to problem running shell command: '"" + cmd
+                                            + "" "" + kinitArgs + ""'"" + ""; exception was:"" + e + "". Exiting refresh thread."",e);
+                                    return;
+                                }
+                            }
                         }
                     }
+                    try {
+                        int retry = 1;
+                        while (retry >= 0) {
+                            try {
+                                reLogin();
+                                break;
+                            } catch (LoginException le) {
+                                if (retry > 0) {
+                                    --retry;
+                                    // sleep for 10 seconds.
+                                    try {
+                                        Thread.sleep(10 * 1000);
+                                    } catch (InterruptedException e) {
+                                        LOG.error(""Interrupted during login retry after LoginException:"", le);
+                                        throw le;
+                                    }
+                                } else {
+                                    LOG.error(""Could not refresh TGT for principal: "" + principal + ""."", le);
+                                }
+                            }
+                        }
+                    } catch (LoginException le) {
+                        LOG.error(""Failed to refresh TGT: refresh thread exiting now."",le);
+                        break;
+                    }
                 }
-            });
-            t.setDaemon(true);
-        }
-        else {
-            LOG.error(""Not using Ticket Granting Ticket cache: will not start a TGT renewal thread."");
-        }
+            }
+        });
+        t.setDaemon(true);
     }
 
     public void startThreadIfNeeded() {
@@ -203,11 +261,25 @@
         }
     }
 
+    public void shutdown() {
+        if ((t != null) && (t.isAlive())) {
+            t.interrupt();
+            try {
+                t.join();
+            } catch (InterruptedException e) {
+                LOG.warn(""error while waiting for Login thread to shutdown: "" + e);
+            }
+        }
+    }
+
+    public Subject getSubject() {
+        return subject;
+    }
 
     private synchronized LoginContext login(final String loginContextName) throws LoginException {
         if (loginContextName == null) {
             throw new LoginException(""loginContext name (JAAS file section header) was null. "" +
-              ""Please check your java.security.login.auth.config setting."");
+                    ""Please check your java.security.login.auth.config setting."");
         }
         LoginContext loginContext = new LoginContext(loginContextName,callbackHandler);
         loginContext.login();
@@ -215,17 +287,14 @@
         return loginContext;
     }
 
-    public Subject getSubject() {
-        return subject;
-    }
-
     // c.f. org.apache.hadoop.security.UserGroupInformation.
     private long getRefreshTime(KerberosTicket tgt) {
         long start = tgt.getStartTime().getTime();
         long expires = tgt.getEndTime().getTime();
-        LOG.info(""TGT valid starting at: "" + tgt.getStartTime().toString());
-        LOG.info(""TGT expires: "" + tgt.getEndTime().toString());
-        long proposedRefresh = start + (long) ((expires - start) * TICKET_RENEW_WINDOW);
+        LOG.info(""TGT valid starting at:        "" + tgt.getStartTime().toString());
+        LOG.info(""TGT expires:                  "" + tgt.getEndTime().toString());
+        long proposedRefresh = start + (long) ((expires - start) *
+                (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * rng.nextDouble())));
         if (proposedRefresh > expires) {
             // proposedRefresh is too far in the future: it's after ticket expires: simply return now.
             return System.currentTimeMillis();
@@ -247,67 +316,80 @@
         return null;
     }
 
-    // TODO : refactor this with login() to maximize code-sharing.
-    public synchronized void reloginFromTicketCache(final String loginContextName, LoginContext loginContext)
-        throws LoginException {
-        if (!(isKrbTicket && isUsingTicketCache)) {
+    private boolean hasSufficientTimeElapsed() {
+        long now = System.currentTimeMillis();
+        if (now - getLastLogin() < MIN_TIME_BEFORE_RELOGIN ) {
+            LOG.warn(""Not attempting to re-login since the last re-login was "" +
+                    ""attempted less than "" + (MIN_TIME_BEFORE_RELOGIN/1000) + "" seconds""+
+                    "" before."");
+            return false;
+        }
+        // register most recent relogin attempt
+        setLastLogin(now);
+        return true;
+    }
+
+    /**
+     * Returns login object
+     * @return login
+     */
+    private LoginContext getLogin() {
+        return login;
+    }
+
+    /**
+     * Set the login object
+     * @param login
+     */
+    private void setLogin(LoginContext login) {
+        this.login = login;
+    }
+
+    /**
+     * Set the last login time.
+     * @param time the number of milliseconds since the beginning of time
+     */
+    private void setLastLogin(long time) {
+        lastLogin = time;
+    }
+
+    /**
+     * Get the time of the last login.
+     * @return the number of milliseconds since the beginning of time.
+     */
+    private long getLastLogin() {
+        return lastLogin;
+    }
+
+    /**
+     * Re-login a principal. This method assumes that {@link #login(String)} has happened already.
+     * @throws javax.security.auth.login.LoginException on a failure
+     */
+    // c.f. HADOOP-6559
+    private synchronized void reLogin()
+            throws LoginException {
+        if (!isKrbTicket) {
             return;
         }
-        if (loginContext == null) {
+        LoginContext login = getLogin();
+        if (login  == null) {
             throw new LoginException(""login must be done first"");
         }
-        String principalName = getPrincipalName();
-        try {
-            LOG.info(""Logging out "" + principalName);
-            //clear up the Kerberos state. But the tokens are not cleared! As per
+        if (!hasSufficientTimeElapsed()) {
+            return;
+        }
+        LOG.info(""Initiating logout for "" + principal);
+        synchronized (Login.class) {
+            //clear up the kerberos state. But the tokens are not cleared! As per
             //the Java kerberos login module code, only the kerberos credentials
-            //are cleared.
-            loginContext.logout();
+            //are cleared
+            login.logout();
             //login and also update the subject field of this instance to
             //have the new credentials (pass it to the LoginContext constructor)
-            if (loginContextName == null) {
-                throw new LoginException(""loginContext name (JAAS file section header) was null. "" +
-                  ""Please check your java.security.login.auth.config setting."");
-            }
-            if (subject == null) {
-                throw new LoginException(""login subject was null."");
-            }
-            LOG.info(""Logging in "" + principalName);
-            loginContext.login();
-            if (principalName.equals(""(no principal name)"")) {
-                // try again to get the principal name, in case the ticket cache was manually refreshed.
-                principalName = getPrincipalName();
-            }
-            LOG.info(""Login successful for "" + principalName);
-        } catch (LoginException le) {
-            throw new LoginException(""Login failure for "" + principalName);
+            login = new LoginContext(loginContextName, getSubject());
+            LOG.info(""Initiating re-login for "" + principal);
+            login.login();
+            setLogin(login);
         }
     }
-
-    private String getPrincipalName() {
-        try {
-            return getSubject().getPrincipals(KerberosPrincipal.class).toArray()[0].toString();
-        }
-        catch (NullPointerException e) {
-            LOG.warn(""could not display principal name because login was null or login's subject was null: returning '(no principal found)'."");
-        }
-        catch (ArrayIndexOutOfBoundsException e) {
-            LOG.warn(""could not display principal name because login's subject had no principals: returning '(no principal found)'."");
-        }
-        return ""(no principal found)"";
-    }
-
-    public void shutdown() {
-        if ((t != null) && (t.isAlive())) {
-            t.interrupt();
-            try {
-                t.join();
-            }
-            catch (InterruptedException e) {
-                LOG.error(""error while waiting for Login thread to shutdown: "" + e);
-            }
-        }
-    }
-
 }
-
"
zookeeper,7307c9825187d3f3debf3b252ad5590965d9b56d,ZOOKEEPER-1206. Sequential node creation does not use always use digits in node name given certain Locales. (Mark Miller via phunt),2011.09.30 06:32:56,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 9e55c7b..ce58145 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -27,6 +27,7 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.ListIterator;
+import java.util.Locale;
 import java.util.Set;
 import java.util.concurrent.LinkedBlockingQueue;
 
@@ -317,7 +318,7 @@
                 CreateMode createMode =
                     CreateMode.fromFlag(createRequest.getFlags());
                 if (createMode.isSequential()) {
-                    path = path + String.format(""%010d"", parentCVersion);
+                    path = path + String.format(Locale.ENGLISH, ""%010d"", parentCVersion);
                 }
                 try {
                     PathUtils.validatePath(path);
"
zookeeper,12f70403c6fdc4a94e6bfa0a66ddabe7f81c3afc,ZOOKEEPER-1174. FD leak when network unreachable (Ted Dunning via camille),2011.09.29 05:17:16,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 8d0525a..6c25e40 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1040,7 +1040,7 @@
 
                     clientCnxnSocket.doTransport(to, pendingQueue, outgoingQueue);
 
-                } catch (Exception e) {
+                } catch (Throwable e) {
                     if (closing) {
                         if (LOG.isDebugEnabled()) {
                             // closing so this is expected
"
zookeeper,12f70403c6fdc4a94e6bfa0a66ddabe7f81c3afc,ZOOKEEPER-1174. FD leak when network unreachable (Ted Dunning via camille),2011.09.29 05:17:16,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
index 9cb2a26..9216751 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
@@ -189,9 +189,15 @@
         sock.configureBlocking(false);
         sock.socket().setSoLinger(false, -1);
         sock.socket().setTcpNoDelay(true);
-        sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
-        if (sock.connect(addr)) {
-            sendThread.primeConnection();
+        try {            
+            sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
+            boolean immediateConnect = sock.connect(addr);
+            if (immediateConnect) {
+                sendThread.primeConnection();
+            }
+        } catch (IOException e) {
+            LOG.error(""Unable to open socket to "" + addr);
+            sock.close();
         }
         initialized = false;
 
@@ -304,4 +310,8 @@
     synchronized void enableReadWriteOnly() {
         sockKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
     }
+
+    Selector getSelector() {
+        return selector;
+    }
 }
"
zookeeper,12f70403c6fdc4a94e6bfa0a66ddabe7f81c3afc,ZOOKEEPER-1174. FD leak when network unreachable (Ted Dunning via camille),2011.09.29 05:17:16,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 3d0b3c4..c7e86fe 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -183,7 +183,7 @@
     /**
      * converts a list of longs to a list of acls.
      *
-     * @param longs
+     * @param longVal
      *            the list of longs
      * @return a list of ACLs that map to longs
      */
@@ -594,7 +594,7 @@
     /**
      * If there is a quota set, return the appropriate prefix for that quota
      * Else return null
-     * @param The ZK path to check for quota
+     * @param path The ZK path to check for quota
      * @return Max quota prefix, or null if none
      */
     public String getMaxPrefixWithQuota(String path) {
@@ -933,9 +933,7 @@
      *
      * @param path
      *            the path to be used
-     * @param bytes
-     *            the long bytes
-     * @param count
+     * @param counts
      *            the int count
      */
     private void getCounts(String path, Counts counts) {
"
zookeeper,9598a30a6620cc336f860cee56916022f7985890,ZOOKEEPER-786. Reverting a bad line of this checkin,2011.09.28 23:46:15,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
index 017ab14..9cb2a26 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
@@ -190,7 +190,9 @@
         sock.socket().setSoLinger(false, -1);
         sock.socket().setTcpNoDelay(true);
         sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
-        sock.connect(addr);
+        if (sock.connect(addr)) {
+            sendThread.primeConnection();
+        }
         initialized = false;
 
         /*
"
zookeeper,7e64875f9d18cb043adbddc53c73e563886942ea,ZOOKEEPER-1185. Send AuthFailed event to client if SASL authentication fails. (Eugene Kuntz via mahadev),2011.09.27 11:06:24,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index db15348..8d0525a 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -558,6 +558,12 @@
                       SetSASLResponse rsp = (SetSASLResponse) p.response;
                       // TODO : check rc (== 0, etc) as with other packet types.
                       cb.processResult(rc,null,p.ctx,rsp.getToken(),null);
+                      ClientCnxn clientCnxn = (ClientCnxn)p.ctx;
+                      if ((clientCnxn == null) || (clientCnxn.zooKeeperSaslClient == null) ||
+                              (clientCnxn.zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.FAILED)) {
+                          queueEvent(new WatchedEvent(EventType.None,
+                                  KeeperState.AuthFailed, null));
+                      }
                   } else if (p.response instanceof GetDataResponse) {
                       DataCallback cb = (DataCallback) p.cb;
                       GetDataResponse rsp = (GetDataResponse) p.response;
@@ -945,6 +951,9 @@
                       + ""configuration file: '"" + System.getProperty(""java.security.auth.login.config"")
                       + ""'. Will continue connection to Zookeeper server without SASL authentication, if Zookeeper ""
                       + ""server allows it."");
+                    eventThread.queueEvent(new WatchedEvent(
+                            Watcher.Event.EventType.None,
+                            KeeperState.AuthFailed, null));
                 }
             }
             clientCnxnSocket.connect(addr);
@@ -979,6 +988,9 @@
                             catch (SaslException e) {
                                 LOG.error(""SASL authentication with Zookeeper Quorum member failed: "" + e);
                                 state = States.AUTH_FAILED;
+                                eventThread.queueEvent(new WatchedEvent(
+                                        Watcher.Event.EventType.None,
+                                        KeeperState.AuthFailed,null));
                             }
                             if (zooKeeperSaslClient.readyToSendSaslAuthEvent()) {
                                 eventThread.queueEvent(new WatchedEvent(
"
zookeeper,7e64875f9d18cb043adbddc53c73e563886942ea,ZOOKEEPER-1185. Send AuthFailed event to client if SASL authentication fails. (Eugene Kuntz via mahadev),2011.09.27 11:06:24,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
index 43382c8..722538e 100644
--- a/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
+++ b/src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java
@@ -59,12 +59,16 @@
     private byte[] saslToken = new byte[0];
     private ClientCnxn cnxn;
 
-    private enum SaslState {
-        INITIAL,INTERMEDIATE,COMPLETE
+    public enum SaslState {
+        INITIAL,INTERMEDIATE,COMPLETE,FAILED
     }
 
     private SaslState saslState = SaslState.INITIAL;
 
+    public SaslState getSaslState() {
+        return saslState;
+    }
+
     public ZooKeeperSaslClient(ClientCnxn cnxn, String serverPrincipal) throws LoginException {
         this.cnxn = cnxn;
         this.saslClient = createSaslClient(serverPrincipal);
@@ -176,8 +180,8 @@
                     queueSaslPacket(saslToken);
                 }
             } catch (SaslException e) {
-                // TODO sendThread should set state to AUTH_FAILED; but currently only sendThread modifies state.
                 LOG.error(""SASL authentication failed."");
+                saslState = SaslState.FAILED;
             }
         }
     }
@@ -265,6 +269,9 @@
     }
 
     public void initialize() throws SaslException {
+        if (saslClient == null) {
+            throw new SaslException(""saslClient failed to initialize properly: it's null."");
+        }
         if (saslState == SaslState.INITIAL) {
             if (saslClient.hasInitialResponse()) {
                 queueSaslPacket();
"
zookeeper,05287a9c14db8d145f61ea09ec2c61f4f0221cc6,ZOOKEEPER-1189. For an invalid snapshot file(less than 10bytes size) RandomAccessFile stream is leaking. (Rakesh R via mahadev),2011.09.27 10:05:13,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/Util.java b/src/java/main/org/apache/zookeeper/server/persistence/Util.java
index 6443434..7ef7f9c 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/Util.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/Util.java
@@ -164,12 +164,12 @@
 
         // Check for a valid snapshot
         RandomAccessFile raf = new RandomAccessFile(f, ""r"");
-        // including the header and the last / bytes
-        // the snapshot should be atleast 10 bytes
-        if (raf.length() < 10) {
-            return false;
-        }
         try {
+            // including the header and the last / bytes
+            // the snapshot should be atleast 10 bytes
+            if (raf.length() < 10) {
+                return false;
+            }
             raf.seek(raf.length() - 5);
             byte bytes[] = new byte[5];
             int readlen = 0;
"
zookeeper,de7289d3a1018fb18ca1818b4a2aee09ec2e0562,ZOOKEEPER-786. Exception in ZooKeeper.toString (Thomas Koch via phunt),2011.09.15 07:50:27,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
index 4b9381e..017ab14 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
@@ -20,6 +20,7 @@
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
+import java.net.Socket;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.SelectionKey;
@@ -43,6 +44,10 @@
 
     private SelectionKey sockKey;
 
+    private SocketAddress localSocketAddress;
+
+    private SocketAddress remoteSocketAddress;
+
     ClientCnxnSocketNIO() throws IOException {
         super();
     }
@@ -185,9 +190,7 @@
         sock.socket().setSoLinger(false, -1);
         sock.socket().setTcpNoDelay(true);
         sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
-        if (sock.connect(addr)) {
-            sendThread.primeConnection();
-        }
+        sock.connect(addr);
         initialized = false;
 
         /*
@@ -205,15 +208,7 @@
      */
     @Override
     SocketAddress getRemoteSocketAddress() {
-        // a lot could go wrong here, so rather than put in a bunch of code
-        // to check for nulls all down the chain let's do it the simple
-        // yet bulletproof way
-        try {
-            return ((SocketChannel) sockKey.channel()).socket()
-                    .getRemoteSocketAddress();
-        } catch (NullPointerException e) {
-            return null;
-        }
+        return remoteSocketAddress;
     }
 
     /**
@@ -224,15 +219,13 @@
      */
     @Override
     SocketAddress getLocalSocketAddress() {
-        // a lot could go wrong here, so rather than put in a bunch of code
-        // to check for nulls all down the chain let's do it the simple
-        // yet bulletproof way
-        try {
-            return ((SocketChannel) sockKey.channel()).socket()
-                    .getLocalSocketAddress();
-        } catch (NullPointerException e) {
-            return null;
-        }
+        return localSocketAddress;
+    }
+    
+    private void updateSocketAddresses() {
+        Socket socket = ((SocketChannel) sockKey.channel()).socket();
+        localSocketAddress = socket.getLocalSocketAddress();
+        remoteSocketAddress = socket.getRemoteSocketAddress();
     }
 
     @Override
@@ -257,6 +250,7 @@
             if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {
                 if (sc.finishConnect()) {
                     updateLastSendAndHeard();
+                    updateSocketAddresses();
                     sendThread.primeConnection();
                 }
             } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
"
zookeeper,43776e4fa233eeda2bdbbb3ca4db5030d2a51a9d,ZOOKEEPER-1136. NEW_LEADER should be queued not sent to match the Zab 1.0 protocol on the twiki (breed via mahadev),2011.09.14 15:56:13,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ByteBufferInputStream.java b/src/java/main/org/apache/zookeeper/server/ByteBufferInputStream.java
index d2f1f7f..e5ac120 100644
--- a/src/java/main/org/apache/zookeeper/server/ByteBufferInputStream.java
+++ b/src/java/main/org/apache/zookeeper/server/ByteBufferInputStream.java
@@ -22,6 +22,9 @@
 import java.io.InputStream;
 import java.nio.ByteBuffer;
 
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.Record;
+
 public class ByteBufferInputStream extends InputStream {
     ByteBuffer bb;
 
@@ -69,4 +72,11 @@
         return n;
     }
 
+    static public void byteBuffer2Record(ByteBuffer bb, Record record)
+            throws IOException {
+        BinaryInputArchive ia;
+        ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));
+        record.deserialize(ia, ""request"");
+    }
+
 }
"
zookeeper,43776e4fa233eeda2bdbbb3ca4db5030d2a51a9d,ZOOKEEPER-1136. NEW_LEADER should be queued not sent to match the Zab 1.0 protocol on the twiki (breed via mahadev),2011.09.14 15:56:13,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ByteBufferOutputStream.java b/src/java/main/org/apache/zookeeper/server/ByteBufferOutputStream.java
new file mode 100644
index 0000000..a2fcc95
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/ByteBufferOutputStream.java
@@ -0,0 +1,52 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+
+public class ByteBufferOutputStream extends OutputStream {
+    ByteBuffer bb;
+    public ByteBufferOutputStream(ByteBuffer bb) {
+        this.bb = bb;
+    }
+    @Override
+    public void write(int b) throws IOException {
+        bb.put((byte)b);
+    }
+    @Override
+    public void write(byte[] b) throws IOException {
+        bb.put(b);
+    }
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+        bb.put(b, off, len);
+    }
+    static public void record2ByteBuffer(Record record, ByteBuffer bb)
+    throws IOException {
+        BinaryOutputArchive oa;
+        oa = BinaryOutputArchive.getArchive(new ByteBufferOutputStream(bb));
+        record.serialize(oa, ""request"");
+    }
+}
"
zookeeper,43776e4fa233eeda2bdbbb3ca4db5030d2a51a9d,ZOOKEEPER-1136. NEW_LEADER should be queued not sent to match the Zab 1.0 protocol on the twiki (breed via mahadev),2011.09.14 15:56:13,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 0690ce9..3987c54 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -880,7 +880,7 @@
                         }
                         assert(record != null);
 
-                        ZooKeeperServer.byteBuffer2Record(bb, record);
+                        ByteBufferInputStream.byteBuffer2Record(bb, record);
                        
                         if (failed && subtxn.getType() != OpCode.error){
                             int ec = post_failed ? Code.RUNTIMEINCONSISTENCY.intValue() 
"
zookeeper,43776e4fa233eeda2bdbbb3ca4db5030d2a51a9d,ZOOKEEPER-1136. NEW_LEADER should be queued not sent to match the Zab 1.0 protocol on the twiki (breed via mahadev),2011.09.14 15:56:13,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index b690817..ab7e6c2 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -255,7 +255,7 @@
             case OpCode.sync: {
                 lastOp = ""SYNC"";
                 SyncRequest syncRequest = new SyncRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request,
+                ByteBufferInputStream.byteBuffer2Record(request.request,
                         syncRequest);
                 rsp = new SyncResponse(syncRequest.getPath());
                 break;
@@ -270,7 +270,7 @@
                 lastOp = ""EXIS"";
                 // TODO we need to figure out the security requirement for this!
                 ExistsRequest existsRequest = new ExistsRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request,
+                ByteBufferInputStream.byteBuffer2Record(request.request,
                         existsRequest);
                 String path = existsRequest.getPath();
                 if (path.indexOf('\0') != -1) {
@@ -284,7 +284,7 @@
             case OpCode.getData: {
                 lastOp = ""GETD"";
                 GetDataRequest getDataRequest = new GetDataRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request,
+                ByteBufferInputStream.byteBuffer2Record(request.request,
                         getDataRequest);
                 DataNode n = zks.getZKDatabase().getNode(getDataRequest.getPath());
                 if (n == null) {
@@ -308,7 +308,7 @@
                 SetWatches setWatches = new SetWatches();
                 // XXX We really should NOT need this!!!!
                 request.request.rewind();
-                ZooKeeperServer.byteBuffer2Record(request.request, setWatches);
+                ByteBufferInputStream.byteBuffer2Record(request.request, setWatches);
                 long relativeZxid = setWatches.getRelativeZxid();
                 zks.getZKDatabase().setWatches(relativeZxid, 
                         setWatches.getDataWatches(), 
@@ -319,7 +319,7 @@
             case OpCode.getACL: {
                 lastOp = ""GETA"";
                 GetACLRequest getACLRequest = new GetACLRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request,
+                ByteBufferInputStream.byteBuffer2Record(request.request,
                         getACLRequest);
                 Stat stat = new Stat();
                 List<ACL> acl = 
@@ -330,7 +330,7 @@
             case OpCode.getChildren: {
                 lastOp = ""GETC"";
                 GetChildrenRequest getChildrenRequest = new GetChildrenRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request,
+                ByteBufferInputStream.byteBuffer2Record(request.request,
                         getChildrenRequest);
                 DataNode n = zks.getZKDatabase().getNode(getChildrenRequest.getPath());
                 if (n == null) {
@@ -353,7 +353,7 @@
             case OpCode.getChildren2: {
                 lastOp = ""GETC"";
                 GetChildren2Request getChildren2Request = new GetChildren2Request();
-                ZooKeeperServer.byteBuffer2Record(request.request,
+                ByteBufferInputStream.byteBuffer2Record(request.request,
                         getChildren2Request);
                 Stat stat = new Stat();
                 DataNode n = zks.getZKDatabase().getNode(getChildren2Request.getPath());
"
zookeeper,43776e4fa233eeda2bdbbb3ca4db5030d2a51a9d,ZOOKEEPER-1136. NEW_LEADER should be queued not sent to match the Zab 1.0 protocol on the twiki (breed via mahadev),2011.09.14 15:56:13,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 30ebf68..6d19f5e 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -488,32 +488,32 @@
             switch (request.type) {
                 case OpCode.create:
                 CreateRequest createRequest = new CreateRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request, createRequest);
+                ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
                 pRequest2Txn(request.type, zks.getNextZxid(), request, createRequest);
                 break;
             case OpCode.delete:
                 DeleteRequest deleteRequest = new DeleteRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request, deleteRequest);
+                ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);
                 pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest);
                 break;
             case OpCode.setData:
                 SetDataRequest setDataRequest = new SetDataRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request, setDataRequest);
+                ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);
                 pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest);
                 break;
             case OpCode.setACL:
                 SetACLRequest setAclRequest = new SetACLRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request, setAclRequest);
+                ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);
                 pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest);
                 break;
             case OpCode.check:
                 CheckVersionRequest checkRequest = new CheckVersionRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request, checkRequest);
+                ByteBufferInputStream.byteBuffer2Record(request.request, checkRequest);
                 pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest);
                 break;
             case OpCode.multi:
                 MultiTransactionRecord multiRequest = new MultiTransactionRecord();
-                ZooKeeperServer.byteBuffer2Record(request.request, multiRequest);
+                ByteBufferInputStream.byteBuffer2Record(request.request, multiRequest);
                 List<Txn> txns = new ArrayList<Txn>();
 
                 //Each op in a multi-op must have the same zxid!
"
zookeeper,43776e4fa233eeda2bdbbb3ca4db5030d2a51a9d,ZOOKEEPER-1136. NEW_LEADER should be queued not sent to match the Zab 1.0 protocol on the twiki (breed via mahadev),2011.09.14 15:56:13,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index c085bfb..2946030 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -661,13 +661,6 @@
         }
     }
 
-    static public void byteBuffer2Record(ByteBuffer bb, Record record)
-            throws IOException {
-        BinaryInputArchive ia;
-        ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));
-        record.deserialize(ia, ""request"");
-    }
-
     public static int getSnapCount() {
         String sc = System.getProperty(""zookeeper.snapCount"");
         try {
@@ -860,7 +853,7 @@
         if (h.getType() == OpCode.auth) {
             LOG.info(""got auth packet "" + cnxn.getRemoteSocketAddress());
             AuthPacket authPacket = new AuthPacket();
-            ZooKeeperServer.byteBuffer2Record(incomingBuffer, authPacket);
+            ByteBufferInputStream.byteBuffer2Record(incomingBuffer, authPacket);
             String scheme = authPacket.getScheme();
             AuthenticationProvider ap = ProviderRegistry.getProvider(scheme);
             Code authReturn = KeeperException.Code.AUTHFAILED;
@@ -917,7 +910,7 @@
     private Record processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn) throws IOException {
         LOG.debug(""Responding to client SASL token."");
         GetSASLRequest clientTokenRecord = new GetSASLRequest();
-        byteBuffer2Record(incomingBuffer,clientTokenRecord);
+        ByteBufferInputStream.byteBuffer2Record(incomingBuffer,clientTokenRecord);
         byte[] clientToken = clientTokenRecord.getToken();
         LOG.debug(""Size of client SASL token: "" + clientToken.length);
         byte[] responseToken = null;
"
zookeeper,43776e4fa233eeda2bdbbb3ca4db5030d2a51a9d,ZOOKEEPER-1136. NEW_LEADER should be queued not sent to match the Zab 1.0 protocol on the twiki (breed via mahadev),2011.09.14 15:56:13,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index fb9dbde..6638b1f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -281,7 +281,7 @@
     
     long epoch = -1;
     boolean waitingForNewEpoch = true;
-    boolean readyToStart = false;
+    volatile boolean readyToStart = false;
     
     /**
      * This method is main function that is called to lead
@@ -309,13 +309,17 @@
             cnxAcceptor = new LearnerCnxAcceptor();
             cnxAcceptor.start();
             
+            readyToStart = true;
             long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());
             self.setAcceptedEpoch(epoch);
+            
             zk.setZxid(ZxidUtils.makeZxid(epoch, 0));
             
+            /*
             synchronized(this){
                 lastProposed = zk.getZxid();
             }
+            */
             
             newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),
                     null, null);
@@ -328,7 +332,6 @@
             outstandingProposals.put(newLeaderProposal.packet.getZxid(), newLeaderProposal);
             newLeaderProposal.ackSet.add(self.getId());
             
-            readyToStart = true;
             waitForEpochAck(self.getId(), leaderStateSummary);
             self.setCurrentEpoch(epoch);
 
"
zookeeper,43776e4fa233eeda2bdbbb3ca4db5030d2a51a9d,ZOOKEEPER-1136. NEW_LEADER should be queued not sent to match the Zab 1.0 protocol on the twiki (breed via mahadev),2011.09.14 15:56:13,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 5ee3e7f..a97a543 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -290,18 +290,17 @@
         	}
         	QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);
         	writePacket(ackNewEpoch, true);
-        	readPacket(qp);
+            return ZxidUtils.makeZxid(newEpoch, 0);
         } else {
         	if (newEpoch > self.getAcceptedEpoch()) {
         		self.setAcceptedEpoch(newEpoch);
         	}
+            if (qp.getType() != Leader.NEWLEADER) {
+                LOG.error(""First packet should have been NEWLEADER"");
+                throw new IOException(""First packet should have been NEWLEADER"");
+            }
+            return qp.getZxid();
         }
-        if (qp.getType() != Leader.NEWLEADER) {
-            LOG.error(""First packet should have been NEWLEADER"");
-            throw new IOException(""First packet should have been NEWLEADER"");
-        }
-        
-        return qp.getZxid();
     } 
     
     /**
@@ -353,6 +352,11 @@
             zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());
                         
             long lastQueued = 0;
+
+            // in V1.0 we take a snapshot when we get the NEWLEADER message, but in pre V1.0
+            // we take the snapshot at the UPDATE, since V1.0 also gets the UPDATE (after the NEWLEADER)
+            // we need to make sure that we don't take the snapshot twice.
+            boolean snapshotTaken = false;
             // we are now going to start getting transactions to apply followed by an UPTODATE
             outerLoop:
             while (self.isRunning()) {
@@ -362,7 +366,7 @@
                     PacketInFlight pif = new PacketInFlight();
                     pif.hdr = new TxnHeader();
                     pif.rec = SerializeUtils.deserializeTxn(qp.getData(), pif.hdr);
-                    if (pif.hdr.    getZxid() != lastQueued + 1) {
+                    if (pif.hdr.getZxid() != lastQueued + 1) {
                     LOG.warn(""Got zxid 0x""
                             + Long.toHexString(pif.hdr.getZxid())
                             + "" expected 0x""
@@ -386,9 +390,16 @@
                     zk.getZKDatabase().processTxn(hdr, txn);
                     break;
                 case Leader.UPTODATE:
-                    zk.takeSnapshot();
+                    if (!snapshotTaken) {
+                        zk.takeSnapshot();
+                    }
                     self.cnxnFactory.setZooKeeperServer(zk);                
                     break outerLoop;
+                case Leader.NEWLEADER: // it will be NEWLEADER in v1.0
+                    zk.takeSnapshot();
+                    snapshotTaken = true;
+                    writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);
+                    break;
                 }
             }
         }
"
zookeeper,43776e4fa233eeda2bdbbb3ca4db5030d2a51a9d,ZOOKEEPER-1136. NEW_LEADER should be queued not sent to match the Zab 1.0 protocol on the twiki (breed via mahadev),2011.09.14 15:56:13,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index 2a77e49..9c28663 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -39,8 +39,8 @@
 import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.KeeperException.SessionExpiredException;
 import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.server.ByteBufferInputStream;
 import org.apache.zookeeper.server.Request;
-import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.server.quorum.Leader.Proposal;
 import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
@@ -233,6 +233,7 @@
     @Override
     public void run() {
         try {            
+            sock.setSoTimeout(leader.self.getTickTime()*leader.self.getInitLimit());
             ia = BinaryInputArchive.getArchive(new BufferedInputStream(sock
                     .getInputStream()));
             bufferedOutput = new BufferedOutputStream(sock.getOutputStream());
@@ -252,7 +253,7 @@
             		this.sid = bbsid.getLong();
             	} else {
             		LearnerInfo li = new LearnerInfo();
-            		ZooKeeperServer.byteBuffer2Record(ByteBuffer.wrap(learnerInfoData), li);
+            		ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(learnerInfoData), li);
             		this.sid = li.getServerid();
             		this.version = li.getProtocolVersion();
             	}
@@ -271,37 +272,33 @@
             
             long peerLastZxid;
             StateSummary ss = null;
-            if (learnerType == LearnerType.PARTICIPANT) {
-            	long zxid = qp.getZxid();
-				long newEpoch = leader.getEpochToPropose(this.getSid(), lastAcceptedEpoch);
-				
-				if (this.getVersion() < 0x10000) {
-					// we are going to have to extrapolate the epoch information
-					long epoch = ZxidUtils.getEpochFromZxid(zxid);
-					ss = new StateSummary(epoch, zxid);
-					// fake the message
-					leader.waitForEpochAck(this.getSid(), ss);
-				} else {
-					byte ver[] = new byte[4];
-					ByteBuffer.wrap(ver).putInt(0x10000);
-				    QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, ZxidUtils.makeZxid(newEpoch, 0), ver, null);
-				    oa.writeRecord(newEpochPacket, ""packet"");
-		            bufferedOutput.flush();
-		            QuorumPacket ackEpochPacket = new QuorumPacket();
-		            ia.readRecord(ackEpochPacket, ""packet"");
-		            if (ackEpochPacket.getType() != Leader.ACKEPOCH) {
-		             	LOG.error(ackEpochPacket.toString()
-		                        + "" is not ACKEPOCH"");
-		                return;
-		            }
-            		ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());
-		            ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());
-		            leader.waitForEpochAck(this.getSid(), ss);
-				}
-            	peerLastZxid = ss.getLastZxid();
+            long zxid = qp.getZxid();
+            long newEpoch = leader.getEpochToPropose(this.getSid(), lastAcceptedEpoch);
+            
+            if (this.getVersion() < 0x10000) {
+                // we are going to have to extrapolate the epoch information
+                long epoch = ZxidUtils.getEpochFromZxid(zxid);
+                ss = new StateSummary(epoch, zxid);
+                // fake the message
+                leader.waitForEpochAck(this.getSid(), ss);
             } else {
-            	peerLastZxid = qp.getZxid();
+                byte ver[] = new byte[4];
+                ByteBuffer.wrap(ver).putInt(0x10000);
+                QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, ZxidUtils.makeZxid(newEpoch, 0), ver, null);
+                oa.writeRecord(newEpochPacket, ""packet"");
+                bufferedOutput.flush();
+                QuorumPacket ackEpochPacket = new QuorumPacket();
+                ia.readRecord(ackEpochPacket, ""packet"");
+                if (ackEpochPacket.getType() != Leader.ACKEPOCH) {
+                    LOG.error(ackEpochPacket.toString()
+                            + "" is not ACKEPOCH"");
+                    return;
+				}
+                ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());
+                ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());
+                leader.waitForEpochAck(this.getSid(), ss);
             }
+            peerLastZxid = ss.getLastZxid();
             
             /* the default to send to the follower */
             int packetToSend = Leader.SNAP;
@@ -390,9 +387,13 @@
                 rl.unlock();
             }
 
-            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,
-                    leaderLastZxid, null, null);
-            oa.writeRecord(newLeaderQP, ""packet"");
+             QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,
+                    ZxidUtils.makeZxid(newEpoch, 0), null, null);
+             if (getVersion() < 0x10000) {
+                oa.writeRecord(newLeaderQP, ""packet"");
+            } else {
+                queuedPackets.add(newLeaderQP);
+            }
             bufferedOutput.flush();
             //Need to set the zxidToSend to the latest zxid
             if (packetToSend == Leader.SNAP) {
@@ -415,13 +416,6 @@
             }
             bufferedOutput.flush();
             
-            // Mutation packets will be queued during the serialize,
-            // so we need to mark when the peer can actually start
-            // using the data
-            //
-            queuedPackets
-                    .add(new QuorumPacket(Leader.UPTODATE, -1, null, null));
-
             // Start sending packets
             new Thread() {
                 public void run() {
@@ -456,6 +450,12 @@
                     leader.zk.wait(20);
                 }
             }
+            // Mutation packets will be queued during the serialize,
+            // so we need to mark when the peer can actually start
+            // using the data
+            //
+            queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));
+
             
             while (true) {
                 qp = new QuorumPacket();
"
zookeeper,d84dc077d576b7cdfbfd003e3425fab85ca29a44,ZOOKEEPER-961. Watch recovery after disconnection when connection string contains a prefix. (Matthias Spycher via mahadev),2011.09.14 14:43:56,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 78b2eb2..723efa1 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -18,27 +18,29 @@
 
 package org.apache.zookeeper;
 
+import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.io.InputStreamReader;
 import java.lang.Thread.UncaughtExceptionHandler;
+import java.net.ConnectException;
 import java.net.InetSocketAddress;
+import java.net.Socket;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.Random;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.concurrent.LinkedBlockingQueue;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.net.ConnectException;
-import java.net.Socket;
+
+import javax.security.auth.login.LoginException;
+import javax.security.sasl.SaslException;
 
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.BinaryOutputArchive;
 import org.apache.jute.Record;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.AsyncCallback.ACLCallback;
 import org.apache.zookeeper.AsyncCallback.Children2Callback;
 import org.apache.zookeeper.AsyncCallback.ChildrenCallback;
@@ -71,9 +73,8 @@
 import org.apache.zookeeper.proto.WatcherEvent;
 import org.apache.zookeeper.server.ByteBufferInputStream;
 import org.apache.zookeeper.server.ZooTrace;
-
-import javax.security.auth.login.LoginException;
-import javax.security.sasl.SaslException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * This class manages the socket i/o for the client. ClientCnxn maintains a list
@@ -748,8 +749,13 @@
                     String serverPath = event.getPath();
                     if(serverPath.compareTo(chrootPath)==0)
                         event.setPath(""/"");
-                    else
+                    else if (serverPath.length() > chrootPath.length())
                         event.setPath(serverPath.substring(chrootPath.length()));
+                    else {
+                    	LOG.warn(""Got server path "" + event.getPath()
+                    			+ "" which is too short for chroot path ""
+                    			+ chrootPath);
+                    }
                 }
 
                 WatchedEvent we = new WatchedEvent(event);
@@ -843,19 +849,22 @@
                 // Only send if there's a pending watch
                 // TODO: here we have the only remaining use of zooKeeper in
                 // this class. It's to be eliminated!
-                if (!disableAutoWatchReset
-                        && (!zooKeeper.getDataWatches().isEmpty()
-                                || !zooKeeper.getExistWatches().isEmpty() || !zooKeeper
-                                .getChildWatches().isEmpty())) {
-                    SetWatches sw = new SetWatches(lastZxid,
-                            zooKeeper.getDataWatches(),
-                            zooKeeper.getExistWatches(),
-                            zooKeeper.getChildWatches());
-                    RequestHeader h = new RequestHeader();
-                    h.setType(ZooDefs.OpCode.setWatches);
-                    h.setXid(-8);
-                    Packet packet = new Packet(h, new ReplyHeader(), sw, null, null);
-                    outgoingQueue.addFirst(packet);
+                if (!disableAutoWatchReset) {
+                    List<String> dataWatches = zooKeeper.getDataWatches();
+                    List<String> existWatches = zooKeeper.getExistWatches();
+                    List<String> childWatches = zooKeeper.getChildWatches();
+                    if (!dataWatches.isEmpty()
+                                || !existWatches.isEmpty() || !childWatches.isEmpty()) {
+                        SetWatches sw = new SetWatches(lastZxid,
+                                prependChroot(dataWatches),
+                                prependChroot(existWatches),
+                                prependChroot(childWatches));
+                        RequestHeader h = new RequestHeader();
+                        h.setType(ZooDefs.OpCode.setWatches);
+                        h.setXid(-8);
+                        Packet packet = new Packet(h, new ReplyHeader(), sw, null, null);
+                        outgoingQueue.addFirst(packet);
+                    }
                 }
 
                 for (AuthData id : authInfo) {
@@ -873,6 +882,23 @@
             }
         }
 
+        private List<String> prependChroot(List<String> paths) {
+            if (chrootPath != null && !paths.isEmpty()) {
+                for (int i = 0; i < paths.size(); ++i) {
+                    String clientPath = paths.get(i);
+                    String serverPath;
+                    // handle clientPath = ""/""
+                    if (clientPath.length() == 1) {
+                        serverPath = chrootPath;
+                    } else {
+                        serverPath = chrootPath + clientPath;
+                    }
+                    paths.set(i, serverPath);
+                }
+            }
+            return paths;
+        }
+
         private void sendPing() {
             lastPingSentNs = System.nanoTime();
             RequestHeader h = new RequestHeader(-2, OpCode.ping);
@@ -888,13 +914,6 @@
         private int pingRwTimeout = minPingRwTimeout;
 
         private void startConnect() throws IOException {
-            if(!isFirstConnect){
-                try {
-                    Thread.sleep(r.nextInt(1000));
-                } catch (InterruptedException e) {
-                    LOG.warn(""Unexpected exception"", e);
-                }
-            }
             state = States.CONNECTING;
 
             InetSocketAddress addr;
@@ -937,8 +956,15 @@
             while (state.isAlive()) {
                 try {
                     if (!clientCnxnSocket.isConnected()) {
+                        if(!isFirstConnect){
+                            try {
+                                Thread.sleep(r.nextInt(1000));
+                            } catch (InterruptedException e) {
+                                LOG.warn(""Unexpected exception"", e);
+                            }
+                        }
                         // don't re-establish connection if we are closing
-                        if (closing) {
+                        if (closing || !state.isAlive()) {
                             break;
                         }
                         startConnect();
"
zookeeper,a7bcf047f577949e96396588d23fde0107ff3b19,ZOOKEEPER-1108. Various bugs in zoo_add_auth in C. (Dheeraj Agrawal via mahadev),2011.09.09 11:27:19,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 9ea59ca..78b2eb2 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1204,7 +1204,7 @@
 
     private int xid = 1;
 
-    private volatile States state;
+    private volatile States state = States.NOT_CONNECTED;
 
     synchronized private int getXid() {
         return xid++;
"
zookeeper,a7bcf047f577949e96396588d23fde0107ff3b19,ZOOKEEPER-1108. Various bugs in zoo_add_auth in C. (Dheeraj Agrawal via mahadev),2011.09.09 11:27:19,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 4fa7376..e82eaa0 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -310,7 +310,7 @@
 
     public enum States {
         CONNECTING, ASSOCIATING, CONNECTED, CONNECTEDREADONLY,
-        CLOSED, AUTH_FAILED;
+        CLOSED, AUTH_FAILED, NOT_CONNECTED;
 
         public boolean isAlive() {
             return this != CLOSED && this != AUTH_FAILED;
"
zookeeper,1d6325605f1c6344c045839c043d239a6612d18a,"ZOOKEEPER-731. Zookeeper#delete , #create - async versions miss a verb in the javadoc (Thomas Koch via camille)",2011.09.06 07:58:46,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 342f160..4fa7376 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -87,8 +87,10 @@
     public static final String ZOOKEEPER_CLIENT_CNXN_SOCKET = ""zookeeper.clientCnxnSocket"";
 
     protected final ClientCnxn cnxn;
-    private static final Logger LOG = LoggerFactory.getLogger(ZooKeeper.class);
+    private static final Logger LOG;
     static {
+        //Keep these two lines together to keep the initialization order explicit
+        LOG = LoggerFactory.getLogger(ZooKeeper.class);
         Environment.logEnv(""Client environment:"", LOG);
     }
 
"
zookeeper,634243cc4bb695e1679584dc80af8e33172309ad,"ZOOKEEPER-731. Zookeeper#delete , #create - async versions miss a verb in the javadoc (Thomas Koch via camille)",2011.09.06 05:03:31,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 00bac9f..342f160 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -59,6 +59,12 @@
  * server before its session ID expires. If successful, the application can
  * continue to use the client.
  * <p>
+ * The ZooKeeper API methods are either synchronous or asynchronous. Synchronous
+ * methods blocks until the server has responded. Asynchronous methods just queue
+ * the request for sending and return immediately. They take a callback object that
+ * will be executed either on successful execution of the request or on error with
+ * an appropriate return code (rc) indicating the error.
+ * <p>
  * Some successful ZooKeeper API calls can leave watches on the ""data nodes"" in
  * the ZooKeeper server. Other successful ZooKeeper API calls can trigger those
  * watches. Once a watch is triggered, an event will be delivered to the client
@@ -77,16 +83,15 @@
  *
  */
 public class ZooKeeper {
-    private static final Logger LOG;
+
     public static final String ZOOKEEPER_CLIENT_CNXN_SOCKET = ""zookeeper.clientCnxnSocket"";
 
+    protected final ClientCnxn cnxn;
+    private static final Logger LOG = LoggerFactory.getLogger(ZooKeeper.class);
     static {
-        LOG = LoggerFactory.getLogger(ZooKeeper.class);
-
         Environment.logEnv(""Client environment:"", LOG);
     }
 
-
     private final ZKWatchManager watchManager = new ZKWatchManager();
 
     List<String> getDataWatches() {
@@ -108,7 +113,7 @@
         }
     }
 
-/**
+    /**
      * Manage watchers & handle events generated by the ClientCnxn object.
      *
      * We are implementing this as a nested class of ZooKeeper so that
@@ -132,7 +137,8 @@
         }
 
         /* (non-Javadoc)
-         * @see org.apache.zookeeper.ClientWatchManager#materialize(Event.KeeperState, Event.EventType, java.lang.String)
+         * @see org.apache.zookeeper.ClientWatchManager#materialize(Event.KeeperState, 
+         *                                                        Event.EventType, java.lang.String)
          */
         @Override
         public Set<Watcher> materialize(Watcher.Event.KeeperState state,
@@ -318,8 +324,6 @@
         }
     }
 
-    protected final ClientCnxn cnxn;
-
     /**
      * To create a ZooKeeper client object, the application needs to pass a
      * connection string containing a comma separated list of host:port pairs,
@@ -780,8 +784,7 @@
     }
 
     /**
-     * The Asynchronous version of create. The request doesn't actually until
-     * the asynchronous callback is called.
+     * The asynchronous version of create.
      *
      * @see #create(String, byte[], List, CreateMode)
      */
@@ -920,12 +923,8 @@
         return new Transaction(this);
     }
 
-  
-
-    
     /**
-     * The Asynchronous version of delete. The request doesn't actually until
-     * the asynchronous callback is called.
+     * The asynchronous version of delete.
      *
      * @see #delete(String, int)
      */
@@ -1031,10 +1030,9 @@
     }
 
     /**
-     * The Asynchronous version of exists. The request doesn't actually until
-     * the asynchronous callback is called.
+     * The asynchronous version of exists.
      *
-     * @see #exists(String, boolean)
+     * @see #exists(String, Watcher)
      */
     public void exists(final String path, Watcher watcher,
             StatCallback cb, Object ctx)
@@ -1061,8 +1059,7 @@
     }
 
     /**
-     * The Asynchronous version of exists. The request doesn't actually until
-     * the asynchronous callback is called.
+     * The asynchronous version of exists.
      *
      * @see #exists(String, boolean)
      */
@@ -1144,8 +1141,7 @@
     }
 
     /**
-     * The Asynchronous version of getData. The request doesn't actually until
-     * the asynchronous callback is called.
+     * The asynchronous version of getData.
      *
      * @see #getData(String, Watcher, Stat)
      */
@@ -1174,8 +1170,7 @@
     }
 
     /**
-     * The Asynchronous version of getData. The request doesn't actually until
-     * the asynchronous callback is called.
+     * The asynchronous version of getData.
      *
      * @see #getData(String, boolean, Stat)
      */
@@ -1235,8 +1230,7 @@
     }
 
     /**
-     * The Asynchronous version of setData. The request doesn't actually until
-     * the asynchronous callback is called.
+     * The asynchronous version of setData.
      *
      * @see #setData(String, byte[], int)
      */
@@ -1297,8 +1291,7 @@
     }
 
     /**
-     * The Asynchronous version of getACL. The request doesn't actually until
-     * the asynchronous callback is called.
+     * The asynchronous version of getACL.
      *
      * @see #getACL(String, Stat)
      */
@@ -1366,8 +1359,7 @@
     }
 
     /**
-     * The Asynchronous version of setACL. The request doesn't actually until
-     * the asynchronous callback is called.
+     * The asynchronous version of setACL.
      *
      * @see #setACL(String, List, int)
      */
@@ -1465,8 +1457,7 @@
     }
 
     /**
-     * The Asynchronous version of getChildren. The request doesn't actually
-     * until the asynchronous callback is called.
+     * The asynchronous version of getChildren.
      *
      * @see #getChildren(String, Watcher)
      */
@@ -1495,8 +1486,7 @@
     }
 
     /**
-     * The Asynchronous version of getChildren. The request doesn't actually
-     * until the asynchronous callback is called.
+     * The asynchronous version of getChildren.
      *
      * @see #getChildren(String, boolean)
      */
@@ -1593,8 +1583,7 @@
     }
 
     /**
-     * The Asynchronous version of getChildren. The request doesn't actually
-     * until the asynchronous callback is called.
+     * The asynchronous version of getChildren.
      *
      * @since 3.3.0
      * 
@@ -1625,8 +1614,7 @@
     }
 
     /**
-     * The Asynchronous version of getChildren. The request doesn't actually
-     * until the asynchronous callback is called.
+     * The asynchronous version of getChildren.
      *
      * @since 3.3.0
      * 
"
zookeeper,27d045af5c6b382fc5c787a5125f63ea730dc9bd,"ZOOKEEPER-1154, ZOOKEEPER-1156:  Data inconsistency when the node(s) with the highest zxid is not present at the time of leader election Log truncation truncating log too much - can cause data loss",2011.09.03 08:07:00,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 05d8431..471fe10 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -401,21 +401,32 @@
         long position;
         protected PositionInputStream(InputStream in) {
             super(in);
+            position = 0;
         }
         
         @Override
         public int read() throws IOException {
             int rc = super.read();
-            if (rc > 0) {
+            if (rc > -1) {
                 position++;
             }
             return rc;
         }
+
+        public int read(byte[] b) throws IOException {
+            int rc = super.read(b);
+            if (rc > 0) {
+                position += rc;
+            }
+            return rc;            
+        }
         
         @Override
         public int read(byte[] b, int off, int len) throws IOException {
             int rc = super.read(b, off, len);
-            position += rc;
+            if (rc > 0) {
+                position += rc;
+            }
             return rc;
         }
         
@@ -430,6 +441,21 @@
         public long getPosition() {
             return position;
         }
+
+        @Override
+        public boolean markSupported() {
+            return false;
+        }
+
+        @Override
+        public void mark(int readLimit) {
+            throw new UnsupportedOperationException(""mark"");
+        }
+
+        @Override
+        public void reset() {
+            throw new UnsupportedOperationException(""reset"");
+        }
     }
     
     /**
@@ -505,7 +531,7 @@
         }
 
         /**
-         * read the header fomr the inputarchive
+         * read the header from the inputarchive
          * @param ia the inputarchive to be read from
          * @param is the inputstream
          * @throws IOException
"
zookeeper,27d045af5c6b382fc5c787a5125f63ea730dc9bd,"ZOOKEEPER-1154, ZOOKEEPER-1156:  Data inconsistency when the node(s) with the highest zxid is not present at the time of leader election Log truncation truncating log too much - can cause data loss",2011.09.03 08:07:00,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index e3d9f20..2a77e49 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -319,14 +319,52 @@
                 rl.lock();        
                 final long maxCommittedLog = leader.zk.getZKDatabase().getmaxCommittedLog();
                 final long minCommittedLog = leader.zk.getZKDatabase().getminCommittedLog();
+                LOG.info(""Synchronizing with Follower sid: "" + this.sid
+                        +"" maxCommittedLog =""+Long.toHexString(maxCommittedLog)
+                        +"" minCommittedLog = ""+Long.toHexString(minCommittedLog)
+                        +"" peerLastZxid = ""+Long.toHexString(peerLastZxid));
+
                 LinkedList<Proposal> proposals = leader.zk.getZKDatabase().getCommittedLog();
+
                 if (proposals.size() != 0) {
                     if ((maxCommittedLog >= peerLastZxid)
                             && (minCommittedLog <= peerLastZxid)) {
-                        packetToSend = Leader.DIFF;
-                        zxidToSend = maxCommittedLog;
+
+                        // as we look through proposals, this variable keeps track of previous
+                        // proposal Id.
+                        long prevProposalZxid = minCommittedLog;
+
+                        // Keep track of whether we are about to send the first packet.
+                        // Before sending the first packet, we have to tell the learner
+                        // whether to expect a trunc or a diff
+                        boolean firstPacket=true;
+
                         for (Proposal propose: proposals) {
-                            if (propose.packet.getZxid() > peerLastZxid) {
+                            // skip the proposals the peer already has
+                            if (propose.packet.getZxid() <= peerLastZxid) {
+                                prevProposalZxid = propose.packet.getZxid();
+                                continue;
+                            } else {
+                                // If we are sending the first packet, figure out whether to trunc
+                                // in case the follower has some proposals that the leader doesn't
+                                if (firstPacket) {
+                                    firstPacket = false;
+                                    // Does the peer have some proposals that the leader hasn't seen yet
+                                    if (prevProposalZxid < peerLastZxid) {
+                                        // send a trunc message before sending the diff
+                                        packetToSend = Leader.TRUNC;
+                                        LOG.info(""Sending TRUNC"");
+                                        zxidToSend = prevProposalZxid;
+                                        updates = zxidToSend;
+                                    } 
+                                    else {
+                                        // Just send the diff
+                                        packetToSend = Leader.DIFF;
+                                        LOG.info(""Sending diff"");
+                                        zxidToSend = maxCommittedLog;        
+                                    }
+
+                                }
                                 queuePacket(propose.packet);
                                 QuorumPacket qcommit = new QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),
                                         null, null);
@@ -341,7 +379,7 @@
                 } else {
                     // just let the state transfer happen
                 }               
-                
+
                 leaderLastZxid = leader.startForwarding(this, updates);
                 if (peerLastZxid == leaderLastZxid) {
                     // We are in sync so we'll do an empty diff
"
zookeeper,ff433f1652339b331f0388ac34648f22e57ebf89,ZOOKEEPER-1168. ZooKeeper fails to run with IKVM (Andrew Finnell via phunt),2011.09.02 02:15:08,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java b/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java
index c14f0cf..0e12d13 100644
--- a/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java
+++ b/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java
@@ -24,6 +24,7 @@
 
 import javax.management.JMException;
 import javax.management.MBeanServer;
+import javax.management.MBeanServerFactory;
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
 
@@ -39,7 +40,7 @@
 public class MBeanRegistry {
     private static final Logger LOG = LoggerFactory.getLogger(MBeanRegistry.class);
     
-    private static MBeanRegistry instance=new MBeanRegistry(); 
+    private static MBeanRegistry instance = new MBeanRegistry(); 
     
     private Map<ZKMBeanInfo, String> mapBean2Path =
         new ConcurrentHashMap<ZKMBeanInfo, String>();
@@ -47,10 +48,31 @@
     private Map<String, ZKMBeanInfo> mapName2Bean =
         new ConcurrentHashMap<String, ZKMBeanInfo>();
 
-    public static MBeanRegistry getInstance(){
+    private MBeanServer mBeanServer;
+
+    public static MBeanRegistry getInstance() {
         return instance;
     }
-    
+
+    public MBeanRegistry () {
+        try {
+            mBeanServer = ManagementFactory.getPlatformMBeanServer();        
+        } catch (Error e) {
+            // Account for running within IKVM and create a new MBeanServer
+            // if the PlatformMBeanServer does not exist.
+            mBeanServer =  MBeanServerFactory.createMBeanServer();
+        }
+    }
+
+    /**
+     * Return the underlying MBeanServer that is being
+     * used to register MBean's. The returned MBeanServer
+     * may be a new empty MBeanServer if running through IKVM.
+     */
+    public MBeanServer getPlatformMBeanServer() {
+        return mBeanServer;
+    }
+
     /**
      * Registers a new MBean with the platform MBean server. 
      * @param bean the bean being registered
@@ -71,10 +93,9 @@
         mapName2Bean.put(bean.getName(), bean);
         if(bean.isHidden())
             return;
-        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
         ObjectName oname = makeObjectName(path, bean);
         try {
-            mbs.registerMBean(bean, oname);
+            mBeanServer.registerMBean(bean, oname);
         } catch (JMException e) {
             LOG.warn(""Failed to register MBean "" + bean.getName());
             throw e;
@@ -90,9 +111,8 @@
         if(path==null)
             return;
         if (!bean.isHidden()) {
-            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
             try {
-                mbs.unregisterMBean(makeObjectName(path, bean));
+                mBeanServer.unregisterMBean(makeObjectName(path, bean));
             } catch (JMException e) {
                 LOG.warn(""Failed to unregister MBean "" + bean.getName());
                 throw e;
"
zookeeper,ff433f1652339b331f0388ac34648f22e57ebf89,ZOOKEEPER-1168. ZooKeeper fails to run with IKVM (Andrew Finnell via phunt),2011.09.02 02:15:08,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java b/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
index 4e0814b..64e1942 100644
--- a/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
+++ b/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
@@ -18,7 +18,6 @@
 
 package org.apache.zookeeper.jmx;
 
-import java.lang.management.ManagementFactory;
 import java.util.Enumeration;
 
 import javax.management.JMException;
@@ -45,7 +44,7 @@
             return;
         }
         
-        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+        MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();
 
         // Create and Register the top level Log4J MBean
         HierarchyDynamicMBean hdm = new HierarchyDynamicMBean();
"
zookeeper,611e0364c198c39ab0445c35da04820bd8a0c3f2,ZOOKEEPER-1140. server shutdown is not stopping threads. (laxman via mahadev),2011.08.30 15:37:07,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index afc172e..e3d9f20 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -523,17 +523,17 @@
             LOG.warn(""******* GOODBYE "" 
                     + (sock != null ? sock.getRemoteSocketAddress() : ""<null>"")
                     + "" ********"");
-            // Send the packet of death
-            try {
-                queuedPackets.put(proposalOfDeath);
-            } catch (InterruptedException e) {
-                LOG.warn(""Ignoring unexpected exception"", e);
-            }
             shutdown();
         }
     }
 
     public void shutdown() {
+        // Send the packet of death
+        try {
+            queuedPackets.put(proposalOfDeath);
+        } catch (InterruptedException e) {
+            LOG.warn(""Ignoring unexpected exception"", e);
+        }
         try {
             if (sock != null && !sock.isClosed()) {
                 sock.close();
"
zookeeper,611e0364c198c39ab0445c35da04820bd8a0c3f2,ZOOKEEPER-1140. server shutdown is not stopping threads. (laxman via mahadev),2011.08.30 15:37:07,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 24f2739..c53043e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -671,33 +671,36 @@
                             logFactory, this,
                             new ZooKeeperServer.BasicDataTreeBuilder(),
                             this.zkDb);
-                    try {
-                        // Instead of starting roZk immediately, wait some grace
-                        // period before we decide we're partitioned.
-                        //
-                        // Thread is used here because otherwise it would require
-                        // changes in each of election strategy classes which is
-                        // unnecessary code coupling.
-                        new Thread() {
-                            public void run() {
-                                try {
-                                    // lower-bound grace period to 2 secs
-                                    sleep(Math.max(2000, tickTime));
-                                    if (ServerState.LOOKING.equals(getPeerState())) {
-                                        roZk.startup();
-                                        LOG.info(""Read-only server started"");
-                                    }
-                                } catch (Exception e) {
-                                    LOG.error(""FAILED to start ReadOnlyZooKeeperServer"", e);
-                                }
-                            }
-                        }.start();
 
+                    // Instead of starting roZk immediately, wait some grace
+                    // period before we decide we're partitioned.
+                    //
+                    // Thread is used here because otherwise it would require
+                    // changes in each of election strategy classes which is
+                    // unnecessary code coupling.
+                    Thread roZkMgr = new Thread() {
+                        public void run() {
+                            try {
+                                // lower-bound grace period to 2 secs
+                                sleep(Math.max(2000, tickTime));
+                                if (ServerState.LOOKING.equals(getPeerState())) {
+                                    roZk.startup();
+                                }
+                            } catch (Exception e) {
+                                LOG.error(""FAILED to start ReadOnlyZooKeeperServer"", e);
+                            }
+                        }
+                    };
+                    try {
+                        roZkMgr.start();
                         setCurrentVote(makeLEStrategy().lookForLeader());
                     } catch (Exception e) {
                         LOG.warn(""Unexpected exception"",e);
                         setPeerState(ServerState.LOOKING);
                     } finally {
+                        // If the thread is in the the grace period, interrupt
+                        // to come out of waiting.
+                        roZkMgr.interrupt();
                         roZk.shutdown();
                     }
                     break;
"
zookeeper,611e0364c198c39ab0445c35da04820bd8a0c3f2,ZOOKEEPER-1140. server shutdown is not stopping threads. (laxman via mahadev),2011.08.30 15:37:07,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java
index 35ffafc..3cbfcaa 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java
@@ -38,6 +38,7 @@
  */
 public class ReadOnlyZooKeeperServer extends QuorumZooKeeperServer {
 
+    private volatile boolean shutdown = false;
     ReadOnlyZooKeeperServer(FileTxnSnapLog logFactory, QuorumPeer self,
             DataTreeBuilder treeBuilder, ZKDatabase zkDb) {
         super(logFactory, self.tickTime, self.minSessionTimeout, self.maxSessionTimeout,
@@ -54,11 +55,16 @@
     }
 
     @Override
-    public void startup() {
+    public synchronized void startup() {
+        // check to avoid startup follows shutdown
+        if (shutdown) {
+            LOG.warn(""Not starting Read-only server as startup follows shutdown!"");
+            return;
+        }
         registerJMX(new ReadOnlyBean(this), self.jmxLocalPeerBean);
         super.startup();
-
         self.cnxnFactory.setZooKeeperServer(this);
+        LOG.info(""Read-only server started"");
     }
 
     @Override
@@ -124,7 +130,8 @@
     }
 
     @Override
-    public void shutdown() {
+    public synchronized void shutdown() {
+        shutdown = true;
         unregisterJMX(this);
 
         // set peer's server to null
"
zookeeper,c17d3501c94d43aaf430216f8a6ea714890eac78,ZOOKEEPER-1152. Exceptions thrown from handleAuthentication can cause buffer corruption issues in NIOServer.,2011.08.21 09:53:46,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index d49c668..c085bfb 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -48,6 +48,7 @@
 import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.Environment;
 import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.KeeperException.Code;
 import org.apache.zookeeper.KeeperException.SessionExpiredException;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.data.ACL;
@@ -862,9 +863,16 @@
             ZooKeeperServer.byteBuffer2Record(incomingBuffer, authPacket);
             String scheme = authPacket.getScheme();
             AuthenticationProvider ap = ProviderRegistry.getProvider(scheme);
-            if (ap == null
-                    || (ap.handleAuthentication(cnxn, authPacket.getAuth())
-                            != KeeperException.Code.OK)) {
+            Code authReturn = KeeperException.Code.AUTHFAILED;
+            if(ap != null) {
+                try {
+                    authReturn = ap.handleAuthentication(cnxn, authPacket.getAuth());
+                } catch(RuntimeException e) {
+                    LOG.warn(""Caught runtime exception from AuthenticationProvider: "" + scheme + "" due to "" + e);
+                    authReturn = KeeperException.Code.AUTHFAILED;                   
+                }
+            }
+            if (authReturn!= KeeperException.Code.OK) {
                 if (ap == null) {
                     LOG.warn(""No authentication provider for scheme: ""
                             + scheme + "" has ""
"
zookeeper,1d1bac2a715aa13cda6d14d0544bae7f7e00f3e2,ZOOKEEPER-1055. check for duplicate ACLs in addACL() and create(). (Eugene Koontz via mahadev),2011.08.15 09:35:18,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 76872c1..30ebf68 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -305,7 +305,8 @@
                             Long.toHexString(request.sessionId));
                     throw new KeeperException.BadArgumentsException(path);
                 }
-                if (!fixupACL(request.authInfo, createRequest.getAcl())) {
+                List<ACL> listACL = removeDuplicates(createRequest.getAcl());
+                if (!fixupACL(request.authInfo, listACL)) {
                     throw new KeeperException.InvalidACLException(path);
                 }
                 String parentPath = path.substring(0, lastSlash);
@@ -339,7 +340,7 @@
                 }
                 int newCversion = parentRecord.stat.getCversion()+1;
                 request.txn = new CreateTxn(path, createRequest.getData(),
-                        createRequest.getAcl(),
+                        listACL,
                         createMode.isEphemeral(), newCversion);
                 StatPersisted s = new StatPersisted();
                 if (createMode.isEphemeral()) {
@@ -350,8 +351,7 @@
                 parentRecord.stat.setCversion(newCversion);
                 addChangeRecord(parentRecord);
                 addChangeRecord(new ChangeRecord(request.hdr.getZxid(), path, s,
-                        0, createRequest.getAcl()));
-
+                        0, listACL));
                 break;
             case OpCode.delete:
                 zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
@@ -403,7 +403,8 @@
                 zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                 SetACLRequest setAclRequest = (SetACLRequest)record;
                 path = setAclRequest.getPath();
-                if (!fixupACL(request.authInfo, setAclRequest.getAcl())) {
+                listACL = removeDuplicates(setAclRequest.getAcl());
+                if (!fixupACL(request.authInfo, listACL)) {
                     throw new KeeperException.InvalidACLException(path);
                 }
                 nodeRecord = getRecordForPath(path);
@@ -415,7 +416,7 @@
                     throw new KeeperException.BadVersionException(path);
                 }
                 version = currentVersion + 1;
-                request.txn = new SetACLTxn(path, setAclRequest.getAcl(), version);
+                request.txn = new SetACLTxn(path, listACL, version);
                 nodeRecord = nodeRecord.duplicate(request.hdr.getZxid());
                 nodeRecord.stat.setAversion(version);
                 addChangeRecord(nodeRecord);
@@ -629,6 +630,20 @@
         nextProcessor.processRequest(request);
     }
 
+    private List<ACL> removeDuplicates(List<ACL> acl) {
+
+        ArrayList<ACL> retval = new ArrayList<ACL>();
+        Iterator<ACL> it = acl.iterator();
+        while (it.hasNext()) {
+            ACL a = it.next();
+            if (retval.contains(a) == false) {
+                retval.add(a);
+            }
+        }
+        return retval;
+    }
+
+
     /**
      * This method checks out the acl making sure it isn't null or empty,
      * it has valid schemes and ids, and expanding any relative ids that
@@ -645,6 +660,7 @@
         if (acl == null || acl.size() == 0) {
             return false;
         }
+
         Iterator<ACL> it = acl.iterator();
         LinkedList<ACL> toAdd = null;
         while (it.hasNext()) {
"
zookeeper,1d1bac2a715aa13cda6d14d0544bae7f7e00f3e2,ZOOKEEPER-1055. check for duplicate ACLs in addACL() and create(). (Eugene Koontz via mahadev),2011.08.15 09:35:18,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
index 2ba41cd..325fba4 100644
--- a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
@@ -77,7 +77,9 @@
     }
 
     public void addAuthInfo(Id id) {
-        authInfo.add(id);
+        if (authInfo.contains(id) == false) {
+            authInfo.add(id);
+        }
     }
 
     public boolean removeAuthInfo(Id id) {
"
zookeeper,41a2f0ac9df73a06386539350732ee7f14904f80,ZOOKEEPER-1144: ZooKeeperServer not starting on leader due to a race condition (Vishal K via camille),2011.08.12 00:19:15,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 032d742..fb9dbde 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -326,6 +326,7 @@
                         + Long.toHexString(newLeaderProposal.packet.getZxid()));
             }
             outstandingProposals.put(newLeaderProposal.packet.getZxid(), newLeaderProposal);
+            newLeaderProposal.ackSet.add(self.getId());
             
             readyToStart = true;
             waitForEpochAck(self.getId(), leaderStateSummary);
@@ -334,7 +335,6 @@
             // We have to get at least a majority of servers in sync with
             // us. We do this by waiting for the NEWLEADER packet to get
             // acknowledged
-            newLeaderProposal.ackSet.add(self.getId());
             while (!self.getQuorumVerifier().containsQuorum(newLeaderProposal.ackSet)){
             //while (newLeaderProposal.ackCount <= self.quorumPeers.size() / 2) {
                 if (self.tick > self.initLimit) {
"
zookeeper,8eeefcf274c2628633ba6d67f383996afcf5712c,ZOOKEEPER-1142. incorrect stat output (phunt via mahadev),2011.08.11 15:00:21,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index c6b5827..60e22ac 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -660,6 +660,7 @@
                     }
                     for(NIOServerCnxn c : cnxnset){
                         c.dumpConnectionInfo(pw, true);
+                        pw.println();
                     }
                     pw.println();
                 }
@@ -690,6 +691,7 @@
                 }
                 for (NIOServerCnxn c : cnxns) {
                     c.dumpConnectionInfo(pw, false);
+                    pw.println();
                 }
                 pw.println();
             }
"
zookeeper,8eeefcf274c2628633ba6d67f383996afcf5712c,ZOOKEEPER-1142. incorrect stat output (phunt via mahadev),2011.08.11 15:00:21,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index 06aae67..0ed0b4a 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -472,6 +472,7 @@
                     }
                     for(ServerCnxn c : cnxns){
                         c.dumpConnectionInfo(pw, true);
+                        pw.println();
                     }
                     pw.println();
                 }
@@ -501,6 +502,7 @@
                 }
                 for (ServerCnxn c : cnxns) {
                     c.dumpConnectionInfo(pw, false);
+                    pw.println();
                 }
                 pw.println();
             }
"
zookeeper,8eeefcf274c2628633ba6d67f383996afcf5712c,ZOOKEEPER-1142. incorrect stat output (phunt via mahadev),2011.08.11 15:00:21,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
index 6d69073..2ba41cd 100644
--- a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
@@ -442,6 +442,7 @@
                 pwriter.print(getMaxLatency());
             }
         }
+        pwriter.print("")"");
     }
 
 }
"
zookeeper,977c21435abdf6bd04eb030d85edd532d9768b3b,"ZOOKEEPER-1139. jenkins is reporting two warnings, fix these (phunt via mahadev)",2011.07.29 08:23:26,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientWatchManager.java b/src/java/main/org/apache/zookeeper/ClientWatchManager.java
index fe6d83e..d56374d 100644
--- a/src/java/main/org/apache/zookeeper/ClientWatchManager.java
+++ b/src/java/main/org/apache/zookeeper/ClientWatchManager.java
@@ -33,7 +33,8 @@
      * @param state event state
      * @param type event type
      * @param path event path
-     * @return
+     * @return may be empty set but must not be null
      */
-    public Set<Watcher> materialize(Watcher.Event.KeeperState state, Watcher.Event.EventType type, String path);
+    public Set<Watcher> materialize(Watcher.Event.KeeperState state,
+        Watcher.Event.EventType type, String path);
 }
"
zookeeper,977c21435abdf6bd04eb030d85edd532d9768b3b,"ZOOKEEPER-1139. jenkins is reporting two warnings, fix these (phunt via mahadev)",2011.07.29 08:23:26,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/Op.java b/src/java/main/org/apache/zookeeper/Op.java
index cee50c1..3c3db2e 100644
--- a/src/java/main/org/apache/zookeeper/Op.java
+++ b/src/java/main/org/apache/zookeeper/Op.java
@@ -127,7 +127,6 @@
      *                the path of the node
      * @param version
      *                the expected matching version
-     * @return
      */
     public static Op check(String path, int version) {
         return new Check(path, version);
"
zookeeper,6f07f77e16bb3dd48146b9df2b8a5ca429f075b3,ZOOKEEPER-1090. Race condition while taking snapshot can lead to not restoring data tree correctly.,2011.07.28 14:49:59,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index d9cd1ce..0690ce9 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -791,9 +791,6 @@
             rc.type = header.getType();
             rc.err = 0;
             rc.multiResult = null;
-            if (rc.zxid > lastProcessedZxid) {
-                lastProcessedZxid = rc.zxid;
-            }
             switch (header.getType()) {
                 case OpCode.create:
                     CreateTxn createTxn = (CreateTxn) txn;
@@ -914,6 +911,23 @@
         } catch (IOException e) {
             LOG.warn(""Failed:"" + debug, e);
         }
+        /*
+         * A snapshot might be in progress while we are modifying the data
+         * tree. If we set lastProcessedZxid prior to making corresponding
+         * change to the tree, then the zxid associated with the snapshot
+         * file will be ahead of its contents. Thus, while restoring from
+         * the snapshot, the restore method will not apply the transaction
+         * for zxid associated with the snapshot file, since the restore
+         * method assumes that transaction to be present in the snapshot.
+         *
+         * To avoid this, we first apply the transaction and then modify
+         * lastProcessedZxid.  During restore, we correctly handle the
+         * case where the snapshot contains data ahead of the zxid associated
+         * with the file.
+         */
+        if (rc.zxid > lastProcessedZxid) {
+        	lastProcessedZxid = rc.zxid;
+        }
         return rc;
     }
 
"
zookeeper,a2cd570a3afce6be2822e30b7c99493e1a86577b,ZOOKEEPER-1134. ClientCnxnSocket string comparison using == rather than equals. (phunt via mahadev),2011.07.26 06:31:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
index a182f41..269f8e8 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocket.java
@@ -26,11 +26,11 @@
 import java.util.List;
 
 import org.apache.jute.BinaryInputArchive;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.zookeeper.ClientCnxn.Packet;
 import org.apache.zookeeper.proto.ConnectResponse;
 import org.apache.zookeeper.server.ByteBufferInputStream;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A ClientCnxnSocket does the lower level communication with a socket
@@ -116,12 +116,12 @@
 
     void readConnectResult() throws IOException {
         if (LOG.isTraceEnabled()) {
-            StringBuffer buf = new StringBuffer(""0x["");
+            StringBuilder buf = new StringBuilder(""0x["");
             for (byte b : incomingBuffer.array()) {
                 buf.append(Integer.toHexString(b) + "","");
             }
             buf.append(""]"");
-            LOG.trace(""readConnectRestult "" + incomingBuffer.remaining() + "" ""
+            LOG.trace(""readConnectResult "" + incomingBuffer.remaining() + "" ""
                     + buf.toString());
         }
         ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);
"
zookeeper,a2cd570a3afce6be2822e30b7c99493e1a86577b,ZOOKEEPER-1134. ClientCnxnSocket string comparison using == rather than equals. (phunt via mahadev),2011.07.26 06:31:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index bab8998..c6b5827 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -762,7 +762,7 @@
                 print(""max_file_descriptor_count"", unixos.getMaxFileDescriptorCount());
             }
 
-            if(stats.getServerState() == ""leader"") {
+            if(stats.getServerState().equals(""leader"")) {
                 Leader leader = ((LeaderZooKeeperServer)zkServer).getLeader();
 
                 print(""followers"", leader.learners.size());
"
zookeeper,a2cd570a3afce6be2822e30b7c99493e1a86577b,ZOOKEEPER-1134. ClientCnxnSocket string comparison using == rather than equals. (phunt via mahadev),2011.07.26 06:31:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index c6ab5dd..06aae67 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -573,7 +573,7 @@
                 print(""max_file_descriptor_count"", unixos.getMaxFileDescriptorCount());
             }
 
-            if(stats.getServerState() == ""leader"") {
+            if(stats.getServerState().equals(""leader"")) {
                 Leader leader = ((LeaderZooKeeperServer)zkServer).getLeader();
 
                 print(""followers"", leader.learners.size());
"
zookeeper,a2cd570a3afce6be2822e30b7c99493e1a86577b,ZOOKEEPER-1134. ClientCnxnSocket string comparison using == rather than equals. (phunt via mahadev),2011.07.26 06:31:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/WatchManager.java b/src/java/main/org/apache/zookeeper/server/WatchManager.java
index 832b95c..76e37f2 100644
--- a/src/java/main/org/apache/zookeeper/server/WatchManager.java
+++ b/src/java/main/org/apache/zookeeper/server/WatchManager.java
@@ -127,7 +127,7 @@
      */
     @Override
     public synchronized String toString() {
-        StringBuffer sb = new StringBuffer();
+        StringBuilder sb = new StringBuilder();
 
         sb.append(watch2Paths.size()).append("" connections watching "")
             .append(watchTable.size()).append("" paths\n"");
"
zookeeper,a2cd570a3afce6be2822e30b7c99493e1a86577b,ZOOKEEPER-1134. ClientCnxnSocket string comparison using == rather than equals. (phunt via mahadev),2011.07.26 06:31:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
index 1bd900e..77c27e7 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
@@ -105,7 +105,7 @@
         for (Vote v : validVotes.values()) {
             Integer count = countTable.get(v);
             if (count == null) {
-                count = Integer.valueOf(0);
+                count = 0;
             }
             countTable.put(v, count + 1);
             if (v.getId() == result.vote.getId()) {
"
zookeeper,f08e26fc1dec101f5b3da37ed7fb756937941542,ZOOKEEPER-1109. Zookeeper service is down when SyncRequestProcessor meets any exception. (Laxman via mahadev),2011.07.26 05:49:26,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index 4c6b71d..be287c0 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -41,6 +41,7 @@
     private final RequestProcessor nextProcessor;
 
     private Thread snapInProcess = null;
+    volatile private boolean running;
 
     /**
      * Transactions that have been written and are waiting to be flushed to
@@ -62,6 +63,7 @@
         super(""SyncThread:"" + zks.getServerId());
         this.zks = zks;
         this.nextProcessor = nextProcessor;
+        running = true;
     }
 
     /**
@@ -147,6 +149,7 @@
             }
         } catch (Throwable t) {
             LOG.error(""Severe unrecoverable error, exiting"", t);
+            running = false;
             System.exit(11);
         }
         LOG.info(""SyncRequestProcessor exited!"");
@@ -170,7 +173,9 @@
         LOG.info(""Shutting down"");
         queuedRequests.add(requestOfDeath);
         try {
-            this.join();
+            if(running){
+                this.join();
+            }
         } catch(InterruptedException e) {
             LOG.warn(""Interrupted while wating for "" + this + "" to finish"");
         }
"
zookeeper,839ecef3ba74e2119dbd177795214d3ae1045bb2,ZOOKEEPER-1124. Multiop submitted to non-leader always fails due to timeout,2011.07.15 13:50:24,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
index 0d6300d..a1c8ce2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
@@ -84,6 +84,7 @@
                 case OpCode.setACL:
                 case OpCode.createSession:
                 case OpCode.closeSession:
+                case OpCode.multi:
                     zks.getFollower().request(request);
                     break;
                 }
"
zookeeper,839ecef3ba74e2119dbd177795214d3ae1045bb2,ZOOKEEPER-1124. Multiop submitted to non-leader always fails due to timeout,2011.07.15 13:50:24,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
index b9a8e6f..e94414f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ObserverRequestProcessor.java
@@ -92,6 +92,7 @@
                 case OpCode.setACL:
                 case OpCode.createSession:
                 case OpCode.closeSession:
+                case OpCode.multi:
                     zks.getObserver().request(request);
                     break;
                 }
"
zookeeper,1dbffb9eca80268e7ebb611dac5afd058fd0f9a6,ZOOKEEPER-1063. Dubious synchronization in Zookeeper and ClientCnxnSocketNIO classes,2011.07.15 13:10:45,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
index d0e74fa..626da04 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java
@@ -58,8 +58,7 @@
      * @throws InterruptedException
      * @throws IOException
      */
-    boolean doIO(List<Packet> pendingQueue, LinkedList<Packet> outgoingQueue) throws InterruptedException, IOException {
-        boolean packetReceived = false;
+    void doIO(List<Packet> pendingQueue, LinkedList<Packet> outgoingQueue) throws InterruptedException, IOException {
         SocketChannel sock = (SocketChannel) sockKey.channel();
         if (sock == null) {
             throw new IOException(""Socket is null!"");
@@ -85,19 +84,21 @@
                     }
                     lenBuffer.clear();
                     incomingBuffer = lenBuffer;
-                    packetReceived = true;
+                    updateLastHeard();
                     initialized = true;
                 } else {
                     sendThread.readResponse(incomingBuffer);
                     lenBuffer.clear();
                     incomingBuffer = lenBuffer;
-                    packetReceived = true;
+                    updateLastHeard();
                 }
             }
         }
         if (sockKey.isWritable()) {
+            LinkedList<Packet> pending = new LinkedList<Packet>();
             synchronized (outgoingQueue) {
                 if (!outgoingQueue.isEmpty()) {
+                    updateLastSend();
                     ByteBuffer pbb = outgoingQueue.getFirst().bb;
                     sock.write(pbb);
                     if (!pbb.hasRemaining()) {
@@ -106,18 +107,15 @@
                         if (p.requestHeader != null
                                 && p.requestHeader.getType() != OpCode.ping
                                 && p.requestHeader.getType() != OpCode.auth) {
-                            pendingQueue.add(p);
+                            pending.add(p);
                         }
                     }
                 }
             }
+            synchronized(pendingQueue) {
+                pendingQueue.addAll(pending);
+            }
         }
-        if (outgoingQueue.isEmpty()) {
-            disableWrite();
-        } else {
-            enableWrite();
-        }
-        return packetReceived;
     }
 
     @Override
@@ -263,21 +261,16 @@
                     sendThread.primeConnection();
                 }
             } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
-                if (outgoingQueue.size() > 0) {
-                    // We have something to send so it's the same
-                    // as if we do the send now.
-                    updateLastSend();
-                }
-                if (doIO(pendingQueue, outgoingQueue)) {
-                    updateLastHeard();
-                }
+                doIO(pendingQueue, outgoingQueue);
             }
         }
         if (sendThread.getZkState().isConnected()) {
-            if (outgoingQueue.size() > 0) {
-                enableWrite();
-            } else {
-                disableWrite();
+            synchronized(outgoingQueue) {
+                if (!outgoingQueue.isEmpty()) {
+                    enableWrite();
+                } else {
+                    disableWrite();
+                }
             }
         }
         selected.clear();
"
zookeeper,1dbffb9eca80268e7ebb611dac5afd058fd0f9a6,ZOOKEEPER-1063. Dubious synchronization in Zookeeper and ClientCnxnSocketNIO classes,2011.07.15 13:10:45,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index f2ab4a6..161ca83 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -90,16 +90,22 @@
     private final ZKWatchManager watchManager = new ZKWatchManager();
 
     List<String> getDataWatches() {
-        List<String> rc = new ArrayList<String>(watchManager.dataWatches.keySet());
-        return rc;
+        synchronized(watchManager.dataWatches) {
+            List<String> rc = new ArrayList<String>(watchManager.dataWatches.keySet());
+            return rc;
+        }
     }
     List<String> getExistWatches() {
-        List<String> rc =  new ArrayList<String>(watchManager.existWatches.keySet());
-        return rc;
+        synchronized(watchManager.existWatches) {
+            List<String> rc =  new ArrayList<String>(watchManager.existWatches.keySet());
+            return rc;
+        }
     }
     List<String> getChildWatches() {
-        List<String> rc = new ArrayList<String>(watchManager.childWatches.keySet());
-        return rc;
+        synchronized(watchManager.childWatches) {
+            List<String> rc = new ArrayList<String>(watchManager.childWatches.keySet());
+            return rc;
+        }
     }
 
 /**
@@ -138,27 +144,32 @@
             switch (type) {
             case None:
                 result.add(defaultWatcher);
-                for(Set<Watcher> ws: dataWatches.values()) {
-                    result.addAll(ws);
-                }
-                for(Set<Watcher> ws: existWatches.values()) {
-                    result.addAll(ws);
-                }
-                for(Set<Watcher> ws: childWatches.values()) {
-                    result.addAll(ws);
-                }
+                boolean clear = ClientCnxn.getDisableAutoResetWatch() &&
+                        state != Watcher.Event.KeeperState.SyncConnected;
 
-                // clear the watches if auto watch reset is not enabled
-                if (ClientCnxn.getDisableAutoResetWatch() &&
-                        state != Watcher.Event.KeeperState.SyncConnected)
-                {
-                    synchronized(dataWatches) {
+                synchronized(dataWatches) {
+                    for(Set<Watcher> ws: dataWatches.values()) {
+                        result.addAll(ws);
+                    }
+                    if (clear) {
                         dataWatches.clear();
                     }
-                    synchronized(existWatches) {
+                }
+
+                synchronized(existWatches) {
+                    for(Set<Watcher> ws: existWatches.values()) {
+                        result.addAll(ws);
+                    }
+                    if (clear) {
                         existWatches.clear();
                     }
-                    synchronized(childWatches) {
+                }
+
+                synchronized(childWatches) {
+                    for(Set<Watcher> ws: childWatches.values()) {
+                        result.addAll(ws);
+                    }
+                    if (clear) {
                         childWatches.clear();
                     }
                 }
"
zookeeper,aee36f4d55c093f263547486b1579cba8668eb2a,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.07.13 22:48:01,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index dc2a5be..d9cd1ce 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -1299,20 +1299,22 @@
     }
 
      /**
-      * If the znode for the specified path is found, then this method
-      * increments the cversion and sets its pzxid to the zxid passed
-      * in the second argument. A NoNodeException is thrown if the znode is
-      * not found.
+      * This method sets the Cversion and Pzxid for the specified node to the
+      * values passed as arguments. The values are modified only if newCversion
+      * is greater than the current Cversion. A NoNodeException is thrown if
+      * a znode for the specified path is not found.
       *
       * @param path
-      *     Full path to the znode whose cversion needs to be incremented.
+      *     Full path to the znode whose Cversion needs to be modified.
       *     A ""/"" at the end of the path is ignored.
+      * @param newCversion
+      *     Value to be assigned to Cversion
       * @param zxid
-      *     Value to be assigned to pzxid
+      *     Value to be assigned to Pzxid
       * @throws KeeperException.NoNodeException
       *     If znode not found.
       **/
-    public void incrementCversion(String path, long zxid)
+    public void setCversionPzxid(String path, int newCversion, long zxid)
         throws KeeperException.NoNodeException {
         if (path.endsWith(""/"")) {
            path = path.substring(0, path.length() - 1);
@@ -1322,8 +1324,13 @@
             throw new KeeperException.NoNodeException(path);
         }
         synchronized (node) {
-            node.stat.setCversion(node.stat.getCversion() + 1);
-            node.stat.setPzxid(zxid);
+            if(newCversion == -1) {
+                newCversion = node.stat.getCversion() + 1;
+            }
+            if (newCversion > node.stat.getCversion()) {
+                node.stat.setCversion(newCversion);
+                node.stat.setPzxid(zxid);
+            }
         }
     }
 }
"
zookeeper,aee36f4d55c093f263547486b1579cba8668eb2a,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.07.13 22:48:01,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 0f936e4..fec70de 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -25,21 +25,19 @@
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.jute.Record;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.KeeperException.Code;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.server.DataTree;
+import org.apache.zookeeper.server.DataTree.ProcessTxnResult;
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;
 import org.apache.zookeeper.txn.CreateSessionTxn;
 import org.apache.zookeeper.txn.CreateTxn;
 import org.apache.zookeeper.txn.TxnHeader;
-import org.apache.zookeeper.KeeperException.Code;
-import org.apache.zookeeper.KeeperException.NoNodeException;
-import org.apache.zookeeper.server.DataTree.ProcessTxnResult;
-import org.apache.zookeeper.KeeperException.NoNodeException;
-import org.apache.zookeeper.KeeperException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * This is a helper class 
@@ -201,10 +199,10 @@
 
         /**
          * Snapshots are taken lazily. It can happen that the child
-         * znodes of a parent are modified (deleted or created) after the parent
+         * znodes of a parent are created after the parent
          * is serialized. Therefore, while replaying logs during restore, a
-         * delete/create might fail because the node was already
-         * deleted/created.
+         * create might fail because the node was already
+         * created.
          *
          * After seeing this failure, we should increment
          * the cversion of the parent znode since the parent was serialized
@@ -213,17 +211,18 @@
          * Note, such failures on DT should be seen only during
          * restore.
          */
-        if ((hdr.getType() == OpCode.create &&
-                rc.err == Code.NODEEXISTS.intValue()) &&
-                ((CreateTxn)txn).getParentCVersion() == -1) {
-            LOG.debug(""Failed Txn: "" + hdr.getType() + "" path:"" +
-                  rc.path + "" err: "" + rc.err);
+        if (hdr.getType() == OpCode.create &&
+                rc.err == Code.NODEEXISTS.intValue()) {
+            LOG.debug(""Adjusting parent cversion for Txn: "" + hdr.getType() +
+                    "" path:"" + rc.path + "" err: "" + rc.err);
             int lastSlash = rc.path.lastIndexOf('/');
             String parentName = rc.path.substring(0, lastSlash);
+            CreateTxn cTxn = (CreateTxn)txn;
             try {
-                dt.incrementCversion(parentName, hdr.getZxid());
+                dt.setCversionPzxid(parentName, cTxn.getParentCVersion(),
+                        hdr.getZxid());
             } catch (KeeperException.NoNodeException e) {
-                LOG.error(""Failed to increment parent cversion for: "" +
+                LOG.error(""Failed to set parent cversion for: "" +
                       parentName, e);
                 throw e;
             }
"
zookeeper,80fac0914a891ae495ec79bd32f5606f12365403,ZOOKEEPER-1097. Quota is not correctly rehydrated on snapshot reload (camille via henryr),2011.06.25 15:13:03,Henry Robinson,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 992ac43..2845790 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -379,11 +379,11 @@
         synchronized (node) {
             thisStats = new StatsTrack(new String(node.data));
         }
-        if (thisStats.getCount() < updatedStat.getCount()) {
+        if (thisStats.getCount() > -1 && (thisStats.getCount() < updatedStat.getCount())) {
             LOG
-                    .warn(""Quota exceeded: "" + lastPrefix + "" count=""
-                            + updatedStat.getCount() + "" limit=""
-                            + thisStats.getCount());
+            .warn(""Quota exceeded: "" + lastPrefix + "" count=""
+                    + updatedStat.getCount() + "" limit=""
+                    + thisStats.getCount());
         }
     }
 
@@ -425,11 +425,11 @@
         synchronized (node) {
             thisStats = new StatsTrack(new String(node.data));
         }
-        if (thisStats.getBytes() < updatedStat.getBytes()) {
+        if (thisStats.getBytes() > -1 && (thisStats.getBytes() < updatedStat.getBytes())) {
             LOG
-                    .warn(""Quota exceeded: "" + lastPrefix + "" bytes=""
-                            + updatedStat.getBytes() + "" limit=""
-                            + thisStats.getBytes());
+            .warn(""Quota exceeded: "" + lastPrefix + "" bytes=""
+                    + updatedStat.getBytes() + "" limit=""
+                    + thisStats.getBytes());
         }
     }
 
@@ -508,8 +508,8 @@
             }
         }
         // also check to update the quotas for this node
-        String lastPrefix = pTrie.findMaxPrefix(path);
-        if (!rootZookeeper.equals(lastPrefix) && !("""".equals(lastPrefix))) {
+        String lastPrefix;
+        if((lastPrefix = getMaxPrefixWithQuota(path)) != null) {
             // ok we have some match and need to update
             updateCount(lastPrefix, 1);
             updateBytes(lastPrefix, data == null ? 0 : data.length);
@@ -567,8 +567,8 @@
         }
 
         // also check to update the quotas for this node
-        String lastPrefix = pTrie.findMaxPrefix(path);
-        if (!rootZookeeper.equals(lastPrefix) && !("""".equals(lastPrefix))) {
+        String lastPrefix;
+        if((lastPrefix = getMaxPrefixWithQuota(path)) != null) {
             // ok we have some match and need to update
             updateCount(lastPrefix, -1);
             int bytes = 0;
@@ -607,18 +607,35 @@
             n.copyStat(s);
         }
         // now update if the path is in a quota subtree.
-        String lastPrefix = pTrie.findMaxPrefix(path);
-        // do nothing for the root.
-        // we are not keeping a quota on the zookeeper
-        // root node for now.
-        if (!rootZookeeper.equals(lastPrefix) && !("""".equals(lastPrefix))) {
-            this.updateBytes(lastPrefix, (data == null ? 0 : data.length)
-                    - (lastdata == null ? 0 : lastdata.length));
+        String lastPrefix;
+        if((lastPrefix = getMaxPrefixWithQuota(path)) != null) {
+          this.updateBytes(lastPrefix, (data == null ? 0 : data.length)
+              - (lastdata == null ? 0 : lastdata.length));
         }
         dataWatches.triggerWatch(path, EventType.NodeDataChanged);
         return s;
     }
 
+    /**
+     * If there is a quota set, return the appropriate prefix for that quota
+     * Else return null
+     * @param The ZK path to check for quota
+     * @return Max quota prefix, or null if none
+     */
+    public String getMaxPrefixWithQuota(String path) {
+        // do nothing for the root.
+        // we are not keeping a quota on the zookeeper
+        // root node for now.
+        String lastPrefix = pTrie.findMaxPrefix(path);
+
+        if (!rootZookeeper.equals(lastPrefix) && !("""".equals(lastPrefix))) {
+            return lastPrefix;
+        }
+        else {
+            return null;
+        }
+    }
+
     public byte[] getData(String path, Stat stat, Watcher watcher)
             throws KeeperException.NoNodeException {
         DataNode n = nodes.get(path);
@@ -919,26 +936,24 @@
                 children = childs.toArray(new String[childs.size()]);
             }
         }
-        if (children != null) {
-            if (children.length == 0) {
-                // this node does not have a child
-                // is the leaf node
-                // check if its the leaf node
-                String endString = ""/"" + Quotas.limitNode;
-                if (path.endsWith(endString)) {
-                    // ok this is the limit node
-                    // get the real node and update
-                    // the count and the bytes
-                    String realPath = path.substring(Quotas.quotaZookeeper
-                            .length(), path.indexOf(endString));
-                    updateQuotaForPath(realPath);
-                    this.pTrie.addPath(realPath);
-                }
-                return;
+        if (children == null || children.length == 0) {
+            // this node does not have a child
+            // is the leaf node
+            // check if its the leaf node
+            String endString = ""/"" + Quotas.limitNode;
+            if (path.endsWith(endString)) {
+                // ok this is the limit node
+                // get the real node and update
+                // the count and the bytes
+                String realPath = path.substring(Quotas.quotaZookeeper
+                        .length(), path.indexOf(endString));
+                updateQuotaForPath(realPath);
+                this.pTrie.addPath(realPath);
             }
-            for (String child : children) {
-                traverseNode(path + ""/"" + child);
-            }
+            return;
+        }
+        for (String child : children) {
+            traverseNode(path + ""/"" + child);
         }
     }
 
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/TxnLogSource.java b/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/TxnLogSource.java
index a9140ee..809c455 100644
--- a/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/TxnLogSource.java
+++ b/src/contrib/loggraph/src/java/org/apache/zookeeper/graph/TxnLogSource.java
@@ -180,9 +180,8 @@
 		    throw new IOException(""CRC doesn't match "" + crcValue +
 					  "" vs "" + crc.getValue());
 		}
-		InputArchive iab = BinaryInputArchive.getArchive(new ByteArrayInputStream(bytes));
 		TxnHeader hdr = new TxnHeader();
-		Record r = SerializeUtils.deserializeTxn(iab, hdr);
+		Record r = SerializeUtils.deserializeTxn(bytes, hdr);
 
 		switch (hdr.getType()) {
 		case OpCode.createSession: {
@@ -328,9 +327,8 @@
 		if (logStream.readByte(""EOR"") != 'B') {
 		    throw new EOFException(""Last transaction was partial."");
 		}
-		InputArchive iab = BinaryInputArchive.getArchive(new ByteArrayInputStream(bytes));
 		TxnHeader hdr = new TxnHeader();
-		Record r = SerializeUtils.deserializeTxn(iab, hdr);
+		Record r = SerializeUtils.deserializeTxn(bytes, hdr);
 		
 		if (starttime == 0) {
 		    starttime = hdr.getTime();
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/DataNode.java b/src/java/main/org/apache/zookeeper/server/DataNode.java
index acd03c6..9498204 100644
--- a/src/java/main/org/apache/zookeeper/server/DataNode.java
+++ b/src/java/main/org/apache/zookeeper/server/DataNode.java
@@ -134,7 +134,6 @@
     synchronized public void copyStat(Stat to) {
         to.setAversion(stat.getAversion());
         to.setCtime(stat.getCtime());
-        to.setCversion(stat.getCversion());
         to.setCzxid(stat.getCzxid());
         to.setMtime(stat.getMtime());
         to.setMzxid(stat.getMzxid());
@@ -142,11 +141,15 @@
         to.setVersion(stat.getVersion());
         to.setEphemeralOwner(stat.getEphemeralOwner());
         to.setDataLength(data == null ? 0 : data.length);
-        if (this.children == null) {
-            to.setNumChildren(0);
-        } else {
-            to.setNumChildren(children.size());
+        int numChildren = 0;
+        if (this.children != null) {
+            numChildren = children.size();
         }
+        // when we do the Cversion we need to translate from the count of the creates
+        // to the count of the changes (v3 semantics)
+        // for every create there is a delete except for the children still present
+        to.setCversion(stat.getCversion()*2 - numChildren);
+        to.setNumChildren(numChildren);
     }
 
     synchronized public void deserialize(InputArchive archive, String tag)
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 6ae70a2..992ac43 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -446,7 +446,7 @@
      * @throws KeeperException
      */
     public String createNode(String path, byte data[], List<ACL> acl,
-            long ephemeralOwner, long zxid, long time)
+            long ephemeralOwner, int parentCVersion, long zxid, long time)
             throws KeeperException.NoNodeException,
             KeeperException.NodeExistsException {
         int lastSlash = path.lastIndexOf('/');
@@ -472,9 +472,12 @@
                     throw new KeeperException.NodeExistsException();
                 }
             }
-            int cver = parent.stat.getCversion();
-            cver++;
-            parent.stat.setCversion(cver);
+            
+            if (parentCVersion == -1) {
+                parentCVersion = parent.stat.getCversion();
+                parentCVersion++;
+            }    
+            parent.stat.setCversion(parentCVersion);
             parent.stat.setPzxid(zxid);
             Long longval = convertAcls(acl);
             DataNode child = new DataNode(parent, data, longval, stat);
@@ -542,7 +545,6 @@
         }
         synchronized (parent) {
             parent.removeChild(childName);
-            parent.stat.setCversion(parent.stat.getCversion() + 1);
             parent.stat.setPzxid(zxid);
             long eowner = node.stat.getEphemeralOwner();
             if (eowner != 0) {
@@ -770,6 +772,7 @@
                             createTxn.getData(),
                             createTxn.getAcl(),
                             createTxn.getEphemeral() ? header.getClientId() : 0,
+                            createTxn.getParentCVersion(),
                             header.getZxid(), header.getTime());
                     break;
                 case OpCode.delete:
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/LogFormatter.java b/src/java/main/org/apache/zookeeper/server/LogFormatter.java
index 16fe448..cd1347d 100644
--- a/src/java/main/org/apache/zookeeper/server/LogFormatter.java
+++ b/src/java/main/org/apache/zookeeper/server/LogFormatter.java
@@ -85,10 +85,8 @@
                 throw new IOException(""CRC doesn't match "" + crcValue +
                         "" vs "" + crc.getValue());
             }
-            InputArchive iab = BinaryInputArchive
-                                .getArchive(new ByteArrayInputStream(bytes));
             TxnHeader hdr = new TxnHeader();
-            SerializeUtils.deserializeTxn(iab, hdr);
+            Record txn = SerializeUtils.deserializeTxn(bytes, hdr);
             System.out.println(DateFormat.getDateTimeInstance(DateFormat.SHORT,
                     DateFormat.LONG).format(new Date(hdr.getTime()))
                     + "" session 0x""
@@ -97,7 +95,7 @@
                     + Long.toHexString(hdr.getCxid())
                     + "" zxid 0x""
                     + Long.toHexString(hdr.getZxid())
-                    + "" "" + TraceFormatter.op2String(hdr.getType()));
+                    + "" "" + TraceFormatter.op2String(hdr.getType()) + "" "" + txn);
             if (logStream.readByte(""EOR"") != 'B') {
                 LOG.error(""Last transaction was partial."");
                 throw new EOFException(""Last transaction was partial."");
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 50f208d..0fddf42 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -256,17 +256,17 @@
                 if (ephemeralParent) {
                     throw new KeeperException.NoChildrenForEphemeralsException(path);
                 }
+                int newCversion = parentRecord.stat.getCversion()+1;
                 txn = new CreateTxn(path, createRequest.getData(),
                         createRequest.getAcl(),
-                        createMode.isEphemeral());
+                        createMode.isEphemeral(), newCversion);
                 StatPersisted s = new StatPersisted();
                 if (createMode.isEphemeral()) {
                     s.setEphemeralOwner(request.sessionId);
                 }
                 parentRecord = parentRecord.duplicate(txnHeader.getZxid());
                 parentRecord.childCount++;
-                parentRecord.stat
-                        .setCversion(parentRecord.stat.getCversion() + 1);
+                parentRecord.stat.setCversion(newCversion);
                 addChangeRecord(parentRecord);
                 addChangeRecord(new ChangeRecord(txnHeader.getZxid(), path, s,
                         0, createRequest.getAcl()));
@@ -300,8 +300,6 @@
                 txn = new DeleteTxn(path);
                 parentRecord = parentRecord.duplicate(txnHeader.getZxid());
                 parentRecord.childCount--;
-                parentRecord.stat
-                        .setCversion(parentRecord.stat.getCversion() + 1);
                 addChangeRecord(parentRecord);
                 addChangeRecord(new ChangeRecord(txnHeader.getZxid(), path,
                         null, -1, null));
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 135ab67..05d8431 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -569,10 +569,8 @@
                     throw new IOException(CRC_ERROR);
                 if (bytes == null || bytes.length == 0)
                     return false;
-                InputArchive iab = BinaryInputArchive
-                                    .getArchive(new ByteArrayInputStream(bytes));
                 hdr = new TxnHeader();
-                record = SerializeUtils.deserializeTxn(iab, hdr);
+                record = SerializeUtils.deserializeTxn(bytes, hdr);
             } catch (EOFException e) {
                 LOG.debug(""EOF excepton "" + e);
                 inputStream.close();
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index ac4b0c6..0f936e4 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -33,6 +33,7 @@
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;
 import org.apache.zookeeper.txn.CreateSessionTxn;
+import org.apache.zookeeper.txn.CreateTxn;
 import org.apache.zookeeper.txn.TxnHeader;
 import org.apache.zookeeper.KeeperException.Code;
 import org.apache.zookeeper.KeeperException.NoNodeException;
@@ -212,10 +213,9 @@
          * Note, such failures on DT should be seen only during
          * restore.
          */
-        if ((hdr.getType() == OpCode.delete &&
-                 rc.err == Code.NONODE.intValue()) ||
-            (hdr.getType() == OpCode.create &&
-                rc.err == Code.NODEEXISTS.intValue())) {
+        if ((hdr.getType() == OpCode.create &&
+                rc.err == Code.NODEEXISTS.intValue()) &&
+                ((CreateTxn)txn).getParentCVersion() == -1) {
             LOG.debug(""Failed Txn: "" + hdr.getType() + "" path:"" +
                   rc.path + "" err: "" + rc.err);
             int lastSlash = rc.path.lastIndexOf('/');
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index 50b6dd5..ab3f288 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -113,9 +113,7 @@
             break;
         case Leader.PROPOSAL:            
             TxnHeader hdr = new TxnHeader();
-            BinaryInputArchive ia = BinaryInputArchive
-            .getArchive(new ByteArrayInputStream(qp.getData()));
-            Record txn = SerializeUtils.deserializeTxn(ia, hdr);
+            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);
             if (hdr.getZxid() != lastQueued + 1) {
                 LOG.warn(""Got zxid 0x""
                         + Long.toHexString(hdr.getZxid())
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index b37f116..5ee3e7f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -361,9 +361,7 @@
                 case Leader.PROPOSAL:
                     PacketInFlight pif = new PacketInFlight();
                     pif.hdr = new TxnHeader();
-                    BinaryInputArchive ia = BinaryInputArchive
-                            .getArchive(new ByteArrayInputStream(qp.getData()));
-                    pif.rec     = SerializeUtils.deserializeTxn(ia, pif.hdr);
+                    pif.rec = SerializeUtils.deserializeTxn(qp.getData(), pif.hdr);
                     if (pif.hdr.    getZxid() != lastQueued + 1) {
                     LOG.warn(""Got zxid 0x""
                             + Long.toHexString(pif.hdr.getZxid())
@@ -384,9 +382,7 @@
                     break;
                 case Leader.INFORM:
                     TxnHeader hdr = new TxnHeader();
-                    ia = BinaryInputArchive
-                            .getArchive(new ByteArrayInputStream(qp.getData()));
-                    Record txn = SerializeUtils.deserializeTxn(ia, hdr);
+                    Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);
                     zk.getZKDatabase().processTxn(hdr, txn);
                     break;
                 case Leader.UPTODATE:
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index add5afb..afc172e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -190,11 +190,9 @@
             break;
         case Leader.PROPOSAL:
             type = ""PROPOSAL"";
-            BinaryInputArchive ia = BinaryInputArchive
-                    .getArchive(new ByteArrayInputStream(p.getData()));
             TxnHeader hdr = new TxnHeader();
             try {
-                txn = SerializeUtils.deserializeTxn(ia, hdr);
+                txn = SerializeUtils.deserializeTxn(p.getData(), hdr);
                 // mess = ""transaction: "" + txn.toString();
             } catch (IOException e) {
                 LOG.warn(""Unexpected exception"",e);
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
index 9da7136..ee61a90 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
@@ -118,9 +118,7 @@
             break;
         case Leader.INFORM:            
             TxnHeader hdr = new TxnHeader();
-            BinaryInputArchive ia = BinaryInputArchive
-                    .getArchive(new ByteArrayInputStream(qp.getData()));
-            Record txn = SerializeUtils.deserializeTxn(ia, hdr);
+            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);
             Request request = new Request (null, hdr.getClientId(), 
                                            hdr.getCxid(),
                                            hdr.getType(), null, null);
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java b/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java
index 8efbdeb..aecc4d2 100644
--- a/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java
+++ b/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java
@@ -115,10 +115,8 @@
                     // empty transaction
                     throw new EOFException();
                 }
-                InputArchive ia = BinaryInputArchive
-                        .getArchive(new ByteArrayInputStream(bytes));
                 TxnHeader hdr = new TxnHeader();
-                Record txn = SerializeUtils.deserializeTxn(ia, hdr);
+                Record txn = SerializeUtils.deserializeTxn(bytes, hdr);
                 if (logStream.readByte(""EOR"") != 'B') {
                     LOG.warn(""Last transaction was partial."");
                     throw new EOFException(""Last transaction was partial."");
"
zookeeper,eb51de49f723542a17e722fa817d81605a04c74c,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.06.24 01:01:47,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/util/SerializeUtils.java b/src/java/main/org/apache/zookeeper/server/util/SerializeUtils.java
index 0ad4dd6..c123db9 100644
--- a/src/java/main/org/apache/zookeeper/server/util/SerializeUtils.java
+++ b/src/java/main/org/apache/zookeeper/server/util/SerializeUtils.java
@@ -18,6 +18,8 @@
 
 package org.apache.zookeeper.server.util;
 
+import java.io.ByteArrayInputStream;
+import java.io.EOFException;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
@@ -26,6 +28,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.InputArchive;
 import org.apache.jute.OutputArchive;
 import org.apache.jute.Record;
@@ -34,6 +37,7 @@
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.txn.CreateSessionTxn;
 import org.apache.zookeeper.txn.CreateTxn;
+import org.apache.zookeeper.txn.CreateTxnV0;
 import org.apache.zookeeper.txn.DeleteTxn;
 import org.apache.zookeeper.txn.ErrorTxn;
 import org.apache.zookeeper.txn.SetACLTxn;
@@ -43,9 +47,13 @@
 public class SerializeUtils {
     private static final Logger LOG = LoggerFactory.getLogger(SerializeUtils.class);
     
-    public static Record deserializeTxn(InputArchive ia, TxnHeader hdr)
+    public static Record deserializeTxn(byte txnBytes[], TxnHeader hdr)
             throws IOException {
+        final ByteArrayInputStream bais = new ByteArrayInputStream(txnBytes);
+        InputArchive ia = BinaryInputArchive.getArchive(bais);
+
         hdr.deserialize(ia, ""hdr"");
+        bais.mark(bais.available());
         Record txn = null;
         switch (hdr.getType()) {
         case OpCode.createSession:
@@ -72,7 +80,26 @@
             break;
         }
         if (txn != null) {
-            txn.deserialize(ia, ""txn"");
+            try {
+                txn.deserialize(ia, ""txn"");
+            } catch(EOFException e) {
+                // perhaps this is a V0 Create
+                if (hdr.getType() == OpCode.create) {
+                    CreateTxn create = (CreateTxn)txn;
+                    bais.reset();
+                    CreateTxnV0 createv0 = new CreateTxnV0();
+                    createv0.deserialize(ia, ""txn"");
+                    // cool now make it V1. a -1 parentCVersion will
+                    // trigger fixup processing in processTxn
+                    create.setPath(createv0.getPath());
+                    create.setData(createv0.getData());
+                    create.setAcl(createv0.getAcl());
+                    create.setEphemeral(createv0.getEphemeral());
+                    create.setParentCVersion(-1);
+                } else {
+                    throw e;
+                }
+            }
         }
         return txn;
     }
"
zookeeper,d5036dad6041cc0d12d3e2d1d1c49a29c4f731e0,"ZOOKEEPER-1087. ForceSync VM arguement not working when set to ""no""",2011.06.21 14:34:08,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 43e062a..135ab67 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -100,9 +100,6 @@
     static {
         LOG = LoggerFactory.getLogger(FileTxnLog.class);
 
-        forceSync =
-            !System.getProperty(""zookeeper.forceSync"", ""yes"").equals(""no"");
-
         String size = System.getProperty(""zookeeper.preAllocSize"");
         if (size != null) {
             try {
@@ -119,7 +116,7 @@
     volatile FileOutputStream fos = null;
 
     File logDir;
-    private static boolean forceSync = true;
+    private final boolean forceSync = !System.getProperty(""zookeeper.forceSync"", ""yes"").equals(""no"");;
     long dbId;
     private LinkedList<FileOutputStream> streamsToFlush =
         new LinkedList<FileOutputStream>();
@@ -386,6 +383,14 @@
     }
 
     /**
+     * the forceSync value. true if forceSync is enabled, false otherwise.
+     * @return the forceSync value
+     */
+    public boolean isForceSync() {
+        return forceSync;
+    }
+
+    /**
      * a class that keeps track of the position 
      * in the input stream. The position points to offset
      * that has been consumed by the applications. It can 
"
zookeeper,68a133174bfffa25940a0289d49bd272f7b4498d,ZOOKEEPER-1060. QuorumPeer takes a long time to shutdown (Vishal via fpj),2011.06.14 21:11:55,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index eea5487..87bbb5e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -766,6 +766,7 @@
         }
         
         if(getElectionAlg() != null){
+            this.interrupt();
         	getElectionAlg().shutdown();
         }
         try {
"
zookeeper,b916b3bbb643d6de07b962452685b8c5929f84b6,ZOOKEEPER-1069: Calling shutdown() on a QuorumPeer too quickly can lead to a corrupt log,2011.06.06 05:54:36,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index f7f8d76..43e062a 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -206,6 +206,8 @@
                oa = BinaryOutputArchive.getArchive(logStream);
                FileHeader fhdr = new FileHeader(TXNLOG_MAGIC,VERSION, dbId);
                fhdr.serialize(oa, ""fileheader"");
+               // Make sure that the magic number is written before padding.
+               logStream.flush();
                currentSize = fos.getChannel().position();
                streamsToFlush.add(fos);
             }
"
zookeeper,a4414196b310dbe62ee9e6e7e0c2a91fcd85c465,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.05.21 07:43:41,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index d16537e..6ae70a2 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -764,17 +764,18 @@
                 case OpCode.create:
                     CreateTxn createTxn = (CreateTxn) txn;
                     debug = ""Create transaction for "" + createTxn.getPath();
+                    rc.path = createTxn.getPath();
                     createNode(
                             createTxn.getPath(),
                             createTxn.getData(),
                             createTxn.getAcl(),
                             createTxn.getEphemeral() ? header.getClientId() : 0,
                             header.getZxid(), header.getTime());
-                    rc.path = createTxn.getPath();
                     break;
                 case OpCode.delete:
                     DeleteTxn deleteTxn = (DeleteTxn) txn;
                     debug = ""Delete transaction for "" + deleteTxn.getPath();
+                    rc.path = deleteTxn.getPath();
                     deleteNode(deleteTxn.getPath(), header.getZxid());
                     break;
                 case OpCode.setData:
@@ -801,11 +802,8 @@
                     break;
             }
         } catch (KeeperException e) {
-            // These are expected errors since we take a lazy snapshot
-            if (initialized
-                    || (e.code() != Code.NONODE && e.code() != Code.NODEEXISTS)) {
-                LOG.warn(""Failed:"" + debug, e);
-            }
+             LOG.debug(""Failed: "" + debug, e);
+             rc.err = e.code().intValue();
         }
         return rc;
     }
@@ -1192,4 +1190,33 @@
             }
         }
     }
+
+     /**
+      * If the znode for the specified path is found, then this method
+      * increments the cversion and sets its pzxid to the zxid passed
+      * in the second argument. A NoNodeException is thrown if the znode is
+      * not found.
+      *
+      * @param path
+      *     Full path to the znode whose cversion needs to be incremented.
+      *     A ""/"" at the end of the path is ignored.
+      * @param zxid
+      *     Value to be assigned to pzxid
+      * @throws KeeperException.NoNodeException
+      *     If znode not found.
+      **/
+    public void incrementCversion(String path, long zxid)
+        throws KeeperException.NoNodeException {
+        if (path.endsWith(""/"")) {
+           path = path.substring(0, path.length() - 1);
+        }
+        DataNode node = nodes.get(path);
+        if (node == null) {
+            throw new KeeperException.NoNodeException(path);
+        }
+        synchronized (node) {
+            node.stat.setCversion(node.stat.getCversion() + 1);
+            node.stat.setPzxid(zxid);
+        }
+    }
 }
"
zookeeper,a4414196b310dbe62ee9e6e7e0c2a91fcd85c465,ZOOKEEPER-1046: Creating a new sequential node results in a ZNODEEXISTS error,2011.05.21 07:43:41,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index fa66549..ac4b0c6 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -34,6 +34,11 @@
 import org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;
 import org.apache.zookeeper.txn.CreateSessionTxn;
 import org.apache.zookeeper.txn.TxnHeader;
+import org.apache.zookeeper.KeeperException.Code;
+import org.apache.zookeeper.KeeperException.NoNodeException;
+import org.apache.zookeeper.server.DataTree.ProcessTxnResult;
+import org.apache.zookeeper.KeeperException.NoNodeException;
+import org.apache.zookeeper.KeeperException;
 
 /**
  * This is a helper class 
@@ -142,7 +147,12 @@
             } else {
                 highestZxid = hdr.getZxid();
             }
-            processTransaction(hdr,dt,sessions, itr.getTxn());
+            try {
+                processTransaction(hdr,dt,sessions, itr.getTxn());
+            } catch(KeeperException.NoNodeException e) {
+               throw new IOException(""Failed to process transaction type: "" +
+                     hdr.getType() + "" error: "" + e.getMessage());
+            }
             listener.onTxnLoaded(hdr, itr.getTxn());
             if (!itr.next()) 
                 break;
@@ -157,8 +167,10 @@
      * @param sessions the sessions to be restored
      * @param txn the transaction to be applied
      */
-    private void processTransaction(TxnHeader hdr,DataTree dt,
-            Map<Long, Integer> sessions, Record txn){
+    public void processTransaction(TxnHeader hdr,DataTree dt,
+            Map<Long, Integer> sessions, Record txn)
+        throws KeeperException.NoNodeException {
+        ProcessTxnResult rc;
         switch (hdr.getType()) {
         case OpCode.createSession:
             sessions.put(hdr.getClientId(),
@@ -171,7 +183,7 @@
                                 + ((CreateSessionTxn) txn).getTimeOut());
             }
             // give dataTree a chance to sync its lastProcessedZxid
-            dt.processTxn(hdr, txn);
+            rc = dt.processTxn(hdr, txn);
             break;
         case OpCode.closeSession:
             sessions.remove(hdr.getClientId());
@@ -180,11 +192,45 @@
                         ""playLog --- close session in log: ""
                                 + Long.toHexString(hdr.getClientId()));
             }
-            dt.processTxn(hdr, txn);
+            rc = dt.processTxn(hdr, txn);
             break;
         default:
-            dt.processTxn(hdr, txn);
-        }        
+            rc = dt.processTxn(hdr, txn);
+        }
+
+        /**
+         * Snapshots are taken lazily. It can happen that the child
+         * znodes of a parent are modified (deleted or created) after the parent
+         * is serialized. Therefore, while replaying logs during restore, a
+         * delete/create might fail because the node was already
+         * deleted/created.
+         *
+         * After seeing this failure, we should increment
+         * the cversion of the parent znode since the parent was serialized
+         * before its children.
+         *
+         * Note, such failures on DT should be seen only during
+         * restore.
+         */
+        if ((hdr.getType() == OpCode.delete &&
+                 rc.err == Code.NONODE.intValue()) ||
+            (hdr.getType() == OpCode.create &&
+                rc.err == Code.NODEEXISTS.intValue())) {
+            LOG.debug(""Failed Txn: "" + hdr.getType() + "" path:"" +
+                  rc.path + "" err: "" + rc.err);
+            int lastSlash = rc.path.lastIndexOf('/');
+            String parentName = rc.path.substring(0, lastSlash);
+            try {
+                dt.incrementCversion(parentName, hdr.getZxid());
+            } catch (KeeperException.NoNodeException e) {
+                LOG.error(""Failed to increment parent cversion for: "" +
+                      parentName, e);
+                throw e;
+            }
+        } else if (rc.err != Code.OK.intValue()) {
+            LOG.debug(""Ignoring processTxn failure hdr: "" + hdr.getType() +
+                  "" : error: "" + rc.err);
+        }
     }
     
     /**
"
zookeeper,1fdcaaf4113114dbc27e1687f12efa14442a8d42,ZOOKEEPER-1058: fix typo in opToString for getData,2011.05.21 05:19:55,Camille Fournier,"diff --git a/src/java/main/org/apache/zookeeper/server/Request.java b/src/java/main/org/apache/zookeeper/server/Request.java
index a5c57e2..b137789 100644
--- a/src/java/main/org/apache/zookeeper/server/Request.java
+++ b/src/java/main/org/apache/zookeeper/server/Request.java
@@ -155,7 +155,7 @@
         case OpCode.exists:
             return ""exists"";
         case OpCode.getData:
-            return ""getDate"";
+            return ""getData"";
         case OpCode.setData:
             return ""setData"";
         case OpCode.sync:
"
zookeeper,7f64942ba8e5ce00948f6e7b23271de0556b668f,ZOOKEEPER-1059. stat command isses on non-existing node causes NPE. (Bhallamudi Kamesh via mahadev),2011.05.17 02:39:01,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index 46aedfd..4827bc9 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -147,7 +147,7 @@
      * A storage class for both command line options and shell commands.
      *
      */
-    static private class MyCommandOptions {
+    static class MyCommandOptions {
 
         private Map<String,String> options = new HashMap<String,String>();
         private List<String> cmdArgs = null;
@@ -724,6 +724,9 @@
         } else if (cmd.equals(""stat"") && args.length >= 2) {
             path = args[1];
             stat = zk.exists(path, watch);
+            if (stat == null) {
+              throw new KeeperException.NoNodeException(path);	
+            }
             printStat(stat);
         } else if (cmd.equals(""listquota"") && args.length >= 2) {
             path = args[1];
"
zookeeper,9a01fadeb3f25ae6ae500c173f6923fecad9b5ae,ZOOKEEPER-1049. Session expire/close flooding renders heartbeats to delay significantly. (chang song via mahadev),2011.05.04 06:29:55,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 68970d2..75aa924 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -102,7 +102,9 @@
             outstandingLimit = zk.getGlobalOutstandingLimit();
         }
         sock.socket().setTcpNoDelay(true);
-        sock.socket().setSoLinger(true, 2);
+        /* set socket linger to false, so that socket close does not
+         * block */
+        sock.socket().setSoLinger(false, -1);
         InetAddress addr = ((InetSocketAddress) sock.socket()
                 .getRemoteSocketAddress()).getAddress();
         authInfo.add(new Id(""ip"", addr.getHostAddress()));
"
zookeeper,db0f374ce739ab561c6ed7fbcaaf314aec0841ec,ZOOKEEPER-1052. Findbugs warning in QuorumPeer.ResponderThread.run()  (fpj via michim),2011.05.04 02:57:44,Michi Mutsuzaki,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 9774fb2..c07a405 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -313,8 +313,10 @@
                     }
                     packet.setLength(b.length);
                 }
-            } catch (Exception e) {
-                LOG.warn(""Unexpected exception in ResponderThread"",e);
+            } catch (RuntimeException e) {
+                LOG.warn(""Unexpected runtime exception in ResponderThread"",e);
+            } catch (IOException e) {
+                LOG.warn(""Unexpected IO exception in ResponderThread"",e);
             } finally {
                 LOG.warn(""QuorumPeer responder thread exited"");
             }
"
zookeeper,2be6b4dc25b55d86d15a68519a8b19630feaa4de,ZOOKEEPER-975. new peer goes in LEADING state even if ensemble is online. (vishal via fpj),2011.04.30 01:12:44,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index baa9ffa..2992d18 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -188,7 +188,7 @@
                 while (!stop) {
                     // Sleeps on receive
                     try{
-                        response = manager.recvQueue.poll(3000, TimeUnit.MILLISECONDS);
+                        response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);
                         if(response == null) continue;
 
                         /*
@@ -288,7 +288,9 @@
                                     if(LOG.isDebugEnabled()){
                                         LOG.debug(""Sending new notification. My id =  "" +
                                                 self.getId() + "", Recipient = "" +
-                                                response.sid);
+                                                response.sid + "" zxid ="" +
+                                                current.zxid + "" leader="" +
+                                                current.id);
                                     }
                                     ToSend notmsg = new ToSend(
                                             ToSend.mType.notification,
@@ -384,14 +386,14 @@
             this.ws = new WorkerSender(manager);
 
             Thread t = new Thread(this.ws,
-                    ""WorkerSender("" + Thread.currentThread().getName() + "")"");
+                    ""WorkerSender[myid="" + self.getId() + ""]"");
             t.setDaemon(true);
             t.start();
 
             this.wr = new WorkerReceiver(manager);
 
             t = new Thread(this.wr,
-                    ""WorkerReceiver("" + Thread.currentThread().getName() + "")"");
+                    ""WorkerReceiver[myid="" + self.getId() + ""]"");
             t.setDaemon(true);
             t.start();
         }
@@ -455,7 +457,13 @@
         this.messenger = new Messenger(manager);
     }
 
-    private void leaveInstance() {
+    private void leaveInstance(Vote v) {
+        if(LOG.isDebugEnabled()){
+            LOG.debug(""About to leave FLE instance: Leader= ""
+                + v.id + "", Zxid = "" +
+                v.zxid + "", My id = "" + self.getId()
+                + "", My state = "" + self.getPeerState());
+        }
         recvqueue.clear();
     }
 
@@ -487,7 +495,12 @@
                     logicalclock,
                     QuorumPeer.ServerState.LOOKING,
                     sid);
-
+            if(LOG.isDebugEnabled()){
+                LOG.debug(""Sending Notification: "" + proposedLeader + "" (n.leader), ""  +
+                      proposedZxid + "" (n.zxid), "" + logicalclock  +
+                      "" (n.round), "" + sid + "" (recipient), "" + self.getId() +
+                      "" (myid)"");
+            }
             sendqueue.offer(notmsg);
         }
     }
@@ -578,6 +591,11 @@
     }
 
     synchronized void updateProposal(long leader, long zxid){
+        if(LOG.isDebugEnabled()){
+            LOG.debug(""Updating proposal: "" + leader + "" (newleader), "" + zxid +
+                  "" (newzxid), "" + proposedLeader + "" (oldleader), "" +
+                  proposedZxid + "" (oldzxid)"");
+        }
         proposedLeader = leader;
         proposedZxid = zxid;
     }
@@ -640,7 +658,9 @@
             LOG.warn(""Failed to register with JMX"", e);
             self.jmxLeaderElectionBean = null;
         }
-
+        if (self.start_fle == 0) {
+           self.start_fle = System.currentTimeMillis();
+        }
         try {
             HashMap<Long, Vote> recvset = new HashMap<Long, Vote>();
 
@@ -689,7 +709,11 @@
                             tmpTimeOut : maxNotificationInterval);
                     LOG.info(""Notification time out: "" + notTimeout);
                 }
-                else{
+                else if(self.getVotingView().containsKey(n.sid)) {
+                    /*
+                     * Only proceed if the vote comes from a replica in the
+                     * voting view.
+                     */
                     switch (n.state) {
                     case LOOKING:
                         // If notification > current, replace and send messages out
@@ -697,11 +721,12 @@
                             logicalclock = n.epoch;
                             recvset.clear();
                             if(totalOrderPredicate(n.leader, n.zxid,
-                                    getInitId(), getInitLastLoggedZxid()))
+                                    getInitId(), getInitLastLoggedZxid())) {
                                 updateProposal(n.leader, n.zxid);
-                            else
+                            } else {
                                 updateProposal(getInitId(),
                                         getInitLastLoggedZxid());
+                            }
                             sendNotifications();
                         } else if (n.epoch < logicalclock) {
                             if(LOG.isDebugEnabled()){
@@ -711,7 +736,6 @@
                             break;
                         } else if (totalOrderPredicate(n.leader, n.zxid,
                                 proposedLeader, proposedZxid)) {
-                            LOG.info(""Updating proposal"");
                             updateProposal(n.leader, n.zxid);
                             sendNotifications();
                         }
@@ -723,85 +747,66 @@
                                     "", Proposed epoch = "" + n.epoch);
                         }
 
-                        /*
-                         * Only proceed if the vote comes from a replica in the
-                         * voting view.
-                         */
-                        if(self.getVotingView().containsKey(n.sid)){
-                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.epoch));
+                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.epoch));
 
-                            //If have received from all nodes, then terminate
-                            if ((self.getVotingView().size() == recvset.size()) &&
-                                    (self.getQuorumVerifier().getWeight(proposedLeader) != 0)){
+                        if (termPredicate(recvset,
+                                new Vote(proposedLeader, proposedZxid,
+                                        logicalclock))) {
+
+                            // Verify if there is any change in the proposed leader
+                            while((n = recvqueue.poll(finalizeWait,
+                                    TimeUnit.MILLISECONDS)) != null){
+                                if(totalOrderPredicate(n.leader, n.zxid,
+                                        proposedLeader, proposedZxid)){
+                                    recvqueue.put(n);
+                                    break;
+                                }
+                            }
+
+                            /*
+                             * This predicate is true once we don't read any new
+                             * relevant message from the reception queue
+                             */
+                            if (n == null) {
                                 self.setPeerState((proposedLeader == self.getId()) ?
                                         ServerState.LEADING: learningState());
-                                leaveInstance();
-                                return new Vote(proposedLeader, proposedZxid);
 
-                            } else if (termPredicate(recvset,
-                                    new Vote(proposedLeader, proposedZxid,
-                                            logicalclock))) {
-
-                                // Verify if there is any change in the proposed leader
-                                while((n = recvqueue.poll(finalizeWait,
-                                        TimeUnit.MILLISECONDS)) != null){
-                                    if(totalOrderPredicate(n.leader, n.zxid,
-                                            proposedLeader, proposedZxid)){
-                                        recvqueue.put(n);
-                                        break;
-                                    }
-                                }
-
-                                /*
-                                 * This predicate is true once we don't read any new
-                                 * relevant message from the reception queue
-                                 */
-                                if (n == null) {
-                                    self.setPeerState((proposedLeader == self.getId()) ?
-                                            ServerState.LEADING: learningState());
-                                    if(LOG.isDebugEnabled()){
-                                        LOG.debug(""About to leave FLE instance: Leader= ""
-                                            + proposedLeader + "", Zxid = "" +
-                                            proposedZxid + "", My id = "" + self.getId()
-                                            + "", My state = "" + self.getPeerState());
-                                    }
-
-                                    leaveInstance();
-                                    return new Vote(proposedLeader,
-                                            proposedZxid);
-                                }
+                                Vote endVote = new Vote(proposedLeader,
+                                        proposedZxid);
+                                leaveInstance(endVote);
+                                return endVote;
                             }
                         }
                         break;
                     case OBSERVING:
                         LOG.debug(""Notification from observer: "" + n.sid);
                         break;
-                    default:
+                    case FOLLOWING:
+                    case LEADING:
                         /*
-                         * There is at most one leader for each epoch, so if a
-                         * peer claims to be the leader for an epoch, then that
-                         * peer must be the leader (no* arbitrary failures
-                         * assumed). Now, if there is no quorum supporting
-                         * this leader, then processes will naturally move
-                         * to a new epoch.
+                         * Consider all notifications from the same epoch
+                         * together.
                          */
                         if(n.epoch == logicalclock){
                             recvset.put(n.sid, new Vote(n.leader, n.zxid, n.epoch));
-                            if((n.state == ServerState.LEADING) ||
-                                    (termPredicate(recvset, new Vote(n.leader,
+                            if(termPredicate(recvset, new Vote(n.leader,
                                             n.zxid, n.epoch, n.state))
-                                            && checkLeader(outofelection, n.leader, n.epoch)) ){
+                                            && checkLeader(outofelection, n.leader, n.epoch)) {
                                 self.setPeerState((n.leader == self.getId()) ?
                                         ServerState.LEADING: learningState());
 
-                                leaveInstance();
-                                return new Vote(n.leader, n.zxid);
+                                Vote endVote = new Vote(n.leader, n.zxid);
+                                leaveInstance(endVote);
+                                return endVote;
                             }
                         }
 
+                        /**
+                         * Before joining an established ensemble, verify that
+                         * a majority are following the same leader.
+                         */
                         outofelection.put(n.sid, new Vote(n.leader, n.zxid,
                                 n.epoch, n.state));
-
                         if (termPredicate(outofelection, new Vote(n.leader,
                                 n.zxid, n.epoch, n.state))
                                 && checkLeader(outofelection, n.leader, n.epoch)) {
@@ -810,15 +815,20 @@
                                 self.setPeerState((n.leader == self.getId()) ?
                                         ServerState.LEADING: learningState());
                             }
-                            leaveInstance();
-                            return new Vote(n.leader, n.zxid);
+                            Vote endVote = new Vote(n.leader, n.zxid);
+                            leaveInstance(endVote);
+                            return endVote;
                         }
-
+                        break;
+                    default:
+                        LOG.warn(""Notification state unrecoginized: "" + n.state
+                              + "" (n.state), "" + n.sid + "" (n.sid)"");
                         break;
                     }
+                } else {
+                    LOG.warn(""Ignoring notification from non-cluster member "" + n.sid);
                 }
             }
-
             return null;
         } finally {
             try {
"
zookeeper,2be6b4dc25b55d86d15a68519a8b19630feaa4de,ZOOKEEPER-975. new peer goes in LEADING state even if ensemble is online. (vishal via fpj),2011.04.30 01:12:44,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index 3a48c8d..5c4eaf8 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -58,9 +58,14 @@
      * @throws InterruptedException
      */
     void followLeader() throws InterruptedException {
+        self.end_fle = System.currentTimeMillis();
+        LOG.info(""FOLLOWING - LEADER ELECTION TOOK - "" +
+              (self.end_fle - self.start_fle));
+        self.start_fle = 0;
+        self.end_fle = 0;
         fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);
-        try {
-            InetSocketAddress addr = findLeader();
+        try {            
+            InetSocketAddress addr = findLeader();            
             try {
                 connectToLeader(addr);
                 long newLeaderZxid = registerWithLeader(Leader.FOLLOWERINFO);
"
zookeeper,2be6b4dc25b55d86d15a68519a8b19630feaa4de,ZOOKEEPER-975. new peer goes in LEADING state even if ensemble is online. (vishal via fpj),2011.04.30 01:12:44,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 7212a3e..c2858b3 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -270,6 +270,12 @@
      * @throws InterruptedException
      */
     void lead() throws IOException, InterruptedException {
+        self.end_fle = System.currentTimeMillis();
+        LOG.info(""LEADING - LEADER ELECTION TOOK - "" +
+              (self.end_fle - self.start_fle));
+        self.start_fle = 0;
+        self.end_fle = 0;
+
         zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);
 
         try {
"
zookeeper,2be6b4dc25b55d86d15a68519a8b19630feaa4de,ZOOKEEPER-975. new peer goes in LEADING state even if ensemble is online. (vishal via fpj),2011.04.30 01:12:44,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index c14db4e..e980467 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -32,6 +32,7 @@
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
+import java.util.NoSuchElementException;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.Date;
 
@@ -64,8 +65,11 @@
     /*
      * Maximum capacity of thread queues
      */
+    static final int RECV_CAPACITY = 100;
+    // Initialized to 1 to prevent sending
+    // stale notifications to peers
+    static final int SEND_CAPACITY = 1;
 
-    static final int CAPACITY = 100;
     static final int PACKETMAXSIZE = 1024 * 1024; 
     /*
      * Maximum number of attempts to connect to a peer
@@ -101,6 +105,10 @@
      * Reception queue
      */
     public final ArrayBlockingQueue<Message> recvQueue;
+    /*
+     * Object to synchronize access to recvQueue
+     */
+    private final Object recvQLock = new Object();
 
     /*
      * Shutdown flag
@@ -129,7 +137,7 @@
     }
 
     public QuorumCnxManager(QuorumPeer self) {
-        this.recvQueue = new ArrayBlockingQueue<Message>(CAPACITY);
+        this.recvQueue = new ArrayBlockingQueue<Message>(RECV_CAPACITY);
         this.queueSendMap = new ConcurrentHashMap<Long, ArrayBlockingQueue<ByteBuffer>>();
         this.senderWorkerMap = new ConcurrentHashMap<Long, SendWorker>();
         this.lastMessageSent = new ConcurrentHashMap<Long, ByteBuffer>();
@@ -196,7 +204,7 @@
             senderWorkerMap.put(sid, sw);
             if (!queueSendMap.containsKey(sid)) {
                 queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
-                        CAPACITY));
+                        SEND_CAPACITY));
             }
             
             sw.start();
@@ -273,7 +281,7 @@
             
             if (!queueSendMap.containsKey(sid)) {
                 queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
-                        CAPACITY));
+                        SEND_CAPACITY));
             }
             
             sw.start();
@@ -293,44 +301,31 @@
          * If sending message to myself, then simply enqueue it (loopback).
          */
         if (self.getId() == sid) {
-            try {
-                b.position(0);
-                recvQueue.put(new Message(b.duplicate(), sid));
-            } catch (InterruptedException e) {
-                LOG.warn(""Exception when loopbacking"", e);
-            }
+             b.position(0);
+             addToRecvQueue(new Message(b.duplicate(), sid));
             /*
              * Otherwise send to the corresponding thread to send.
              */
         } else {
-            try {
-                /*
-                 * Start a new connection if doesn't have one already.
-                 */
-                if (!queueSendMap.containsKey(sid)) {
-                    ArrayBlockingQueue<ByteBuffer> bq = new ArrayBlockingQueue<ByteBuffer>(
-                            CAPACITY);
-                    queueSendMap.put(sid, bq);
-                    bq.put(b);
+             /*
+              * Start a new connection if doesn't have one already.
+              */
+             if (!queueSendMap.containsKey(sid)) {
+                 ArrayBlockingQueue<ByteBuffer> bq = new ArrayBlockingQueue<ByteBuffer>(
+                         SEND_CAPACITY);
+                 queueSendMap.put(sid, bq);
+                 addToSendQueue(bq, b);
 
-                } else {
-                    ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
-                    if(bq != null){
-                        if (bq.remainingCapacity() == 0) {
-                            bq.take();
-                        }
-                        bq.put(b);
-                    } else {
-                        LOG.error(""No queue for server "" + sid);
-                    }
-                }
-
-                connectOne(sid);
+             } else {
+                 ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
+                 if(bq != null){
+                     addToSendQueue(bq, b);
+                 } else {
+                     LOG.error(""No queue for server "" + sid);
+                 }
+             }
+             connectOne(sid);
                 
-            } catch (InterruptedException e) {
-                LOG.warn(""Interrupted while waiting to put message in queue."",
-                        e);
-            }
         }
     }
     
@@ -634,9 +629,26 @@
         public void run() {
             threadCnt.incrementAndGet();
             try {
-                ByteBuffer b = lastMessageSent.get(sid);
-                if (b != null) {
-                    send(b);
+                /**
+                 * If there is nothing in the queue to send, then we
+                 * send the lastMessage to ensure that the last message
+                 * was received by the peer. The message could be dropped
+                 * in case self or the peer shutdown their connection
+                 * (and exit the thread) prior to reading/processing
+                 * the last message. Duplicate messages are handled correctly
+                 * by the peer.
+                 *
+                 * If the send queue is non-empty, then we have a recent
+                 * message than that stored in lastMessage. To avoid sending
+                 * stale message, we should send the message in the send queue.
+                 */
+                ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
+                if (bq == null || isSendQueueEmpty(bq)) {
+                   ByteBuffer b = lastMessageSent.get(sid);
+                   if (b != null) {
+                       LOG.debug(""Attempting to send lastMessage to sid="" + sid);
+                       send(b);
+                   }
                 }
             } catch (IOException e) {
                 LOG.error(""Failed to send last message. Shutting down thread."", e);
@@ -651,7 +663,7 @@
                         ArrayBlockingQueue<ByteBuffer> bq = queueSendMap
                                 .get(sid);
                         if (bq != null) {
-                            b = bq.poll(1000, TimeUnit.MILLISECONDS);
+                            b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);
                         } else {
                             LOG.error(""No queue of incoming messages for "" +
                                       ""server "" + sid);
@@ -742,7 +754,7 @@
                     byte[] msgArray = new byte[length];
                     din.readFully(msgArray, 0, length);
                     ByteBuffer message = ByteBuffer.wrap(msgArray);
-                    recvQueue.put(new Message(message.duplicate(), sid));
+                    addToRecvQueue(new Message(message.duplicate(), sid));
                 }
             } catch (Exception e) {
                 LOG.warn(""Connection broken for id "" + sid + "", my id = "" + 
@@ -756,4 +768,116 @@
             }
         }
     }
+
+    /**
+     * Inserts an element in the specified queue. If the Queue is full, this
+     * method removes an element from the head of the Queue and then inserts
+     * the element at the tail. It can happen that the an element is removed
+     * by another thread in {@link SendWorker#processMessage() processMessage}
+     * method before this method attempts to remove an element from the queue.
+     * This will cause {@link ArrayBlockingQueue#remove() remove} to throw an
+     * exception, which is safe to ignore.
+     *
+     * Unlike {@link #addToRecvQueue(Message) addToRecvQueue} this method does
+     * not need to be synchronized since there is only one thread that inserts
+     * an element in the queue and another thread that reads from the queue.
+     *
+     * @param queue
+     *          Reference to the Queue
+     * @param buffer
+     *          Reference to the buffer to be inserted in the queue
+     */
+    private void addToSendQueue(ArrayBlockingQueue<ByteBuffer> queue,
+          ByteBuffer buffer) {
+        if (queue.remainingCapacity() == 0) {
+            try {
+                queue.remove();
+            } catch (NoSuchElementException ne) {
+                // element could be removed by poll()
+                LOG.debug(""Trying to remove from an empty "" +
+                        ""Queue. Ignoring exception "" + ne);
+            }
+        }
+        try {
+            queue.add(buffer);
+        } catch (IllegalStateException ie) {
+            // This should never happen
+            LOG.error(""Unable to insert an element in the queue "" + ie);
+        }
+    }
+
+    /**
+     * Returns true if queue is empty.
+     * @param queue
+     *          Reference to the queue
+     * @return
+     *      true if the specified queue is empty
+     */
+    private boolean isSendQueueEmpty(ArrayBlockingQueue<ByteBuffer> queue) {
+        return queue.isEmpty();
+    }
+
+    /**
+     * Retrieves and removes buffer at the head of this queue,
+     * waiting up to the specified wait time if necessary for an element to
+     * become available.
+     *
+     * {@link ArrayBlockingQueue#poll(long, java.util.concurrent.TimeUnit)}
+     */
+    private ByteBuffer pollSendQueue(ArrayBlockingQueue<ByteBuffer> queue,
+          long timeout, TimeUnit unit) throws InterruptedException {
+       return queue.poll(timeout, unit);
+    }
+
+    /**
+     * Inserts an element in the {@link #recvQueue}. If the Queue is full, this
+     * methods removes an element from the head of the Queue and then inserts
+     * the element at the tail of the queue.
+     *
+     * This method is synchronized to achieve fairness between two threads that
+     * are trying to insert an element in the queue. Each thread checks if the
+     * queue is full, then removes the element at the head of the queue, and
+     * then inserts an element at the tail. This three-step process is done to
+     * prevent a thread from blocking while inserting an element in the queue.
+     * If we do not synchronize the call to this method, then a thread can grab
+     * a slot in the queue created by the second thread. This can cause the call
+     * to insert by the second thread to fail.
+     * Note that synchronizing this method does not block another thread
+     * from polling the queue since that synchronization is provided by the
+     * queue itself.
+     *
+     * @param msg
+     *          Reference to the message to be inserted in the queue
+     */
+    public void addToRecvQueue(Message msg) {
+        synchronized(recvQLock) {
+            if (recvQueue.remainingCapacity() == 0) {
+                try {
+                    recvQueue.remove();
+                } catch (NoSuchElementException ne) {
+                    // element could be removed by poll()
+                     LOG.debug(""Trying to remove from an empty "" +
+                         ""recvQueue. Ignoring exception "" + ne);
+                }
+            }
+            try {
+                recvQueue.add(msg);
+            } catch (IllegalStateException ie) {
+                // This should never happen
+                LOG.error(""Unable to insert element in the recvQueue "" + ie);
+            }
+        }
+    }
+
+    /**
+     * Retrieves and removes a message at the head of this queue,
+     * waiting up to the specified wait time if necessary for an element to
+     * become available.
+     *
+     * {@link ArrayBlockingQueue#poll(long, java.util.concurrent.TimeUnit)}
+     */
+    public Message pollRecvQueue(long timeout, TimeUnit unit)
+       throws InterruptedException {
+       return recvQueue.poll(timeout, unit);
+    }
 }
"
zookeeper,2be6b4dc25b55d86d15a68519a8b19630feaa4de,ZOOKEEPER-975. new peer goes in LEADING state even if ensemble is online. (vishal via fpj),2011.04.30 01:12:44,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index ab5f893..9774fb2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -139,6 +139,11 @@
      */
     
     static final long OBSERVER_ID = Long.MAX_VALUE;
+
+    /*
+     * Record leader election time
+     */
+    public long start_fle, end_fle;
     
     /*
      * Default value of peer is participant
@@ -573,7 +578,8 @@
 
     @Override
     public void run() {
-        setName(""QuorumPeer:"" + cnxnFactory.getLocalAddress());
+        setName(""QuorumPeer"" + ""[myid="" + getId() + ""]"" +
+                cnxnFactory.getLocalAddress());
 
         LOG.debug(""Starting quorum peer"");
         try {
"
zookeeper,b5116d920d3a5bac42b1ba08aa5cef4a31801ebf,ZOOKEEPER-874. FileTxnSnapLog.restore does not call listener (diogo via fpj),2011.04.14 01:10:02,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 146190d..fa66549 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -143,6 +143,7 @@
                 highestZxid = hdr.getZxid();
             }
             processTransaction(hdr,dt,sessions, itr.getTxn());
+            listener.onTxnLoaded(hdr, itr.getTxn());
             if (!itr.next()) 
                 break;
         }
"
zookeeper,1e4ed1c912a45fc8c36a4f4008b228fa55a891b5,ZOOKEEPER-1030: Increase default for maxClientCnxns (Todd Lipcon via breed/mahadev/phunt),2011.04.07 01:17:18,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
index 9facbc7..bdcbe36 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxnFactory.java
@@ -70,7 +70,7 @@
     final HashMap<InetAddress, Set<NIOServerCnxn>> ipMap =
         new HashMap<InetAddress, Set<NIOServerCnxn>>( );
 
-    int maxClientCnxns = 10;
+    int maxClientCnxns = 60;
 
 
     /**
@@ -303,4 +303,4 @@
         return cnxns;
     }
 
-}
\ No newline at end of file
+}
"
zookeeper,1e4ed1c912a45fc8c36a4f4008b228fa55a891b5,ZOOKEEPER-1030: Increase default for maxClientCnxns (Todd Lipcon via breed/mahadev/phunt),2011.04.07 01:17:18,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
index 5c3a2bd..3392497 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java
@@ -54,7 +54,7 @@
     HashMap<InetAddress, Set<NettyServerCnxn>> ipMap =
         new HashMap<InetAddress, Set<NettyServerCnxn>>( );
     InetSocketAddress localAddress;
-    int maxClientCnxns = 10;
+    int maxClientCnxns = 60;
     
     /**
      * This is an inner class since we need to extend SimpleChannelHandler, but
"
zookeeper,1e4ed1c912a45fc8c36a4f4008b228fa55a891b5,ZOOKEEPER-1030: Increase default for maxClientCnxns (Todd Lipcon via breed/mahadev/phunt),2011.04.07 01:17:18,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 6904a48..ae2cbb1 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -48,7 +48,7 @@
     protected String dataDir;
     protected String dataLogDir;
     protected int tickTime = ZooKeeperServer.DEFAULT_TICK_TIME;
-    protected int maxClientCnxns = 10;
+    protected int maxClientCnxns = 60;
     /** defaults to -1 if not set explicitly */
     protected int minSessionTimeout = -1;
     /** defaults to -1 if not set explicitly */
"
zookeeper,858e308a70a831bcd6e131bae7d72449ec8ee7f8,ZOOKEEPER-880. QuorumCnxManager$SendWorker grows without bounds,2011.03.17 03:49:18,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 9468968..f75dae7 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -32,6 +32,8 @@
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.Date;
 
 import org.apache.log4j.Logger;
 
@@ -110,6 +112,11 @@
      */
     public final Listener listener;
 
+    /*
+     * Counter to count worker threads
+     */
+    private AtomicInteger threadCnt = new AtomicInteger(0);
+
     static public class Message {
         Message(ByteBuffer buffer, long sid) {
             this.buffer = buffer;
@@ -177,7 +184,7 @@
             // Otherwise proceed with the connection
         } else {
             SendWorker sw = new SendWorker(sock, sid);
-            RecvWorker rw = new RecvWorker(sock, sid);
+            RecvWorker rw = new RecvWorker(sock, sid, sw);
             sw.setRecv(rw);
 
             SendWorker vsw = senderWorkerMap.get(sid);
@@ -253,7 +260,7 @@
             // Otherwise start worker threads to receive data.
         } else {
             SendWorker sw = new SendWorker(sock, sid);
-            RecvWorker rw = new RecvWorker(sock, sid);
+            RecvWorker rw = new RecvWorker(sock, sid, sw);
             sw.setRecv(rw);
 
             SendWorker vsw = senderWorkerMap.get(sid);
@@ -448,6 +455,19 @@
     }
 
     /**
+     * Return number of worker threads
+     */
+    public long getThreadCount() {
+        return threadCnt.get();
+    }
+    /**
+     * Return reference to QuorumPeer
+     */
+    public QuorumPeer getQuorumPeer() {
+        return self;
+    }
+
+    /**
      * Thread to listen on some port
      */
     public class Listener extends Thread {
@@ -591,6 +611,7 @@
                 LOG.debug(""Removing entry from senderWorkerMap sid="" + sid);
             }
             senderWorkerMap.remove(sid, this);
+            threadCnt.decrementAndGet();
             return running;
         }
         
@@ -610,6 +631,7 @@
 
         @Override
         public void run() {
+            threadCnt.incrementAndGet();
             try {
                 ByteBuffer b = lastMessageSent.get(sid);
                 if (b != null) {
@@ -662,10 +684,12 @@
         Socket sock;
         volatile boolean running = true;
         DataInputStream din;
+        final SendWorker sw;
 
-        RecvWorker(Socket sock, Long sid) {
+        RecvWorker(Socket sock, Long sid, SendWorker sw) {
             this.sid = sid;
             this.sock = sock;
+            this.sw = sw;
             try {
                 din = new DataInputStream(sock.getInputStream());
                 // OK to wait until socket disconnects while reading.
@@ -692,11 +716,13 @@
             running = false;            
 
             this.interrupt();
+            threadCnt.decrementAndGet();
             return running;
         }
 
         @Override
         public void run() {
+            threadCnt.incrementAndGet();
             try {
                 while (running && !shutdown && sock != null) {
                     /**
@@ -719,8 +745,10 @@
                 }
             } catch (Exception e) {
                 LOG.warn(""Connection broken for id "" + sid + "", my id = "" + 
-                        self.getId() + "", error = "" + e);
+                        self.getId() + "", error = "" , e);
             } finally {
+                LOG.warn(""Interrupting SendWorker"");
+                sw.finish();
                 if (sock != null) {
                     closeSocket(sock);
                 }
"
zookeeper,858e308a70a831bcd6e131bae7d72449ec8ee7f8,ZOOKEEPER-880. QuorumCnxManager$SendWorker grows without bounds,2011.03.17 03:49:18,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 7eb3684..23859ba 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -74,6 +74,7 @@
     QuorumBean jmxQuorumBean;
     LocalPeerBean jmxLocalPeerBean;
     LeaderElectionBean jmxLeaderElectionBean;
+    QuorumCnxManager qcm;
 
     /* ZKDatabase is a top level member of quorumpeer 
      * which will be used in all the zookeeperservers
@@ -524,11 +525,11 @@
             le = new AuthFastLeaderElection(this, true);
             break;
         case 3:
-            QuorumCnxManager mng = new QuorumCnxManager(this);
-            QuorumCnxManager.Listener listener = mng.listener;
+            qcm = new QuorumCnxManager(this);
+            QuorumCnxManager.Listener listener = qcm.listener;
             if(listener != null){
                 listener.start();
-                le = new FastLeaderElection(this,mng);
+                le = new FastLeaderElection(this, qcm);
             } else {
                 LOG.error(""Null listener when initializing cnx manager"");
             }
@@ -957,4 +958,11 @@
     public boolean isRunning() {
         return running;
     }
+
+    /**
+     * get reference to QuorumCnxManager
+     */
+    public QuorumCnxManager getQuorumCnxManager() {
+        return qcm;
+}
 }
"
zookeeper,575c53253bf9f548f342c3371d05bc00d2c2363d,ZOOKEEPER-985. Test BookieRecoveryTest fails on trunk. (fpj via breed),2011.02.19 02:54:48,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java
index 40278a3..3f6d347 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java
@@ -66,6 +66,9 @@
 
     // ZooKeeper client instance for the Bookie
     ZooKeeper zk;
+    
+    // Running flag
+    private volatile boolean running = false;
 
     public static class NoLedgerException extends IOException {
         private static final long serialVersionUID = 1L;
@@ -378,6 +381,10 @@
     
     private LastLogMark lastLogMark = new LastLogMark(0, 0);
     
+    public boolean isRunning(){
+        return running;
+    }
+    
     @Override
     public void run() {
         LinkedList<QueueEntry> toFlush = new LinkedList<QueueEntry>();
@@ -390,6 +397,7 @@
             long nextPrealloc = preAllocSize;
             long lastFlushPosition = 0;
             logFile.write(zeros, nextPrealloc);
+            running = true;
             // TODO: Currently, when we roll over the journal logs, the older
             // ones are never garbage collected. We should remove a journal log
             // once all of its entries have been synced with the entry logs.
@@ -432,6 +440,7 @@
         } catch (Exception e) {
             LOG.fatal(""Bookie thread exiting"", e);
         }
+        running = false;
     }
 
     private FileChannel openChannel(long logId) throws FileNotFoundException {
"
zookeeper,575c53253bf9f548f342c3371d05bc00d2c2363d,ZOOKEEPER-985. Test BookieRecoveryTest fails on trunk. (fpj via breed),2011.02.19 02:54:48,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/BookieServer.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/BookieServer.java
index fd2bd18..5881fcb 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/BookieServer.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/BookieServer.java
@@ -38,7 +38,7 @@
 public class BookieServer implements NIOServerFactory.PacketProcessor, BookkeeperInternalCallbacks.WriteCallback {
     int port;
     NIOServerFactory nioServerFactory;
-    volatile boolean down = false;
+    private volatile boolean running = false;
     Bookie bookie;
     static Logger LOG = Logger.getLogger(BookieServer.class);
 
@@ -49,16 +49,17 @@
 
     public void start() throws IOException {
         nioServerFactory = new NIOServerFactory(port, this);
+        running = true;
     }
 
     public void shutdown() throws InterruptedException {
-        down = true;
+        running = false;
         nioServerFactory.shutdown();
         bookie.shutdown();
     }
 
-    public boolean isDown() {
-        return down;
+    public boolean isRunning(){
+        return bookie.isRunning() && nioServerFactory.isRunning() && running;
     }
 
     public void join() throws InterruptedException {
"
zookeeper,575c53253bf9f548f342c3371d05bc00d2c2363d,ZOOKEEPER-985. Test BookieRecoveryTest fails on trunk. (fpj via breed),2011.02.19 02:54:48,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/NIOServerFactory.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/NIOServerFactory.java
index 46cb5b7..377b14f 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/NIOServerFactory.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/NIOServerFactory.java
@@ -90,6 +90,10 @@
         }
     }
 
+    public boolean isRunning() {
+        return !ss.socket().isClosed();
+    }
+    
     @Override
     public void run() {
         while (!ss.socket().isClosed()) {
"
zookeeper,4bbdfaf41ee86b55eb19073d1ec848eda1377290,"ZOOKEEPER-902. Fix findbug issue in trunk ""Malicious code vulnerability""",2011.02.08 04:26:47,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
index c3bb6ca..c278cf0 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
@@ -25,7 +25,11 @@
 import java.net.SocketException;
 import java.nio.ByteBuffer;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.Semaphore;
 
@@ -193,11 +197,11 @@
         long lastProposedLeader;
         long lastProposedZxid;
         long lastEpoch;
-        final LinkedBlockingQueue<Long> acksqueue;
-        final HashMap<Long, Long> challengeMap;
-        final HashMap<Long, Semaphore> challengeMutex;
-        final HashMap<Long, Semaphore> ackMutex;
-        final HashMap<InetSocketAddress, HashMap<Long, Long>> addrChallengeMap;
+        final Set<Long> ackset;
+        final ConcurrentHashMap<Long, Long> challengeMap;
+        final ConcurrentHashMap<Long, Semaphore> challengeMutex;
+        final ConcurrentHashMap<Long, Semaphore> ackMutex;
+        final ConcurrentHashMap<InetSocketAddress, ConcurrentHashMap<Long, Long>> addrChallengeMap;
 
         class WorkerReceiver implements Runnable {
 
@@ -210,11 +214,9 @@
             }
 
             boolean saveChallenge(long tag, long challenge) {
-
-                //Long l = challengeMutex.get(tag);
                 Semaphore s = challengeMutex.get(tag);
                 if (s != null) {
-                        synchronized (challengeMap) {
+                        synchronized (Messenger.this) {
                             challengeMap.put(tag, challenge);
                             challengeMutex.remove(tag);
                         }
@@ -310,27 +312,30 @@
                         InetSocketAddress addr = (InetSocketAddress) responsePacket
                                 .getSocketAddress();
                         if (authEnabled) {
-                            if (addrChallengeMap.get(addr).get(tag) != null) {
-                                recChallenge = responseBuffer.getLong();
+                            ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(addr);
+                            if(tmpMap != null){
+                                if (tmpMap.get(tag) != null) {
+                                    recChallenge = responseBuffer.getLong();
 
-                                if (addrChallengeMap.get(addr).get(tag) == recChallenge) {
-                                    recvqueue.offer(n);
+                                    if (tmpMap.get(tag) == recChallenge) {
+                                        recvqueue.offer(n);
 
-                                    ToSend a = new ToSend(ToSend.mType.ack,
-                                            tag, current.id,
-                                            current.zxid,
-                                            logicalclock, self.getPeerState(),
-                                            addr);
+                                        ToSend a = new ToSend(ToSend.mType.ack,
+                                                tag, current.id,
+                                                current.zxid,
+                                                logicalclock, self.getPeerState(),
+                                                addr);
 
-                                    sendqueue.offer(a);
+                                        sendqueue.offer(a);
+                                    } else {
+                                        LOG.warn(""Incorrect challenge: ""
+                                                + recChallenge + "", ""
+                                                + addrChallengeMap.toString());
+                                    }
                                 } else {
-                                    LOG.warn(""Incorrect challenge: ""
-                                            + recChallenge + "", ""
-                                            + addrChallengeMap.toString());
+                                    LOG.warn(""No challenge for host: "" + addr
+                                            + "" "" + tag);
                                 }
-                            } else {
-                                LOG.warn(""No challenge for host: "" + addr
-                                        + "" "" + tag);
                             }
                         } else {
                             recvqueue.offer(n);
@@ -354,11 +359,17 @@
                             s.release();
                         else LOG.error(""Empty ack semaphore"");
                         
-                        acksqueue.offer(tag);
+                        ackset.add(tag);
 
                         if (authEnabled) {
-                            addrChallengeMap.get(responsePacket
-                                            .getSocketAddress()).remove(tag);
+                            ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(responsePacket
+                                    .getSocketAddress());
+                            if(tmpMap != null) {
+                                tmpMap.remove(tag);
+                            } else {
+                                LOG.warn(""No such address in the ensemble configuration "" + responsePacket
+                                    .getSocketAddress());
+                            }
                         }
 
                         if (ackstate != QuorumPeer.ServerState.LOOKING) {
@@ -485,40 +496,46 @@
                      */
 
                     long newChallenge;
-                    if (addrChallengeMap.get(m.addr).containsKey(m.tag)) {
-                        newChallenge = addrChallengeMap.get(m.addr).get(m.tag);
+                    ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(m.addr); 
+                    if(tmpMap != null){
+                        Long tmpLong = tmpMap.get(m.tag);
+                        if (tmpLong != null) {
+                            newChallenge = tmpLong;
+                        } else {
+                            newChallenge = genChallenge();
+                        }
+
+                        tmpMap.put(m.tag, newChallenge);
+
+                        requestBuffer.clear();
+                        requestBuffer.putInt(ToSend.mType.challenge.ordinal());
+                        requestBuffer.putLong(m.tag);
+                        requestBuffer.putInt(m.state.ordinal());
+                        requestBuffer.putLong(newChallenge);
+                        zeroes = new byte[24];
+                        requestBuffer.put(zeroes);
+
+                        requestPacket.setLength(48);
+                        try {
+                            requestPacket.setSocketAddress(m.addr);
+                        } catch (IllegalArgumentException e) {
+                            // Sun doesn't include the address that causes this
+                            // exception to be thrown, so we wrap the exception
+                            // in order to capture this critical detail.
+                            throw new IllegalArgumentException(
+                                    ""Unable to set socket address on packet, msg:""
+                                    + e.getMessage() + "" with addr:"" + m.addr,
+                                    e);
+                        }
+
+
+                        try {
+                            mySocket.send(requestPacket);
+                        } catch (IOException e) {
+                            LOG.warn(""Exception while sending challenge: "", e);
+                        }
                     } else {
-                        newChallenge = genChallenge();
-                    }
-
-                    addrChallengeMap.get(m.addr).put(m.tag, newChallenge);
-
-                    requestBuffer.clear();
-                    requestBuffer.putInt(ToSend.mType.challenge.ordinal());
-                    requestBuffer.putLong(m.tag);
-                    requestBuffer.putInt(m.state.ordinal());
-                    requestBuffer.putLong(newChallenge);
-                    zeroes = new byte[24];
-                    requestBuffer.put(zeroes);
-
-                    requestPacket.setLength(48);
-                    try {
-                        requestPacket.setSocketAddress(m.addr);
-                    } catch (IllegalArgumentException e) {
-                        // Sun doesn't include the address that causes this
-                        // exception to be thrown, so we wrap the exception
-                        // in order to capture this critical detail.
-                        throw new IllegalArgumentException(
-                                ""Unable to set socket address on packet, msg:""
-                                + e.getMessage() + "" with addr:"" + m.addr,
-                                e);
-                    }
-
-
-                    try {
-                        mySocket.send(requestPacket);
-                    } catch (IOException e) {
-                        LOG.warn(""Exception while sending challenge: "", e);
+                        LOG.error(""Address is not in the configuration: "" + m.addr);
                     }
 
                     break;
@@ -573,9 +590,8 @@
                                     double timeout = ackWait
                                             * java.lang.Math.pow(2, attempts);
 
-                                    //Long l = new Long(m.tag);
                                     Semaphore s = new Semaphore(0);
-                                    synchronized (s) {
+                                    synchronized(Messenger.this) {
                                         challengeMutex.put(m.tag, s);
                                         s.tryAcquire((long) timeout, TimeUnit.MILLISECONDS);
                                         myChallenge = challengeMap
@@ -598,7 +614,12 @@
 
                             if (authEnabled) {
                                 requestBuffer.position(40);
-                                requestBuffer.putLong(challengeMap.get(m.tag));
+                                Long tmpLong = challengeMap.get(m.tag);
+                                if(tmpLong != null){
+                                    requestBuffer.putLong(tmpLong);
+                                } else {
+                                    LOG.warn(""No challenge with tag: "" + m.tag);
+                                }
                             }
                             mySocket.send(requestPacket);
                             try {
@@ -610,26 +631,11 @@
                             } catch (InterruptedException e) {
                                 LOG.warn(""Ack exception: "", e);
                             }
-                            synchronized (acksqueue) {
-                                for (int i = 0; i < acksqueue.size(); ++i) {
-                                    Long newack = acksqueue.poll();
-
-                                    /*
-                                     * Under highly concurrent load, a thread
-                                     * may get into this loop but by the time it
-                                     * tries to read from the queue, the queue
-                                     * is empty. There are two alternatives:
-                                     * synchronize this block, or test if newack
-                                     * is null.
-                                     *
-                                     */
-
-                                    if (newack == m.tag) {
-                                        myAck = true;
-                                    } else
-                                        acksqueue.offer(newack);
-                                }
-                            }
+                            
+                            if(ackset.remove(m.tag)){
+                                myAck = true;
+                            } 
+                        
                         } catch (IOException e) {
                             LOG.warn(""Sending exception: "", e);
                             /*
@@ -640,8 +646,8 @@
                             /*
                              * Received ack successfully, so return
                              */
-                            if (challengeMap.get(m.tag) != null)
-                                challengeMap.remove(m.tag);
+                            challengeMap.remove(m.tag);
+                            
                             return;
                         } else
                             attempts++;
@@ -690,17 +696,17 @@
         }
 
         public boolean queueEmpty() {
-            return (sendqueue.isEmpty() || acksqueue.isEmpty() || recvqueue
+            return (sendqueue.isEmpty() || ackset.isEmpty() || recvqueue
                     .isEmpty());
         }
 
         Messenger(int threads, DatagramSocket s) {
             mySocket = s;
-            acksqueue = new LinkedBlockingQueue<Long>();
-            challengeMap = new HashMap<Long, Long>();
-            challengeMutex = new HashMap<Long, Semaphore>();
-            ackMutex = new HashMap<Long, Semaphore>();
-            addrChallengeMap = new HashMap<InetSocketAddress, HashMap<Long, Long>>();
+            ackset =  Collections.<Long>newSetFromMap(new ConcurrentHashMap<Long, Boolean>());
+            challengeMap = new ConcurrentHashMap<Long, Long>();
+            challengeMutex = new ConcurrentHashMap<Long, Semaphore>();
+            ackMutex = new ConcurrentHashMap<Long, Semaphore>();
+            addrChallengeMap = new ConcurrentHashMap<InetSocketAddress, ConcurrentHashMap<Long, Long>>();
             lastProposedLeader = 0;
             lastProposedZxid = 0;
             lastEpoch = 0;
@@ -715,7 +721,7 @@
             for (QuorumServer server : self.getVotingView().values()) {
                 InetSocketAddress saddr = new InetSocketAddress(server.addr
                         .getAddress(), port);
-                addrChallengeMap.put(saddr, new HashMap<Long, Long>());
+                addrChallengeMap.put(saddr, new ConcurrentHashMap<Long, Long>());
             }
 
             Thread t = new Thread(new WorkerReceiver(s, this),
"
zookeeper,4bbdfaf41ee86b55eb19073d1ec848eda1377290,"ZOOKEEPER-902. Fix findbug issue in trunk ""Malicious code vulnerability""",2011.02.08 04:26:47,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index ec2f3bf..7d8e837 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -86,11 +86,8 @@
                     e1.printStackTrace();
                 }
     
-                synchronized (pendingRevalidations) {
-                    // clear pending revalidations
-                    pendingRevalidations.clear();
-                    pendingRevalidations.notifyAll();
-                }
+                // clear pending revalidations
+                pendingRevalidations.clear();
             }
         } finally {
             zk.unregisterJMX((Learner)this);
"
zookeeper,4bbdfaf41ee86b55eb19073d1ec848eda1377290,"ZOOKEEPER-902. Fix findbug issue in trunk ""Malicious code vulnerability""",2011.02.08 04:26:47,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 576e755..38b6e3e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -384,16 +384,14 @@
         DataInputStream dis = new DataInputStream(bis);
         long sessionId = dis.readLong();
         boolean valid = dis.readBoolean();
-        synchronized (pendingRevalidations) {
-            ServerCnxn cnxn = pendingRevalidations
-                    .remove(sessionId);
-            if (cnxn == null) {
-                LOG.warn(""Missing session 0x""
-                        + Long.toHexString(sessionId)
-                        + "" for validation"");
-            } else {
-                zk.finishSessionInit(cnxn, valid);
-            }
+        ServerCnxn cnxn = pendingRevalidations
+        .remove(sessionId);
+        if (cnxn == null) {
+            LOG.warn(""Missing session 0x""
+                    + Long.toHexString(sessionId)
+                    + "" for validation"");
+        } else {
+            zk.finishSessionInit(cnxn, valid);
         }
         if (LOG.isTraceEnabled()) {
             ZooTrace.logTraceMessage(LOG,
"
zookeeper,4bbdfaf41ee86b55eb19073d1ec848eda1377290,"ZOOKEEPER-902. Fix findbug issue in trunk ""Malicious code vulnerability""",2011.02.08 04:26:47,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
index 1b35586..9da7136 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
@@ -83,11 +83,8 @@
                     e1.printStackTrace();
                 }
     
-                synchronized (pendingRevalidations) {
-                    // clear pending revalidations
-                    pendingRevalidations.clear();
-                    pendingRevalidations.notifyAll();
-                }
+                // clear pending revalidations
+                pendingRevalidations.clear();
             }
         } finally {
             zk.unregisterJMX(this);
"
zookeeper,4bbdfaf41ee86b55eb19073d1ec848eda1377290,"ZOOKEEPER-902. Fix findbug issue in trunk ""Malicious code vulnerability""",2011.02.08 04:26:47,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 188d45d..9468968 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -698,7 +698,6 @@
         @Override
         public void run() {
             try {
-                byte[] size = new byte[4];
                 while (running && !shutdown && sock != null) {
                     /**
                      * Reads the first int to determine the length of the
@@ -716,9 +715,7 @@
                     byte[] msgArray = new byte[length];
                     din.readFully(msgArray, 0, length);
                     ByteBuffer message = ByteBuffer.wrap(msgArray);
-                    synchronized (recvQueue) {
-                        recvQueue.put(new Message(message.duplicate(), sid));
-                    }
+                    recvQueue.put(new Message(message.duplicate(), sid));
                 }
             } catch (Exception e) {
                 LOG.warn(""Connection broken for id "" + sid + "", my id = "" + 
"
zookeeper,2bf093ec150923624dd7a042d8d9459d589b1ef3,ZOOKEEPER-962. leader/follower coherence issue when follower is receiving a DIFF,2011.01.23 04:38:57,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 3dde4b3..806141d 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -26,6 +26,9 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
 
 import org.apache.jute.BinaryOutputArchive;
 import org.apache.jute.InputArchive;
@@ -33,16 +36,16 @@
 import org.apache.jute.Record;
 import org.apache.log4j.Logger;
 import org.apache.zookeeper.KeeperException;
-import org.apache.zookeeper.Watcher;
 import org.apache.zookeeper.KeeperException.NoNodeException;
+import org.apache.zookeeper.Watcher;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.server.DataTree.ProcessTxnResult;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog.PlayBackListener;
 import org.apache.zookeeper.server.quorum.Leader;
-import org.apache.zookeeper.server.quorum.QuorumPacket;
 import org.apache.zookeeper.server.quorum.Leader.Proposal;
+import org.apache.zookeeper.server.quorum.QuorumPacket;
 import org.apache.zookeeper.server.util.SerializeUtils;
 import org.apache.zookeeper.txn.TxnHeader;
 
@@ -67,6 +70,7 @@
     public static final int commitLogCount = 500;
     protected static int commitLogBuffer = 700;
     protected LinkedList<Proposal> committedLog = new LinkedList<Proposal>();
+    protected ReentrantReadWriteLock logLock = new ReentrantReadWriteLock();
     volatile private boolean initialized = false;
     
     /**
@@ -104,8 +108,12 @@
          */
         dataTree = new DataTree();
         sessionsWithTimeouts.clear();
-        synchronized (committedLog) {
+        WriteLock lock = logLock.writeLock();
+        try {            
+            lock.lock();
             committedLog.clear();
+        } finally {
+            lock.unlock();
         }
         initialized = false;
     }
@@ -136,13 +144,30 @@
     public long getminCommittedLog() {
         return minCommittedLog;
     }
-    
-    public LinkedList<Proposal> getCommittedLog() {
-        synchronized (this.committedLog) {
-            return new LinkedList<Proposal>(this.committedLog);
-        }
+    /**
+     * Get the lock that controls the committedLog. If you want to get the pointer to the committedLog, you need
+     * to use this lock to acquire a read lock before calling getCommittedLog()
+     * @return the lock that controls the committed log
+     */
+    public ReentrantReadWriteLock getLogLock() {
+        return logLock;
     }
     
+
+    public synchronized LinkedList<Proposal> getCommittedLog() {
+        ReadLock rl = logLock.readLock();
+        // only make a copy if this thread isn't already holding a lock
+        if(logLock.getReadHoldCount() <=0) {
+            try {
+                rl.lock();
+                return new LinkedList<Proposal>(this.committedLog);
+            } finally {
+                rl.unlock();
+            }
+        } 
+        return this.committedLog;
+    }      
+    
     /**
      * get the last processed zxid from a datatree
      * @return the last processed zxid of a datatree
@@ -206,7 +231,9 @@
      * @param request committed request
      */
     public void addCommittedProposal(Request request) {
-        synchronized (committedLog) {
+        WriteLock wl = logLock.writeLock();
+        try {
+            wl.lock();
             if (committedLog.size() > commitLogCount) {
                 committedLog.removeFirst();
                 minCommittedLog = committedLog.getFirst().packet.getZxid();
@@ -234,6 +261,8 @@
             p.request = request;
             committedLog.add(p);
             maxCommittedLog = p.packet.getZxid();
+        } finally {
+            wl.unlock();
         }
     }
 
"
zookeeper,2bf093ec150923624dd7a042d8d9459d589b1ef3,ZOOKEEPER-962. leader/follower coherence issue when follower is receiving a DIFF,2011.01.23 04:38:57,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
index 8ede6f3..b27a54d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
@@ -46,6 +46,7 @@
     LinkedList<Request> committedRequests = new LinkedList<Request>();
 
     RequestProcessor nextProcessor;
+    ArrayList<Request> toProcess = new ArrayList<Request>();
 
     /**
      * This flag indicates whether we need to wait for a response to come back from the
@@ -65,8 +66,7 @@
     @Override
     public void run() {
         try {
-            Request nextPending = null;
-            ArrayList<Request> toProcess = new ArrayList<Request>();
+            Request nextPending = null;            
             while (!finished) {
                 int len = toProcess.size();
                 for (int i = 0; i < len; i++) {
"
zookeeper,2bf093ec150923624dd7a042d8d9459d589b1ef3,ZOOKEEPER-962. leader/follower coherence issue when follower is receiving a DIFF,2011.01.23 04:38:57,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index 97096b5..ec2f3bf 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -125,8 +125,7 @@
             fzk.commit(qp.getZxid());
             break;
         case Leader.UPTODATE:
-            fzk.takeSnapshot();
-            self.cnxnFactory.setZooKeeperServer(fzk);
+            LOG.error(""Received an UPTODATE message after Follower started"");
             break;
         case Leader.REVALIDATE:
             revalidate(qp);
"
zookeeper,2bf093ec150923624dd7a042d8d9459d589b1ef3,ZOOKEEPER-962. leader/follower coherence issue when follower is receiving a DIFF,2011.01.23 04:38:57,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index cad423f..576e755 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -28,6 +28,7 @@
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.util.HashMap;
+import java.util.LinkedList;
 import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 
@@ -35,11 +36,14 @@
 import org.apache.jute.BinaryOutputArchive;
 import org.apache.jute.InputArchive;
 import org.apache.jute.OutputArchive;
+import org.apache.jute.Record;
 import org.apache.log4j.Logger;
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.ServerCnxn;
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+import org.apache.zookeeper.server.util.SerializeUtils;
+import org.apache.zookeeper.txn.TxnHeader;
 
 /**
  * This class is the superclass of two of the three main actors in a ZK
@@ -47,6 +51,10 @@
  * a good deal of code which is moved into Peer to avoid duplication. 
  */
 public class Learner {       
+    static class PacketInFlight {
+        TxnHeader hdr;
+        Record rec;
+    }
     QuorumPeer self;
     LearnerZooKeeperServer zk;
     
@@ -275,7 +283,8 @@
         QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);
         QuorumPacket qp = new QuorumPacket();
         
-        readPacket(qp);        
+        readPacket(qp);   
+        LinkedList<PacketInFlight> packetsNotCommitted = new LinkedList<PacketInFlight>();
         synchronized (zk) {
             if (qp.getType() == Leader.DIFF) {
                 LOG.info(""Getting a diff from the leader 0x"" + Long.toHexString(qp.getZxid()));                
@@ -289,7 +298,7 @@
                 String signature = leaderIs.readString(""signature"");
                 if (!signature.equals(""BenWasHere"")) {
                     LOG.error(""Missing signature. Got "" + signature);
-                    throw new IOException(""Missing signature"");
+                    throw new IOException(""Missing signature"");                   
                 }
             } else if (qp.getType() == Leader.TRUNC) {
                 //we need to truncate the log to the lastzxid of the leader
@@ -310,15 +319,63 @@
                 System.exit(13);
 
             }
+            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());
             if(LOG.isInfoEnabled()){
                 LOG.info(""Setting leader epoch "" + Long.toHexString(newLeaderZxid >> 32L));
             }
-            zk.getZKDatabase().setlastProcessedZxid(newLeaderZxid);
+                        
+            long lastQueued = 0;
+            // we are now going to start getting transactions to apply followed by an UPTODATE
+            outerLoop:
+            while (self.isRunning()) {
+                readPacket(qp);
+                switch(qp.getType()) {
+                case Leader.PROPOSAL:
+                    PacketInFlight pif = new PacketInFlight();
+                    pif.hdr = new TxnHeader();
+                    BinaryInputArchive ia = BinaryInputArchive
+                            .getArchive(new ByteArrayInputStream(qp.getData()));
+                    pif.rec     = SerializeUtils.deserializeTxn(ia, pif.hdr);
+                    if (pif.hdr.    getZxid() != lastQueued + 1) {
+                    LOG.warn(""Got zxid 0x""
+                            + Long.toHexString(pif.hdr.getZxid())
+                            + "" expected 0x""
+                            + Long.toHexString(lastQueued + 1));
+                    }
+                    lastQueued = pif.hdr.getZxid();
+                    packetsNotCommitted.add(pif);
+                    break;
+                case Leader.COMMIT:
+                    pif = packetsNotCommitted.peekFirst();
+                    if (pif.hdr.getZxid() != qp.getZxid()) {
+                        LOG.warn(""Committing "" + qp.getZxid() + "", but next proposal is "" + pif.hdr.getZxid());
+                    } else {
+                        zk.getZKDatabase().processTxn(pif.hdr, pif.rec);
+                        packetsNotCommitted.remove();
+                    }
+                    break;
+                case Leader.INFORM:
+                    TxnHeader hdr = new TxnHeader();
+                    ia = BinaryInputArchive
+                            .getArchive(new ByteArrayInputStream(qp.getData()));
+                    Record txn = SerializeUtils.deserializeTxn(ia, hdr);
+                    zk.getZKDatabase().processTxn(hdr, txn);
+                    break;
+                case Leader.UPTODATE:
+                    zk.takeSnapshot();
+                    self.cnxnFactory.setZooKeeperServer(zk);                
+                    break outerLoop;
+                }
+            }
         }
         ack.setZxid(newLeaderZxid & ~0xffffffffL);
         writePacket(ack, true);
         sock.setSoTimeout(self.tickTime * self.syncLimit);
         zk.startup();
+        //We have to have a commit processor to do this
+        for(PacketInFlight p: packetsNotCommitted) {
+            ((FollowerZooKeeperServer)zk).logRequest(p.hdr, p.rec);
+        }
     }
     
     protected void revalidate(QuorumPacket qp) throws IOException {
"
zookeeper,2bf093ec150923624dd7a042d8d9459d589b1ef3,ZOOKEEPER-962. leader/follower coherence issue when follower is receiving a DIFF,2011.01.23 04:38:57,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index 6bccdd9..74defbd 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -29,6 +29,8 @@
 import java.nio.ByteBuffer;
 import java.util.LinkedList;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
 
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.BinaryOutputArchive;
@@ -254,79 +256,72 @@
             long peerLastZxid = qp.getZxid();
             /* the default to send to the follower */
             int packetToSend = Leader.SNAP;
-            boolean logTxns = true;
             long zxidToSend = 0;
-            
+            long leaderLastZxid = 0;
             /** the packets that the follower needs to get updates from **/
             long updates = peerLastZxid;
             
             /* we are sending the diff check if we have proposals in memory to be able to 
              * send a diff to the 
              */ 
-            LinkedList<Proposal> proposals = leader.zk.getZKDatabase().getCommittedLog();
-            synchronized(proposals) {
+            ReentrantReadWriteLock lock = leader.zk.getZKDatabase().getLogLock();
+            ReadLock rl = lock.readLock();
+            try {
+                rl.lock();        
+                final long maxCommittedLog = leader.zk.getZKDatabase().getmaxCommittedLog();
+                final long minCommittedLog = leader.zk.getZKDatabase().getminCommittedLog();
+                LinkedList<Proposal> proposals = leader.zk.getZKDatabase().getCommittedLog();
                 if (proposals.size() != 0) {
-                    if ((leader.zk.getZKDatabase().getmaxCommittedLog() >= peerLastZxid)
-                            && (leader.zk.getZKDatabase().getminCommittedLog() <= peerLastZxid)) {
+                    if ((maxCommittedLog >= peerLastZxid)
+                            && (minCommittedLog <= peerLastZxid)) {
                         packetToSend = Leader.DIFF;
-                        zxidToSend = leader.zk.getZKDatabase().getmaxCommittedLog();
+                        zxidToSend = maxCommittedLog;
                         for (Proposal propose: proposals) {
                             if (propose.packet.getZxid() > peerLastZxid) {
                                 queuePacket(propose.packet);
                                 QuorumPacket qcommit = new QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),
                                         null, null);
                                 queuePacket(qcommit);
-
                             }
                         }
+                    } else if (peerLastZxid > maxCommittedLog) {
+                        packetToSend = Leader.TRUNC;
+                        zxidToSend = maxCommittedLog;
+                        updates = zxidToSend;
                     }
+                } else {
+                    // just let the state transfer happen
+                }               
+                
+                leaderLastZxid = leader.startForwarding(this, updates);
+                if (peerLastZxid == leaderLastZxid) {
+                    // We are in sync so we'll do an empty diff
+                    packetToSend = Leader.DIFF;
+                    zxidToSend = leaderLastZxid;
                 }
-                else {
-                    logTxns = false;
-                }            
-            }
-            
-            //check if we decided to send a diff or we need to send a truncate
-            // we avoid using epochs for truncating because epochs make things
-            // complicated. Two epochs might have the last 32 bits as same.
-            // only if we know that there is a committed zxid in the queue that
-            // is less than the one the peer has we send a trunc else to make
-            // things simple we just send sanpshot.
-            if (logTxns && (peerLastZxid > leader.zk.getZKDatabase().getmaxCommittedLog())) {
-                // this is the only case that we are sure that
-                // we can ask the peer to truncate the log
-                packetToSend = Leader.TRUNC;
-                zxidToSend = leader.zk.getZKDatabase().getmaxCommittedLog();
-                updates = zxidToSend;
-            }
-            
-            /* see what other packets from the proposal
-             * and tobeapplied queues need to be sent
-             * and then decide if we can just send a DIFF
-             * or we actually need to send the whole snapshot
-             */
-            long leaderLastZxid = leader.startForwarding(this, updates);
-            // a special case when both the ids are the same 
-            if (peerLastZxid == leaderLastZxid) {
-                packetToSend = Leader.DIFF;
-                zxidToSend = leaderLastZxid;
+            } finally {
+                rl.unlock();
             }
 
             QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,
                     leaderLastZxid, null, null);
             oa.writeRecord(newLeaderQP, ""packet"");
             bufferedOutput.flush();
-            
-           
+            //Need to set the zxidToSend to the latest zxid
+            if (packetToSend == Leader.SNAP) {
+                zxidToSend = leader.zk.getZKDatabase().getDataTreeLastProcessedZxid();
+            }
             oa.writeRecord(new QuorumPacket(packetToSend, zxidToSend, null, null), ""packet"");
             bufferedOutput.flush();
             
             /* if we are not truncating or sending a diff just send a snapshot */
             if (packetToSend == Leader.SNAP) {
-                LOG.warn(""Sending snapshot last zxid of peer is 0x""
+                LOG.info(""Sending snapshot last zxid of peer is 0x""
                         + Long.toHexString(peerLastZxid) + "" "" 
                         + "" zxid of leader is 0x""
-                        + Long.toHexString(leaderLastZxid));
+                        + Long.toHexString(leaderLastZxid)
+                        + ""sent zxid of db as 0x"" 
+                        + Long.toHexString(zxidToSend));
                 // Dump data to peer
                 leader.zk.getZKDatabase().serializeSnapshot(oa);
                 oa.writeString(""BenWasHere"", ""signature"");
@@ -524,6 +519,6 @@
 
     public boolean synced() {
         return isAlive()
-                && tickOfLastAck >= leader.self.tick - leader.self.syncLimit;
+        && tickOfLastAck >= leader.self.tick - leader.self.syncLimit;
     }
 }
"
zookeeper,2bf093ec150923624dd7a042d8d9459d589b1ef3,ZOOKEEPER-962. leader/follower coherence issue when follower is receiving a DIFF,2011.01.23 04:38:57,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
index 3509c11..1b35586 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
@@ -111,8 +111,7 @@
             LOG.warn(""Ignoring commit"");            
             break;            
         case Leader.UPTODATE:
-            zk.takeSnapshot();
-            self.cnxnFactory.setZooKeeperServer(zk);
+            LOG.error(""Received an UPTODATE message after Observer started"");
             break;
         case Leader.REVALIDATE:
             revalidate(qp);
"
zookeeper,2a6f177a50c84b7998fa831db1ee54a2f6e2349a,ZOOKEEPER-882. Startup loads last transaction from snapshot (jared via fpj),2010.12.23 21:42:42,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 3d7788f..35942ec 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -570,11 +570,14 @@
                 inputStream.close();
                 inputStream = null;
                 ia = null;
-                // thsi means that the file has ended
+                hdr = null;
+                // this means that the file has ended
                 // we shoud go to the next file
                 if (!goToNextLog()) {
                     return false;
                 }
+                // if we went to the next log file, we should call next() again
+                return next();
             }
             return true;
         }
"
zookeeper,2a6f177a50c84b7998fa831db1ee54a2f6e2349a,ZOOKEEPER-882. Startup loads last transaction from snapshot (jared via fpj),2010.12.23 21:42:42,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 4b73096..555c636 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -123,7 +123,7 @@
             PlayBackListener listener) throws IOException {
         snapLog.deserialize(dt, sessions);
         FileTxnLog txnLog = new FileTxnLog(dataDir);
-        TxnIterator itr = txnLog.read(dt.lastProcessedZxid);
+        TxnIterator itr = txnLog.read(dt.lastProcessedZxid+1);
         long highestZxid = dt.lastProcessedZxid;
         TxnHeader hdr;
         while (true) {
"
zookeeper,0e604b1006d0edc079004639e63477a800f2f9f5,"ZOOKEEPER-913. Version parser fails to parse ""3.3.2-dev"" from build.xml",2010.12.09 04:29:34,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/Version.java b/src/java/main/org/apache/zookeeper/Version.java
index 9725dbf..4657371 100644
--- a/src/java/main/org/apache/zookeeper/Version.java
+++ b/src/java/main/org/apache/zookeeper/Version.java
@@ -18,7 +18,7 @@
 
 package org.apache.zookeeper;
 
-public class Version implements org.apache.zookeeper.version.Info{
+public class Version implements org.apache.zookeeper.version.Info {
 
     public static int getRevision() {
         return REVISION;
@@ -29,7 +29,8 @@
     }
 
     public static String getVersion() {
-        return MAJOR + ""."" + MINOR + ""."" + MICRO;
+        return MAJOR + ""."" + MINOR + ""."" + MICRO
+            + (QUALIFIER == null ? """" : ""-"" + QUALIFIER);
     }
 
     public static String getVersionRevision() {
"
zookeeper,0e604b1006d0edc079004639e63477a800f2f9f5,"ZOOKEEPER-913. Version parser fails to parse ""3.3.2-dev"" from build.xml",2010.12.09 04:29:34,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/version/util/VerGen.java b/src/java/main/org/apache/zookeeper/version/util/VerGen.java
index 2a177b2..be494cd 100644
--- a/src/java/main/org/apache/zookeeper/version/util/VerGen.java
+++ b/src/java/main/org/apache/zookeeper/version/util/VerGen.java
@@ -21,6 +21,8 @@
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 public class VerGen {
     private static final String PACKAGE_NAME = ""org.apache.zookeeper.version"";
@@ -28,12 +30,12 @@
 
     static void printUsage() {
         System.out.print(""Usage:\tjava  -cp <classpath> org.apache.zookeeper.""
-                + ""version.util.VerGen maj.min.micro rev buildDate"");
+                + ""version.util.VerGen maj.min.micro[-qualifier] rev buildDate"");
         System.exit(1);
     }
 
-    static void generateFile(File outputDir, int maj, int min, int micro, int rev,
-            String buildDate) {
+    public static void generateFile(File outputDir, Version version, int rev, String buildDate)
+    {
         String path = PACKAGE_NAME.replaceAll(""\\."", ""/"");
         File pkgdir = new File(outputDir, path);
         if (!pkgdir.exists()) {
@@ -74,9 +76,13 @@
             w.write(""\n"");
             w.write(""package "" + PACKAGE_NAME + "";\n\n"");
             w.write(""public interface "" + TYPE_NAME + "" {\n"");
-            w.write(""    public static final int MAJOR="" + maj + "";\n"");
-            w.write(""    public static final int MINOR="" + min + "";\n"");
-            w.write(""    public static final int MICRO="" + micro + "";\n"");
+            w.write(""    public static final int MAJOR="" + version.maj + "";\n"");
+            w.write(""    public static final int MINOR="" + version.min + "";\n"");
+            w.write(""    public static final int MICRO="" + version.micro + "";\n"");
+            w.write(""    public static final String QUALIFIER=""
+                    + (version.qualifier == null ? null :
+                        ""\"""" + version.qualifier + ""\"""")
+                    + "";\n"");
             if (rev < 0) {
                 System.out.println(""Unknown REVISION number, using "" + rev);
             }
@@ -100,18 +106,46 @@
         }
     }
 
+    public static class Version {
+        public int maj;
+        public int min;
+        public int micro;
+        public String qualifier;
+    }
+    
+    public static Version parseVersionString(String input) {
+        Version result = new Version();
+
+        Pattern p = Pattern.compile(""^(\\d+).(\\d+).(\\d+)(-(.+))?$"");
+        Matcher m = p.matcher(input);
+
+        if (!m.matches()) {
+            return null;
+        }
+        result.maj = Integer.parseInt(m.group(1));
+        result.min = Integer.parseInt(m.group(2));
+        result.micro = Integer.parseInt(m.group(3));
+        if (m.groupCount() == 5) {
+            result.qualifier = m.group(5);
+        } else {
+            result.qualifier = null;
+        }
+        return result;
+    }
+
     /**
      * Emits a org.apache.zookeeper.version.Info interface file with version and
      * revision information constants set to the values passed in as command
      * line parameters. The file is created in the current directory. <br>
-     * Usage: java org.apache.zookeeper.version.util.VerGen maj.min.micro rev
-     * buildDate
+     * Usage: java org.apache.zookeeper.version.util.VerGen maj.min.micro[-qualifier]
+     * rev buildDate
      *
      * @param args
      *            <ul>
      *            <li>maj - major version number
      *            <li>min - minor version number
      *            <li>micro - minor minor version number
+     *            <li>qualifier - optional qualifier (dash followed by qualifier text)
      *            <li>rev - current SVN revision number
      *            <li>buildDate - date the build
      *            </ul>
@@ -120,25 +154,22 @@
         if (args.length != 3)
             printUsage();
         try {
-            String[] v = args[0].split(""\\."");
-            if (v.length != 3) {
-                System.err
-                        .println(""Invalid version number format, must be \""x.y.z\"""");
+            Version version = parseVersionString(args[0]);
+            if (version == null) {
+                System.err.println(
+                        ""Invalid version number format, must be \""x.y.z(-.*)?\"""");
                 System.exit(1);
             }
-            int maj = Integer.parseInt(v[0]);
-            int min = Integer.parseInt(v[1]);
-            int micro = Integer.parseInt(v[2]);
             int rev;
             try {
                 rev = Integer.parseInt(args[1]);
             } catch (NumberFormatException e) {
                 rev = -1;
             }
-            generateFile(new File("".""), maj, min, micro, rev, args[2]);
+            generateFile(new File("".""), version, rev, args[2]);
         } catch (NumberFormatException e) {
-            System.err
-                .println(""All version-related parameters must be valid integers!"");
+            System.err.println(
+                    ""All version-related parameters must be valid integers!"");
             throw e;
         }
     }
"
zookeeper,9ef18fd3788eb37c90888e2cd12c84251e4db1aa,ZOOKEEPER-884. Remove LedgerSequence references from BookKeeper documentation and comments in tests,2010.11.05 14:16:46,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/benchmark/org/apache/bookkeeper/benchmark/TestClient.java b/src/contrib/bookkeeper/benchmark/org/apache/bookkeeper/benchmark/TestClient.java
index 5fbf8da..d24bf7a 100644
--- a/src/contrib/bookkeeper/benchmark/org/apache/bookkeeper/benchmark/TestClient.java
+++ b/src/contrib/bookkeeper/benchmark/org/apache/bookkeeper/benchmark/TestClient.java
@@ -24,6 +24,7 @@
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.util.Enumeration;
 import java.util.HashMap;
 
 import org.apache.bookkeeper.client.AddCallback;
@@ -31,7 +32,6 @@
 import org.apache.bookkeeper.client.BookKeeper;
 import org.apache.bookkeeper.client.LedgerEntry;
 import org.apache.bookkeeper.client.LedgerHandle;
-import org.apache.bookkeeper.client.LedgerSequence;
 import org.apache.bookkeeper.client.QuorumEngine;
 import org.apache.bookkeeper.client.ReadCallback;
 import org.apache.bookkeeper.client.LedgerHandle.QMode;
@@ -239,7 +239,7 @@
         this.removeEntryId((Integer) ctx);
     }
    
-    public void readComplete(int rc, long ledgerId, LedgerSequence seq, Object ctx){
+    public void readComplete(int rc, long ledgerId, Enumeration<LedgerEntry> seq, Object ctx){
         System.out.println(""Read callback: "" + rc);
         while(seq.hasMoreElements()){
             LedgerEntry le = seq.nextElement();
"
zookeeper,dad9d5791ba9f8db74e9c94ae9a063a7919cf8ef,"ZOOKEEPER-907. Spurious ""KeeperErrorCode = Session moved"" messages",2010.11.05 01:01:51,Benjamin Reed,"diff --git a/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java b/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java
index dbcc374..0a47470 100644
--- a/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java
+++ b/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/common/ServerConfiguration.java
@@ -56,6 +56,8 @@
     protected final static String RETENTION_SECS = ""retention_secs"";
     protected final static String INTER_REGION_SSL_ENABLED = ""inter_region_ssl_enabled"";
     protected final static String MESSAGES_CONSUMED_THREAD_RUN_INTERVAL = ""messages_consumed_thread_run_interval"";
+    protected final static String BK_ENSEMBLE_SIZE = ""bk_ensemble_size"";
+    protected final static String BK_QUORUM_SIZE = ""bk_quorum_size"";
 
     // these are the derived attributes
     protected ByteString myRegionByteString = null;
@@ -244,6 +246,20 @@
         return conf.getInt(MESSAGES_CONSUMED_THREAD_RUN_INTERVAL, 60000);
     }
 
+    // This parameter is used when Bookkeeper is the persistence store
+    // and indicates what the ensemble size is (i.e. how many bookie
+    // servers to stripe the ledger entries across).
+    public int getBkEnsembleSize() {
+        return conf.getInt(BK_ENSEMBLE_SIZE, 3);
+    }
+
+    // This parameter is used when Bookkeeper is the persistence store
+    // and indicates what the quorum size is (i.e. how many redundant
+    // copies of each ledger entry is written).
+    public int getBkQuorumSize() {
+        return conf.getInt(BK_QUORUM_SIZE, 2);
+    }
+
     /*
      * Is this a valid configuration that we can run with? This code might grow
      * over time.
@@ -262,6 +278,11 @@
                     throw new ConfigurationException(""Region defined does not have required SSL port: "" + hubString);
             }
         }
+        // Validate that the Bookkeeper ensemble size >= quorum size.
+        if (getBkEnsembleSize() < getBkQuorumSize()) {
+            throw new ConfigurationException(""BK ensemble size ("" + getBkEnsembleSize()
+                    + "") is less than the quorum size ("" + getBkQuorumSize() + "")"");
+        }
 
         // add other checks here
     }
"
zookeeper,dad9d5791ba9f8db74e9c94ae9a063a7919cf8ef,"ZOOKEEPER-907. Spurious ""KeeperErrorCode = Session moved"" messages",2010.11.05 01:01:51,Benjamin Reed,"diff --git a/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java b/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java
index 3835fe3..5409102 100644
--- a/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java
+++ b/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/persistence/BookkeeperPersistenceManager.java
@@ -608,10 +608,7 @@
          *            the same when we try to write
          */
         private void openNewTopicLedger(final int expectedVersionOfLedgersNode, final TopicInfo topicInfo) {
-            final int ENSEMBLE_SIZE = 3;
-            final int QUORUM_SIZE = 2;
-
-            bk.asyncCreateLedger(ENSEMBLE_SIZE, QUORUM_SIZE, DigestType.CRC32, passwd,
+            bk.asyncCreateLedger(cfg.getBkEnsembleSize(), cfg.getBkQuorumSize(), DigestType.CRC32, passwd,
                     new SafeAsynBKCallback.CreateCallback() {
                         boolean processed = false;
 
"
zookeeper,dad9d5791ba9f8db74e9c94ae9a063a7919cf8ef,"ZOOKEEPER-907. Spurious ""KeeperErrorCode = Session moved"" messages",2010.11.05 01:01:51,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index d8fad42..ce9d574 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -782,6 +782,9 @@
             }
         } else if (cmd.equals(""close"")) {
                 zk.close();            
+        } else if (cmd.equals(""sync"") && args.length >= 2) {
+            path = args[1];
+            zk.sync(path, new AsyncCallback.VoidCallback() { public void processResult(int rc, String path, Object ctx) { System.out.println(""Sync returned "" + rc); } }, null );
         } else if (cmd.equals(""addauth"") && args.length >=2 ) {
             byte[] b = null;
             if (args.length >= 3)
"
zookeeper,dad9d5791ba9f8db74e9c94ae9a063a7919cf8ef,"ZOOKEEPER-907. Spurious ""KeeperErrorCode = Session moved"" messages",2010.11.05 01:01:51,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index c6c9daa..6bccdd9 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -449,14 +449,14 @@
                     cxid = bb.getInt();
                     type = bb.getInt();
                     bb = bb.slice();
+                    Request si;
                     if(type == OpCode.sync){
-                     	leader.zk.submitRequest(new LearnerSyncRequest(this, sessionId, cxid, type, bb,
-                                qp.getAuthinfo()));
+                        si = new LearnerSyncRequest(this, sessionId, cxid, type, bb, qp.getAuthinfo());
                     } else {
-                        Request si = new Request(null, sessionId, cxid, type, bb, qp.getAuthinfo());
-                        si.setOwner(this);
-                        leader.zk.submitRequest(si);
+                        si = new Request(null, sessionId, cxid, type, bb, qp.getAuthinfo());
                     }
+                    si.setOwner(this);
+                    leader.zk.submitRequest(si);
                     break;
                 default:
                 }
"
zookeeper,8030fe25eaa4a8dc50c28f464c448575da4f9ad4,ZOOKEEPER-904. super digest is not actually acting as a full superuser (Camille Fournier via mahadev),2010.10.27 07:30:06,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 607d6f7..f760b46 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -168,6 +168,11 @@
         if (acl == null || acl.size() == 0) {
             return;
         }
+        for (Id authId : ids) {
+            if (authId.getScheme().equals(""super"")) {
+                return;
+            }
+        }
         for (ACL a : acl) {
             Id id = a.getId();
             if ((a.getPerms() & perm) != 0) {
@@ -178,10 +183,7 @@
                 AuthenticationProvider ap = ProviderRegistry.getProvider(id
                         .getScheme());
                 if (ap != null) {
-                    for (Id authId : ids) {
-                        if (authId.getScheme().equals(""super"")) {
-                            return;
-                        }
+                    for (Id authId : ids) {                        
                         if (authId.getScheme().equals(id.getScheme())
                                 && ap.matches(authId.getId(), id.getId())) {
                             return;
"
zookeeper,d43038a0c8b8881fb4624ef20a7b30b8511e6b24,ZOOKEEPER-794. Callbacks are not invoked when the client is closed,2010.10.21 09:44:05,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index d37ac27..a61c83e 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -451,6 +451,9 @@
          */
         private volatile KeeperState sessionState = KeeperState.Disconnected;
 
+       private volatile boolean wasKilled = false;
+       private volatile boolean isRunning = false;
+
         EventThread() {
             super(makeThreadName(""-EventThread""));
             setUncaughtExceptionHandler(uncaughtExceptionHandler);
@@ -473,9 +476,16 @@
             waitingEvents.add(pair);
         }
 
-        public void queuePacket(Packet packet) {
-            waitingEvents.add(packet);
-        }
+       public void queuePacket(Packet packet) {
+          if (wasKilled) {
+             synchronized (waitingEvents) {
+                if (isRunning) waitingEvents.add(packet);
+                else processEvent(packet);
+             }
+          } else {
+             waitingEvents.add(packet);
+          }
+       }
 
         public void queueEventOfDeath() {
             waitingEvents.add(eventOfDeath);
@@ -483,119 +493,131 @@
 
         @Override
         public void run() {
-            try {
-                while (true) {
-                    Object event = waitingEvents.take();
-                    try {
-                        if (event == eventOfDeath) {
-                            return;
-                        }
-
-                        if (event instanceof WatcherSetEventPair) {
-                            // each watcher will process the event
-                            WatcherSetEventPair pair = (WatcherSetEventPair) event;
-                            for (Watcher watcher : pair.watchers) {
-                                try {
-                                    watcher.process(pair.event);
-                                } catch (Throwable t) {
-                                    LOG.error(""Error while calling watcher "", t);
-                                }
-                            }
-                        } else {
-                            Packet p = (Packet) event;
-                            int rc = 0;
-                            String clientPath = p.clientPath;
-                            if (p.replyHeader.getErr() != 0) {
-                                rc = p.replyHeader.getErr();
-                            }
-                            if (p.cb == null) {
-                                LOG.warn(""Somehow a null cb got to EventThread!"");
-                            } else if (p.response instanceof ExistsResponse
-                                    || p.response instanceof SetDataResponse
-                                    || p.response instanceof SetACLResponse) {
-                                StatCallback cb = (StatCallback) p.cb;
-                                if (rc == 0) {
-                                    if (p.response instanceof ExistsResponse) {
-                                        cb.processResult(rc, clientPath, p.ctx,
-                                                ((ExistsResponse) p.response)
-                                                        .getStat());
-                                    } else if (p.response instanceof SetDataResponse) {
-                                        cb.processResult(rc, clientPath, p.ctx,
-                                                ((SetDataResponse) p.response)
-                                                        .getStat());
-                                    } else if (p.response instanceof SetACLResponse) {
-                                        cb.processResult(rc, clientPath, p.ctx,
-                                                ((SetACLResponse) p.response)
-                                                        .getStat());
-                                    }
-                                } else {
-                                    cb.processResult(rc, clientPath, p.ctx, null);
-                                }
-                            } else if (p.response instanceof GetDataResponse) {
-                                DataCallback cb = (DataCallback) p.cb;
-                                GetDataResponse rsp = (GetDataResponse) p.response;
-                                if (rc == 0) {
-                                    cb.processResult(rc, clientPath, p.ctx, rsp
-                                            .getData(), rsp.getStat());
-                                } else {
-                                    cb.processResult(rc, clientPath, p.ctx, null,
-                                            null);
-                                }
-                            } else if (p.response instanceof GetACLResponse) {
-                                ACLCallback cb = (ACLCallback) p.cb;
-                                GetACLResponse rsp = (GetACLResponse) p.response;
-                                if (rc == 0) {
-                                    cb.processResult(rc, clientPath, p.ctx, rsp
-                                            .getAcl(), rsp.getStat());
-                                } else {
-                                    cb.processResult(rc, clientPath, p.ctx, null,
-                                            null);
-                                }
-                            } else if (p.response instanceof GetChildrenResponse) {
-                                ChildrenCallback cb = (ChildrenCallback) p.cb;
-                                GetChildrenResponse rsp = (GetChildrenResponse) p.response;
-                                if (rc == 0) {
-                                    cb.processResult(rc, clientPath, p.ctx, rsp
-                                            .getChildren());
-                                } else {
-                                    cb.processResult(rc, clientPath, p.ctx, null);
-                                }
-                            } else if (p.response instanceof GetChildren2Response) {
-                                Children2Callback cb = (Children2Callback) p.cb;
-                                GetChildren2Response rsp = (GetChildren2Response) p.response;
-                                if (rc == 0) {
-                                    cb.processResult(rc, clientPath, p.ctx, rsp
-                                            .getChildren(), rsp.getStat());
-                                } else {
-                                    cb.processResult(rc, clientPath, p.ctx, null, null);
-                                }
-                            } else if (p.response instanceof CreateResponse) {
-                                StringCallback cb = (StringCallback) p.cb;
-                                CreateResponse rsp = (CreateResponse) p.response;
-                                if (rc == 0) {
-                                    cb.processResult(rc, clientPath, p.ctx,
-                                            (chrootPath == null
-                                                    ? rsp.getPath()
-                                                    : rsp.getPath()
-                                              .substring(chrootPath.length())));
-                                } else {
-                                    cb.processResult(rc, clientPath, p.ctx, null);
-                                }
-                            } else if (p.cb instanceof VoidCallback) {
-                                VoidCallback cb = (VoidCallback) p.cb;
-                                cb.processResult(rc, clientPath, p.ctx);
-                            }
-                        }
-                    } catch (Throwable t) {
-                        LOG.error(""Caught unexpected throwable"", t);
+           try {
+              isRunning = true;
+              while (true) {
+                 Object event = waitingEvents.take();
+                 if (event == eventOfDeath) {
+                    wasKilled = true;
+                 } else {
+                    processEvent(event);
+                 }
+                 if (wasKilled)
+                    synchronized (waitingEvents) {
+                       if (waitingEvents.isEmpty()) {
+                          isRunning = false;
+                          break;
+                       }
                     }
-                }
-            } catch (InterruptedException e) {
-                LOG.error(""Event thread exiting due to interruption"", e);
-            }
+              }
+           } catch (InterruptedException e) {
+              LOG.error(""Event thread exiting due to interruption"", e);
+           }
 
             LOG.info(""EventThread shut down"");
         }
+
+       private void processEvent(Object event) {
+          try {
+              if (event instanceof WatcherSetEventPair) {
+                  // each watcher will process the event
+                  WatcherSetEventPair pair = (WatcherSetEventPair) event;
+                  for (Watcher watcher : pair.watchers) {
+                      try {
+                          watcher.process(pair.event);
+                      } catch (Throwable t) {
+                          LOG.error(""Error while calling watcher "", t);
+                      }
+                  }
+              } else {
+                  Packet p = (Packet) event;
+                  int rc = 0;
+                  String clientPath = p.clientPath;
+                  if (p.replyHeader.getErr() != 0) {
+                      rc = p.replyHeader.getErr();
+                  }
+                  if (p.cb == null) {
+                      LOG.warn(""Somehow a null cb got to EventThread!"");
+                  } else if (p.response instanceof ExistsResponse
+                          || p.response instanceof SetDataResponse
+                          || p.response instanceof SetACLResponse) {
+                      StatCallback cb = (StatCallback) p.cb;
+                      if (rc == 0) {
+                          if (p.response instanceof ExistsResponse) {
+                              cb.processResult(rc, clientPath, p.ctx,
+                                      ((ExistsResponse) p.response)
+                                              .getStat());
+                          } else if (p.response instanceof SetDataResponse) {
+                              cb.processResult(rc, clientPath, p.ctx,
+                                      ((SetDataResponse) p.response)
+                                              .getStat());
+                          } else if (p.response instanceof SetACLResponse) {
+                              cb.processResult(rc, clientPath, p.ctx,
+                                      ((SetACLResponse) p.response)
+                                              .getStat());
+                          }
+                      } else {
+                          cb.processResult(rc, clientPath, p.ctx, null);
+                      }
+                  } else if (p.response instanceof GetDataResponse) {
+                      DataCallback cb = (DataCallback) p.cb;
+                      GetDataResponse rsp = (GetDataResponse) p.response;
+                      if (rc == 0) {
+                          cb.processResult(rc, clientPath, p.ctx, rsp
+                                  .getData(), rsp.getStat());
+                      } else {
+                          cb.processResult(rc, clientPath, p.ctx, null,
+                                  null);
+                      }
+                  } else if (p.response instanceof GetACLResponse) {
+                      ACLCallback cb = (ACLCallback) p.cb;
+                      GetACLResponse rsp = (GetACLResponse) p.response;
+                      if (rc == 0) {
+                          cb.processResult(rc, clientPath, p.ctx, rsp
+                                  .getAcl(), rsp.getStat());
+                      } else {
+                          cb.processResult(rc, clientPath, p.ctx, null,
+                                  null);
+                      }
+                  } else if (p.response instanceof GetChildrenResponse) {
+                      ChildrenCallback cb = (ChildrenCallback) p.cb;
+                      GetChildrenResponse rsp = (GetChildrenResponse) p.response;
+                      if (rc == 0) {
+                          cb.processResult(rc, clientPath, p.ctx, rsp
+                                  .getChildren());
+                      } else {
+                          cb.processResult(rc, clientPath, p.ctx, null);
+                      }
+                  } else if (p.response instanceof GetChildren2Response) {
+                      Children2Callback cb = (Children2Callback) p.cb;
+                      GetChildren2Response rsp = (GetChildren2Response) p.response;
+                      if (rc == 0) {
+                          cb.processResult(rc, clientPath, p.ctx, rsp
+                                  .getChildren(), rsp.getStat());
+                      } else {
+                          cb.processResult(rc, clientPath, p.ctx, null, null);
+                      }
+                  } else if (p.response instanceof CreateResponse) {
+                      StringCallback cb = (StringCallback) p.cb;
+                      CreateResponse rsp = (CreateResponse) p.response;
+                      if (rc == 0) {
+                          cb.processResult(rc, clientPath, p.ctx,
+                                  (chrootPath == null
+                                          ? rsp.getPath()
+                                          : rsp.getPath()
+                                    .substring(chrootPath.length())));
+                      } else {
+                          cb.processResult(rc, clientPath, p.ctx, null);
+                      }
+                  } else if (p.cb instanceof VoidCallback) {
+                      VoidCallback cb = (VoidCallback) p.cb;
+                      cb.processResult(rc, clientPath, p.ctx);
+                  }
+              }
+          } catch (Throwable t) {
+              LOG.error(""Caught unexpected throwable"", t);
+          }
+       }
     }
 
     private void finishPacket(Packet p) {
@@ -1243,9 +1265,9 @@
         }
 
         public void close() {
-            zooKeeper.state = States.CLOSED;
             synchronized (this) {
-                selector.wakeup();
+               zooKeeper.state = States.CLOSED;
+               selector.wakeup();
             }
         }
     }
"
zookeeper,51dd9c039f70da96b4a5755f372ffcdc8009824b,ZOOKEEPER-893. ZooKeeper high cpu usage when invalid requests,2010.10.20 07:32:09,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 09ede64..08098e3 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -673,28 +673,33 @@
                     }
                     msgLength.position(0);
                     int length = msgLength.getInt();
+                    if(length <= 0) {
+                        throw new IOException(""Invalid packet length:"" + length);
+                    }
                     /**
                      * Allocates a new ByteBuffer to receive the message
                      */
-                    if (length > 0) {
-                        if (length > PACKETMAXSIZE) {
-                            throw new IOException(""Invalid packet of length "" + length);
-                        }
-                        byte[] msgArray = new byte[length];
-                        ByteBuffer message = ByteBuffer.wrap(msgArray);
-                        int numbytes = 0;
-                        while (message.hasRemaining()) {
-                            numbytes += channel.read(message);
-                        }
-                        message.position(0);
-                        synchronized (recvQueue) {
-                            recvQueue
-                                    .put(new Message(message.duplicate(), sid));
-                        }
-                        msgLength.position(0);
+                    if (length > PACKETMAXSIZE) {
+                        throw new IOException(""Invalid packet of length "" + length);
                     }
+                    byte[] msgArray = new byte[length];
+                    ByteBuffer message = ByteBuffer.wrap(msgArray);
+                    int numbytes = 0;
+                    int temp_numbytes = 0;
+                    while (message.hasRemaining()) {
+                        temp_numbytes = channel.read(message); 
+                        if(temp_numbytes < 0) {
+                            throw new IOException(""Channel eof before end"");
+                        }
+                        numbytes += temp_numbytes;
+                    }
+                    message.position(0);
+                    synchronized (recvQueue) {
+                        recvQueue
+                        .put(new Message(message.duplicate(), sid));
+                    }
+                    msgLength.position(0);
                 }
-
             } catch (Exception e) {
                 LOG.warn(""Connection broken for id "" + sid + "", my id = "" + 
                         self.getId() + "", error = "" + e);
"
zookeeper,06834b9a48c4753701917cb890829241939ad9c6,ZOOKEEPER-881. ZooKeeperServer.loadData loads database twice (jared cantwell via breed),2010.10.15 14:21:26,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 00f1df9..31c2b6e 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -238,7 +238,6 @@
      *  Restore sessions and data
      */
     public void loadData() throws IOException, InterruptedException {
-        zkDb.loadDataBase();
         setZxid(zkDb.loadDataBase());
         // Clean up dead sessions
         LinkedList<Long> deadSessions = new LinkedList<Long>();
"
zookeeper,fe2f2ced4efd1ce615f1f5efc007d6463278ae7b,"ZOOKEEPER-886. Hedwig Server stays in ""disconnected"" state when connection to ZK dies but gets reconnected",2010.10.12 05:54:25,Benjamin Reed,"diff --git a/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java b/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java
index 95bf626..9b2ba83 100644
--- a/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java
+++ b/src/contrib/hedwig/server/src/main/java/org/apache/hedwig/server/topics/ZkTopicManager.java
@@ -92,14 +92,19 @@
                     if (event.getState().equals(Watcher.Event.KeeperState.Disconnected)) {
                         logger.warn(""ZK client has been disconnected to the ZK server!"");
                         isSuspended = true;
+                    } else if (event.getState().equals(Watcher.Event.KeeperState.SyncConnected)) {
+			if (isSuspended) {
+	                    logger.info(""ZK client has been reconnected to the ZK server!"");
+			}
+			isSuspended = false;
                     }
-                } else if (event.getState().equals(Watcher.Event.KeeperState.Expired)) {
+		}
+		// Check for expired connection.
+                if (event.getState().equals(Watcher.Event.KeeperState.Expired)) {
                     logger.error(""ZK client connection to the ZK server has expired!"");
                     System.exit(1);
-                } else if (event.getState().equals(Watcher.Event.KeeperState.SyncConnected)) {
-                    isSuspended = false;
-                }
-            }
+                }             
+	    }
         });
         final SynchronousQueue<Either<Void, PubSubException>> queue = new SynchronousQueue<Either<Void, PubSubException>>();
 
"
zookeeper,472048297814559b81251dcca98ee662ea09f14d,ZOOKEEPER-822. Leader election taking a long time to complete,2010.10.07 02:01:53,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 09fade4..09ede64 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -35,7 +35,7 @@
 
 /**
  * This class implements a connection manager for leader election using TCP. It
- * maintains one coonection for every pair of servers. The tricky part is to
+ * maintains one connection for every pair of servers. The tricky part is to
  * guarantee that there is exactly one connection for every pair of servers that
  * are operating correctly and that can communicate over the network.
  * 
@@ -75,6 +75,12 @@
     private long observerCounter = -1;
     
     /*
+     * Connection time out value in milliseconds 
+     */
+    
+    private int cnxTO = 5000;
+    
+    /*
      * Local IP address
      */
     final QuorumPeer self;
@@ -118,6 +124,11 @@
         this.senderWorkerMap = new ConcurrentHashMap<Long, SendWorker>();
         this.lastMessageSent = new ConcurrentHashMap<Long, ByteBuffer>();
         
+        String cnxToValue = System.getProperty(""zookeeper.cnxTimeout"");
+        if(cnxToValue != null){
+            this.cnxTO = new Integer(cnxToValue); 
+        }
+        
         this.self = self;
 
         // Starts listener thread that waits for connection requests 
@@ -131,9 +142,12 @@
      */
     public void testInitiateConnection(long sid) throws Exception {
         SocketChannel channel;
-        LOG.debug(""Opening channel to server ""  + sid);
-        channel = SocketChannel
-                .open(self.getVotingView().get(sid).electionAddr);
+        if(LOG.isDebugEnabled()){
+            LOG.debug(""Opening channel to server ""  + sid);
+        }
+        
+        channel = SocketChannel.open();
+        channel.socket().connect(self.getVotingView().get(sid).electionAddr, cnxTO);
         channel.socket().setTcpNoDelay(true);
         initiateConnection(channel, sid);
     }
@@ -173,11 +187,11 @@
             sw.setRecv(rw);
 
             SendWorker vsw = senderWorkerMap.get(sid);
-            senderWorkerMap.put(sid, sw);
             
             if(vsw != null)
                 vsw.finish();
-
+            
+            senderWorkerMap.put(sid, sw);
             if (!queueSendMap.containsKey(sid)) {
                 queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
                         CAPACITY));
@@ -258,11 +272,12 @@
             sw.setRecv(rw);
 
             SendWorker vsw = senderWorkerMap.get(sid);
-            senderWorkerMap.put(sid, sw);
             
             if(vsw != null)
                 vsw.finish();
-
+            
+            senderWorkerMap.put(sid, sw);
+            
             if (!queueSendMap.containsKey(sid)) {
                 queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
                         CAPACITY));
@@ -343,9 +358,12 @@
             }
             try {
                 SocketChannel channel;
-                LOG.debug(""Opening channel to server ""  + sid);
-                channel = SocketChannel
-                        .open(self.getView().get(sid).electionAddr);
+                if(LOG.isDebugEnabled()){
+                    LOG.debug(""Opening channel to server ""  + sid);
+                }
+                
+                channel = SocketChannel.open();
+                channel.socket().connect(self.getView().get(sid).electionAddr, cnxTO);                
                 channel.socket().setTcpNoDelay(true);
                 initiateConnection(channel, sid);
             } catch (UnresolvedAddressException e) {
@@ -520,10 +538,19 @@
         }
                 
         synchronized boolean finish() {
+            if(LOG.isDebugEnabled()){
+                LOG.debug(""Calling finish"");
+            }
+            
+            if(!running){
+                /*
+                 * Avoids running finish() twice. 
+                 */
+                return running;
+            }
+            
             running = false;
-
-            LOG.debug(""Calling finish"");
-            this.interrupt();
+            
             try{
                 channel.close();
             } catch (IOException e) {
@@ -534,6 +561,10 @@
             this.interrupt();
             if (recvWorker != null)
                 recvWorker.finish();
+            
+            if(LOG.isDebugEnabled()){
+                LOG.debug(""Removing entry from senderWorkerMap sid="" + sid);
+            }
             senderWorkerMap.remove(sid);
             return running;
         }
@@ -585,7 +616,8 @@
                     }
                 }
             } catch (Exception e) {
-                LOG.warn(""Exception when using channel: "" + sid, e);
+                LOG.warn(""Exception when using channel: for id "" + sid + "" my id = "" + 
+                        self.getId() + "" error = "" + e);
             }
             this.finish();
             LOG.warn(""Send worker leaving thread"");
@@ -612,7 +644,14 @@
          * @return boolean  Value of variable running
          */
         synchronized boolean finish() {
-            running = false;
+            if(!running){
+                /*
+                 * Avoids running finish() twice. 
+                 */
+                return running;
+            }
+            running = false;            
+
             this.interrupt();
             return running;
         }
@@ -657,7 +696,8 @@
                 }
 
             } catch (Exception e) {
-                LOG.warn(""Connection broken: "", e);
+                LOG.warn(""Connection broken for id "" + sid + "", my id = "" + 
+                        self.getId() + "", error = "" + e);
             } finally {
                 try{
                     channel.socket().close();
"
zookeeper,b6c3c7a94bbe873afcf7e25f98344d5dcb25b2d0,ZOOKEEPER-844. handle auth failure in java client,2010.10.07 01:14:43,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 69afa3b..d37ac27 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -748,8 +748,12 @@
                 return;
             }
             if (replyHdr.getXid() == -4) {
-                // -2 is the xid for AuthPacket
-                // TODO: process AuthPacket here
+                // -4 is the xid for AuthPacket               
+                if(replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) {
+                    zooKeeper.state = States.AUTH_FAILED;                    
+                    eventThread.queueEvent( new WatchedEvent(Watcher.Event.EventType.None, 
+                            Watcher.Event.KeeperState.AuthFailed, null) );            		            		
+                }
                 if (LOG.isDebugEnabled()) {
                     LOG.debug(""Got auth sessionid:0x""
                             + Long.toHexString(sessionId));
"
zookeeper,b6c3c7a94bbe873afcf7e25f98344d5dcb25b2d0,ZOOKEEPER-844. handle auth failure in java client,2010.10.07 01:14:43,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/Watcher.java b/src/java/main/org/apache/zookeeper/Watcher.java
index b61ad23..d20015d 100644
--- a/src/java/main/org/apache/zookeeper/Watcher.java
+++ b/src/java/main/org/apache/zookeeper/Watcher.java
@@ -58,7 +58,13 @@
              * client connection (the session) is no longer valid. You must
              * create a new client connection (instantiate a new ZooKeeper
              * instance) if you with to access the ensemble. */
-            Expired (-112);
+            Expired (-112),
+
+            /**
+             * Auth failed state
+             * 
+             */
+            AuthFailed(4);
 
             private final int intValue;     // Integer representation of value
                                             // for sending over wire
@@ -77,6 +83,7 @@
                     case    0: return KeeperState.Disconnected;
                     case    1: return KeeperState.NoSyncConnected;
                     case    3: return KeeperState.SyncConnected;
+                    case    4: return KeeperState.AuthFailed;
                     case -112: return KeeperState.Expired;
 
                     default:
"
zookeeper,f9f2f0f5242f007e866b65e9624ce0affe6960d7,ZOOKEEPER-846. zookeeper client doesn't shut down cleanly on the close call,2010.09.22 15:36:39,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 435da80..69afa3b 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1274,8 +1274,6 @@
                       + Long.toHexString(getSessionId()));
         }
 
-        closing = true;
-
         try {
             RequestHeader h = new RequestHeader();
             h.setType(ZooDefs.OpCode.closeSession);
@@ -1323,9 +1321,14 @@
             packet.ctx = ctx;
             packet.clientPath = clientPath;
             packet.serverPath = serverPath;
-            if (!zooKeeper.state.isAlive()) {
+            if (!zooKeeper.state.isAlive() || closing) {
                 conLossPacket(packet);
             } else {
+                // If the client is asking to close the session then
+                // mark as closing
+                if (h.getType() == OpCode.closeSession) {
+                    closing = true;
+                }
                 outgoingQueue.add(packet);
             }
         }
"
zookeeper,e1109ed7d6353fae077e81d2cdb010b570677ee3,ZOOKEEPER-831. BookKeeper: Throttling improved for reads,2010.09.18 01:58:07,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
index 8aba332..e37806f 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
@@ -67,7 +67,7 @@
   private Integer throttling = 5000;
   
   final Queue<PendingAddOp> pendingAddOps = new ArrayDeque<PendingAddOp>();
-
+  
   LedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,
       DigestType digestType, byte[] password)
       throws GeneralSecurityException, NumberFormatException {
@@ -149,6 +149,15 @@
   }
   
   /**
+   * Return total number of available slots.
+   * 
+   * @return int    available slots
+   */
+  Semaphore getAvailablePermits(){
+      return this.opCounterSem;
+  }
+  
+  /**
    * Get the Distribution Schedule
    * 
    * @return DistributionSchedule for the LedgerHandle
@@ -277,7 +286,6 @@
     }
 
     new PendingReadOp(this, firstEntry, lastEntry, cb, ctx).initiate();
-    opCounterSem.acquire();
   }
 
   /**
@@ -310,26 +318,32 @@
    */
   public void asyncAddEntry(final byte[] data, final AddCallback cb,
       final Object ctx) throws InterruptedException {
-      bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {
-      @Override
-      public void safeRun() {
-        if (metadata.isClosed()) {
-          LOG.warn(""Attempt to add to closed ledger: "" + ledgerId);
-          cb.addComplete(BKException.Code.LedgerClosedException,
-              LedgerHandle.this, -1, ctx);
-          return;
-        }
-
-        long entryId = ++lastAddPushed;
-        PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx, entryId);
-        pendingAddOps.add(op);
-        ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(
-            entryId, lastAddConfirmed, data);
-        op.initiate(toSend);
-
-      }
-      });
       opCounterSem.acquire();
+      
+      try{
+          bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {
+              @Override
+              public void safeRun() {
+                  if (metadata.isClosed()) {
+                      LOG.warn(""Attempt to add to closed ledger: "" + ledgerId);
+                      LedgerHandle.this.opCounterSem.release();
+                      cb.addComplete(BKException.Code.LedgerClosedException,
+                              LedgerHandle.this, -1, ctx);
+                      return;
+                  }
+
+                  long entryId = ++lastAddPushed;
+                  PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx, entryId);
+                  pendingAddOps.add(op);
+                  ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(
+                          entryId, lastAddConfirmed, data);
+                  op.initiate(toSend);
+              }
+          });
+      } catch (RuntimeException e) {
+          opCounterSem.release();
+          throw e;
+      }
   }
 
   // close the ledger and send fails to all the adds in the pipeline
"
zookeeper,e1109ed7d6353fae077e81d2cdb010b570677ee3,ZOOKEEPER-831. BookKeeper: Throttling improved for reads,2010.09.18 01:58:07,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingReadOp.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingReadOp.java
index bf9cd0c..8161419 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingReadOp.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingReadOp.java
@@ -64,12 +64,18 @@
         numPendingReads = endEntryId - startEntryId + 1;
     }
 
-    public void initiate() {
+    public void initiate() throws InterruptedException {
         long nextEnsembleChange = startEntryId, i = startEntryId;
 
         ArrayList<InetSocketAddress> ensemble = null;
         do {
 
+            if(LOG.isDebugEnabled()){
+                LOG.debug(""Acquiring lock: "" + i);
+            }
+           
+            lh.opCounterSem.acquire();
+            
             if (i == nextEnsembleChange) {
                 ensemble = lh.metadata.getEnsemble(i);
                 nextEnsembleChange = lh.metadata.getNextEnsembleChange(i);
@@ -80,7 +86,6 @@
             sendRead(ensemble, entry, BKException.Code.ReadException);
 
         } while (i <= endEntryId);
-
     }
 
     void sendRead(ArrayList<InetSocketAddress> ensemble, LedgerEntry entry, int lastErrorCode) {
@@ -114,7 +119,6 @@
             return;
         }
         
-        numPendingReads--;
         ChannelBufferInputStream is;
         try {
             is = lh.macManager.verifyDigestAndReturnData(entryId, buffer);
@@ -125,15 +129,23 @@
 
         entry.entryDataStream = is;
 
+        numPendingReads--;
         if (numPendingReads == 0) {
             submitCallback(BKException.Code.OK);
         }
-
+        
+        if(LOG.isDebugEnabled()){
+            LOG.debug(""Releasing lock: "" + entryId);
+        }
+        
+        lh.opCounterSem.release();
+        
+        if(numPendingReads < 0)
+            LOG.error(""Read too many values"");
     }
 
     private void submitCallback(int code){
         cb.readComplete(code, lh, PendingReadOp.this, PendingReadOp.this.ctx);
-        lh.opCounterSem.release();
     }
     public boolean hasMoreElements() {
         return !seq.isEmpty();
"
zookeeper,46c1493fac179d12acd5ac33aadae6549a0dd2fd,ZOOKEEPER-785. Zookeeper 3.3.1 shouldn't infinite loop if someone creates a server.0 line,2010.09.11 01:13:11,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index a07a555..8035b11 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -243,7 +243,14 @@
             throw new IllegalArgumentException(
                     ""minSessionTimeout must not be larger than maxSessionTimeout"");
         }
-        if (servers.size() > 1) {
+        if (servers.size() == 1) {
+            LOG.error(""Invalid configuration, only one server specified (ignoring)"");
+            servers.clear();
+        } else if (servers.size() > 1) {
+            if (servers.size() == 2) {
+                LOG.warn(""No server failure will be tolerated. "" +
+                    ""You need at least 3 servers."");
+            }
             if (initLimit == 0) {
                 throw new IllegalArgumentException(""initLimit is not set"");
             }
"
zookeeper,a4f6dc7cbc951b9520347a773c09d60721b1cab0,ZOOKEEPER-854. BookKeeper does not compile due to changes in the ZooKeeper code (Flavio via mahadev),2010.08.29 01:10:27,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
index 9b31b0e..5d8ecfc 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
@@ -38,7 +38,7 @@
 import org.apache.zookeeper.Watcher;
 import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.ZooDefs.Ids;
-import org.apache.zookeeper.server.NIOServerCnxn;
+import org.apache.zookeeper.server.NIOServerCnxnFactory;
 import org.apache.zookeeper.server.ZooKeeperServer;
 
 public class LocalBookKeeper {
@@ -62,7 +62,7 @@
 	}
 	
 	private final String HOSTPORT = ""127.0.0.1:2181"";
-	NIOServerCnxn.Factory serverFactory;
+	NIOServerCnxnFactory serverFactory;
 	ZooKeeperServer zks;
 	ZooKeeper zkc;
 	int ZooKeeperDefaultPort = 2181;
@@ -77,7 +77,7 @@
 	 * @param args
 	 */
 	
-	private void runZookeeper() throws IOException{
+	private void runZookeeper(int maxCC) throws IOException{
 		// create a ZooKeeper server(dataDir, dataLogDir, port)
 		LOG.info(""Starting ZK server"");
 		//ServerStats.registerAsConcrete();
@@ -88,7 +88,8 @@
 		    
 		try {
 			zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);
-			serverFactory =  new NIOServerCnxn.Factory(new InetSocketAddress(ZooKeeperDefaultPort));
+			serverFactory =  new NIOServerCnxnFactory();
+			serverFactory.configure(new InetSocketAddress(ZooKeeperDefaultPort), maxCC);
 			serverFactory.startup(zks);
 		} catch (Exception e) {
 			// TODO Auto-generated catch block
@@ -143,7 +144,7 @@
 			System.exit(-1);
 		}
 		LocalBookKeeper lb = new LocalBookKeeper(Integer.parseInt(args[0]));
-		lb.runZookeeper();
+		lb.runZookeeper(1000);
 		lb.initializeZookeper();
 		lb.runBookies();
 		while (true){
"
zookeeper,b95f1ca96a76ec848519cd9d58b9ea35f8d75a25,"ZOOKEEPER-795. eventThread isn't shutdown after a connection ""session expired"" event coming (Sergey Doroshenko and Ben via mahadev)",2010.08.05 16:09:02,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 8eb227d..968b77b 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -430,6 +430,17 @@
         }
     }
 
+    /**
+     * Guard against creating ""-EventThread-EventThread-EventThread-..."" thread
+     * names when ZooKeeper object is being created from within a watcher.
+     * See ZOOKEEPER-795 for details.
+     */
+    private static String makeThreadName(String suffix) {
+        String name = Thread.currentThread().getName().
+            replaceAll(""-EventThread"", """");
+        return name + suffix;
+    }
+
     class EventThread extends Thread {
         private final LinkedBlockingQueue<Object> waitingEvents =
             new LinkedBlockingQueue<Object>();
@@ -441,7 +452,7 @@
         private volatile KeeperState sessionState = KeeperState.Disconnected;
 
         EventThread() {
-            super(currentThread().getName() + ""-EventThread"");
+            super(makeThreadName(""-EventThread""));
             setUncaughtExceptionHandler(uncaughtExceptionHandler);
             setDaemon(true);
         }
@@ -689,6 +700,7 @@
                 eventThread.queueEvent(new WatchedEvent(
                         Watcher.Event.EventType.None,
                         Watcher.Event.KeeperState.Expired, null));
+                eventThread.queueEventOfDeath();
                 throw new SessionExpiredException(
                         ""Unable to reconnect to ZooKeeper service, session 0x""
                         + Long.toHexString(sessionId) + "" has expired"");
@@ -898,7 +910,7 @@
         }
 
         SendThread() {
-            super(currentThread().getName() + ""-SendThread()"");
+            super(makeThreadName(""-SendThread()""));
             zooKeeper.state = States.CONNECTING;
             setUncaughtExceptionHandler(uncaughtExceptionHandler);
             setDaemon(true);
"
zookeeper,2678baf5c1e0789d3acead9e91ac7f64e70d7e48,ZOOKEEPER-790.  Last processed zxid set prematurely while establishing leadership (flavio via mahadev),2010.07.30 06:10:36,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 7bb3d67..5571aec 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -163,6 +163,7 @@
         public void startup(ZooKeeperServer zks) throws IOException,
                 InterruptedException {
             start();
+            zks.startdata();
             zks.startup();
             setZooKeeperServer(zks);
         }
"
zookeeper,2678baf5c1e0789d3acead9e91ac7f64e70d7e48,ZOOKEEPER-790.  Last processed zxid set prematurely while establishing leadership (flavio via mahadev),2010.07.30 06:10:36,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index ee59144..afaa2f1 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -357,14 +357,18 @@
         }
     }
     
-    public void startup() throws IOException, InterruptedException {
+    public void startdata() 
+    throws IOException, InterruptedException {
         //check to see if zkDb is not null
         if (zkDb == null) {
             zkDb = new ZKDatabase(this.txnLogFactory);
-        }
+        }  
         if (!zkDb.isInitialized()) {
             loadData();
         }
+    }
+    
+    public void startup() {        
         createSessionTracker();
         setupRequestProcessors();
 
"
zookeeper,2678baf5c1e0789d3acead9e91ac7f64e70d7e48,ZOOKEEPER-790.  Last processed zxid set prematurely while establishing leadership (flavio via mahadev),2010.07.30 06:10:36,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 4214857..b395011 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -327,12 +327,6 @@
                 self.tick++;
             }
             
-            if(LOG.isInfoEnabled()){
-                LOG.info(""Have quorum of supporters; starting up and setting last processed zxid: "" + zk.getZxid());
-            }
-            zk.startup();
-            zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());
-            
             if (!System.getProperty(""zookeeper.leaderServes"", ""yes"").equals(""no"")) {
                 self.cnxnFactory.setZooKeeperServer(zk);
             }
@@ -499,6 +493,11 @@
                 return;
             } else {
                 lastCommitted = zxid;
+                if(LOG.isInfoEnabled()){
+                    LOG.info(""Have quorum of supporters; starting up and setting last processed zxid: "" + zk.getZxid());
+                }
+                zk.startup();
+                zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());
             }
         }
     }
"
zookeeper,2678baf5c1e0789d3acead9e91ac7f64e70d7e48,ZOOKEEPER-790.  Last processed zxid set prematurely while establishing leadership (flavio via mahadev),2010.07.30 06:10:36,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index bb11ad8..c6c9daa 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -352,7 +352,29 @@
                     }
                 }
             }.start();
-
+            
+            /*
+             * Have to wait for the first ACK, wait until 
+             * the leader is ready, and only then we can
+             * start processing messages.
+             */
+            qp = new QuorumPacket();
+            ia.readRecord(qp, ""packet"");
+            if(qp.getType() != Leader.ACK){
+                LOG.error(""Next packet was supposed to be an ACK"");
+                return;
+            }
+            leader.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());
+            
+            /*
+             * Wait until leader starts up
+             */
+            synchronized(leader.zk){
+                while(!leader.zk.isRunning() && !this.isInterrupted()){
+                    leader.zk.wait(20);
+                }
+            }
+            
             while (true) {
                 qp = new QuorumPacket();
                 ia.readRecord(qp, ""packet"");
@@ -475,6 +497,7 @@
         } catch (IOException e) {
             LOG.warn(""Ignoring unexpected exception during socket close"", e);
         }
+        this.interrupt();
         leader.removeLearnerHandler(this);
     }
 
"
zookeeper,2ae181498d46d0b5393157a63f3a9fcf71c667bd,ZOOKEEPER-783. committedLog in ZKDatabase is not properly synchronized (henry via mahadev),2010.07.27 07:44:12,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 872276e..3dde4b3 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -104,7 +104,9 @@
          */
         dataTree = new DataTree();
         sessionsWithTimeouts.clear();
-        committedLog.clear();
+        synchronized (committedLog) {
+            committedLog.clear();
+        }
         initialized = false;
     }
     
@@ -136,7 +138,9 @@
     }
     
     public LinkedList<Proposal> getCommittedLog() {
-        return this.committedLog;
+        synchronized (this.committedLog) {
+            return new LinkedList<Proposal>(this.committedLog);
+        }
     }
     
     /**
"
zookeeper,debd8a0368f8c81af33691c9d402990bb0976fd5,ZOOKEEPER-790. Last processed zxid set prematurely while establishing leadership (fpj via breed),2010.07.23 13:22:27,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 328be44..3d7788f 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -193,7 +193,12 @@
                         + hdr.getType());
             }
             if (logStream==null) {
-               logFileWrite = new File(logDir, (""log."" +
+               if(LOG.isInfoEnabled()){
+                    LOG.info(""Creating new log file: log."" +  
+                            Long.toHexString(hdr.getZxid()));
+               }
+               
+               logFileWrite = new File(logDir, (""log."" + 
                        Long.toHexString(hdr.getZxid())));
                fos = new FileOutputStream(logFileWrite);
                logStream=new BufferedOutputStream(fos);
"
zookeeper,debd8a0368f8c81af33691c9d402990bb0976fd5,ZOOKEEPER-790. Last processed zxid set prematurely while establishing leadership (fpj via breed),2010.07.23 13:22:27,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index bbf1ad8..4214857 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -274,16 +274,15 @@
         try {
             self.tick = 0;
             zk.loadData();
-            zk.startup();
+            
             long epoch = self.getLastLoggedZxid() >> 32L;
             epoch++;
             zk.setZxid(epoch << 32L);
-            zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());
             
             synchronized(this){
                 lastProposed = zk.getZxid();
             }
-                        
+            
             newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),
                     null, null);
 
@@ -327,6 +326,13 @@
                 Thread.sleep(self.tickTime);
                 self.tick++;
             }
+            
+            if(LOG.isInfoEnabled()){
+                LOG.info(""Have quorum of supporters; starting up and setting last processed zxid: "" + zk.getZxid());
+            }
+            zk.startup();
+            zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());
+            
             if (!System.getProperty(""zookeeper.leaderServes"", ""yes"").equals(""no"")) {
                 self.cnxnFactory.setZooKeeperServer(zk);
             }
@@ -466,7 +472,7 @@
             LOG.debug(""Count for zxid: 0x"" + Long.toHexString(zxid)
                     + "" is "" + p.ackSet.size());
         }
-        if (self.getQuorumVerifier().containsQuorum(p.ackSet)){        
+        if (self.getQuorumVerifier().containsQuorum(p.ackSet)){             
             if (zxid != lastCommitted+1) {
                 LOG.warn(""Commiting zxid 0x"" + Long.toHexString(zxid)
                         + "" from "" + followerAddr + "" not first!"");
@@ -603,6 +609,16 @@
 
     long lastProposed;
 
+    
+    /**
+     * Returns the current epoch of the leader.
+     * 
+     * @return
+     */
+    public long getEpoch(){
+        return lastProposed >> 32L;
+    }
+    
     /**
      * create a proposal and send it out to all the members
      * 
"
zookeeper,debd8a0368f8c81af33691c9d402990bb0976fd5,ZOOKEEPER-790. Last processed zxid set prematurely while establishing leadership (fpj via breed),2010.07.23 13:22:27,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 93b3b4a..67b7791 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -311,6 +311,9 @@
                 System.exit(13);
 
             }
+            if(LOG.isInfoEnabled()){
+                LOG.info(""Setting leader epoch "" + Long.toHexString(newLeaderZxid >> 32L));
+            }
             zk.getZKDatabase().setlastProcessedZxid(newLeaderZxid);
         }
         ack.setZxid(newLeaderZxid & ~0xffffffffL);
"
zookeeper,8953aabcb954bcd8f6827d450f70b77e2a6e81ca,ZOOKEEPER-719. Add throttling to BookKeeper client,2010.07.10 05:53:36,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BKException.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BKException.java
index e83e5e4..67da981 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BKException.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BKException.java
@@ -70,6 +70,8 @@
             return new BKWriteException();
         case Code.NoSuchEntryException:
             return new BKNoSuchEntryException();
+        case Code.IncorrectParameterException:
+            return new BKIncorrectParameterException();
         default:
             return new BKIllegalOpException();
         }
@@ -94,7 +96,8 @@
         int LedgerClosedException = -11;
         int WriteException = -12;
         int NoSuchEntryException = -13;
-
+        int IncorrectParameterException = -14;
+        
         int IllegalOpException = -100;
     }
 
@@ -136,6 +139,8 @@
             return ""Write failed on bookie"";
         case Code.NoSuchEntryException:
             return ""No such entry"";
+        case Code.IncorrectParameterException:
+            return ""Incorrect parameter input"";
         default:
             return ""Invalid operation"";
         }
@@ -224,4 +229,10 @@
             super(Code.LedgerClosedException);
         }
     }
+    
+    public static class BKIncorrectParameterException extends BKException {
+        public BKIncorrectParameterException() {
+            super(Code.IncorrectParameterException);
+        }
+    }
 }
"
zookeeper,8953aabcb954bcd8f6827d450f70b77e2a6e81ca,ZOOKEEPER-719. Add throttling to BookKeeper client,2010.07.10 05:53:36,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerCreateOp.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerCreateOp.java
index 5c89893..6c0d11a 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerCreateOp.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerCreateOp.java
@@ -145,6 +145,10 @@
             LOG.error(""Security exception while creating ledger: "" + ledgerId, e);
             cb.createComplete(BKException.Code.DigestNotInitializedException, null, this.ctx);
             return;
+        } catch (NumberFormatException e) {
+            LOG.error(""Incorrectly entered parameter throttle: "" + System.getProperty(""throttle""), e);
+            cb.createComplete(BKException.Code.IncorrectParameterException, null, this.ctx);
+            return;
         }
 
         lh.writeLedgerConfig(this, null);
"
zookeeper,8953aabcb954bcd8f6827d450f70b77e2a6e81ca,ZOOKEEPER-719. Add throttling to BookKeeper client,2010.07.10 05:53:36,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
index 30afd34..41fe430 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
@@ -27,6 +27,8 @@
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.Queue;
+import java.util.concurrent.Semaphore;
+
 import org.apache.bookkeeper.client.BKException;
 import org.apache.bookkeeper.client.AsyncCallback.AddCallback;
 import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;
@@ -61,10 +63,14 @@
   final DigestManager macManager;
   final DistributionSchedule distributionSchedule;
 
+  final Semaphore opCounterSem;
+  private Integer throttling = 5000;
+  
   final Queue<PendingAddOp> pendingAddOps = new ArrayDeque<PendingAddOp>();
 
   LedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,
-      DigestType digestType, byte[] password) throws GeneralSecurityException {
+      DigestType digestType, byte[] password)
+      throws GeneralSecurityException, NumberFormatException {
     this.bk = bk;
     this.metadata = metadata;
     if (metadata.isClosed()) {
@@ -72,14 +78,21 @@
     } else {
       lastAddConfirmed = lastAddPushed = -1;
     }
-
+    
     this.ledgerId = ledgerId;
+    
+    String throttleValue = System.getProperty(""throttle"");
+    if(throttleValue != null){
+        this.throttling = new Integer(throttleValue); 
+    }
+    this.opCounterSem = new Semaphore(throttling);
+    
     macManager = DigestManager.instantiate(ledgerId, password, digestType);
     this.ledgerKey = MacDigestManager.genDigest(""ledger"", password);
     distributionSchedule = new RoundRobinDistributionSchedule(
         metadata.quorumSize, metadata.ensembleSize);
   }
-
+  
   /**
    * Get the id of the current ledger
    * 
@@ -219,7 +232,7 @@
    *          control object
    */
   public void asyncReadEntries(long firstEntry, long lastEntry,
-      ReadCallback cb, Object ctx) {
+      ReadCallback cb, Object ctx) throws InterruptedException {
     // Little sanity check
     if (firstEntry < 0 || lastEntry > lastAddConfirmed
         || firstEntry > lastEntry) {
@@ -228,7 +241,7 @@
     }
 
     new PendingReadOp(this, firstEntry, lastEntry, cb, ctx).initiate();
-
+    opCounterSem.acquire();
   }
 
   /**
@@ -260,8 +273,8 @@
    *          some control object
    */
   public void asyncAddEntry(final byte[] data, final AddCallback cb,
-      final Object ctx) {
-    bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {
+      final Object ctx) throws InterruptedException {
+      bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {
       @Override
       public void safeRun() {
         if (metadata.isClosed()) {
@@ -279,7 +292,8 @@
         op.initiate(toSend);
 
       }
-    });
+      });
+      opCounterSem.acquire();
   }
 
   // close the ledger and send fails to all the adds in the pipeline
"
zookeeper,8953aabcb954bcd8f6827d450f70b77e2a6e81ca,ZOOKEEPER-719. Add throttling to BookKeeper client,2010.07.10 05:53:36,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerOpenOp.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerOpenOp.java
index d62455d..1c08d98 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerOpenOp.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerOpenOp.java
@@ -114,6 +114,10 @@
             LOG.error(""Security exception while opening ledger: "" + ledgerId, e);
             cb.openComplete(BKException.Code.DigestNotInitializedException, null, this.ctx);
             return;
+        } catch (NumberFormatException e) {
+            LOG.error(""Incorrectly entered parameter throttle: "" + System.getProperty(""throttle""), e);
+            cb.openComplete(BKException.Code.IncorrectParameterException, null, this.ctx);
+            return;
         }
 
         if (metadata.close != LedgerMetadata.NOTCLOSED) {
"
zookeeper,8953aabcb954bcd8f6827d450f70b77e2a6e81ca,ZOOKEEPER-719. Add throttling to BookKeeper client,2010.07.10 05:53:36,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java
index 0752a75..039a231 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java
@@ -117,9 +117,13 @@
      * Try to read past the last confirmed.
      */
     private void doRecoveryRead() {
-        lh.lastAddConfirmed++;
-        lh.asyncReadEntries(lh.lastAddConfirmed, lh.lastAddConfirmed, this, null);
-
+        try{
+            lh.lastAddConfirmed++;
+            lh.asyncReadEntries(lh.lastAddConfirmed, lh.lastAddConfirmed, this, null);
+        } catch (InterruptedException e) {
+            LOG.error(""Interrupted while trying to read entry."", e);
+            Thread.currentThread().interrupt();
+        }
     }
 
     @Override
@@ -127,7 +131,12 @@
         // get back to prev value
         lh.lastAddConfirmed--;
         if (rc == BKException.Code.OK) {
-            lh.asyncAddEntry(seq.nextElement().getEntry(), this, null);
+            try{
+                lh.asyncAddEntry(seq.nextElement().getEntry(), this, null);
+            } catch (InterruptedException e) {
+                LOG.error(""Interrupted while adding entry."", e);
+                Thread.currentThread().interrupt();
+            }
             return;
         }
 
"
zookeeper,8953aabcb954bcd8f6827d450f70b77e2a6e81ca,ZOOKEEPER-719. Add throttling to BookKeeper client,2010.07.10 05:53:36,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingAddOp.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingAddOp.java
index 91f4325..1b6d167 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingAddOp.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingAddOp.java
@@ -132,6 +132,7 @@
 
     void submitCallback(final int rc) {
         cb.addComplete(rc, lh, entryId, ctx);
+        lh.opCounterSem.release();
     }
 
 }
\ No newline at end of file
"
zookeeper,8953aabcb954bcd8f6827d450f70b77e2a6e81ca,ZOOKEEPER-719. Add throttling to BookKeeper client,2010.07.10 05:53:36,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingReadOp.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingReadOp.java
index 44c290e..bf9cd0c 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingReadOp.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/PendingReadOp.java
@@ -87,7 +87,7 @@
         if (entry.nextReplicaIndexToReadFrom >= lh.metadata.quorumSize) {
             // we are done, the read has failed from all replicas, just fail the
             // read
-            cb.readComplete(lastErrorCode, lh, null, ctx);
+            submitCallback(lastErrorCode);
             return;
         }
 
@@ -126,11 +126,15 @@
         entry.entryDataStream = is;
 
         if (numPendingReads == 0) {
-            cb.readComplete(BKException.Code.OK, lh, PendingReadOp.this, PendingReadOp.this.ctx);
+            submitCallback(BKException.Code.OK);
         }
 
     }
 
+    private void submitCallback(int code){
+        cb.readComplete(code, lh, PendingReadOp.this, PendingReadOp.this.ctx);
+        lh.opCounterSem.release();
+    }
     public boolean hasMoreElements() {
         return !seq.isEmpty();
     }
"
zookeeper,8953aabcb954bcd8f6827d450f70b77e2a6e81ca,ZOOKEEPER-719. Add throttling to BookKeeper client,2010.07.10 05:53:36,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java
index 07be5d7..14879b6 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java
@@ -23,6 +23,7 @@
 import java.util.ArrayDeque;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Semaphore;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.bookkeeper.client.BKException;
@@ -69,6 +70,7 @@
 
     InetSocketAddress addr;
     boolean connected = false;
+    Semaphore opCounterSem = new Semaphore(2000);
     AtomicLong totalBytesOutstanding;
     ClientSocketChannelFactory channelFactory;
     OrderedSafeExecutor executor;
@@ -206,6 +208,7 @@
             Object ctx) {
 
         final int entrySize = toSend.readableBytes();
+        
         // if (totalBytesOutstanding.get() > maxMemory) {
         // // TODO: how to throttle, throw an exception, or call the callback?
         // // Maybe this should be done at the layer above?
"
zookeeper,44e2475ed44024f45ed06b9095c832d7750cfff7,ZOOKEEPER-769: Leader can treat observers as quorum members,2010.05.22 01:22:52,Henry Robinson,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index d46e37f..5c4121a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -310,6 +310,18 @@
                 throw new IllegalArgumentException(""serverid "" + myIdString
                         + "" is not a number"");
             }
+            
+            // Warn about inconsistent peer type
+            LearnerType roleByServersList = observers.containsKey(serverId) ? LearnerType.OBSERVER
+                    : LearnerType.PARTICIPANT;
+            if (roleByServersList != peerType) {
+                LOG.warn(""Peer type from servers list ("" + roleByServersList
+                        + "") doesn't match peerType ("" + peerType
+                        + ""). Defaulting to servers list."");
+
+                peerType = roleByServersList;
+            }
+            
         }
     }
 
"
zookeeper,472c93adc6e4dfc7dbb7b5a95d211dce09cc154f,ZOOKEEPER-764. Observer elected leader due to inconsistent voting view (henry via mahadev),2010.05.06 05:32:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 2e5a3d7..245a8a5 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -587,7 +587,7 @@
      * @return ServerState
      */
     private ServerState learningState(){
-        if(self.getPeerType() == LearnerType.PARTICIPANT){
+        if(self.getLearnerType() == LearnerType.PARTICIPANT){
             LOG.debug(""I'm a participant: "" + self.getId());
             return ServerState.FOLLOWING;
         }
@@ -603,7 +603,7 @@
      * @return long
      */
     private long getInitId(){
-        if(self.getPeerType() == LearnerType.PARTICIPANT)
+        if(self.getLearnerType() == LearnerType.PARTICIPANT)
             return self.getId();
         else return Long.MIN_VALUE;
     }
@@ -614,7 +614,7 @@
      * @return long
      */
     private long getInitLastLoggedZxid(){
-        if(self.getPeerType() == LearnerType.PARTICIPANT)
+        if(self.getLearnerType() == LearnerType.PARTICIPANT)
             return self.getLastLoggedZxid();
         else return Long.MIN_VALUE;
     }
"
zookeeper,472c93adc6e4dfc7dbb7b5a95d211dce09cc154f,ZOOKEEPER-764. Observer elected leader due to inconsistent voting view (henry via mahadev),2010.05.06 05:32:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
index 8b18422..9dbfad3 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
@@ -226,7 +226,7 @@
                             self.setCurrentVote(result.winner);
                             s.close();
                             Vote current = self.getCurrentVote();
-                            LOG.info(""Found leader: my type is: "" + self.getPeerType());
+                            LOG.info(""Found leader: my type is: "" + self.getLearnerType());
                             /*
                              * We want to make sure we implement the state machine
                              * correctly. If we are a PARTICIPANT, once a leader
@@ -234,7 +234,7 @@
                              * FOLLOWING. However if we are an OBSERVER, it is an
                              * error to be elected as a Leader.
                              */
-                            if (self.getPeerType() == LearnerType.OBSERVER) {
+                            if (self.getLearnerType() == LearnerType.OBSERVER) {
                                 if (current.id == self.getId()) {
                                     // This should never happen!
                                     LOG.error(""OBSERVER elected as leader!"");
"
zookeeper,472c93adc6e4dfc7dbb7b5a95d211dce09cc154f,ZOOKEEPER-764. Observer elected leader due to inconsistent voting view (henry via mahadev),2010.05.06 05:32:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 714ceaa..6807c85 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -148,14 +148,24 @@
     /*
      * Default value of peer is participant
      */
-    private LearnerType peerType = LearnerType.PARTICIPANT;
+    private LearnerType learnerType = LearnerType.PARTICIPANT;
     
-    public LearnerType getPeerType() {
-        return peerType;
+    public LearnerType getLearnerType() {
+        return learnerType;
     }
     
-    public void setPeerType(LearnerType p) {
-        peerType = p;
+    /**
+     * Sets the LearnerType both in the QuorumPeer and in the peerMap
+     */
+    public void setLearnerType(LearnerType p) {
+        learnerType = p;
+        if (quorumPeers.containsKey(this.myid)) {
+            this.quorumPeers.get(myid).type = p;
+        } else {
+            LOG.error(""Setting LearnerType to "" + p + "" but "" + myid 
+                    + "" not in QuorumPeers. "");
+        }
+        
     }
     /**
      * The servers that make up the cluster
"
zookeeper,472c93adc6e4dfc7dbb7b5a95d211dce09cc154f,ZOOKEEPER-764. Observer elected leader due to inconsistent voting view (henry via mahadev),2010.05.06 05:32:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
index f62180a..f61f0c3 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
@@ -138,7 +138,7 @@
           quorumPeer.setQuorumVerifier(config.getQuorumVerifier());
           quorumPeer.setCnxnFactory(cnxnFactory);
           quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));
-          quorumPeer.setPeerType(config.getPeerType());
+          quorumPeer.setLearnerType(config.getPeerType());
   
           quorumPeer.start();
           quorumPeer.join();
"
zookeeper,472c93adc6e4dfc7dbb7b5a95d211dce09cc154f,ZOOKEEPER-764. Observer elected leader due to inconsistent voting view (henry via mahadev),2010.05.06 05:32:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
index d71a4c5..ea29a27 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
@@ -57,6 +57,6 @@
         pwriter.print(""quorumPort="");
         pwriter.println(self.quorumPeers.get(self.getId()).addr.getPort());
         pwriter.print(""peerType="");
-        pwriter.println(self.getPeerType().ordinal());
+        pwriter.println(self.getLearnerType().ordinal());
     }
 }
"
zookeeper,73719a1081b542fa7557513a0535fcb9c503ab64,ZOOKEEPER-738. zookeeper.jute.h fails to compile with -pedantic,2010.04.27 03:54:06,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/jute/compiler/JRecord.java b/src/java/main/org/apache/jute/compiler/JRecord.java
index d1cee7a..3315a23 100644
--- a/src/java/main/org/apache/jute/compiler/JRecord.java
+++ b/src/java/main/org/apache/jute/compiler/JRecord.java
@@ -114,7 +114,7 @@
                 String struct_name = JVector.extractVectorName(jvType);
                 if (vectorStructs.get(struct_name) == null) {
                     vectorStructs.put(struct_name, struct_name);
-                    h.write(""struct "" + struct_name + "" {\n    int32_t count;\n"" + jv.getElementType().genCDecl(""*data"") + "";\n};\n"");
+                    h.write(""struct "" + struct_name + "" {\n    int32_t count;\n"" + jv.getElementType().genCDecl(""*data"") + ""\n};\n"");
                     h.write(""int serialize_"" + struct_name + ""(struct oarchive *out, const char *tag, struct "" + struct_name + "" *v);\n"");
                     h.write(""int deserialize_"" + struct_name + ""(struct iarchive *in, const char *tag, struct "" + struct_name + "" *v);\n"");
                     h.write(""int allocate_"" + struct_name + ""(struct "" + struct_name + "" *v, int32_t len);\n"");
"
zookeeper,22e330464a7c33f96137b8482e44f8ec8f86b78c,ZOOKEEPER-746. learner outputs session id to log in dec,2010.04.26 13:17:50,Henry Robinson,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index f0a135d..93b3b4a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -92,7 +92,7 @@
      */
     void validateSession(ServerCnxn cnxn, long clientId, int timeout)
             throws IOException, InterruptedException {
-        LOG.info(""Revalidating client: "" + clientId);
+        LOG.info(""Revalidating client: 0x"" + Long.toHexString(clientId));
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream(baos);
         dos.writeLong(clientId);
"
zookeeper,6ad91e3ff0b8f6b956c4d5cac596562c46947c96,ZOOKEEPER-741. root level create on REST proxy fails,2010.04.22 14:42:51,Patrick D. Hunt,"diff --git a/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/RuntimeExceptionMapper.java b/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/RuntimeExceptionMapper.java
index 551f34b..46f33bb 100644
--- a/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/RuntimeExceptionMapper.java
+++ b/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/RuntimeExceptionMapper.java
@@ -18,6 +18,7 @@
 
 package org.apache.zookeeper.server.jersey.resources;
 
+import javax.ws.rs.WebApplicationException;
 import javax.ws.rs.core.Context;
 import javax.ws.rs.core.Response;
 import javax.ws.rs.core.UriInfo;
@@ -40,9 +41,15 @@
     }
 
     public Response toResponse(RuntimeException e) {
+        // don't try to handle jersey exceptions ourselves
+        if (e instanceof WebApplicationException) { 
+            WebApplicationException ie =(WebApplicationException) e; 
+            return ie.getResponse(); 
+        } 
+
         return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(
                 new ZError(ui.getRequestUri().toString(),
-                        ""Error processing request due to "" + e.getMessage()
+                        ""Error processing request due to "" + e
                         )).build();
     }
 }
"
zookeeper,6ad91e3ff0b8f6b956c4d5cac596562c46947c96,ZOOKEEPER-741. root level create on REST proxy fails,2010.04.22 14:42:51,Patrick D. Hunt,"diff --git a/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java b/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java
index 35890ef..19227d2 100644
--- a/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java
+++ b/src/contrib/rest/src/java/org/apache/zookeeper/server/jersey/resources/ZNodeResource.java
@@ -58,7 +58,7 @@
  * Version 1 implementation of the ZooKeeper REST specification.
  */
 // TODO test octet fully
-@Path(""znodes/v1/{path: .*}"")
+@Path(""znodes/v1{path: /.*}"")
 public class ZNodeResource {
     private final ZooKeeper zk;
 
@@ -66,17 +66,37 @@
         zk = ZooKeeperService.getClient(ui.getBaseUri().toString());
     }
 
+    private void ensurePathNotNull(String path) {
+        if (path == null) {
+            throw new IllegalArgumentException(""Invalid path \"""" + path + ""\"""");
+        }
+    }
+
     @HEAD
     @Produces({MediaType.APPLICATION_JSON, ""application/javascript"",
-        MediaType.APPLICATION_XML, MediaType.APPLICATION_OCTET_STREAM})
-    public void existsZNode(@PathParam(""path"") String path, @Context UriInfo ui)
+        MediaType.APPLICATION_XML})
+    public Response existsZNode(@PathParam(""path"") String path,
+            @Context UriInfo ui)
         throws InterruptedException, KeeperException
     {
-        path = ""/"" + path;
         Stat stat = zk.exists(path, false);
         if (stat == null) {
             throwNotFound(path, ui);
         }
+        return Response.status(Response.Status.OK).build();
+    }
+
+    @HEAD
+    @Produces({MediaType.APPLICATION_OCTET_STREAM})
+    public Response existsZNodeAsOctet(@PathParam(""path"") String path,
+            @Context UriInfo ui)
+        throws InterruptedException, KeeperException
+    {
+        Stat stat = zk.exists(path, false);
+        if (stat == null) {
+            throwNotFound(path, ui);
+        }
+        return Response.status(Response.Status.NO_CONTENT).build();
     }
 
     /*
@@ -115,7 +135,8 @@
             String view, String dataformat, UriInfo ui)
         throws InterruptedException, KeeperException
     {
-        path = ""/"" + path;
+        ensurePathNotNull(path);
+
         if (view.equals(""children"")) {
             List<String> children = new ArrayList<String>();
             for (String child : zk.getChildren(path, false)) {
@@ -171,7 +192,8 @@
     public Response getZNodeListAsOctet(@PathParam(""path"") String path)
         throws InterruptedException, KeeperException
     {
-        path = ""/"" + path;
+        ensurePathNotNull(path);
+
         Stat stat = new Stat();
         byte[] data = zk.getData(path, false, stat);
 
@@ -195,7 +217,7 @@
             byte[] data)
         throws InterruptedException, KeeperException
     {
-        path = ""/"" + path;
+        ensurePathNotNull(path);
 
         int version;
         try {
@@ -235,7 +257,7 @@
             byte[] data)
         throws InterruptedException, KeeperException
     {
-        path = ""/"" + path;
+        ensurePathNotNull(path);
 
         int version;
         try {
@@ -269,7 +291,13 @@
             byte[] data)
         throws InterruptedException, KeeperException
     {
-        path = ""/"" + path + ""/"" + name;
+        ensurePathNotNull(path);
+
+        if (path.equals(""/"")) {
+            path += name;
+        } else {
+            path += ""/"" + name;
+        }
 
         if (!op.equals(""create"")) {
             throw new WebApplicationException(Response.status(
@@ -311,7 +339,13 @@
             byte[] data)
         throws InterruptedException, KeeperException
     {
-        path = ""/"" + path + ""/"" + name;
+        ensurePathNotNull(path);
+
+        if (path.equals(""/"")) {
+            path += name;
+        } else {
+            path += ""/"" + name;
+        }
 
         if (!op.equals(""create"")) {
             throw new WebApplicationException(Response.status(
@@ -348,7 +382,7 @@
             @Context UriInfo ui)
         throws InterruptedException, KeeperException
     {
-        path = ""/"" + path;
+        ensurePathNotNull(path);
 
         int version;
         try {
"
zookeeper,b1c614b2ca982b2e029d11605717846af790870f,ZOOKEEPER-710. permanent ZSESSIONMOVED error after client app reconnects to zookeeper cluster,2010.03.19 15:46:36,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index 12093b2..bf4fa14 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -27,6 +27,7 @@
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.ZooDefs;
 import org.apache.zookeeper.KeeperException.Code;
+import org.apache.zookeeper.KeeperException.SessionMovedException;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
@@ -327,6 +328,17 @@
                 break;
             }
             }
+        } catch (SessionMovedException e) {
+            // session moved is a connection level error, we need to tear
+            // down the connection otw ZOOKEEPER-710 might happen
+            // ie client on slow follower starts to renew session, fails
+            // before this completes, then tries the fast follower (leader)
+            // and is successful, however the initial renew is then 
+            // successfully fwd/processed by the leader and as a result
+            // the client and leader disagree on where the client is most
+            // recently attached (and therefore invalid SESSION MOVED generated)
+            cnxn.sendCloseSession();
+            return;
         } catch (KeeperException e) {
             err = e.code();
         } catch (Exception e) {
"
zookeeper,5749256a08bb3d9cc584a285938bdf14a36dec66,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown,2010.03.17 07:25:58,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index c502ec6..714ceaa 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -672,11 +672,6 @@
 
     public void shutdown() {
         running = false;
-        try {
-            zkDb.close();
-        } catch (IOException ie) {
-            LOG.warn(""Error closing logs "", ie);
-        }
         if (leader != null) {
             leader.shutdown(""quorum Peer shutdown"");
         }
@@ -691,6 +686,11 @@
         if(getElectionAlg() != null){
         	getElectionAlg().shutdown();
         }
+        try {
+            zkDb.close();
+        } catch (IOException ie) {
+            LOG.warn(""Error closing logs "", ie);
+        }     
     }
 
     /**
"
zookeeper,f4138613a151f0383bf55ea0608708acbe070cc5,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (3rd attempt),2010.03.17 06:23:07,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index 0799531..63e04a9 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -172,11 +172,6 @@
         } catch(InterruptedException e) {
             LOG.warn(""Interrupted while wating for "" + this + "" to finish"");
         }
-        try {
-            zks.getZKDatabase().close();
-        } catch (IOException ie) {
-            LOG.warn(""Error closing logs "", ie);
-        }
         nextProcessor.shutdown();
     }
 
"
zookeeper,f4138613a151f0383bf55ea0608708acbe070cc5,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (3rd attempt),2010.03.17 06:23:07,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index b9d5c47..328be44 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -156,7 +156,7 @@
      * rollover the current log file to a new one.
      * @throws IOException
      */
-    public void rollLog() throws IOException {
+    public synchronized void rollLog() throws IOException {
         if (logStream != null) {
             this.logStream.flush();
             this.logStream = null;
"
zookeeper,f4138613a151f0383bf55ea0608708acbe070cc5,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (3rd attempt),2010.03.17 06:23:07,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 22e0f8a..c502ec6 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -672,6 +672,11 @@
 
     public void shutdown() {
         running = false;
+        try {
+            zkDb.close();
+        } catch (IOException ie) {
+            LOG.warn(""Error closing logs "", ie);
+        }
         if (leader != null) {
             leader.shutdown(""quorum Peer shutdown"");
         }
"
zookeeper,037d07cb711b54558593b56d5d25ddfa24a6084d,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (breed via mahadev),2010.03.14 13:01:05,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index 249baad..0799531 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -166,12 +166,17 @@
     }
 
     public void shutdown() {
-        try{
+        queuedRequests.add(requestOfDeath);
+        try {
+            this.join();
+        } catch(InterruptedException e) {
+            LOG.warn(""Interrupted while wating for "" + this + "" to finish"");
+        }
+        try {
             zks.getZKDatabase().close();
         } catch (IOException ie) {
             LOG.warn(""Error closing logs "", ie);
         }
-        queuedRequests.add(requestOfDeath);
         nextProcessor.shutdown();
     }
 
"
zookeeper,e419600dff67353429353aef419d856e3935af8b,ZOOKEEPER-698. intermittent JMX test failures due to not verifying QuorumPeer shutdown,2010.03.13 09:06:55,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 6748b68..2e5a3d7 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -20,9 +20,9 @@
 package org.apache.zookeeper.server.quorum;
 
 import java.nio.ByteBuffer;
-import java.util.Map;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 
"
zookeeper,e419600dff67353429353aef419d856e3935af8b,ZOOKEEPER-698. intermittent JMX test failures due to not verifying QuorumPeer shutdown,2010.03.13 09:06:55,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
index 4ff42c7..f62180a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java
@@ -63,7 +63,7 @@
 
     private static final String USAGE = ""Usage: QuorumPeerMain configfile"";
 
-    private QuorumPeer quorumPeer;
+    protected QuorumPeer quorumPeer;
 
     /**
      * To start the replicated server specify the configuration file name on
@@ -147,8 +147,4 @@
           LOG.warn(""Quorum Peer interrupted"", e);
       }
     }
-
-    protected void shutdown() {
-        quorumPeer.shutdown();
-    }
 }
"
zookeeper,f9413133fdc674bb7b9de43cdd652df416f4a9f0,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (mahadev),2010.03.13 07:36:12,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index 9a91bb7..249baad 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -166,6 +166,11 @@
     }
 
     public void shutdown() {
+        try{
+            zks.getZKDatabase().close();
+        } catch (IOException ie) {
+            LOG.warn(""Error closing logs "", ie);
+        }
         queuedRequests.add(requestOfDeath);
         nextProcessor.shutdown();
     }
"
zookeeper,f9413133fdc674bb7b9de43cdd652df416f4a9f0,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (mahadev),2010.03.13 07:36:12,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
index 0420332..872276e 100644
--- a/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
+++ b/src/java/main/org/apache/zookeeper/server/ZKDatabase.java
@@ -450,5 +450,12 @@
         this.snapLog.commit();
     }
     
+    /**
+     * close this database. free the resources
+     * @throws IOException
+     */
+    public void close() throws IOException {
+        this.snapLog.close();
+    }
     
 }
\ No newline at end of file
"
zookeeper,f9413133fdc674bb7b9de43cdd652df416f4a9f0,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (mahadev),2010.03.13 07:36:12,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
index f3ede4b..71e037e 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
@@ -49,6 +49,7 @@
  */
 public class FileSnap implements SnapShot {
     File snapDir;
+    private volatile boolean close = false;
     private static final int VERSION=2;
     private static final long dbId=-1;
     private static final Logger LOG = Logger.getLogger(FileSnap.class);
@@ -217,20 +218,32 @@
      * @param sessions the sessions to be serialized
      * @param snapShot the file to store snapshot into
      */
-    public void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot)
+    public synchronized void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot)
             throws IOException {
-        OutputStream sessOS = new BufferedOutputStream(new FileOutputStream(snapShot));
-        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());
-        //CheckedOutputStream cout = new CheckedOutputStream()
-        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);
-        FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);
-        serialize(dt,sessions,oa, header);
-        long val = crcOut.getChecksum().getValue();
-        oa.writeLong(val, ""val"");
-        oa.writeString(""/"", ""path"");
-        sessOS.flush();
-        crcOut.close();
-        sessOS.close();
+        if (!close) {
+            OutputStream sessOS = new BufferedOutputStream(new FileOutputStream(snapShot));
+            CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());
+            //CheckedOutputStream cout = new CheckedOutputStream()
+            OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);
+            FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);
+            serialize(dt,sessions,oa, header);
+            long val = crcOut.getChecksum().getValue();
+            oa.writeLong(val, ""val"");
+            oa.writeString(""/"", ""path"");
+            sessOS.flush();
+            crcOut.close();
+            sessOS.close();
+        }
+    }
+
+    /**
+     * synchronized close just so that if serialize is in place
+     * the close operation will block and will wait till serialize
+     * is done and will set the close flag
+     */
+    @Override
+    public synchronized void close() throws IOException {
+        close = true;
     }
 
  }
\ No newline at end of file
"
zookeeper,f9413133fdc674bb7b9de43cdd652df416f4a9f0,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (mahadev),2010.03.13 07:36:12,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index d7853d8..b9d5c47 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -165,6 +165,19 @@
     }
 
     /**
+     * close all the open file handles
+     * @throws IOException
+     */
+    public synchronized void close() throws IOException {
+        if (logStream != null) {
+            logStream.close();
+        }
+        for (FileOutputStream log : streamsToFlush) {
+            log.close();
+        }
+    }
+    
+    /**
      * append an entry to the transaction log
      * @param hdr the header of the transaction
      * @param txn the transaction part of the entry
"
zookeeper,f9413133fdc674bb7b9de43cdd652df416f4a9f0,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (mahadev),2010.03.13 07:36:12,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index dd18592..4b73096 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -285,4 +285,12 @@
         txnLog.rollLog();
     }
     
+    /**
+     * close the transaction log files
+     * @throws IOException
+     */
+    public void close() throws IOException {
+        txnLog.close();
+        snapLog.close();
+    }
 }
"
zookeeper,f9413133fdc674bb7b9de43cdd652df416f4a9f0,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (mahadev),2010.03.13 07:36:12,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/SnapShot.java b/src/java/main/org/apache/zookeeper/server/persistence/SnapShot.java
index cebc0c9..a59f045 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/SnapShot.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/SnapShot.java
@@ -57,4 +57,10 @@
      * @throws IOException
      */
     File findMostRecentSnapshot() throws IOException;
+    
+    /**
+     * free resources from this snapshot immediately
+     * @throws IOException
+     */
+    void close() throws IOException;
 } 
\ No newline at end of file
"
zookeeper,f9413133fdc674bb7b9de43cdd652df416f4a9f0,ZOOKEEPER-121. SyncRequestProcessor is not closing log stream during shutdown (mahadev),2010.03.13 07:36:12,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/TxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/TxnLog.java
index c2c60f0..d52dfb7 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/TxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/TxnLog.java
@@ -83,6 +83,10 @@
      */
     void commit() throws IOException;
    
+    /** 
+     * close the transactions logs
+     */
+    void close() throws IOException;
     /**
      * an iterating interface for reading 
      * transaction logs. 
"
zookeeper,42e23d3a7d70964d177e9c10cae736912aff5521,ZOOKEEPER-511. bad error handling in FollowerHandle.sendPackets (mahadev via flavio),2010.03.11 23:05:15,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index 4e1da4b..bb11ad8 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -139,7 +139,15 @@
                 oa.writeRecord(p, ""packet"");
             } catch (IOException e) {
                 if (!sock.isClosed()) {
-                    LOG.warn(""Unexpected exception"",e);
+                    LOG.warn(""Unexpected exception at "" + this, e);
+                    try {
+                        // this will cause everything to shutdown on
+                        // this learner handler and will help notify
+                        // the learner/observer instantaneously
+                        sock.close();
+                    } catch(IOException ie) {
+                        LOG.warn(""Error closing socket for handler "" + this, ie);
+                    }
                 }
                 break;
             }
"
zookeeper,df20416c08fa0079d96f6327d10c6f102ebabd85,"ZOOKEEPER-696. NPE in the hudson logs, seems nioservercnxn closed twice (phunt via mahadev)",2010.03.11 12:17:04,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ConnectionBean.java b/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
index 37f364b..a8596a0 100644
--- a/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
+++ b/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
@@ -41,30 +41,44 @@
     private final CnxnStats stats;
 
     private final ZooKeeperServer zk;
+    
+    private final String remoteIP;
+    private final long sessionId;
 
     public ConnectionBean(ServerCnxn connection,ZooKeeperServer zk){
         this.connection = connection;
         this.stats = (CnxnStats)connection.getStats();
         this.zk = zk;
+        
+        InetSocketAddress sockAddr = connection.getRemoteAddress();
+        if (sockAddr == null) {
+            remoteIP = ""Unknown"";
+        } else {
+            InetAddress addr = sockAddr.getAddress();
+            if (addr instanceof Inet6Address) {
+                remoteIP = ObjectName.quote(addr.getHostAddress());
+            } else {
+                remoteIP = addr.getHostAddress();
+            }
+        }
+        sessionId = connection.getSessionId();
     }
     
     public String getSessionId() {
-        return ""0x"" + Long.toHexString(connection.getSessionId());
+        return ""0x"" + Long.toHexString(sessionId);
     }
 
     public String getSourceIP() {
         InetSocketAddress sockAddr = connection.getRemoteAddress();
+        if (sockAddr == null) {
+            return null;
+        }
         return sockAddr.getAddress().getHostAddress()
             + "":"" + sockAddr.getPort();
     }
 
     public String getName() {
-        InetAddress addr = connection.getRemoteAddress().getAddress();
-        String ip = addr.getHostAddress();
-        if (addr instanceof Inet6Address) {
-            ip = ObjectName.quote(ip);
-        }
-        return MBeanRegistry.getInstance().makeFullPath(""Connections"", ip,
+        return MBeanRegistry.getInstance().makeFullPath(""Connections"", remoteIP,
                 getSessionId());
     }
     
@@ -74,7 +88,7 @@
     
     public String[] getEphemeralNodes() {
         if(zk.getZKDatabase()  !=null){
-            String[] res= zk.getZKDatabase().getEphemerals(connection.getSessionId())
+            String[] res= zk.getZKDatabase().getEphemerals(sessionId)
                 .toArray(new String[0]);
             Arrays.sort(res);
             return res;
@@ -88,7 +102,7 @@
     
     public void terminateSession() {
         try {
-            zk.closeSession(connection.getSessionId());
+            zk.closeSession(sessionId);
         } catch (Exception e) {
             LOG.warn(""Unable to closeSession() for session: 0x"" 
                     + getSessionId(), e);
"
zookeeper,df20416c08fa0079d96f6327d10c6f102ebabd85,"ZOOKEEPER-696. NPE in the hudson logs, seems nioservercnxn closed twice (phunt via mahadev)",2010.03.11 12:17:04,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 6517675..5375757 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -276,26 +276,29 @@
         }
 
         /**
-         * clear all the connections in the selector
+         * Clear all the connections in the selector.
+         * 
+         * You must first close ss (the serversocketchannel) if you wish
+         * to block any new connections from being established.
          *
          */
+        @SuppressWarnings(""unchecked"")
         synchronized public void clear() {
             selector.wakeup();
-            synchronized (cnxns) {
-                // got to clear all the connections that we have in the selector
-                for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
-                        .hasNext();) {
-                    NIOServerCnxn cnxn = it.next();
-                    it.remove();
-                    try {
-                        cnxn.close();
-                    } catch (Exception e) {
-                        LOG.warn(""Ignoring exception closing cnxn sessionid 0x""
-                                + Long.toHexString(cnxn.sessionId), e);
-                    }
+            HashSet<NIOServerCnxn> cnxns;
+            synchronized (this.cnxns) {
+                cnxns = (HashSet<NIOServerCnxn>)this.cnxns.clone();
+            }
+            // got to clear all the connections that we have in the selector
+            for (NIOServerCnxn cnxn: cnxns) {
+                try {
+                    // don't hold this.cnxns lock as deadlock may occur
+                    cnxn.close();
+                } catch (Exception e) {
+                    LOG.warn(""Ignoring exception closing cnxn sessionid 0x""
+                            + Long.toHexString(cnxn.sessionId), e);
                 }
             }
-
         }
 
         public void shutdown() {
@@ -324,21 +327,21 @@
             closeSessionWithoutWakeup(sessionId);
         }
 
-
+        @SuppressWarnings(""unchecked"")
         private void closeSessionWithoutWakeup(long sessionId) {
-            synchronized (cnxns) {
-                for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
-                        .hasNext();) {
-                    NIOServerCnxn cnxn = it.next();
-                    if (cnxn.sessionId == sessionId) {
-                        it.remove();
-                        try {
-                            cnxn.close();
-                        } catch (Exception e) {
-                            LOG.warn(""exception during session close"", e);
-                        }
-                        break;
+            HashSet<NIOServerCnxn> cnxns;
+            synchronized (this.cnxns) {
+                cnxns = (HashSet<NIOServerCnxn>)this.cnxns.clone();
+            }
+
+            for (NIOServerCnxn cnxn : cnxns) {
+                if (cnxn.sessionId == sessionId) {
+                    try {
+                        cnxn.close();
+                    } catch (Exception e) {
+                        LOG.warn(""exception during session close"", e);
                     }
+                    break;
                 }
             }
         }
@@ -1202,31 +1205,58 @@
     }
 
     /*
-     * (non-Javadoc)
-     *
-     * @see org.apache.zookeeper.server.ServerCnxnIface#close()
+     * Close the cnxn and remove it from the factory cnxns list.
+     * 
+     * This function returns immediately if the cnxn is not on the cnxns list.
      */
     public void close() {
-        // unregister from JMX
-        try {
-            if(jmxConnectionBean != null){
-                MBeanRegistry.getInstance().unregister(jmxConnectionBean);
+        synchronized(factory.cnxns){
+            // if this is not in cnxns then it's already closed
+            if (!factory.cnxns.remove(this)) {
+                return;
             }
-        } catch (Exception e) {
-            LOG.warn(""Failed to unregister with JMX"", e);
-        }
-        jmxConnectionBean = null;
 
-        synchronized (factory.ipMap)
-        {
-            Set<NIOServerCnxn> s = factory.ipMap.get(sock.socket().getInetAddress());
-            s.remove(this);
+            synchronized (factory.ipMap) {
+                Set<NIOServerCnxn> s =
+                    factory.ipMap.get(sock.socket().getInetAddress());
+                s.remove(this);
+            }
+
+            // unregister from JMX
+            try {
+                if(jmxConnectionBean != null){
+                    MBeanRegistry.getInstance().unregister(jmxConnectionBean);
+                }
+            } catch (Exception e) {
+                LOG.warn(""Failed to unregister with JMX"", e);
+            }
+            jmxConnectionBean = null;
+    
+            if (zk != null) {
+                zk.removeCnxn(this);
+            }
+    
+            closeSock();
+    
+            if (sk != null) {
+                try {
+                    // need to cancel this selection key from the selector
+                    sk.cancel();
+                } catch (Exception e) {
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""ignoring exception during selectionkey cancel"", e);
+                    }
+                }
+            }
         }
-        synchronized (factory.cnxns) {
-            factory.cnxns.remove(this);
-        }
-        if (zk != null) {
-            zk.removeCnxn(this);
+    }
+
+    /**
+     * Close resources associated with the sock of this cnxn. 
+     */
+    private void closeSock() {
+        if (sock == null) {
+            return;
         }
 
         LOG.info(""Closed socket connection for client ""
@@ -1275,18 +1305,8 @@
             }
         }
         sock = null;
-        if (sk != null) {
-            try {
-                // need to cancel this selection key from the selector
-                sk.cancel();
-            } catch (Exception e) {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug(""ignoring exception during selectionkey cancel"", e);
-                }
-            }
-        }
     }
-
+    
     private final static byte fourBytes[] = new byte[4];
 
     /*
@@ -1419,7 +1439,10 @@
         return authInfo;
     }
 
-    public InetSocketAddress getRemoteAddress() {
+    public synchronized InetSocketAddress getRemoteAddress() {
+        if (sock == null) {
+            return null;
+        }
         return (InetSocketAddress) sock.socket().getRemoteSocketAddress();
     }
 
"
zookeeper,df20416c08fa0079d96f6327d10c6f102ebabd85,"ZOOKEEPER-696. NPE in the hudson logs, seems nioservercnxn closed twice (phunt via mahadev)",2010.03.11 12:17:04,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index c7df1ce..bbf1ad8 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -396,17 +396,17 @@
         
         // NIO should not accept conenctions
         self.cnxnFactory.setZooKeeperServer(null);
+        try {
+            ss.close();
+        } catch (IOException e) {
+            LOG.warn(""Ignoring unexpected exception during close"",e);
+        }
         // clear all the connections
         self.cnxnFactory.clear();
         // shutdown the previous zk
         if (zk != null) {
             zk.shutdown();
         }
-        try {
-            ss.close();
-        } catch (IOException e) {
-            LOG.warn(""Ignoring unexpected exception during close"",e);
-        }
         synchronized (learners) {
             for (Iterator<LearnerHandler> it = learners.iterator(); it
                     .hasNext();) {
"
zookeeper,892c491e49f8f2333308f10a6fb4367772625b07,ZOOKEEPER-693. TestObserver stuck in tight notification loop in FLE,2010.03.11 03:52:11,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
index 3ac757e..c3bb6ca 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
@@ -808,6 +808,17 @@
 
     }
 
+    /**
+     * There is nothing to shutdown in this implementation of
+     * leader election, so we simply have an empty method.
+     */
+    public void shutdown(){}
+    
+    /**
+     * Invoked in QuorumPeer to find or elect a new leader.
+     * 
+     * @throws InterruptedException
+     */
     public Vote lookForLeader() throws InterruptedException {
         try {
             self.jmxLeaderElectionBean = new LeaderElectionBean();
"
zookeeper,892c491e49f8f2333308f10a6fb4367772625b07,ZOOKEEPER-693. TestObserver stuck in tight notification loop in FLE,2010.03.11 03:52:11,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Election.java b/src/java/main/org/apache/zookeeper/server/quorum/Election.java
index 48c38ee..2f78cdb 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Election.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Election.java
@@ -23,4 +23,5 @@
 
 public interface Election {
     public Vote lookForLeader() throws InterruptedException;
+    public void shutdown();
 }
\ No newline at end of file
"
zookeeper,892c491e49f8f2333308f10a6fb4367772625b07,ZOOKEEPER-693. TestObserver stuck in tight notification loop in FLE,2010.03.11 03:52:11,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
index 3b3f9ec..8b18422 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
@@ -111,6 +111,17 @@
         return result;
     }
 
+    /**
+     * There is nothing to shutdown in this implementation of
+     * leader election, so we simply have an empty method.
+     */
+    public void shutdown(){}
+    
+    /**
+     * Invoked in QuorumPeer to find or elect a new leader.
+     * 
+     * @throws InterruptedException
+     */
     public Vote lookForLeader() throws InterruptedException {
         try {
             self.jmxLeaderElectionBean = new LeaderElectionBean();
"
zookeeper,892c491e49f8f2333308f10a6fb4367772625b07,ZOOKEEPER-693. TestObserver stuck in tight notification loop in FLE,2010.03.11 03:52:11,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 28cafad..d71ef31 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -670,6 +670,10 @@
         if(udpSocket != null) {
             udpSocket.close();
         }
+        
+        if(getElectionAlg() != null){
+        	getElectionAlg().shutdown();
+        }
     }
 
     /**
"
zookeeper,f0da09751b34ad6969656df34bea7201632ef0ba,ZOOKEEPER-684. Race in LENonTerminateTest,2010.03.10 10:27:14,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index 1f8d5b4..5328b20 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -74,7 +74,7 @@
                 }
                 syncWithLeader(newLeaderZxid);                
                 QuorumPacket qp = new QuorumPacket();
-                while (self.running) {
+                while (self.isRunning()) {
                     readPacket(qp);
                     processPacket(qp);                   
                 }                              
"
zookeeper,f0da09751b34ad6969656df34bea7201632ef0ba,ZOOKEEPER-684. Race in LENonTerminateTest,2010.03.10 10:27:14,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
index 1b07e82..3b3f9ec 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
@@ -41,9 +41,9 @@
 
 public class LeaderElection implements Election  {
     private static final Logger LOG = Logger.getLogger(LeaderElection.class);
-    private static Random epochGen = new Random();
+    protected static Random epochGen = new Random();
 
-    QuorumPeer self;
+    protected QuorumPeer self;
 
     public LeaderElection(QuorumPeer self) {
         this.self = self;
@@ -59,7 +59,7 @@
         public int winningCount;
     }
 
-    private ElectionResult countVotes(HashMap<InetSocketAddress, Vote> votes, HashSet<Long> heardFrom) {
+    protected ElectionResult countVotes(HashMap<InetSocketAddress, Vote> votes, HashSet<Long> heardFrom) {
         ElectionResult result = new ElectionResult();
         // Initialize with null vote
         result.vote = new Vote(Long.MIN_VALUE, Long.MIN_VALUE);
@@ -145,7 +145,7 @@
             HashMap<InetSocketAddress, Vote> votes =
                 new HashMap<InetSocketAddress, Vote>(self.getVotingView().size());
             int xid = epochGen.nextInt();
-            while (self.running) {
+            while (self.isRunning()) {
                 votes.clear();
                 requestBuffer.clear();
                 requestBuffer.putInt(xid);
"
zookeeper,f0da09751b34ad6969656df34bea7201632ef0ba,ZOOKEEPER-684. Race in LENonTerminateTest,2010.03.10 10:27:14,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
index 0b766f1..3509c11 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
@@ -71,7 +71,7 @@
                 
                 syncWithLeader(newLeaderZxid);
                 QuorumPacket qp = new QuorumPacket();
-                while (self.running) {
+                while (self.isRunning()) {
                     readPacket(qp);
                     processPacket(qp);                   
                 }
"
zookeeper,f0da09751b34ad6969656df34bea7201632ef0ba,ZOOKEEPER-684. Race in LENonTerminateTest,2010.03.10 10:27:14,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index e1993a5..28cafad 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -495,7 +495,7 @@
                 this, new ZooKeeperServer.BasicDataTreeBuilder(), this.zkDb));
     }
 
-    private Election createElectionAlgorithm(int electionAlgorithm){
+    protected Election createElectionAlgorithm(int electionAlgorithm){
         Election le=null;
                 
         //TODO: use a factory rather than a switch
@@ -891,4 +891,12 @@
     public void setZKDatabase(ZKDatabase database) {
         this.zkDb = database;
     }
+
+    public void setRunning(boolean running) {
+        this.running = running;
+    }
+
+    public boolean isRunning() {
+        return running;
+    }
 }
"
zookeeper,618b01886c3fc18fdca9cbe36eacc3615d72563a,ZOOKEEPER-691. Interface changed for NIOServer.Factory (breed via mahadev),2010.03.10 05:50:14,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
index c83210f..67672cb 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
@@ -23,6 +23,7 @@
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
+import java.net.InetSocketAddress;
 import java.net.Socket;
 
 import org.apache.bookkeeper.proto.BookieServer;
@@ -86,7 +87,7 @@
 		    
 		try {
 			zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);
-			serverFactory =  new NIOServerCnxn.Factory(ZooKeeperDefaultPort);
+			serverFactory =  new NIOServerCnxn.Factory(new InetSocketAddress(ZooKeeperDefaultPort));
 			serverFactory.startup(zks);
 		} catch (Exception e) {
 			// TODO Auto-generated catch block
"
zookeeper,ab5aa8c07299b04cccf3d2ca8b5c59db4f69af56,ZOOKEEPER-59. Synchronized block in NIOServerCnxn (flavio via mahadev),2010.03.09 11:00:46,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index b6f7e34..4d8661f 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -395,7 +395,8 @@
                     return;
                 }
             }
-            synchronized (factory) {
+
+            synchronized(this.factory){
                 sk.selector().wakeup();
                 if (LOG.isTraceEnabled()) {
                     LOG.trace(""Add a buffer to outgoingBuffers, sk "" + sk
@@ -406,6 +407,7 @@
                     sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);
                 }
             }
+            
         } catch(Exception e) {
             LOG.error(""Unexpected Exception: "", e);
         }
@@ -564,7 +566,8 @@
                     // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK, ""after send,
                     // outgoingBuffers.size() = "" + outgoingBuffers.size());
                 }
-                synchronized (this) {
+
+                synchronized(this.factory){
                     if (outgoingBuffers.size() == 0) {
                         if (!initialized
                                 && (sk.interestOps() & SelectionKey.OP_READ) == 0) {
@@ -574,7 +577,7 @@
                                 & (~SelectionKey.OP_WRITE));
                     } else {
                         sk.interestOps(sk.interestOps()
-                                        | SelectionKey.OP_WRITE);
+                                | SelectionKey.OP_WRITE);
                     }
                 }
             }
@@ -654,19 +657,19 @@
         }
         if (h.getXid() >= 0) {
             synchronized (this) {
-                synchronized (this.factory) {
-                    outstandingRequests++;
-                    // check throttling
-                    if (zk.getInProcess() > factory.outstandingLimit) {
-                        if (LOG.isDebugEnabled()) {
-                            LOG.debug(""Throttling recv "" + zk.getInProcess());
-                        }
-                        disableRecv();
-                        // following lines should not be needed since we are
-                        // already reading
-                        // } else {
-                        // enableRecv();
+                outstandingRequests++;
+            }
+            synchronized (this.factory) {        
+                // check throttling
+                if (zk.getInProcess() > factory.outstandingLimit) {
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""Throttling recv "" + zk.getInProcess());
                     }
+                    disableRecv();
+                    // following lines should not be needed since we are
+                    // already reading
+                    // } else {
+                    // enableRecv();
                 }
             }
         }
@@ -1312,9 +1315,11 @@
             bb.putInt(b.length - 4).rewind();
             sendBuffer(bb);
             if (h.getXid() > 0) {
-                synchronized (this.factory) {
+                synchronized(this){
                     outstandingRequests--;
-                    // check throttling
+                }
+                // check throttling
+                synchronized (this.factory) {        
                     if (zk.getInProcess() < factory.outstandingLimit
                             || outstandingRequests < 1) {
                         sk.selector().wakeup();
"
zookeeper,0051cd26087492fe393932d9fdac1f7bff8b7ac4,ZOOKEEPER-693: hudson failure in ZKDatabaseCorruptionTest (mahadev via henryr),2010.03.09 10:18:55,Henry Robinson,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 596c684..d7853d8 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -489,7 +489,8 @@
             FileHeader header= new FileHeader();
             header.deserialize(ia, ""fileheader"");
             if (header.getMagic() != FileTxnLog.TXNLOG_MAGIC) {
-                throw new IOException(""Invalid magic number "" + header.getMagic()
+                throw new IOException(""Transaction log: "" + this.logFile + "" has invalid magic number "" 
+                        + header.getMagic()
                         + "" != "" + FileTxnLog.TXNLOG_MAGIC);
             }
         }
@@ -506,7 +507,7 @@
                 LOG.debug(""Created new input stream "" + logFile);
                 ia  = BinaryInputArchive.getArchive(inputStream);
                 inStreamCreated(ia,inputStream);
-                LOG.debug(""created new input archive "" + logFile);
+                LOG.debug(""Created new input archive "" + logFile);
             }
             return ia;
         }
"
zookeeper,0051cd26087492fe393932d9fdac1f7bff8b7ac4,ZOOKEEPER-693: hudson failure in ZKDatabaseCorruptionTest (mahadev via henryr),2010.03.09 10:18:55,Henry Robinson,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 5851af2..dd18592 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -109,7 +109,7 @@
     }
     
     /**
-     * this function restors the server 
+     * this function restores the server 
      * database after reading from the 
      * snapshots and transaction logs
      * @param dt the datatree to be restored
"
zookeeper,691dfa44b48240a8917883f3065e3b25e633a58c,"ZOOKEEPER-682. Event is not processed when the watcher is set to watch ""/"" if chrooted (Scott Wang via mahadev)",2010.03.04 10:28:41,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 9f0eeb8..e7c8eed 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -744,7 +744,10 @@
                 // convert from a server path to a client path
                 if (chrootPath != null) {
                     String serverPath = event.getPath();
-                    event.setPath(serverPath.substring(chrootPath.length()));
+                    if(serverPath.compareTo(chrootPath)==0)
+                        event.setPath(""/"");
+                    else
+                        event.setPath(serverPath.substring(chrootPath.length()));
                 }
 
                 WatchedEvent we = new WatchedEvent(event);
"
zookeeper,90dd37368463c49c1415564896d4141cdb674a6b,ZOOKEEPER-683. LogFormatter fails to parse transactional log files (phunt via mahadev),2010.03.04 08:07:21,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/LogFormatter.java b/src/java/main/org/apache/zookeeper/server/LogFormatter.java
index ac4c56b..fd01521 100644
--- a/src/java/main/org/apache/zookeeper/server/LogFormatter.java
+++ b/src/java/main/org/apache/zookeeper/server/LogFormatter.java
@@ -21,13 +21,19 @@
 import java.io.ByteArrayInputStream;
 import java.io.EOFException;
 import java.io.FileInputStream;
+import java.io.IOException;
 import java.text.DateFormat;
 import java.util.Date;
-
-import org.apache.log4j.Logger;
+import java.util.zip.Adler32;
+import java.util.zip.Checksum;
 
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.InputArchive;
+import org.apache.jute.Record;
+import org.apache.log4j.Logger;
+import org.apache.zookeeper.server.persistence.FileHeader;
+import org.apache.zookeeper.server.persistence.FileTxnLog;
+import org.apache.zookeeper.server.util.SerializeUtils;
 import org.apache.zookeeper.txn.TxnHeader;
 
 public class LogFormatter {
@@ -43,23 +49,51 @@
         }
         FileInputStream fis = new FileInputStream(args[0]);
         BinaryInputArchive logStream = BinaryInputArchive.getArchive(fis);
+        FileHeader fhdr = new FileHeader();
+        fhdr.deserialize(logStream, ""fileheader"");
+
+        if (fhdr.getMagic() != FileTxnLog.TXNLOG_MAGIC) {
+            System.err.println(""Invalid magic number for "" + args[0]);
+            System.exit(2);
+        }
+        System.out.println(""ZooKeeper Transactional Log File with dbid ""
+                + fhdr.getDbid() + "" txnlog format version ""
+                + fhdr.getVersion());
+
+        int count = 0;
         while (true) {
-            byte[] bytes = logStream.readBuffer(""txnEntry"");
+            long crcValue;
+            byte[] bytes;
+            try {
+                crcValue = logStream.readLong(""crcvalue"");
+
+                bytes = logStream.readBuffer(""txnEntry"");
+            } catch (EOFException e) {
+                System.out.println(""EOF reached after "" + count + "" txns."");
+                return;
+            }
             if (bytes.length == 0) {
                 // Since we preallocate, we define EOF to be an
                 // empty transaction
-                throw new EOFException();
+                System.out.println(""EOF reached after "" + count + "" txns."");
+                return;
             }
-            InputArchive ia = BinaryInputArchive
-                    .getArchive(new ByteArrayInputStream(bytes));
+            Checksum crc = new Adler32();
+            crc.update(bytes, 0, bytes.length);
+            if (crcValue != crc.getValue()) {
+                throw new IOException(""CRC doesn't match "" + crcValue +
+                        "" vs "" + crc.getValue());
+            }
+            InputArchive iab = BinaryInputArchive
+                                .getArchive(new ByteArrayInputStream(bytes));
             TxnHeader hdr = new TxnHeader();
-            hdr.deserialize(ia, ""hdr"");
+            SerializeUtils.deserializeTxn(iab, hdr);
             System.out.println(DateFormat.getDateTimeInstance(DateFormat.SHORT,
                     DateFormat.LONG).format(new Date(hdr.getTime()))
                     + "" session 0x""
                     + Long.toHexString(hdr.getClientId())
-                    + "":""
-                    + hdr.getCxid()
+                    + "" cxid 0x""
+                    + Long.toHexString(hdr.getCxid())
                     + "" zxid 0x""
                     + Long.toHexString(hdr.getZxid())
                     + "" "" + TraceFormatter.op2String(hdr.getType()));
@@ -67,6 +101,7 @@
                 LOG.error(""Last transaction was partial."");
                 throw new EOFException(""Last transaction was partial."");
             }
+            count++;
         }
     }
 }
"
zookeeper,90dd37368463c49c1415564896d4141cdb674a6b,ZOOKEEPER-683. LogFormatter fails to parse transactional log files (phunt via mahadev),2010.03.04 08:07:21,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index d842234..596c684 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -47,7 +47,44 @@
 /**
  * This class implements the TxnLog interface. It provides api's
  * to access the txnlogs and add entries to it.
- *
+ * <p>
+ * The format of a Transactional log is as follows:
+ * <blockquote><pre>
+ * LogFile:
+ *     FileHeader TxnList ZeroPad
+ * 
+ * FileHeader: {
+ *     magic 4bytes (ZKLG)
+ *     version 4bytes
+ *     dbid 8bytes
+ *   }
+ * 
+ * TxnList:
+ *     Txn || Txn TxnList
+ *     
+ * Txn:
+ *     checksum Txnlen TxnHeader Record 0x42
+ * 
+ * checksum: 8bytes Adler32 is currently used
+ *   calculated across payload -- Txnlen, TxnHeader, Record and 0x42
+ * 
+ * Txnlen:
+ *     len 4bytes
+ * 
+ * TxnHeader: {
+ *     sessionid 8bytes
+ *     cxid 4bytes
+ *     zxid 8bytes
+ *     time 8bytes
+ *     type 4bytes
+ *   }
+ *     
+ * Record:
+ *     See Jute definition file for details on the various record types
+ *      
+ * ZeroPad:
+ *     0 padded to EOF (filled during preallocation stage)
+ * </pre></blockquote> 
  */
 public class FileTxnLog implements TxnLog {
     private static final Logger LOG;
"
zookeeper,6d3844bf7716e379e4974df39ca524fab886e149,ZOOKEEPER-669. watchedevent tostring should clearly output the state/type/path (phunt via mahadev),2010.02.24 03:22:34,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/WatchedEvent.java b/src/java/main/org/apache/zookeeper/WatchedEvent.java
index bef0893..63f29c3 100644
--- a/src/java/main/org/apache/zookeeper/WatchedEvent.java
+++ b/src/java/main/org/apache/zookeeper/WatchedEvent.java
@@ -64,10 +64,8 @@
 
     @Override
     public String toString() {
-        if(path == null)  // then is a state change 
-            return ""WatchedEvent: Server state change. New state: "" + keeperState;
-         else  // is a znode change
-            return ""WatchedEvent: Znode change. Path: "" + path + "" Type: "" + eventType;
+        return ""WatchedEvent state:"" + keeperState
+            + "" type:"" + eventType + "" path:"" + path;
     }
 
     /**
"
zookeeper,b8ccc0c5708c11021a647dc4c1508499bc79cca2,ZOOKEEPER-569. Failure of elected leader can lead to never-ending leader election (henry via flavio),2010.02.20 23:26:00,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
index d5eda76..1b07e82 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
@@ -198,40 +198,50 @@
                         // down
                     }
                 }
+
                 ElectionResult result = countVotes(votes, heardFrom);
-                if (result.winner.id >= 0) {
-                    self.setCurrentVote(result.vote);
-                    // To do: this doesn't use a quorum verifier
-                    if (result.winningCount > (self.getVotingView().size() / 2)) {
-                        self.setCurrentVote(result.winner);
-                        s.close();
-                        Vote current = self.getCurrentVote();
-                        LOG.info(""Found leader: my type is: "" + self.getPeerType());
-                        /**
-                         * We want to make sure we implement the state machine
-                         * correctly. If we are a PARTICIPANT, once a leader
-                         * is elected we can move either to LEADING or 
-                         * FOLLOWING. However if we are an OBSERVER, it is an
-                         * error to be elected as a Leader.
-                         */
-                        if (self.getPeerType() == LearnerType.OBSERVER) {
-                            if (current.id == self.getId()) {
-                                // This should never happen!
-                                LOG.error(""OBSERVER elected as leader!"");
-                                Thread.sleep(100);
-                            }
-                            else {
-                                self.setPeerState(ServerState.OBSERVING);
-                                Thread.sleep(100);
+                // ZOOKEEPER-569:
+                // If no votes are received for live peers, reset to voting 
+                // for ourselves as otherwise we may hang on to a vote 
+                // for a dead peer                 
+                if (votes.size() == 0) {                    
+                    self.setCurrentVote(new Vote(self.getId(),
+                            self.getLastLoggedZxid()));
+                } else {
+                    if (result.winner.id >= 0) {
+                        self.setCurrentVote(result.vote);
+                        // To do: this doesn't use a quorum verifier
+                        if (result.winningCount > (self.getVotingView().size() / 2)) {
+                            self.setCurrentVote(result.winner);
+                            s.close();
+                            Vote current = self.getCurrentVote();
+                            LOG.info(""Found leader: my type is: "" + self.getPeerType());
+                            /*
+                             * We want to make sure we implement the state machine
+                             * correctly. If we are a PARTICIPANT, once a leader
+                             * is elected we can move either to LEADING or 
+                             * FOLLOWING. However if we are an OBSERVER, it is an
+                             * error to be elected as a Leader.
+                             */
+                            if (self.getPeerType() == LearnerType.OBSERVER) {
+                                if (current.id == self.getId()) {
+                                    // This should never happen!
+                                    LOG.error(""OBSERVER elected as leader!"");
+                                    Thread.sleep(100);
+                                }
+                                else {
+                                    self.setPeerState(ServerState.OBSERVING);
+                                    Thread.sleep(100);
+                                    return current;
+                                }
+                            } else {
+                                self.setPeerState((current.id == self.getId())
+                                        ? ServerState.LEADING: ServerState.FOLLOWING);
+                                if (self.getPeerState() == ServerState.FOLLOWING) {
+                                    Thread.sleep(100);
+                                }                            
                                 return current;
                             }
-                        } else {
-                            self.setPeerState((current.id == self.getId())
-                                    ? ServerState.LEADING: ServerState.FOLLOWING);
-                            if (self.getPeerState() == ServerState.FOLLOWING) {
-                                Thread.sleep(100);
-                            }                            
-                            return current;
                         }
                     }
                 }
"
zookeeper,b8ccc0c5708c11021a647dc4c1508499bc79cca2,ZOOKEEPER-569. Failure of elected leader can lead to never-ending leader election (henry via flavio),2010.02.20 23:26:00,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index c7498ee..4a503a2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -501,7 +501,7 @@
         //TODO: use a factory rather than a switch
         switch (electionAlgorithm) {
         case 0:
-            // will create a new instance for each run of the protocol
+            le = new LeaderElection(this);
             break;
         case 1:
             le = new AuthFastLeaderElection(this);
@@ -527,10 +527,9 @@
 
     protected Election makeLEStrategy(){
         LOG.debug(""Initializing leader election protocol..."");
-
-        if(electionAlg==null){
-            return new LeaderElection(this);
-        }
+        if (getElectionType() == 0) {
+            electionAlg = new LeaderElection(this);
+        }        
         return electionAlg;
     }
 
"
zookeeper,75abbb34e2d10b0c5fc955f76ffd17286922f14a,ZOOKEEPER-668. Close method in LedgerInputStream doesn't do anything (flavio via mahadev),2010.02.19 11:42:39,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/streaming/LedgerInputStream.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/streaming/LedgerInputStream.java
index ce2dffa..5566aa2 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/streaming/LedgerInputStream.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/streaming/LedgerInputStream.java
@@ -74,6 +74,11 @@
         ledgerSeq = lh.readEntries(0, lastEntry);
     }
 
+    /**
+     * Method close currently doesn't do anything. The application
+     * is supposed to open and close the ledger handle backing up 
+     * a stream ({@link LedgerHandle}).
+     */
     @Override
     public void close() {
         // do nothing
"
zookeeper,f0fad0f10e324b64bfafe0981732eecf38dbb3a3,ZOOKEEPER-593.  java client api does not allow client to access negotiated session timeout (phunt via mahadev),2010.01.26 11:22:40,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 7eca379..9f0eeb8 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -129,6 +129,13 @@
 
     private int connectTimeout;
 
+    /** The timeout in ms the client negotiated with the server. This is the 
+     *  ""real"" timeout, not the timeout request by the client (which may
+     *  have been increased/decreased by the server which applies bounds
+     *  to this value.
+     */
+    private volatile int negotiatedSessionTimeout;
+
     private int readTimeout;
 
     private final int sessionTimeout;
@@ -165,6 +172,10 @@
         return sessionPasswd;
     }
 
+    public int getSessionTimeout() {
+        return negotiatedSessionTimeout;
+    }
+
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder();
@@ -668,8 +679,8 @@
             BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
             ConnectResponse conRsp = new ConnectResponse();
             conRsp.deserialize(bbia, ""connect"");
-            int sessionTimeout = conRsp.getTimeOut();
-            if (sessionTimeout <= 0) {
+            negotiatedSessionTimeout = conRsp.getTimeOut();
+            if (negotiatedSessionTimeout <= 0) {
                 zooKeeper.state = States.CLOSED;
 
                 eventThread.queueEvent(new WatchedEvent(
@@ -679,8 +690,8 @@
                         ""Unable to reconnect to ZooKeeper service, session 0x""
                         + Long.toHexString(sessionId) + "" has expired"");
             }
-            readTimeout = sessionTimeout * 2 / 3;
-            connectTimeout = sessionTimeout / serverAddrs.size();
+            readTimeout = negotiatedSessionTimeout * 2 / 3;
+            connectTimeout = negotiatedSessionTimeout / serverAddrs.size();
             sessionId = conRsp.getSessionId();
             sessionPasswd = conRsp.getPasswd();
             zooKeeper.state = States.CONNECTED;
@@ -689,7 +700,7 @@
                         .socket().getRemoteSocketAddress()
                     + "", sessionid = 0x""
                     + Long.toHexString(sessionId)
-                    + "", negotiated timeout = "" + sessionTimeout);
+                    + "", negotiated timeout = "" + negotiatedSessionTimeout);
             eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None,
                     Watcher.Event.KeeperState.SyncConnected, null));
         }
"
zookeeper,f0fad0f10e324b64bfafe0981732eecf38dbb3a3,ZOOKEEPER-593.  java client api does not allow client to access negotiated session timeout (phunt via mahadev),2010.01.26 11:22:40,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 0ddbad0..834055c 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -473,6 +473,19 @@
     }
 
     /**
+     * The negotiated session timeout for this ZooKeeper client instance. The
+     * value returned is not valid until the client connects to a server and
+     * may change after a re-connect.
+     *
+     * This method is NOT thread safe
+     *
+     * @return current session timeout
+     */
+    public int getSessionTimeout() {
+        return cnxn.getSessionTimeout();
+    }
+
+    /**
      * Add the specified scheme:auth information to this connection.
      *
      * This method is NOT thread safe
@@ -1469,7 +1482,12 @@
      */
     @Override
     public String toString() {
-        return (""State:"" + getState().toString() + "" "" + cnxn);
+        States state = getState();
+        return (""State:"" + state.toString()
+                + (state == States.CONNECTED ?
+                        "" Timeout:"" + getSessionTimeout() + "" "" :
+                        "" "")
+                + cnxn);
     }
 
     /*
"
zookeeper,b4e31ff98c2c2bce326999361a27e89c4f79998c,ZOOKEEPER-626. ensure the c/java cli's print xid/sessionid/etc... in hex (pat via mahadev),2010.01.22 09:49:22,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index 646e0a5..2d40e38 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -127,15 +127,16 @@
     }
 
     private static void printStat(Stat stat) {
-        System.err.println(""cZxid = "" + stat.getCzxid());
+        System.err.println(""cZxid = 0x"" + Long.toHexString(stat.getCzxid()));
         System.err.println(""ctime = "" + new Date(stat.getCtime()).toString());
-        System.err.println(""mZxid = "" + stat.getMzxid());
+        System.err.println(""mZxid = 0x"" + Long.toHexString(stat.getMzxid()));
         System.err.println(""mtime = "" + new Date(stat.getMtime()).toString());
-        System.err.println(""pZxid = "" + stat.getPzxid());
+        System.err.println(""pZxid = 0x"" + Long.toHexString(stat.getPzxid()));
         System.err.println(""cversion = "" + stat.getCversion());
         System.err.println(""dataVersion = "" + stat.getVersion());
         System.err.println(""aclVersion = "" + stat.getAversion());
-        System.err.println(""ephemeralOwner = "" + stat.getEphemeralOwner());
+        System.err.println(""ephemeralOwner = 0x""
+        		+ Long.toHexString(stat.getEphemeralOwner()));
         System.err.println(""dataLength = "" + stat.getDataLength());
         System.err.println(""numChildren = "" + stat.getNumChildren());
     }
"
zookeeper,773ed4078caf8d9b85330dc7d3aa91b330690e60,ZOOKEEPER-647. hudson failure in testLeaderShutdown (flavio via mahadev),2010.01.21 12:08:47,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 766d74a..ab7bd2e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -560,33 +560,32 @@
                 this.finish();
             }
             
-            while (running && !shutdown && channel != null) {
+            try {
+                while (running && !shutdown && channel != null) {
 
-                ByteBuffer b = null;
-                try {
-                    ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);                    
-                    if(bq != null) 
-                        b = bq.poll(1000, TimeUnit.MILLISECONDS);
-                    else {
-                        LOG.error(""No queue of incoming messages for server "" + sid);
-                        this.finish();
+                    ByteBuffer b = null;
+                    try {
+                        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);                    
+                        if(bq != null) 
+                            b = bq.poll(1000, TimeUnit.MILLISECONDS);
+                        else {
+                            LOG.error(""No queue of incoming messages for server "" + sid);
+                            break;
+                        }
+
+                        if(b != null){
+                            lastMessageSent.put(sid, b);
+                            send(b);
+                        }
+                    } catch (InterruptedException e) {
+                        LOG.warn(""Interrupted while waiting for message on queue"",
+                                e);
                     }
-                } catch (InterruptedException e) {
-                    LOG.warn(""Interrupted while waiting for message on queue"",
-                            e);
-                    continue;
                 }
-                
-                try {
-                    if(b != null){
-                        lastMessageSent.put(sid, b);
-                        send(b);
-                    }
-                } catch (Exception e) {
-                    LOG.warn(""Exception when using channel: "" + sid, e);
-                    this.finish();
-                }
+            } catch (Exception e) {
+                LOG.warn(""Exception when using channel: "" + sid, e);
             }
+            this.finish();
             LOG.warn(""Send worker leaving thread"");
         }
     }
"
zookeeper,75277a873629db46a61847c3b073d8ad0dbdce2a,ZOOKEEPER-623. ClientBase in bookkeeper.util requires junit,2009.12.18 02:36:19,Benjamin Reed,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
index ff751dc..7e52521 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
@@ -18,8 +18,12 @@
  * limitations under the License.
  */
 
+import java.io.BufferedReader;
 import java.io.File;
 import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.Socket;
 
 import org.apache.bookkeeper.client.BookKeeper;
 import org.apache.bookkeeper.client.LedgerHandle;
@@ -42,12 +46,13 @@
 import org.apache.log4j.Logger;
 
 public class LocalBookKeeper {
-    Logger LOG = Logger.getLogger(LocalBookKeeper.class);
+    protected static final Logger LOG = Logger.getLogger(LocalBookKeeper.class);
+    public static final int CONNECTION_TIMEOUT = 30000;
+    
 	ConsoleAppender ca;
 	int numberOfBookies;
 	
 	public LocalBookKeeper() {
-		LOG = Logger.getRootLogger();
 		ca = new ConsoleAppender(new PatternLayout());
 		LOG.addAppender(ca);
 		LOG.setLevel(Level.INFO);
@@ -94,7 +99,7 @@
 			LOG.fatal(""Exception while instantiating ZooKeeper"", e);
 		} 
 		
-        boolean b = ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT);
+        boolean b = waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT);
         LOG.debug(""ZooKeeper server up: "" + b);
 	}
 	
@@ -160,5 +165,50 @@
 	class emptyWatcher implements Watcher{
 		public void process(WatchedEvent event) {}
 	}
+	
+	public static boolean waitForServerUp(String hp, long timeout) {
+        long start = System.currentTimeMillis();
+        String split[] = hp.split("":"");
+        String host = split[0];
+        int port = Integer.parseInt(split[1]);
+        while (true) {
+            try {
+                Socket sock = new Socket(host, port);
+                BufferedReader reader = null;
+                try {
+                    OutputStream outstream = sock.getOutputStream();
+                    outstream.write(""stat"".getBytes());
+                    outstream.flush();
+
+                    reader =
+                        new BufferedReader(
+                                new InputStreamReader(sock.getInputStream()));
+                    String line = reader.readLine();
+                    if (line != null && line.startsWith(""Zookeeper version:"")) {
+                        LOG.info(""Server UP"");
+                        return true;
+                    }
+                } finally {
+                    sock.close();
+                    if (reader != null) {
+                        reader.close();
+                    }
+                }
+            } catch (IOException e) {
+                // ignore as this is expected
+                LOG.info(""server "" + hp + "" not up "" + e);
+            }
+
+            if (System.currentTimeMillis() > start + timeout) {
+                break;
+            }
+            try {
+                Thread.sleep(250);
+            } catch (InterruptedException e) {
+                // ignore
+            }
+        }
+        return false;
+    }
 
 }
"
zookeeper,2ed6485e9d503e68c8f9ab3d5655be88ab1e0851,ZOOKEEPER-614. Improper synchronisation in getClientCnxnCount (henry via mahadev),2009.12.12 08:03:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 8e37af0..9eb4a0b 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -201,10 +201,15 @@
             return new NIOServerCnxn(zks, sock, sk, this);
         }
 
-        private int getClientCnxnCount( InetAddress cl) {
-            Set<NIOServerCnxn> s = ipMap.get(cl);
-            if (s == null) return 0;
-            return s.size();
+        private int getClientCnxnCount(InetAddress cl) {
+            // The ipMap lock covers both the map, and its contents
+            // (that is, the cnxn sets shouldn't be modified outside of
+            // this lock)
+            synchronized (ipMap) {
+                Set<NIOServerCnxn> s = ipMap.get(cl);
+                if (s == null) return 0;
+                return s.size();
+            }
         }
 
         public void run() {
"
zookeeper,47356252a1371452afc3bf371f569cb815d71e29,ZOOKEEPER-587.  client should log timeout negotiated with server (phunt via mahadev),2009.12.12 06:46:06,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 581db8c..03f5123 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -637,8 +637,12 @@
             sessionId = conRsp.getSessionId();
             sessionPasswd = conRsp.getPasswd();
             zooKeeper.state = States.CONNECTED;
-            LOG.info(""Session establishment complete, sessionid = 0x""
-                    + Long.toHexString(sessionId));
+            LOG.info(""Session establishment complete on server ""
+                    + ((SocketChannel)sockKey.channel())
+                        .socket().getRemoteSocketAddress()
+                    + "", sessionid = 0x""
+                    + Long.toHexString(sessionId)
+                    + "", negotiated timeout = "" + sessionTimeout);
             eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None,
                     Watcher.Event.KeeperState.SyncConnected, null));
         }
"
zookeeper,47356252a1371452afc3bf371f569cb815d71e29,ZOOKEEPER-587.  client should log timeout negotiated with server (phunt via mahadev),2009.12.12 06:46:06,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 45fea82..cfe1b50 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -1141,6 +1141,7 @@
             } else {
                 LOG.info(""Established session 0x""
                         + Long.toHexString(sessionId)
+                        + "" with negotiated timeout "" + sessionTimeout
                         + "" for client ""
                         + sock.socket().getRemoteSocketAddress());
             }
"
zookeeper,c22c30d7c8c2ace2ad5f6675ccc6331310c0c144,ZOOKEEPER-588. remove unnecessary/annoying log of tostring error in Request.toString(),2009.12.12 05:24:23,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/KeeperException.java b/src/java/main/org/apache/zookeeper/KeeperException.java
index 8c734ee..f8d91b8 100644
--- a/src/java/main/org/apache/zookeeper/KeeperException.java
+++ b/src/java/main/org/apache/zookeeper/KeeperException.java
@@ -484,6 +484,9 @@
         public BadArgumentsException() {
             super(Code.BADARGUMENTS);
         }
+        public BadArgumentsException(String path) {
+            super(Code.BADARGUMENTS, path);
+        }
     }
 
     /**
@@ -493,6 +496,9 @@
         public BadVersionException() {
             super(Code.BADVERSION);
         }
+        public BadVersionException(String path) {
+            super(Code.BADVERSION, path);
+        }
     }
 
     /**
@@ -520,6 +526,9 @@
         public InvalidACLException() {
             super(Code.INVALIDACL);
         }
+        public InvalidACLException(String path) {
+            super(Code.INVALIDACL, path);
+        }
     }
 
     /**
@@ -556,6 +565,9 @@
         public NoChildrenForEphemeralsException() {
             super(Code.NOCHILDRENFOREPHEMERALS);
         }
+        public NoChildrenForEphemeralsException(String path) {
+            super(Code.NOCHILDRENFOREPHEMERALS, path);
+        }
     }
 
     /**
@@ -565,6 +577,9 @@
         public NodeExistsException() {
             super(Code.NODEEXISTS);
         }
+        public NodeExistsException(String path) {
+            super(Code.NODEEXISTS, path);
+        }
     }
 
     /**
@@ -574,6 +589,9 @@
         public NoNodeException() {
             super(Code.NONODE);
         }
+        public NoNodeException(String path) {
+            super(Code.NONODE, path);
+        }
     }
 
     /**
@@ -583,6 +601,9 @@
         public NotEmptyException() {
             super(Code.NOTEMPTY);
         }
+        public NotEmptyException(String path) {
+            super(Code.NOTEMPTY, path);
+        }
     }
 
     /**
"
zookeeper,c22c30d7c8c2ace2ad5f6675ccc6331310c0c144,ZOOKEEPER-588. remove unnecessary/annoying log of tostring error in Request.toString(),2009.12.12 05:24:23,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 705c987..5b60591 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -147,7 +147,7 @@
             }
         }
         if (lastChange == null || lastChange.stat == null) {
-            throw new KeeperException.NoNodeException();
+            throw new KeeperException.NoNodeException(path);
         }
         return lastChange;
     }
@@ -218,10 +218,10 @@
                 if (lastSlash == -1 || path.indexOf('\0') != -1 || failCreate) {
                     LOG.info(""Invalid path "" + path + "" with session "" +
                             Long.toHexString(request.sessionId));
-                    throw new KeeperException.BadArgumentsException();
+                    throw new KeeperException.BadArgumentsException(path);
                 }
                 if (!fixupACL(request.authInfo, createRequest.getAcl())) {
-                    throw new KeeperException.InvalidACLException();
+                    throw new KeeperException.InvalidACLException(path);
                 }
                 String parentPath = path.substring(0, lastSlash);
                 ChangeRecord parentRecord = getRecordForPath(parentPath);
@@ -239,18 +239,18 @@
                 } catch(IllegalArgumentException ie) {
                     LOG.info(""Invalid path "" + path + "" with session "" +
                             Long.toHexString(request.sessionId));
-                    throw new KeeperException.BadArgumentsException();
+                    throw new KeeperException.BadArgumentsException(path);
                 }
                 try {
                     if (getRecordForPath(path) != null) {
-                        throw new KeeperException.NodeExistsException();
+                        throw new KeeperException.NodeExistsException(path);
                     }
                 } catch (KeeperException.NoNodeException e) {
                     // ignore this one
                 }
                 boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;
                 if (ephemeralParent) {
-                    throw new KeeperException.NoChildrenForEphemeralsException();
+                    throw new KeeperException.NoChildrenForEphemeralsException(path);
                 }
                 txn = new CreateTxn(path, createRequest.getData(),
                         createRequest.getAcl(),
@@ -279,7 +279,7 @@
                 lastSlash = path.lastIndexOf('/');
                 if (lastSlash == -1 || path.indexOf('\0') != -1
                         || zks.dataTree.isSpecialPath(path)) {
-                    throw new KeeperException.BadArgumentsException();
+                    throw new KeeperException.BadArgumentsException(path);
                 }
                 parentPath = path.substring(0, lastSlash);
                 parentRecord = getRecordForPath(parentPath);
@@ -288,10 +288,10 @@
                         request.authInfo);
                 int version = deleteRequest.getVersion();
                 if (version != -1 && nodeRecord.stat.getVersion() != version) {
-                    throw new KeeperException.BadVersionException();
+                    throw new KeeperException.BadVersionException(path);
                 }
                 if (nodeRecord.childCount > 0) {
-                    throw new KeeperException.NotEmptyException();
+                    throw new KeeperException.NotEmptyException(path);
                 }
                 txn = new DeleteTxn(path);
                 parentRecord = parentRecord.duplicate(txnHeader.getZxid());
@@ -316,7 +316,7 @@
                 version = setDataRequest.getVersion();
                 int currentVersion = nodeRecord.stat.getVersion();
                 if (version != -1 && version != currentVersion) {
-                    throw new KeeperException.BadVersionException();
+                    throw new KeeperException.BadVersionException(path);
                 }
                 version = currentVersion + 1;
                 txn = new SetDataTxn(path, setDataRequest.getData(), version);
@@ -331,17 +331,17 @@
                 SetACLRequest setAclRequest = new SetACLRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         setAclRequest);
-                if (!fixupACL(request.authInfo, setAclRequest.getAcl())) {
-                    throw new KeeperException.InvalidACLException();
-                }
                 path = setAclRequest.getPath();
+                if (!fixupACL(request.authInfo, setAclRequest.getAcl())) {
+                    throw new KeeperException.InvalidACLException(path);
+                }
                 nodeRecord = getRecordForPath(path);
                 checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN,
                         request.authInfo);
                 version = setAclRequest.getVersion();
                 currentVersion = nodeRecord.stat.getAversion();
                 if (version != -1 && version != currentVersion) {
-                    throw new KeeperException.BadVersionException();
+                    throw new KeeperException.BadVersionException(path);
                 }
                 version = currentVersion + 1;
                 txn = new SetACLTxn(path, setAclRequest.getAcl(), version);
@@ -393,7 +393,8 @@
             case OpCode.getChildren2:
             case OpCode.ping:
             case OpCode.setWatches:
-                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+                zks.sessionTracker.checkSession(request.sessionId,
+                        request.getOwner());
                 break;
             }
         } catch (KeeperException e) {
@@ -402,7 +403,9 @@
                 txn = new ErrorTxn(e.code().intValue());
             }
             LOG.info(""Got user-level KeeperException when processing ""
-                    + request.toString() + "" Error:"" + e.getMessage());
+                    + request.toString()
+                    + "" Error Path:"" + e.getPath()
+                    + "" Error:"" + e.getMessage());
             request.setException(e);
         } catch (Exception e) {
             // log at error level as we are returning a marshalling
"
zookeeper,c22c30d7c8c2ace2ad5f6675ccc6331310c0c144,ZOOKEEPER-588. remove unnecessary/annoying log of tostring error in Request.toString(),2009.12.12 05:24:23,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/Request.java b/src/java/main/org/apache/zookeeper/server/Request.java
index f31e0ef..2c59c25 100644
--- a/src/java/main/org/apache/zookeeper/server/Request.java
+++ b/src/java/main/org/apache/zookeeper/server/Request.java
@@ -56,15 +56,15 @@
         this.authInfo = authInfo;
     }
 
-    public long sessionId;
+    public final long sessionId;
 
-    public int cxid;
+    public final int cxid;
 
-    public int type;
+    public final int type;
 
-    public ByteBuffer request;
+    public final ByteBuffer request;
 
-    public ServerCnxn cnxn;
+    public final ServerCnxn cnxn;
 
     public TxnHeader hdr;
 
@@ -72,14 +72,14 @@
 
     public long zxid = -1;
 
-    public List<Id> authInfo;
+    public final List<Id> authInfo;
 
-    public long createTime = System.currentTimeMillis();
+    public final long createTime = System.currentTimeMillis();
     
     private Object owner;
     
     private KeeperException e;
-    
+
     public Object getOwner() {
         return owner;
     }
@@ -183,31 +183,41 @@
     @Override
     public String toString() {
         StringBuffer sb = new StringBuffer();
-        sb.append(""sessionid:0x"").append(Long.toHexString(sessionId));
-        sb.append("" type:"").append(op2String(type));
-        sb.append("" cxid:0x"").append(Long.toHexString(cxid));
-        sb.append("" zxid:0x"").append(Long.toHexString((hdr == null ?
-                -2 : hdr.getZxid())));
-        sb.append("" txntype:"" + (hdr == null ?
-                ""unknown"" : """" + hdr.getType()));
-        sb.append("" "");
+        sb.append(""sessionid:0x"").append(Long.toHexString(sessionId))
+            .append("" type:"").append(op2String(type))
+            .append("" cxid:0x"").append(Long.toHexString(cxid))
+            .append("" zxid:0x"").append(Long.toHexString(hdr == null ?
+                    -2 : hdr.getZxid()))
+            .append("" txntype:"").append(hdr == null ?
+                    ""unknown"" : """" + hdr.getType());
 
+        // best effort to print the path assoc with this request
         String path = ""n/a"";
-        if (type != OpCode.createSession && request != null
+        if (type != OpCode.createSession
+                && type != OpCode.setWatches
+                && type != OpCode.closeSession
+                && request != null
                 && request.remaining() >= 4)
         {
             try {
-                request.clear();
-                int pathLen = request.getInt();
-                byte b[] = new byte[pathLen];
-                request.get(b);
-                path = new String(b);
-                request.clear();
+                // make sure we don't mess with request itself
+                ByteBuffer rbuf = request.asReadOnlyBuffer();
+                rbuf.clear();
+                int pathLen = rbuf.getInt();
+                // sanity check
+                if (pathLen >= 0
+                        && pathLen < 4096
+                        && rbuf.remaining() >= pathLen)
+                {
+                    byte b[] = new byte[pathLen];
+                    rbuf.get(b);
+                    path = new String(b);
+                }
             } catch (Exception e) {
-                LOG.warn(""Ignoring exception during toString"", e);
+                // ignore - can't find the path, will output ""n/a"" instead
             }
         }
-        sb.append(path).append("" "");
+        sb.append("" reqpath:"").append(path);
 
         return sb.toString();
     }
"
zookeeper,6b85723d2db06b94af82b9e10d4c742838b2222e,ZOOKEEPER-615. wrong javadoc for create with a sequence flag,2009.12.12 04:38:47,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 987721b..87ebdfe 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -555,7 +555,8 @@
      * <p>
      * The flags argument can also specify to create a sequential node. The
      * actual path name of a sequential node will be the given path plus a
-     * suffix ""_i"" where i is the current sequential number of the node. Once
+     * suffix ""i"" where i is the current sequential number of the node. The sequence
+     * number is always fixed length of 10 digits, 0 padded. Once
      * such a node is created, the sequential number will be incremented by one.
      * <p>
      * If a node with the same actual path already exists in the ZooKeeper, a
"
zookeeper,9ecca8210ec1b065193984c1ff507ae5505ecbe1,ZOOKEEPER-611. hudson build failure (take 2) (mahadev),2009.12.08 10:20:42,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index b4291dd..45fea82 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -71,22 +71,25 @@
 
     private ConnectionBean jmxConnectionBean;
 
-    static {
-        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
-            public void uncaughtException(Thread t, Throwable e) {
-                LOG.error(""Thread "" + t + "" died"", e);
-            }
-        });
-        /**
-         * this is to avoid the jvm bug:
-         * NullPointerException in Selector.open()
-         * http://bugs.sun.com/view_bug.do?bug_id=6427854
-         */
-        System.setProperty(""sun.nio.ch.bugLevel"", 
-                System.getProperty(""sun.nio.ch.bugLevel"",""""));
-    }
-
     static public class Factory extends Thread {
+        static {
+            Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+                public void uncaughtException(Thread t, Throwable e) {
+                    LOG.error(""Thread "" + t + "" died"", e);
+                }
+            });
+            /**
+             * this is to avoid the jvm bug:
+             * NullPointerException in Selector.open()
+             * http://bugs.sun.com/view_bug.do?bug_id=6427854
+             */
+            try {
+                Selector.open().close();
+            } catch(IOException ie) {
+                LOG.error(""Selector failed to open"", ie);
+            }
+        }
+
         ZooKeeperServer zks;
 
         ServerSocketChannel ss;
"
zookeeper,9722b84b52b08e27a9f3170fc60f66e721128014,ZOOKEEPER-611.  hudson build failiure (mahadev),2009.12.08 07:31:08,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index dc3ba1f..b4291dd 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -77,17 +77,13 @@
                 LOG.error(""Thread "" + t + "" died"", e);
             }
         });
-        
         /**
          * this is to avoid the jvm bug:
          * NullPointerException in Selector.open()
          * http://bugs.sun.com/view_bug.do?bug_id=6427854
          */
-        try {
-        	Selector.open().close();
-        } catch(IOException ie) {
-        	LOG.error(""Exception while opening a selector"", ie);
-        }
+        System.setProperty(""sun.nio.ch.bugLevel"", 
+                System.getProperty(""sun.nio.ch.bugLevel"",""""));
     }
 
     static public class Factory extends Thread {
"
zookeeper,6b9c7c225e6f6d4a763ea8cc4e1ccac7aa265915,ZOOKEEPER-597. ASyncHammerTest is failing intermittently on hudson trunk (take 5) (mahadev),2009.12.05 08:47:30,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 52fab05..dc3ba1f 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -77,6 +77,17 @@
                 LOG.error(""Thread "" + t + "" died"", e);
             }
         });
+        
+        /**
+         * this is to avoid the jvm bug:
+         * NullPointerException in Selector.open()
+         * http://bugs.sun.com/view_bug.do?bug_id=6427854
+         */
+        try {
+        	Selector.open().close();
+        } catch(IOException ie) {
+        	LOG.error(""Exception while opening a selector"", ie);
+        }
     }
 
     static public class Factory extends Thread {
@@ -350,36 +361,40 @@
     }
 
     void sendBuffer(ByteBuffer bb) {
-        if (bb != closeConn) {
-            // We check if write interest here because if it is NOT set,
-            // nothing is queued, so we can try to send the buffer right
-            // away without waking up the selector
-            if ((sk.interestOps() & SelectionKey.OP_WRITE) == 0) {
-                try {
-                    sock.write(bb);
-                } catch (IOException e) {
-                    // we are just doing best effort right now
+        try {
+            if (bb != closeConn) {
+                // We check if write interest here because if it is NOT set,
+                // nothing is queued, so we can try to send the buffer right
+                // away without waking up the selector
+                if ((sk.interestOps() & SelectionKey.OP_WRITE) == 0) {
+                    try {
+                        sock.write(bb);
+                    } catch (IOException e) {
+                        // we are just doing best effort right now
+                    }
+                }
+                // if there is nothing left to send, we are done
+                if (bb.remaining() == 0) {
+                    packetSent();
+                    return;
                 }
             }
-            // if there is nothing left to send, we are done
-            if (bb.remaining() == 0) {
-                packetSent();
-                return;
+            synchronized (factory) {
+                sk.selector().wakeup();
+                if (LOG.isTraceEnabled()) {
+                    LOG.trace(""Add a buffer to outgoingBuffers, sk "" + sk
+                            + "" is valid: "" + sk.isValid());
+                }
+                outgoingBuffers.add(bb);
+                if (sk.isValid()) {
+                    sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);
+                }
             }
-        }
-        synchronized (factory) {
-            sk.selector().wakeup();
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""Add a buffer to outgoingBuffers, sk "" + sk
-                        + "" is valid: "" + sk.isValid());
-            }
-            outgoingBuffers.add(bb);
-            if (sk.isValid()) {
-                sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);
-            }
+        } catch(Exception e) {
+            LOG.error(""Unexpected Exception: "", e);
         }
     }
-
+    
     private static class CloseRequestException extends IOException {
         private static final long serialVersionUID = -7854505709816442681L;
 
"
zookeeper,5ac3e719264a917674ded90490d5554c9a4da76c,ZOOKEEPER-597. ASyncHammerTest is failing intermittently on hudson trunk (take 4) (breed via mahadev),2009.12.04 07:30:44,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index a5a53a4..52fab05 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -71,6 +71,13 @@
 
     private ConnectionBean jmxConnectionBean;
 
+    static {
+        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+            public void uncaughtException(Thread t, Throwable e) {
+                LOG.error(""Thread "" + t + "" died"", e);
+            }
+        });
+    }
 
     static public class Factory extends Thread {
         ZooKeeperServer zks;
@@ -937,8 +944,6 @@
         return ""NIOServerCnxn object with sock = "" + sock + "" and sk = "" + sk;
     }
 
-    boolean closed;
-
     /*
      * (non-Javadoc)
      *
@@ -955,12 +960,6 @@
         }
         jmxConnectionBean = null;
 
-        synchronized(this) {
-            if (closed) {
-                return;
-            }
-            closed = true;
-        }
         synchronized (factory.ipMap)
         {
             Set<NIOServerCnxn> s = factory.ipMap.get(sock.socket().getInetAddress());
@@ -1041,14 +1040,6 @@
      */
     synchronized public void sendResponse(ReplyHeader h, Record r, String tag) {
         try {
-            if (closed) {
-                if (LOG.isTraceEnabled()) {
-                    LOG.trace(""send called on closed session 0x""
-                              + Long.toHexString(sessionId)
-                              + "" with record "" + r);
-                }
-                return;
-            }
             ByteArrayOutputStream baos = new ByteArrayOutputStream();
             // Make space for length
             BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
@@ -1078,7 +1069,7 @@
                 }
             }
          } catch(Exception e) {
-            LOG.error(""Unexpected exception. Destruction averted."", e);
+            LOG.warn(""Unexpected exception. Destruction averted."", e);
          }
     }
 
"
zookeeper,1feeef99596f3db72ef731705deda47debf008bf,ZOOKEEPER-597. ASyncHammerTest is failing intermittently on hudson trunk (take 3) (phunt via mahadev),2009.12.03 11:12:28,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
index 1401f89..d4ca401 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
@@ -142,6 +142,8 @@
             }
         } catch (InterruptedException e) {
             LOG.warn(""Interrupted exception while waiting"", e);
+        } catch (Throwable e) {
+            LOG.error(""Unexpected exception causing CommitProcessor to exit"", e);
         }
         LOG.info(""CommitProcessor exited loop!"");
     }
"
zookeeper,154647fa5d8cbb8e03dcace62707e1ce8f678fd6,ZOOKEEPER-597. ASyncHammerTest is failing intermittently on hudson trunk,2009.12.03 03:36:24,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 022e392..a5a53a4 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -955,10 +955,12 @@
         }
         jmxConnectionBean = null;
 
-        if (closed) {
-            return;
+        synchronized(this) {
+            if (closed) {
+                return;
+            }
+            closed = true;
         }
-        closed = true;
         synchronized (factory.ipMap)
         {
             Set<NIOServerCnxn> s = factory.ipMap.get(sock.socket().getInetAddress());
@@ -1038,42 +1040,46 @@
      *      org.apache.jute.Record, java.lang.String)
      */
     synchronized public void sendResponse(ReplyHeader h, Record r, String tag) {
-        if (closed) {
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""send called on closed session 0x""
-                          + Long.toHexString(sessionId)
-                          + "" with record "" + r);
-            }
-            return;
-        }
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        // Make space for length
-        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
         try {
-            baos.write(fourBytes);
-            bos.writeRecord(h, ""header"");
-            if (r != null) {
-                bos.writeRecord(r, tag);
+            if (closed) {
+                if (LOG.isTraceEnabled()) {
+                    LOG.trace(""send called on closed session 0x""
+                              + Long.toHexString(sessionId)
+                              + "" with record "" + r);
+                }
+                return;
             }
-            baos.close();
-        } catch (IOException e) {
-            LOG.error(""Error serializing response"");
-        }
-        byte b[] = baos.toByteArray();
-        ByteBuffer bb = ByteBuffer.wrap(b);
-        bb.putInt(b.length - 4).rewind();
-        sendBuffer(bb);
-        if (h.getXid() > 0) {
-            synchronized (this.factory) {
-                outstandingRequests--;
-                // check throttling
-                if (zk.getInProcess() < factory.outstandingLimit
-                        || outstandingRequests < 1) {
-                    sk.selector().wakeup();
-                    enableRecv();
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            // Make space for length
+            BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);
+            try {
+                baos.write(fourBytes);
+                bos.writeRecord(h, ""header"");
+                if (r != null) {
+                    bos.writeRecord(r, tag);
+                }
+                baos.close();
+            } catch (IOException e) {
+                LOG.error(""Error serializing response"");
+            }
+            byte b[] = baos.toByteArray();
+            ByteBuffer bb = ByteBuffer.wrap(b);
+            bb.putInt(b.length - 4).rewind();
+            sendBuffer(bb);
+            if (h.getXid() > 0) {
+                synchronized (this.factory) {
+                    outstandingRequests--;
+                    // check throttling
+                    if (zk.getInProcess() < factory.outstandingLimit
+                            || outstandingRequests < 1) {
+                        sk.selector().wakeup();
+                        enableRecv();
+                    }
                 }
             }
-        }
+         } catch(Exception e) {
+            LOG.error(""Unexpected exception. Destruction averted."", e);
+         }
     }
 
     /*
"
zookeeper,8de689292a6664dcfa1c0f0bff087b1d172537cc,ZOOKEEPER-598: LearnerHandler is misspelt in the thread's constructor.,2009.11.30 21:03:36,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index e3baf4b..d6d617c 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -82,7 +82,7 @@
     private BufferedOutputStream bufferedOutput;
 
     LearnerHandler(Socket sock, Leader leader) throws IOException {
-        super(""LeanerHandler-"" + sock.getRemoteSocketAddress());
+        super(""LearnerHandler-"" + sock.getRemoteSocketAddress());
         this.sock = sock;
         this.leader = leader;
         leader.addLearnerHandler(this);
"
zookeeper,a62d0245c91f3ed70f0ee0833e3ec3799a24e377,ZOOKEEPER-582. ZooKeeper can revert to old data when a snapshot is created outside of normal processing (ben reed and mahadev via mahadev),2009.11.21 07:28:38,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index a659146..d056a07 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -64,6 +64,14 @@
             try {
                 connectToLeader(addr);
                 long newLeaderZxid = registerWithLeader(Leader.FOLLOWERINFO);
+                //check to see if the leader zxid is lower than ours
+                //this should never happen but is just a safety check
+                long lastLoggedZxid = self.getLastLoggedZxid();
+                if ((newLeaderZxid >> 32L) < (lastLoggedZxid >> 32L)) {
+                    LOG.fatal(""Leader epoch "" + Long.toHexString(newLeaderZxid >> 32L)
+                            + "" is less than our epoch "" + Long.toHexString(lastLoggedZxid >> 32L));
+                    throw new IOException(""Error: Epoch of leader is lower"");
+                }
                 syncWithLeader(newLeaderZxid);                
                 QuorumPacket qp = new QuorumPacket();
                 while (self.running) {
"
zookeeper,a62d0245c91f3ed70f0ee0833e3ec3799a24e377,ZOOKEEPER-582. ZooKeeper can revert to old data when a snapshot is created outside of normal processing (ben reed and mahadev via mahadev),2009.11.21 07:28:38,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index e49c902..bd6cb0d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -36,6 +36,7 @@
 import org.apache.zookeeper.server.NIOServerCnxn;
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.persistence.Util;
 import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
 import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
 
@@ -431,9 +432,35 @@
                 new NIOServerCnxn.Factory(clientPort), quorumConfig);
     }
     
-    public long getLastLoggedZxid(){
-        return logFactory.getLastLoggedZxid();
+    /**
+     * returns the highest zxid that this host has seen
+     * 
+     * @return the highest zxid for this host
+     */
+    public long getLastLoggedZxid() {
+        /*
+         * it is possible to have the last zxid with just a snapshot and no log
+         * related to it. one example is during upgrade wherein the there is no
+         * corresponding log to the snapshot. in that case just use the snapshot
+         * zxid
+         */
+
+        File lastSnapshot = null;
+        long maxZxid = -1L;
+        long maxLogZxid = logFactory.getLastLoggedZxid();
+        try {
+            lastSnapshot = logFactory.findMostRecentSnapshot();
+            if (lastSnapshot != null) {
+                maxZxid = Math.max(Util.getZxidFromName(lastSnapshot.getName(),
+                        ""snapshot""), maxLogZxid);
+            }
+        } catch (IOException ie) {
+            LOG.warn(""Exception finding last snapshot "", ie);
+            maxZxid = maxLogZxid;
+        }
+        return maxZxid;
     }
+    
     public Follower follower;
     public Leader leader;
     public Observer observer;
"
zookeeper,921710c6f184120e275d68351117fbcd4a209fb3,"ZOOKEEPER-3. syncLimit has slightly different comments in the class header, and > inline with the variable.",2009.11.19 02:47:38,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 5dfb69f..7b5213b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -670,16 +670,14 @@
     }
         
     /**
-     * Get the number of ticks that can pass between sending a request and getting
-     * an acknowledgement
+     * Get the synclimit
      */
     public int getSyncLimit() {
         return syncLimit;
     }
 
     /**
-     * Set the number of ticks that can pass between sending a request and getting
-     * an acknowledgement
+     * Set the synclimit
      */
     public void setSyncLimit(int syncLimit) {
         this.syncLimit = syncLimit;
"
zookeeper,989144a47532f26543291229e026efb11d4b5c48,ZOOKEEPER-519. Followerhandler should close the socket if it gets an exception on a write.,2009.11.19 02:44:56,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
index e08bc60..97cb2aa 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java
@@ -420,6 +420,13 @@
             if (sock != null && !sock.isClosed()) {
                 LOG.error(""Unexpected exception causing shutdown while sock ""
                         + ""still open"", e);
+            	//close the socket to make sure the 
+            	//other side can see it being close
+            	try {
+            		sock.close();
+            	} catch(IOException ie) {
+            		// do nothing
+            	}
             }
         } catch (InterruptedException e) {
             LOG.error(""Unexpected exception causing shutdown"", e);
"
zookeeper,72f258cbdd2b5b59a35df8b45e6da6364cd8c915,ZOOKEEPER-547. Sanity check in QuorumCnxn Manager and quorum communication port.,2009.11.18 08:38:49,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index f2ea2b3..557fd65 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -60,7 +60,7 @@
      */
 
     static final int CAPACITY = 100;
-
+    static final int PACKETMAXSIZE = 1024 * 1024; 
     /*
      * Maximum number of attempts to connect to a peer
      */
@@ -615,11 +615,13 @@
                     }
                     msgLength.position(0);
                     int length = msgLength.getInt();
-
                     /**
                      * Allocates a new ByteBuffer to receive the message
                      */
                     if (length > 0) {
+                        if (length > PACKETMAXSIZE) {
+                            throw new IOException(""Invalid packet of length "" + length);
+                        }
                         byte[] msgArray = new byte[length];
                         ByteBuffer message = ByteBuffer.wrap(msgArray);
                         int numbytes = 0;
"
zookeeper,41bd0e5f7f05694d7a22a72eceafad8907f57cfc,"ZOOKEEPER-567. javadoc for getchildren2 needs to mention ""new in 3.3.0""",2009.11.13 05:02:35,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 74cdcad..987721b 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -1312,6 +1312,8 @@
      * A KeeperException with error code KeeperException.NoNode will be thrown
      * if no node with the given path exists.
      *
+     * @since 3.3.0
+     * 
      * @param path
      * @param watcher explicit watcher
      * @param stat stat of the znode designated by path
@@ -1366,6 +1368,8 @@
      * A KeeperException with error code KeeperException.NoNode will be thrown
      * if no node with the given path exists.
      *
+     * @since 3.3.0
+     * 
      * @param path
      * @param watch
      * @param stat stat of the znode designated by path
@@ -1384,7 +1388,9 @@
      * The Asynchronous version of getChildren. The request doesn't actually
      * until the asynchronous callback is called.
      *
-     * @see #getChildren(String, Watcher)
+     * @since 3.3.0
+     * 
+     * @see #getChildren(String, Watcher, Stat)
      */
     public void getChildren(final String path, Watcher watcher,
             Children2Callback cb, Object ctx)
@@ -1414,7 +1420,9 @@
      * The Asynchronous version of getChildren. The request doesn't actually
      * until the asynchronous callback is called.
      *
-     * @see #getChildren(String, boolean)
+     * @since 3.3.0
+     * 
+     * @see #getChildren(String, boolean, Stat)
      */
     public void getChildren(String path, boolean watch, Children2Callback cb,
             Object ctx)
"
zookeeper,47c4bdb0c3c40d756ec0ced91a39c771351e826a,"ZOOKEEPER-566. ""reqs"" four letter word (command port) returns no information",2009.11.13 04:53:07,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/ConnectionBean.java b/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
index 74cf47e..6c6f4ad 100644
--- a/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
+++ b/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
@@ -29,20 +29,23 @@
 import org.apache.log4j.Logger;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
+import org.apache.zookeeper.server.NIOServerCnxn.CnxnStats;
 
 /**
  * Implementation of connection MBean interface.
  */
 public class ConnectionBean implements ConnectionMXBean, ZKMBeanInfo {
     private static final Logger LOG = Logger.getLogger(ConnectionBean.class);
-    private ServerCnxn connection;
-    private ZooKeeperServer zk;
-    private Date timeCreated;
-    
+
+    private final ServerCnxn connection;
+    private final CnxnStats stats;
+
+    private final ZooKeeperServer zk;
+
     public ConnectionBean(ServerCnxn connection,ZooKeeperServer zk){
-        this.connection=connection;
-        this.zk=zk;
-        timeCreated=new Date();
+        this.connection = connection;
+        this.stats = (CnxnStats)connection.getStats();
+        this.zk = zk;
     }
     
     public String getSessionId() {
@@ -80,7 +83,7 @@
     }
     
     public String getStartedTime() {
-        return timeCreated.toString();
+        return stats.getEstablished().toString();
     }
     
     public void terminateSession() {
@@ -96,6 +99,10 @@
         connection.sendCloseSession();
     }
 
+    public void resetCounters() {
+        stats.reset();
+    }
+
     @Override
     public String toString() {
         return ""ConnectionBean{ClientIP="" + ObjectName.quote(getSourceIP())
@@ -103,19 +110,50 @@
     }
     
     public long getOutstandingRequests() {
-        return connection.getStats().getOutstandingRequests();
+        return stats.getOutstandingRequests();
     }
     
     public long getPacketsReceived() {
-        return connection.getStats().getPacketsReceived();
+        return stats.getPacketsReceived();
     }
     
     public long getPacketsSent() {
-        return connection.getStats().getPacketsSent();
+        return stats.getPacketsSent();
     }
     
     public int getSessionTimeout() {
         return connection.getSessionTimeout();
     }
 
+    public long getMinLatency() {
+        return stats.getMinLatency();
+    }
+
+    public long getAvgLatency() {
+        return stats.getAvgLatency();
+    }
+
+    public long getMaxLatency() {
+        return stats.getMaxLatency();
+    }
+    
+    public String getLastOperation() {
+        return stats.getLastOperation();
+    }
+
+    public String getLastCxid() {
+        return ""0x"" + Long.toHexString(stats.getLastCxid());
+    }
+
+    public String getLastZxid() {
+        return ""0x"" + Long.toHexString(stats.getLastZxid());
+    }
+
+    public String getLastResponseTime() {
+        return new Date(stats.getLastResponseTime()).toString();
+    }
+
+    public long getLastLatency() {
+        return stats.getLastLatency();
+    }
 }
"
zookeeper,47c4bdb0c3c40d756ec0ced91a39c771351e826a,"ZOOKEEPER-566. ""reqs"" four letter word (command port) returns no information",2009.11.13 04:53:07,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/ConnectionMXBean.java b/src/java/main/org/apache/zookeeper/server/ConnectionMXBean.java
index 2067640..8bdec9a 100644
--- a/src/java/main/org/apache/zookeeper/server/ConnectionMXBean.java
+++ b/src/java/main/org/apache/zookeeper/server/ConnectionMXBean.java
@@ -65,4 +65,34 @@
      * reconnect with the same session id.
      */
     public void terminateConnection();
+
+
+    /** Min latency in ms
+     * @since 3.3.0 */
+    long getMinLatency();
+    /** Average latency in ms
+     * @since 3.3.0 */
+    long getAvgLatency();
+    /** Max latency in ms
+     * @since 3.3.0 */
+    long getMaxLatency();
+    /** Last operation performed by this connection
+     * @since 3.3.0 */
+    String getLastOperation();
+    /** Last cxid of this connection
+     * @since 3.3.0 */
+    String getLastCxid();
+    /** Last zxid of this connection
+     * @since 3.3.0 */
+    String getLastZxid();
+    /** Last time server sent a response to client on this connection
+     * @since 3.3.0 */
+    String getLastResponseTime();
+    /** Latency of last response to client on this connection in ms
+     * @since 3.3.0 */
+    long getLastLatency();
+
+    /** Reset counters
+     * @since 3.3.0 */
+    void resetCounters();
 }
"
zookeeper,47c4bdb0c3c40d756ec0ced91a39c771351e826a,"ZOOKEEPER-566. ""reqs"" four letter word (command port) returns no information",2009.11.13 04:53:07,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index dbdc6ba..e974d54 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -35,10 +35,10 @@
 import org.apache.zookeeper.proto.ExistsResponse;
 import org.apache.zookeeper.proto.GetACLRequest;
 import org.apache.zookeeper.proto.GetACLResponse;
-import org.apache.zookeeper.proto.GetChildrenRequest;
-import org.apache.zookeeper.proto.GetChildrenResponse;
 import org.apache.zookeeper.proto.GetChildren2Request;
 import org.apache.zookeeper.proto.GetChildren2Response;
+import org.apache.zookeeper.proto.GetChildrenRequest;
+import org.apache.zookeeper.proto.GetChildrenResponse;
 import org.apache.zookeeper.proto.GetDataRequest;
 import org.apache.zookeeper.proto.GetDataResponse;
 import org.apache.zookeeper.proto.ReplyHeader;
@@ -48,6 +48,7 @@
 import org.apache.zookeeper.proto.SyncRequest;
 import org.apache.zookeeper.proto.SyncResponse;
 import org.apache.zookeeper.server.DataTree.ProcessTxnResult;
+import org.apache.zookeeper.server.NIOServerCnxn.CnxnStats;
 import org.apache.zookeeper.server.NIOServerCnxn.Factory;
 import org.apache.zookeeper.server.ZooKeeperServer.ChangeRecord;
 import org.apache.zookeeper.txn.CreateSessionTxn;
@@ -136,6 +137,9 @@
         if (request.cnxn == null) {
             return;
         }
+        ServerCnxn cnxn = request.cnxn;
+
+        String lastOp = ""NA"";
         zks.decInProcess();
         Code err = Code.OK;
         Record rsp = null;
@@ -145,7 +149,7 @@
                 throw KeeperException.create(KeeperException.Code.get((
                         (ErrorTxn) request.txn).getErr()));
             }
-            
+
             KeeperException ke = request.getException();
             if (ke != null) {
                 throw ke;
@@ -156,39 +160,59 @@
             }
             switch (request.type) {
             case OpCode.ping: {
-                request.cnxn.sendResponse(new ReplyHeader(-2,
+                zks.serverStats().updateLatency(request.createTime);
+
+                lastOp = ""PING"";
+                ((CnxnStats)cnxn.getStats())
+                .updateForResponse(request.cxid, request.zxid, lastOp,
+                        request.createTime, System.currentTimeMillis());
+
+                cnxn.sendResponse(new ReplyHeader(-2,
                         zks.dataTree.lastProcessedZxid, 0), null, ""response"");
                 return;
             }
             case OpCode.createSession: {
-                request.cnxn.finishSessionInit(true);
+                zks.serverStats().updateLatency(request.createTime);
+
+                lastOp = ""SESS"";
+                ((CnxnStats)cnxn.getStats())
+                .updateForResponse(request.cxid, request.zxid, lastOp,
+                        request.createTime, System.currentTimeMillis());
+
+                cnxn.finishSessionInit(true);
                 return;
             }
             case OpCode.create: {
+                lastOp = ""CREA"";
                 rsp = new CreateResponse(rc.path);
                 err = Code.get(rc.err);
                 break;
             }
             case OpCode.delete: {
+                lastOp = ""DELE"";
                 err = Code.get(rc.err);
                 break;
             }
             case OpCode.setData: {
+                lastOp = ""SETD"";
                 rsp = new SetDataResponse(rc.stat);
                 err = Code.get(rc.err);
                 break;
             }
             case OpCode.setACL: {
+                lastOp = ""SETD"";
                 rsp = new SetACLResponse(rc.stat);
                 err = Code.get(rc.err);
                 break;
             }
             case OpCode.closeSession: {
+                lastOp = ""CLOS"";
                 closeSession = true;
                 err = Code.get(rc.err);
                 break;
             }
             case OpCode.sync: {
+                lastOp = ""SYNC"";
                 SyncRequest syncRequest = new SyncRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         syncRequest);
@@ -196,6 +220,7 @@
                 break;
             }
             case OpCode.exists: {
+                lastOp = ""EXIS"";
                 // TODO we need to figure out the security requirement for this!
                 ExistsRequest existsRequest = new ExistsRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
@@ -205,11 +230,12 @@
                     throw new KeeperException.BadArgumentsException();
                 }
                 Stat stat = zks.dataTree.statNode(path, existsRequest
-                        .getWatch() ? request.cnxn : null);
+                        .getWatch() ? cnxn : null);
                 rsp = new ExistsResponse(stat);
                 break;
             }
             case OpCode.getData: {
+                lastOp = ""GETD"";
                 GetDataRequest getDataRequest = new GetDataRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         getDataRequest);
@@ -226,11 +252,12 @@
                         request.authInfo);
                 Stat stat = new Stat();
                 byte b[] = zks.dataTree.getData(getDataRequest.getPath(), stat,
-                        getDataRequest.getWatch() ? request.cnxn : null);
+                        getDataRequest.getWatch() ? cnxn : null);
                 rsp = new GetDataResponse(b, stat);
                 break;
             }
             case OpCode.setWatches: {
+                lastOp = ""SETW"";
                 SetWatches setWatches = new SetWatches();
                 // XXX We really should NOT need this!!!!
                 request.request.rewind();
@@ -239,10 +266,11 @@
                 zks.dataTree.setWatches(relativeZxid, 
                         setWatches.getDataWatches(), 
                         setWatches.getExistWatches(),
-                        setWatches.getChildWatches(), request.cnxn);
+                        setWatches.getChildWatches(), cnxn);
                 break;
             }
             case OpCode.getACL: {
+                lastOp = ""GETA"";
                 GetACLRequest getACLRequest = new GetACLRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         getACLRequest);
@@ -253,6 +281,7 @@
                 break;
             }
             case OpCode.getChildren: {
+                lastOp = ""GETC"";
                 GetChildrenRequest getChildrenRequest = new GetChildrenRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         getChildrenRequest);
@@ -269,11 +298,12 @@
                         request.authInfo);
                 List<String> children = zks.dataTree.getChildren(
                         getChildrenRequest.getPath(), null, getChildrenRequest
-                                .getWatch() ? request.cnxn : null);
+                                .getWatch() ? cnxn : null);
                 rsp = new GetChildrenResponse(children);
                 break;
             }
             case OpCode.getChildren2: {
+                lastOp = ""GETC"";
                 GetChildren2Request getChildren2Request = new GetChildren2Request();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         getChildren2Request);
@@ -291,7 +321,7 @@
                         request.authInfo);
                 List<String> children = zks.dataTree.getChildren(
                         getChildren2Request.getPath(), stat, getChildren2Request
-                                .getWatch() ? request.cnxn : null);
+                                .getWatch() ? cnxn : null);
                 rsp = new GetChildren2Response(children, stat);
                 break;
             }
@@ -311,13 +341,19 @@
             LOG.error(""Dumping request buffer: 0x"" + sb.toString());
             err = Code.MARSHALLINGERROR;
         }
+
         ReplyHeader hdr =
             new ReplyHeader(request.cxid, request.zxid, err.intValue());
+
         zks.serverStats().updateLatency(request.createTime);
+        ((CnxnStats)cnxn.getStats())
+            .updateForResponse(request.cxid, request.zxid, lastOp,
+                    request.createTime, System.currentTimeMillis());
+
         try {
-            request.cnxn.sendResponse(hdr, rsp, ""response"");
+            cnxn.sendResponse(hdr, rsp, ""response"");
             if (closeSession) {
-                request.cnxn.sendCloseSession();
+                cnxn.sendCloseSession();
             }
         } catch (IOException e) {
             LOG.error(""FIXMSG"",e);
"
zookeeper,47c4bdb0c3c40d756ec0ced91a39c771351e826a,"ZOOKEEPER-566. ""reqs"" four letter word (command port) returns no information",2009.11.13 04:53:07,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index f6ab7f7..022e392 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -32,13 +32,14 @@
 import java.nio.channels.SocketChannel;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.BinaryOutputArchive;
@@ -334,8 +335,6 @@
 
     ArrayList<Id> authInfo = new ArrayList<Id>();
 
-    LinkedList<Request> outstanding = new LinkedList<Request>();
-
     /* Send close connection packet to the client, doIO will eventually
      * close the underlying machinery (like socket, selectorkey, etc...)
      */
@@ -388,7 +387,7 @@
         public EndOfStreamException(String msg) {
             super(msg);
         }
-        
+
         public String toString() {
             return ""EndOfStreamException: "" + getMessage();
         }
@@ -418,7 +417,7 @@
             incomingBuffer = lenBuffer;
         }
     }
-    
+
     void doIO(SelectionKey k) throws InterruptedException {
         try {
             if (sock == null) {
@@ -701,14 +700,14 @@
     }
 
     private void packetReceived() {
-        stats.packetsReceived++;
+        stats.incrPacketsReceived();
         if (zk != null) {
             zk.serverStats().incrementPacketsReceived();
         }
     }
 
     private void packetSent() {
-        stats.packetsSent++;
+        stats.incrPacketsSent();
         if (zk != null) {
             zk.serverStats().incrementPacketsSent();
         }
@@ -779,38 +778,25 @@
             }
             k.interestOps(SelectionKey.OP_WRITE);
             return true;
-        } else if (len == reqsCmd) {
-            LOG.info(""Processing reqs command from ""
+        } else if (len == statCmd || len == srvrCmd) {
+            LOG.info(""Processing "" + (len == statCmd ? ""stat"" : ""srvr"") 
+                    + "" command from ""
                     + sock.socket().getRemoteSocketAddress());
             packetReceived();
 
             StringBuffer sb = new StringBuffer();
-            sb.append(""Requests:\n"");
-            synchronized (outstanding) {
-                for (Request r : outstanding) {
-                    sb.append(r.toString());
-                    sb.append('\n');
-                }
-            }
-            sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
-            k.interestOps(SelectionKey.OP_WRITE);
-            return true;
-        } else if (len == statCmd) {
-            LOG.info(""Processing stat command from ""
-                    + sock.socket().getRemoteSocketAddress());
-            packetReceived();
-
-            StringBuffer sb = new StringBuffer();
-            if(zk != null){
+            if (zk != null){
                 sb.append(""Zookeeper version: "").append(Version.getFullVersion())
                     .append(""\n"");
-                sb.append(""Clients:\n"");
-                synchronized(factory.cnxns){
-                    for(NIOServerCnxn c : factory.cnxns){
-                        sb.append(c.getStats().toString());
+                if (len == statCmd) {
+                    sb.append(""Clients:\n"");
+                    synchronized(factory.cnxns){
+                        for(NIOServerCnxn c : factory.cnxns){
+                            sb.append(((CnxnStats)c.getStats()).toString(true));
+                        }
                     }
+                    sb.append(""\n"");
                 }
-                sb.append(""\n"");
                 sb.append(zk.serverStats().toString());
                 sb.append(""Node count: "").append(zk.dataTree.getNodeCount()).
                     append(""\n"");
@@ -821,6 +807,26 @@
             sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
             k.interestOps(SelectionKey.OP_WRITE);
             return true;
+        } else if (len == consCmd) {
+            LOG.info(""Processing cons command from ""
+                    + sock.socket().getRemoteSocketAddress());
+            packetReceived();
+
+            StringBuffer sb = new StringBuffer();
+            if (zk != null){
+                synchronized(factory.cnxns){
+                    for(NIOServerCnxn c : factory.cnxns){
+                        sb.append(((CnxnStats)c.getStats()).toString(false));
+                    }
+                }
+                sb.append(""\n"");
+            } else {
+                sb.append(""ZooKeeperServer not running\n"");
+            }
+
+            sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
+            k.interestOps(SelectionKey.OP_WRITE);
+            return true;
         } else if (len == enviCmd) {
             LOG.info(""Processing envi command from ""
                     + sock.socket().getRemoteSocketAddress());
@@ -846,7 +852,21 @@
 
             zk.serverStats().reset();
 
-            sendBuffer(ByteBuffer.wrap(""Stats reset.\n"".getBytes()));
+            sendBuffer(ByteBuffer.wrap(""Server stats reset.\n"".getBytes()));
+            k.interestOps(SelectionKey.OP_WRITE);
+            return true;
+        } else if (len == crstCmd) {
+            LOG.info(""Processing crst command from ""
+                    + sock.socket().getRemoteSocketAddress());
+            packetReceived();
+
+            synchronized(factory.cnxns){
+                for(NIOServerCnxn c : factory.cnxns){
+                    c.getStats().reset();
+                }
+            }
+
+            sendBuffer(ByteBuffer.wrap(""Connection stats reset.\n"".getBytes()));
             k.interestOps(SelectionKey.OP_WRITE);
             return true;
         }
@@ -1146,13 +1166,77 @@
         return (InetSocketAddress) sock.socket().getRemoteSocketAddress();
     }
 
-    private class CnxnStats implements ServerCnxn.Stats{
-        long packetsReceived;
-        long packetsSent;
+    class CnxnStats implements ServerCnxn.Stats {
+        private final Date established = new Date();
 
-        /**
-         * The number of requests that have been submitted but not yet responded to.
-         */
+        private final AtomicLong packetsReceived = new AtomicLong();
+        private final AtomicLong packetsSent = new AtomicLong();
+
+        private long minLatency;
+        private long maxLatency;
+        private String lastOp;
+        private long lastCxid;
+        private long lastZxid;
+        private long lastResponseTime;
+        private long lastLatency;
+
+        private long count;
+        private long totalLatency;
+
+        CnxnStats() {
+            reset();
+        }
+
+        public synchronized void reset() {
+            packetsReceived.set(0);
+            packetsSent.set(0);
+            minLatency = Long.MAX_VALUE;
+            maxLatency = 0;
+            lastOp = ""NA"";
+            lastCxid = -1;
+            lastZxid = -1;
+            lastResponseTime = 0;
+            lastLatency = 0;
+
+            count = 0;
+            totalLatency = 0;
+        }
+
+        long incrPacketsReceived() {
+            return packetsReceived.incrementAndGet();
+        }
+
+        long incrPacketsSent() {
+            return packetsSent.incrementAndGet();
+        }
+
+        synchronized void updateForResponse(long cxid, long zxid, String op,
+                long start, long end)
+        {
+            // don't overwrite with ""special"" xids - we're interested
+            // in the clients last real operation
+            if (cxid >= 0) {
+                lastCxid = cxid;
+            }
+            lastZxid = zxid;
+            lastOp = op;
+            lastResponseTime = end;
+            long elapsed = end - start;
+            lastLatency = elapsed;
+            if (elapsed < minLatency) {
+                minLatency = elapsed;
+            }
+            if (elapsed > maxLatency) {
+                maxLatency = elapsed;
+            }
+            count++;
+            totalLatency += elapsed;
+        }
+
+        public Date getEstablished() {
+            return established;
+        }
+
         public long getOutstandingRequests() {
             synchronized (NIOServerCnxn.this) {
                 synchronized (NIOServerCnxn.this.factory) {
@@ -1162,16 +1246,61 @@
         }
 
         public long getPacketsReceived() {
-            return packetsReceived;
+            return packetsReceived.longValue();
         }
 
         public long getPacketsSent() {
-            return packetsSent;
+            return packetsSent.longValue();
         }
 
+        public synchronized long getMinLatency() {
+            return minLatency == Long.MAX_VALUE ? 0 : minLatency;
+        }
+
+        public synchronized long getAvgLatency() {
+            return count == 0 ? 0 : totalLatency / count;
+        }
+
+        public synchronized long getMaxLatency() {
+            return maxLatency;
+        }
+
+        public synchronized String getLastOperation() {
+            return lastOp;
+        }
+
+        public synchronized long getLastCxid() {
+            return lastCxid;
+        }
+
+        public synchronized long getLastZxid() {
+            return lastZxid;
+        }
+
+        public synchronized long getLastResponseTime() {
+            return lastResponseTime;
+        }
+
+        public synchronized long getLastLatency() {
+            return lastLatency;
+        }
+
+        /** Prints brief stats information for the connection.
+         * 
+         * @see toString(boolean) for detailed stats
+         */
         @Override
-        public String toString(){
-            StringBuilder sb=new StringBuilder();
+        public String toString() {
+            return toString(false);
+        }
+
+        /**
+         * Print information about the connection.
+         * @param brief iff true prints brief details, otw full detail
+         * @return information about this connection
+         */
+        public String toString(boolean brief) {
+            StringBuilder sb = new StringBuilder();
             Channel channel = sk.channel();
             if (channel instanceof SocketChannel) {
                 sb.append("" "").append(((SocketChannel)channel).socket()
@@ -1179,15 +1308,37 @@
                   .append(""["").append(Integer.toHexString(sk.interestOps()))
                   .append(""](queued="").append(getOutstandingRequests())
                   .append("",recved="").append(getPacketsReceived())
-                  .append("",sent="").append(getPacketsSent()).append("")\n"");
+                  .append("",sent="").append(getPacketsSent());
+
+                if (!brief) {
+                    long sessionId = getSessionId();
+                    if (sessionId != 0) {
+                        sb.append("",sid=0x"").append(Long.toHexString(sessionId))
+                            .append("",lop="").append(getLastOperation())
+                            .append("",est="").append(getEstablished().getTime())
+                            .append("",to="").append(getSessionTimeout());
+                        long lastCxid = getLastCxid();
+                        if (lastCxid >= 0) {
+                            sb.append("",lcxid=0x"")
+                                .append(Long.toHexString(lastCxid));
+                        }
+                        sb.append("",lzxid=0x"")
+                                .append(Long.toHexString(getLastZxid()))
+                            .append("",lresp="").append(getLastResponseTime())
+                            .append("",llat="").append(getLastLatency())
+                            .append("",minlat="").append(getMinLatency())
+                            .append("",avglat="").append(getAvgLatency())
+                            .append("",maxlat="").append(getMaxLatency());
+                    }
+                }
+                sb.append("")\n"");
             }
             return sb.toString();
         }
     }
 
-    private CnxnStats stats=new CnxnStats();
+    private final CnxnStats stats = new CnxnStats();
     public Stats getStats() {
         return stats;
     }
-
 }
"
zookeeper,47c4bdb0c3c40d756ec0ced91a39c771351e826a,"ZOOKEEPER-566. ""reqs"" four letter word (command port) returns no information",2009.11.13 04:53:07,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
index d0da9d0..4f619e8 100644
--- a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
@@ -22,6 +22,7 @@
 import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Date;
 
 import org.apache.jute.Record;
 import org.apache.zookeeper.WatchedEvent;
@@ -29,8 +30,11 @@
 import org.apache.zookeeper.data.Id;
 import org.apache.zookeeper.proto.ReplyHeader;
 
+/**
+ * Interface to a Server connection - represents a connection from a client
+ * to the server.
+ */
 public interface ServerCnxn extends Watcher {
-    
     /**
      * See <a href=""{@docRoot}/../../../docs/zookeeperAdmin.html#sc_zkCommands"">
      * Zk Admin</a>. this link is for all the commands.
@@ -38,21 +42,25 @@
     final static int ruokCmd = ByteBuffer.wrap(""ruok"".getBytes()).getInt();
 
     final static int dumpCmd = ByteBuffer.wrap(""dump"".getBytes()).getInt();
-    
+
     final static int statCmd = ByteBuffer.wrap(""stat"".getBytes()).getInt();
-    
-    final static int reqsCmd = ByteBuffer.wrap(""reqs"".getBytes()).getInt();
+
+    final static int srvrCmd = ByteBuffer.wrap(""srvr"".getBytes()).getInt();
+
+    final static int consCmd = ByteBuffer.wrap(""cons"".getBytes()).getInt();
 
     final static int setTraceMaskCmd = ByteBuffer.wrap(""stmk"".getBytes())
             .getInt();
-    
+
     final static int getTraceMaskCmd = ByteBuffer.wrap(""gtmk"".getBytes())
             .getInt();
-    
+
     final static int enviCmd = ByteBuffer.wrap(""envi"".getBytes()).getInt();
-    
+
     final static int srstCmd = ByteBuffer.wrap(""srst"".getBytes()).getInt();
-    
+
+    final static int crstCmd = ByteBuffer.wrap(""crst"".getBytes()).getInt();
+
     final static ByteBuffer imok = ByteBuffer.wrap(""imok"".getBytes());
 
     // This is just an arbitrary object to represent requests issued by
@@ -64,8 +72,8 @@
     void sendResponse(ReplyHeader h, Record r, String tag) throws IOException;
 
     /* notify the client the session is closing and close/cleanup socket */
-    void sendCloseSession(); 
-    
+    void sendCloseSession();
+
     void finishSessionInit(boolean valid);
 
     void process(WatchedEvent event);
@@ -77,12 +85,53 @@
     ArrayList<Id> getAuthInfo();
 
     InetSocketAddress getRemoteAddress();
-    
+
+    /**
+     * Statistics on the ServerCnxn
+     */
     interface Stats {
-        public long getOutstandingRequests();
-        public long getPacketsReceived();
-        public long getPacketsSent();
+        /** Date/time the connection was established
+         * @since 3.3.0 */
+        Date getEstablished();
+
+        /**
+         * The number of requests that have been submitted but not yet
+         * responded to.
+         */
+        long getOutstandingRequests();
+        /** Number of packets received */
+        long getPacketsReceived();
+        /** Number of packets sent (incl notifications) */
+        long getPacketsSent();
+        /** Min latency in ms
+         * @since 3.3.0 */
+        long getMinLatency();
+        /** Average latency in ms
+         * @since 3.3.0 */
+        long getAvgLatency();
+        /** Max latency in ms
+         * @since 3.3.0 */
+        long getMaxLatency();
+        /** Last operation performed by this connection
+         * @since 3.3.0 */
+        String getLastOperation();
+        /** Last cxid of this connection
+         * @since 3.3.0 */
+        long getLastCxid();
+        /** Last zxid of this connection
+         * @since 3.3.0 */
+        long getLastZxid();
+        /** Last time server sent a response to client on this connection
+         * @since 3.3.0 */
+        long getLastResponseTime();
+        /** Latency of last response to client on this connection in ms
+         * @since 3.3.0 */
+        long getLastLatency();
+
+        /** Reset counters
+         * @since 3.3.0 */
+        void reset();
     }
-    
+
     Stats getStats();
 }
"
zookeeper,47c4bdb0c3c40d756ec0ced91a39c771351e826a,"ZOOKEEPER-566. ""reqs"" four letter word (command port) returns no information",2009.11.13 04:53:07,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
index 46e191a..89628a2 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
@@ -105,15 +105,16 @@
 
     @Override
     synchronized public String toString() {
-        StringBuffer sb = new StringBuffer(""Session Sets (""
-                + sessionSets.size() + ""):\n"");
+        StringBuffer sb = new StringBuffer(""Session Sets ("")
+                .append(sessionSets.size()).append(""):\n"");
         ArrayList<Long> keys = new ArrayList<Long>(sessionSets.keySet());
         Collections.sort(keys);
         for (long time : keys) {
-            sb.append(sessionSets.get(time).sessions.size() + "" expire at ""
-                    + new Date(time) + "":\n"");
+            sb.append(sessionSets.get(time).sessions.size())
+                .append("" expire at "").append(new Date(time)).append("":\n"");
             for (SessionImpl s : sessionSets.get(time).sessions) {
-                sb.append(""\t"" + s.sessionId + ""\n"");
+                sb.append(""\t0x"").append(Long.toHexString(s.sessionId))
+                    .append(""\n"");
             }
         }
         return sb.toString();
"
zookeeper,b1b3bd11865ddd74b0977e977aedabdaf5603a1e,ZOOKEEPER-551. unnecessary SetWatches message on new session (phunt via flavio),2009.11.09 06:41:13,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 4c75e1b..581db8c 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -851,7 +851,12 @@
             bb.rewind();
             synchronized (outgoingQueue) {
                 // We add backwards since we are pushing into the front
-                if (!disableAutoWatchReset) {
+                // Only send if there's a pending watch
+                if (!disableAutoWatchReset &&
+                        (!zooKeeper.getDataWatches().isEmpty()
+                         || !zooKeeper.getExistWatches().isEmpty()
+                         || !zooKeeper.getChildWatches().isEmpty()))
+                {
                     SetWatches sw = new SetWatches(lastZxid,
                             zooKeeper.getDataWatches(),
                             zooKeeper.getExistWatches(),
"
zookeeper,2a23a2599b31dcbc971ddd68b05a13b9570247cc,ZOOKEEPER-568. SyncRequestProcessor snapping too frequently - counts non-log events as log events,2009.11.07 16:16:30,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index 0ecbdf9..3c06ad3 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -34,42 +34,44 @@
  */
 public class SyncRequestProcessor extends Thread implements RequestProcessor {
     private static final Logger LOG = Logger.getLogger(SyncRequestProcessor.class);
-    private ZooKeeperServer zks;
-    private LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
-    private RequestProcessor nextProcessor;
-    Thread snapInProcess = null;
-    
+    private final ZooKeeperServer zks;
+    private final LinkedBlockingQueue<Request> queuedRequests =
+        new LinkedBlockingQueue<Request>();
+    private final RequestProcessor nextProcessor;
+
+    private Thread snapInProcess = null;
+
     /**
      * Transactions that have been written and are waiting to be flushed to
      * disk. Basically this is the list of SyncItems whose callbacks will be
      * invoked after flush returns successfully.
      */
-    private LinkedList<Request> toFlush = new LinkedList<Request>();
-    private Random r = new Random(System.nanoTime());
-    private int logCount = 0;
+    private final LinkedList<Request> toFlush = new LinkedList<Request>();
+    private final Random r = new Random(System.nanoTime());
     /**
      * The number of log entries to log before starting a snapshot
      */
     private static int snapCount = ZooKeeperServer.getSnapCount();
 
-    private Request requestOfDeath = Request.requestOfDeath;
+    private final Request requestOfDeath = Request.requestOfDeath;
 
     public SyncRequestProcessor(ZooKeeperServer zks,
-            RequestProcessor nextProcessor) {
+            RequestProcessor nextProcessor)
+    {
         super(""SyncThread:"" + zks.getServerId());
         this.zks = zks;
         this.nextProcessor = nextProcessor;
     }
-    
+
     /**
-     * used by tests to check for changing 
+     * used by tests to check for changing
      * snapcounts
      * @param count
      */
     public static void setSnapCount(int count) {
         snapCount = count;
     }
-    
+
     /**
      * used by tests to get the snapcount
      * @return the snapcount
@@ -77,10 +79,14 @@
     public static int getSnapCount() {
         return snapCount;
     }
-    
+
     @Override
     public void run() {
         try {
+            int logCount = 0;
+
+            // we do this in an attempt to ensure that not all of the servers
+            // in the ensemble take a snapshot at the same time
             int randRoll = r.nextInt(snapCount/2);
             while (true) {
                 Request si = null;
@@ -97,7 +103,8 @@
                     break;
                 }
                 if (si != null) {
-                    zks.getLogWriter().append(si);
+                    // track the number of records written to the log
+                    if (zks.getLogWriter().append(si)) {
                         logCount++;
                         if (logCount > (snapCount / 2 + randRoll)) {
                             randRoll = r.nextInt(snapCount/2);
@@ -106,21 +113,31 @@
                             // take a snapshot
                             if (snapInProcess != null && snapInProcess.isAlive()) {
                                 LOG.warn(""Too busy to snap, skipping"");
-                            }
-                            else {
+                            } else {
                                 snapInProcess = new Thread(""Snapshot Thread"") {
-                                    public void run() {
-                                     try {
-                                         zks.takeSnapshot();
-                                     } catch(Exception e) {
-                                         LOG.warn(""Unexpected exception"", e);
-                                     }
-                                    }
-                                };
+                                        public void run() {
+                                            try {
+                                                zks.takeSnapshot();
+                                            } catch(Exception e) {
+                                                LOG.warn(""Unexpected exception"", e);
+                                            }
+                                        }
+                                    };
                                 snapInProcess.start();
                             }
                             logCount = 0;
                         }
+                    } else if (toFlush.isEmpty()) {
+                        // optimization for read heavy workloads
+                        // iff this is a read, and there are no pending
+                        // flushes (writes), then just pass this to the next
+                        // processor
+                        nextProcessor.processRequest(si);
+                        if (nextProcessor instanceof Flushable) {
+                            ((Flushable)nextProcessor).flush();
+                        }
+                        continue;
+                    }
                     toFlush.add(si);
                     if (toFlush.size() > 1000) {
                         flush(toFlush);
@@ -135,11 +152,11 @@
     }
 
     private void flush(LinkedList<Request> toFlush) throws IOException {
-        if (toFlush.size() == 0)
+        if (toFlush.isEmpty())
             return;
 
         zks.getLogWriter().commit();
-        while (toFlush.size() > 0) {
+        while (!toFlush.isEmpty()) {
             Request i = toFlush.remove();
             nextProcessor.processRequest(i);
         }
"
zookeeper,2a23a2599b31dcbc971ddd68b05a13b9570247cc,ZOOKEEPER-568. SyncRequestProcessor snapping too frequently - counts non-log events as log events,2009.11.07 16:16:30,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 76340b4..d842234 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -131,9 +131,11 @@
      * append an entry to the transaction log
      * @param hdr the header of the transaction
      * @param txn the transaction part of the entry
+     * returns true iff something appended, otw false 
      */
-    public synchronized void append(TxnHeader hdr, Record txn)
-        throws IOException {
+    public synchronized boolean append(TxnHeader hdr, Record txn)
+        throws IOException
+    {
         if (hdr != null) {
             if (hdr.getZxid() <= lastZxidSeen) {
                 LOG.warn(""Current zxid "" + hdr.getZxid()
@@ -161,7 +163,10 @@
             crc.update(buf, 0, buf.length);
             oa.writeLong(crc.getValue(), ""txnEntryCRC"");
             Util.writeTxnBytes(oa, buf);
+            
+            return true;
         }
+        return false;
     }
 
     /**
"
zookeeper,2a23a2599b31dcbc971ddd68b05a13b9570247cc,ZOOKEEPER-568. SyncRequestProcessor snapping too frequently - counts non-log events as log events,2009.11.07 16:16:30,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index 648b6a4..5851af2 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -262,10 +262,11 @@
     /**
      * append the request to the transaction logs
      * @param si the request to be appended
+     * returns true iff something appended, otw false 
      * @throws IOException
      */
-    public void append(Request si) throws IOException {
-        txnLog.append(si.hdr, si.txn);
+    public boolean append(Request si) throws IOException {
+        return txnLog.append(si.hdr, si.txn);
     }
 
     /**
"
zookeeper,2a23a2599b31dcbc971ddd68b05a13b9570247cc,ZOOKEEPER-568. SyncRequestProcessor snapping too frequently - counts non-log events as log events,2009.11.07 16:16:30,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/TxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/TxnLog.java
index 1980da1..c2c60f0 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/TxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/TxnLog.java
@@ -39,9 +39,10 @@
      * Append a request to the transaction log
      * @param hdr the transaction header
      * @param r the transaction itself
+     * returns true iff something appended, otw false 
      * @throws IOException
      */
-    void append(TxnHeader hdr, Record r) throws IOException;
+    boolean append(TxnHeader hdr, Record r) throws IOException;
 
     /**
      * Start reading the transaction logs
"
zookeeper,c472d685e02ced4448054b3d8a83a1b669dee58e,ZOOKEEPER-512. FLE election fails to elect leader (flavio via mahadev),2009.10.28 06:14:00,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index c5c6389..f2ea2b3 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -28,6 +28,7 @@
 import java.util.Enumeration;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
 
 import org.apache.log4j.Logger;
 
@@ -314,9 +315,15 @@
      */
     
     synchronized void connectOne(long sid){
-        if (senderWorkerMap.get(sid) == null){ 
-            InetSocketAddress electionAddr =
-                self.quorumPeers.get(sid).electionAddr;
+        if (senderWorkerMap.get(sid) == null){
+            InetSocketAddress electionAddr;
+            if(self.quorumPeers.containsKey(sid))
+                electionAddr =
+                    self.quorumPeers.get(sid).electionAddr;
+            else{
+                LOG.warn(""Invalid server id: "" + sid);
+                return;
+            }
             try {
                 SocketChannel channel;
                 LOG.debug(""Opening channel to server ""  + sid);
@@ -403,27 +410,38 @@
          */
         @Override
         public void run() {
-            try {
-                ss = ServerSocketChannel.open();
-                int port = self.quorumPeers.get(self.getId()).electionAddr.getPort();
-                LOG.info(""My election bind port: "" + port);
-                ss.socket().setReuseAddress(true); 
-                ss.socket().bind(new InetSocketAddress(port));
+            int numRetries = 0;
+            while((!shutdown) && (numRetries < 3)){
+                try {
+                    ss = ServerSocketChannel.open();
+                    int port = self.quorumPeers.get(self.getId()).electionAddr.getPort();
+                    LOG.info(""My election bind port: "" + port);
+                    ss.socket().setReuseAddress(true); 
+                    ss.socket().bind(new InetSocketAddress(port));
 
-                while (!shutdown) {
-                    SocketChannel client = ss.accept();
-                    Socket sock = client.socket();
-                    sock.setTcpNoDelay(true);
+                    while (!shutdown) {
+                        SocketChannel client = ss.accept();
+                        Socket sock = client.socket();
+                        sock.setTcpNoDelay(true);
                     
-                    LOG.debug(""Connection request ""
-                            + sock.getRemoteSocketAddress());
+                        LOG.debug(""Connection request ""
+                                + sock.getRemoteSocketAddress());
                     
-                    LOG.debug(""Connection request: "" + self.getId());
-                    receiveConnection(client);
+                        LOG.debug(""Connection request: "" + self.getId());
+                        receiveConnection(client);
+                        numRetries = 0;
+                    }
+                } catch (IOException e) {
+                    LOG.error(""Exception while listening"", e);
+                    numRetries++;
                 }
-            } catch (IOException e) {
-                LOG.error(""Listener.run: "" + e.getMessage());
             }
+            LOG.info(""Leaving listener"");
+            if(!shutdown)
+                LOG.fatal(""As I'm leaving the listener thread, "" +
+                		""I won't be able to participate in leader "" +
+                		""election any longer: "" + 
+                		self.quorumPeers.get(self.getId()).electionAddr);
         }
         
         /**
@@ -530,7 +548,7 @@
                 try {
                     ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);                    
                     if(bq != null) 
-                        b = bq.take();
+                        b = bq.poll(1000, TimeUnit.MILLISECONDS);
                     else {
                         LOG.error(""No queue of incoming messages for server "" + sid);
                         this.finish();
@@ -541,11 +559,11 @@
                     continue;
                 }
                 
-                if(b != null)
-                    lastMessageSent.put(sid, b);
-                
                 try {
-                    if(b != null) send(b);
+                    if(b != null){
+                        lastMessageSent.put(sid, b);
+                        send(b);
+                    }
                 } catch (Exception e) {
                     LOG.warn(""Exception when using channel: "" + sid, e);
                     this.finish();
@@ -617,11 +635,14 @@
                     }
                 }
 
-            } catch (IOException e) {
+            } catch (Exception e) {
                 LOG.warn(""Connection broken: "", e);
-            } catch (InterruptedException e) {
-                LOG.warn(""Interrupted while trying to add new ""
-                        + ""message to the reception queue"", e);
+            } finally {
+                try{
+                    channel.socket().close();
+                } catch (IOException e) {
+                    LOG.warn(""Exception while trying to close channel"");
+                }
             }
         }
     }
"
zookeeper,0a7c3b05744008862e1875dd6a651aa2a36d8cef,ZOOKEEPER-508. proposals and commits for DIFF and Truncate messages from the leader to the followers is buggy. (mahadev and ben via mahadev),2009.08.25 14:45:24,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index ef17353..76340b4 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -24,6 +24,7 @@
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
+import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.RandomAccessFile;
@@ -271,8 +272,8 @@
      */
     public boolean truncate(long zxid) throws IOException {
         FileTxnIterator itr = new FileTxnIterator(this.logDir, zxid);
-        FileInputStream input = itr.inputStream;
-        long pos = input.getChannel().position();
+        PositionInputStream input = itr.inputStream;
+        long pos = input.getPosition();
         // now, truncate at the current position
         RandomAccessFile raf=new RandomAccessFile(itr.logFile,""rw"");
         raf.setLength(pos);
@@ -322,6 +323,48 @@
     }
 
     /**
+     * a class that keeps track of the position 
+     * in the input stream. The position points to offset
+     * that has been consumed by the applications. It can 
+     * wrap buffered input streams to provide the right offset 
+     * for the application.
+     */
+    static class PositionInputStream extends FilterInputStream {
+        long position;
+        protected PositionInputStream(InputStream in) {
+            super(in);
+        }
+        
+        @Override
+        public int read() throws IOException {
+            int rc = super.read();
+            if (rc > 0) {
+                position++;
+            }
+            return rc;
+        }
+        
+        @Override
+        public int read(byte[] b, int off, int len) throws IOException {
+            int rc = super.read(b, off, len);
+            position += rc;
+            return rc;
+        }
+        
+        @Override
+        public long skip(long n) throws IOException {
+            long rc = super.skip(n);
+            if (rc > 0) {
+                position += rc;
+            }
+            return rc;
+        }
+        public long getPosition() {
+            return position;
+        }
+    }
+    
+    /**
      * this class implements the txnlog iterator interface
      * which is used for reading the transaction logs
      */
@@ -333,7 +376,8 @@
         File logFile;
         InputArchive ia;
         static final String CRC_ERROR=""CRC check failed"";
-        FileInputStream inputStream=null;
+       
+        PositionInputStream inputStream=null;
         //stored files is the list of files greater than
         //the zxid we are looking for.
         private ArrayList<File> storedFiles;
@@ -398,7 +442,7 @@
          * @param is the inputstream
          * @throws IOException
          */
-        protected void inStreamCreated(InputArchive ia, FileInputStream is)
+        protected void inStreamCreated(InputArchive ia, InputStream is)
             throws IOException{
             FileHeader header= new FileHeader();
             header.deserialize(ia, ""fileheader"");
@@ -416,9 +460,9 @@
          **/
         protected InputArchive createInputArchive(File logFile) throws IOException {
             if(inputStream==null){
-                inputStream= new FileInputStream(logFile);
+                inputStream= new PositionInputStream(new BufferedInputStream(new FileInputStream(logFile)));
                 LOG.debug(""Created new input stream "" + logFile);
-                ia  = BinaryInputArchive.getArchive(new BufferedInputStream(inputStream));
+                ia  = BinaryInputArchive.getArchive(inputStream);
                 inStreamCreated(ia,inputStream);
                 LOG.debug(""created new input archive "" + logFile);
             }
"
zookeeper,0a7c3b05744008862e1875dd6a651aa2a36d8cef,ZOOKEEPER-508. proposals and commits for DIFF and Truncate messages from the leader to the followers is buggy. (mahadev and ben via mahadev),2009.08.25 14:45:24,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index ceb1b47..1bb203b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -200,7 +200,7 @@
                 readPacket(qp);
                 synchronized (zk) {
                     if (qp.getType() == Leader.DIFF) {
-                        LOG.info(""Getting a diff from the leader!"");
+                        LOG.info(""Getting a diff from the leader 0x"" + Long.toHexString(qp.getZxid()));
                         zk.loadData();
                     }
                     else if (qp.getType() == Leader.SNAP) {
"
zookeeper,0a7c3b05744008862e1875dd6a651aa2a36d8cef,ZOOKEEPER-508. proposals and commits for DIFF and Truncate messages from the leader to the followers is buggy. (mahadev and ben via mahadev),2009.08.25 14:45:24,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
index 7ea84a5..5cd508b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
@@ -62,7 +62,7 @@
     
     long getSid(){
         return sid;
-    }
+    }                    
 
     /**
      * The packets to be sent to the follower
@@ -224,15 +224,23 @@
             } else {
             	this.sid = leader.followerCounter.getAndDecrement();
             }
-            LOG.info(""The follower sid: "" + this.sid);
+            LOG.info(""Follower sid: "" + this.sid + "" : info : ""
+                    + leader.self.quorumPeers.get(this.sid));
             
+            /* this is the last zxid from the follower but the leader might have to
+              restart the follower from a different zxid depending on truncate and diff. */
             long peerLastZxid = qp.getZxid();
-            
+            /* the default to send to the follower */
             int packetToSend = Leader.SNAP;
             boolean logTxns = true;
-
             long zxidToSend = 0;
-            // we are sending the diff
+            
+            /** the packets that the follower needs to get updates from **/
+            long updates = peerLastZxid;
+            
+            /* we are sending the diff check if we have proposals in memory to be able to 
+             * send a diff to the 
+             */ 
             synchronized(leader.zk.committedLog) {
                 if (leader.zk.committedLog.size() != 0) {
                     if ((leader.zk.maxCommittedLog >= peerLastZxid)
@@ -252,16 +260,7 @@
                 }
                 else {
                     logTxns = false;
-                }            }
-            long leaderLastZxid = leader.startForwarding(this, peerLastZxid);
-            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,
-                    leaderLastZxid, null, null);
-            oa.writeRecord(newLeaderQP, ""packet"");
-            bufferedOutput.flush();
-            // a special case when both the ids are the same
-            if (peerLastZxid == leaderLastZxid) {
-                packetToSend = Leader.DIFF;
-                zxidToSend = leaderLastZxid;
+                }            
             }
             //check if we decided to send a diff or we need to send a truncate
             // we avoid using epochs for truncating because epochs make things
@@ -274,11 +273,31 @@
                 // we can ask the follower to truncate the log
                 packetToSend = Leader.TRUNC;
                 zxidToSend = leader.zk.maxCommittedLog;
-
+                updates = zxidToSend;
             }
+            
+            /* see what other packets from the proposal
+             * and tobeapplied queues need to be sent
+             * and then decide if we can just send a DIFF
+             * or we actually need to send the whole snapshot
+             */
+            long leaderLastZxid = leader.startForwarding(this, updates);
+            // a special case when both the ids are the same 
+            if (peerLastZxid == leaderLastZxid) {
+                packetToSend = Leader.DIFF;
+                zxidToSend = leaderLastZxid;
+            }
+
+            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,
+                    leaderLastZxid, null, null);
+            oa.writeRecord(newLeaderQP, ""packet"");
+            bufferedOutput.flush();
+            
+           
             oa.writeRecord(new QuorumPacket(packetToSend, zxidToSend, null, null), ""packet"");
             bufferedOutput.flush();
-            // only if we are not truncating or fast sycning
+            
+            /* if we are not truncating or sending a diff just send a snapshot */
             if (packetToSend == Leader.SNAP) {
                 LOG.warn(""Sending snapshot last zxid of peer is 0x""
                         + Long.toHexString(peerLastZxid) + "" "" 
@@ -289,7 +308,7 @@
                 oa.writeString(""BenWasHere"", ""signature"");
             }
             bufferedOutput.flush();
-            //
+            
             // Mutation packets will be queued during the serialize,
             // so we need to mark when the follower can actually start
             // using the data
"
zookeeper,0a7c3b05744008862e1875dd6a651aa2a36d8cef,ZOOKEEPER-508. proposals and commits for DIFF and Truncate messages from the leader to the followers is buggy. (mahadev and ben via mahadev),2009.08.25 14:45:24,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 2e07474..d7c2904 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -647,8 +647,7 @@
                 }
                 handler.queuePacket(p.packet);
                 // Since the proposal has been committed we need to send the
-                // commit message
-                // also
+                // commit message also
                 QuorumPacket qp = new QuorumPacket(Leader.COMMIT, p.packet
                         .getZxid(), null, null);
                 handler.queuePacket(qp);
"
zookeeper,0a7c3b05744008862e1875dd6a651aa2a36d8cef,ZOOKEEPER-508. proposals and commits for DIFF and Truncate messages from the leader to the followers is buggy. (mahadev and ben via mahadev),2009.08.25 14:45:24,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/SendAckRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/SendAckRequestProcessor.java
index eb219c1..f0cbf60 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/SendAckRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/SendAckRequestProcessor.java
@@ -43,13 +43,33 @@
             try {
                 follower.writePacket(qp, false);
             } catch (IOException e) {
-                LOG.warn(""Ignoring unexpected exception during packet send"", e);
+                LOG.warn(""Closing connection to leader, exception during packet send"", e);
+                try {
+                    if (!follower.sock.isClosed()) {
+                        follower.sock.close();
+                    }
+                } catch (IOException e1) {
+                    // Nothing to do, we are shutting things down, so an exception here is irrelevant
+                    LOG.debug(""Ignoring error closing the connection"", e1);
+                }
             }
         }
     }
     
     public void flush() throws IOException {
-        follower.writePacket(null, true);
+        try {
+            follower.writePacket(null, true);
+        } catch(IOException e) {
+            LOG.warn(""Closing connection to leader, exception during packet send"", e);
+            try {
+                if (!follower.sock.isClosed()) {
+                    follower.sock.close();
+                }
+            } catch (IOException e1) {
+                    // Nothing to do, we are shutting things down, so an exception here is irrelevant
+                    LOG.debug(""Ignoring error closing the connection"", e1);
+            }
+        }
     }
 
     public void shutdown() {
"
zookeeper,8b22eb1e4b8bfe4be08a766a98f636149e62fb28,ZOOKEEPER-498. Unending Leader Elections : WAN configuration (flavio via  mahadev),2009.08.12 06:09:32,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 22ed518..8bc7b8c 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -172,20 +172,22 @@
          */
         
         class WorkerReceiver implements Runnable {
-
+            volatile boolean stop;
         	QuorumCnxManager manager;
 
             WorkerReceiver(QuorumCnxManager manager) {
+                this.stop = false;
                 this.manager = manager;
             }
 
             public void run() {
                 
             	Message response;
-            	while (true) {
+            	while (!stop) {
                     // Sleeps on receive
             		try{
-            			response = manager.recvQueue.take();
+            			response = manager.recvQueue.poll(3000, TimeUnit.MILLISECONDS);
+            			if(response == null) continue;
             			
             			// Receive new message
             			LOG.debug(""Receive new message."");
@@ -266,6 +268,7 @@
             					e.toString());
             		}
             	}
+                LOG.info(""WorkerReceiver is down"");
             }
         }
 
@@ -276,23 +279,26 @@
          */
         
         class WorkerSender implements Runnable {
-        	
+        	volatile boolean stop;
             QuorumCnxManager manager;
 
             WorkerSender(QuorumCnxManager manager){ 
+                this.stop = false;
                 this.manager = manager;
             }
             
             public void run() {
-                while (true) {
+                while (!stop) {
                     try {
-                        ToSend m = sendqueue.take();
+                        ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);
+                        if(m == null) continue;
+                        
                         process(m);
                     } catch (InterruptedException e) {
                         break;
                     }
-
                 }
+                LOG.info(""WorkerSender is down"");
             }
 
             /**
@@ -326,6 +332,10 @@
             return (sendqueue.isEmpty() || recvqueue.isEmpty());
         }
 
+        
+        WorkerSender ws;
+        WorkerReceiver wr;
+        
         /**
          * Constructor of class Messenger.
          * 
@@ -333,20 +343,33 @@
          */
         Messenger(QuorumCnxManager manager) {
 
-            Thread t = new Thread(new WorkerSender(manager),
+            this.ws = new WorkerSender(manager);
+            
+            Thread t = new Thread(this.ws,
             		""WorkerSender Thread"");
             t.setDaemon(true);
             t.start();
 
-            t = new Thread(new WorkerReceiver(manager),
+            this.wr = new WorkerReceiver(manager);
+        
+            t = new Thread(this.wr,
                     				""WorkerReceiver Thread"");
             t.setDaemon(true);
             t.start();
         }
+        
+        /**
+         * Stops instances of WorkerSender and WorkerReceiver
+         */
+        void halt(){
+            this.ws.stop = true;
+            this.wr.stop = true;
+        }
 
     }
 
-    QuorumPeer self;
+    QuorumPeer self;    
+    Messenger messenger;
     volatile long logicalclock; /* Election instance */
     long proposedLeader;
     long proposedZxid;
@@ -369,7 +392,8 @@
      * @param manager   Connection manager
      */
     public FastLeaderElection(QuorumPeer self, QuorumCnxManager manager){
-    	this.manager = manager;
+    	this.stop = false;
+        this.manager = manager;
     	starter(self, manager);
     }
     
@@ -390,7 +414,7 @@
 
         sendqueue = new LinkedBlockingQueue<ToSend>();
         recvqueue = new LinkedBlockingQueue<Notification>();
-        new Messenger(manager);
+        this.messenger = new Messenger(manager);
     }
 
     private void leaveInstance() {
@@ -401,9 +425,14 @@
     	return manager;
     }
     
+    volatile boolean stop;
     public void shutdown(){
+        stop = true;
         LOG.debug(""Shutting down connection manager"");
         manager.halt();
+        LOG.debug(""Shutting down messenger"");
+        messenger.halt();
+        LOG.debug(""FLE is down"");
     }
 
     
@@ -434,6 +463,10 @@
      */
     private boolean totalOrderPredicate(long newId, long newZxid, long curId, long curZxid) {
         LOG.debug(""id: "" + newId + "", proposed id: "" + curId + "", zxid: "" + newZxid + "", proposed zxid: "" + curZxid);
+        if(self.getQuorumVerifier().getWeight(newId) == 0){
+            return false;
+        }
+        
         if ((newZxid > curZxid)
                 || ((newZxid == curZxid) && (newId > curId)))
             return true;
@@ -550,7 +583,8 @@
              * Loop in which we exchange notifications until we find a leader
              */
     
-            while (self.getPeerState() == ServerState.LOOKING) {
+            while ((self.getPeerState() == ServerState.LOOKING) &&
+                    (!stop)){
                 /*
                  * Remove next notification from queue, times out after 2 times
                  * the termination time
@@ -606,14 +640,12 @@
                         }
                     
                         LOG.info(""Adding vote"");
-                        /*
-                         * Skip zero-weight servers
-                         */
-                        if(self.getQuorumVerifier().getWeight(n.sid) != 0) 
-                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.epoch));
+
+                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.epoch));
     
                         //If have received from all nodes, then terminate
-                        if (self.quorumPeers.size() == recvset.size()) {
+                        if ((self.quorumPeers.size() == recvset.size()) &&
+                                (self.getQuorumVerifier().getWeight(proposedLeader) != 0)){
                             self.setPeerState((proposedLeader == self.getId()) ? 
                                     ServerState.LEADING: ServerState.FOLLOWING);
                             leaveInstance();
"
zookeeper,8b22eb1e4b8bfe4be08a766a98f636149e62fb28,ZOOKEEPER-498. Unending Leader Elections : WAN configuration (flavio via  mahadev),2009.08.12 06:09:32,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 9a46cd4..c5c6389 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -338,7 +338,7 @@
                         e);
             }
         } else {
-            LOG.error(""There is a connection for server "" + sid);
+            LOG.debug(""There is a connection already for server "" + sid);
         }
     }
     
"
zookeeper,8b22eb1e4b8bfe4be08a766a98f636149e62fb28,ZOOKEEPER-498. Unending Leader Elections : WAN configuration (flavio via  mahadev),2009.08.12 06:09:32,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
index 1e429bd..10c92ef 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
@@ -121,8 +121,8 @@
         this.serverGroup = serverGroup;
         this.groupWeight = new HashMap<Long, Long>();
         
-        computeGroupWeight();
         this.numGroups = numGroups;
+        computeGroupWeight();   
     }
     
     
@@ -219,7 +219,11 @@
          * Do not consider groups with weight zero
          */
         for(long weight: groupWeight.values()){
-            if(weight == 0) numGroups--;
+            LOG.debug(""Group weight: "" + weight);
+            if(weight == ((long) 0)){
+                numGroups--;
+                LOG.debug(""One zero-weight group: "" + 1 + "", "" + numGroups);
+            }
         }
     }
     
@@ -233,7 +237,7 @@
          * Adds up weights per group
          */
         if(set.size() == 0) return false;
-        else LOG.info(""Set size: "" + set.size());
+        else LOG.debug(""Set size: "" + set.size());
         
         for(long sid : set){
             Long gid = serverGroup.get(sid);
@@ -250,17 +254,18 @@
          */
         int majGroupCounter = 0;
         for(long gid : expansion.keySet()) {
-            LOG.info(""gid: "" + expansion.get(gid));
+            LOG.debug(""Group info: "" + expansion.get(gid) + "", "" + gid + "", "" + groupWeight.get(gid));
             if(expansion.get(gid) > (groupWeight.get(gid) / 2) )
                 majGroupCounter++;
         }
         
+        LOG.debug(""Majority group counter: "" + majGroupCounter + "", "" + numGroups); 
         if((majGroupCounter > (numGroups / 2))){
-            LOG.info(""Positive set size: "" + set.size());
+            LOG.debug(""Positive set size: "" + set.size());
             return true;
         }
         else {
-            LOG.info(""Negative set size: "" + set.size());
+            LOG.debug(""Negative set size: "" + set.size());
             return false;
         }
     }
"
zookeeper,b12aad6381345396ad68be2c4c9df778883bd203,"ZOOKEEPER-483. ZK fataled on me, and ugly",2009.08.11 14:44:51,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/SendAckRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/SendAckRequestProcessor.java
index eb219c1..f0cbf60 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/SendAckRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/SendAckRequestProcessor.java
@@ -43,13 +43,33 @@
             try {
                 follower.writePacket(qp, false);
             } catch (IOException e) {
-                LOG.warn(""Ignoring unexpected exception during packet send"", e);
+                LOG.warn(""Closing connection to leader, exception during packet send"", e);
+                try {
+                    if (!follower.sock.isClosed()) {
+                        follower.sock.close();
+                    }
+                } catch (IOException e1) {
+                    // Nothing to do, we are shutting things down, so an exception here is irrelevant
+                    LOG.debug(""Ignoring error closing the connection"", e1);
+                }
             }
         }
     }
     
     public void flush() throws IOException {
-        follower.writePacket(null, true);
+        try {
+            follower.writePacket(null, true);
+        } catch(IOException e) {
+            LOG.warn(""Closing connection to leader, exception during packet send"", e);
+            try {
+                if (!follower.sock.isClosed()) {
+                    follower.sock.close();
+                }
+            } catch (IOException e1) {
+                    // Nothing to do, we are shutting things down, so an exception here is irrelevant
+                    LOG.debug(""Ignoring error closing the connection"", e1);
+            }
+        }
     }
 
     public void shutdown() {
"
zookeeper,d26abefde17d4e168a32146238036e5515267655,ZOOKEEPER-499. electionAlg should default to FLE (3) - regression (phunt via mahadev),2009.08.11 07:24:06,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index d3ffb55..9a46cd4 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -19,15 +19,13 @@
 package org.apache.zookeeper.server.quorum;
 
 import java.io.IOException;
-import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
+import java.nio.channels.UnresolvedAddressException;
 import java.util.Enumeration;
-import java.util.Random;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
 
@@ -316,17 +314,28 @@
      */
     
     synchronized void connectOne(long sid){
-        
-        if ((senderWorkerMap.get(sid) == null)){ 
+        if (senderWorkerMap.get(sid) == null){ 
+            InetSocketAddress electionAddr =
+                self.quorumPeers.get(sid).electionAddr;
             try {
                 SocketChannel channel;
                 LOG.debug(""Opening channel to server ""  + sid);
-                channel = SocketChannel
-                        .open(self.quorumPeers.get(sid).electionAddr);
+                channel = SocketChannel.open(electionAddr);
                 channel.socket().setTcpNoDelay(true);
                 initiateConnection(channel, sid);
+            } catch (UnresolvedAddressException e) {
+                // Sun doesn't include the address that causes this
+                // exception to be thrown, also UAE cannot be wrapped cleanly
+                // so we log the exception in order to capture this critical
+                // detail.
+                LOG.warn(""Cannot open channel to "" + sid
+                        + "" at election address "" + electionAddr,
+                        e);
+                throw e;
             } catch (IOException e) {
-                LOG.warn(""Cannot open channel to "" + sid, e);
+                LOG.warn(""Cannot open channel to "" + sid
+                        + "" at election address "" + electionAddr,
+                        e);
             }
         } else {
             LOG.error(""There is a connection for server "" + sid);
"
zookeeper,d26abefde17d4e168a32146238036e5515267655,ZOOKEEPER-499. electionAlg should default to FLE (3) - regression (phunt via mahadev),2009.08.11 07:24:06,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 86c6f37..dbb1e15 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -47,8 +47,8 @@
 
     protected int initLimit;
     protected int syncLimit;
-    protected int electionAlg;
-    protected int electionPort;
+    protected int electionAlg = 3;
+    protected int electionPort = 2182;
     protected int maxClientCnxns = 10;
     protected final HashMap<Long,QuorumServer> servers =
         new HashMap<Long, QuorumServer>();
"
zookeeper,30fe838bb0d0a728eb99f962094dcc115c9990d4,ZOOKEEPER-501. CnxManagerTest failed on hudson. (flavio via mahadev),2009.08.08 06:00:05,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index fb5e15f..d3ffb55 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -96,7 +96,7 @@
      */
     public Listener listener;
 
-    static class Message {
+    static public class Message {
         Message(ByteBuffer buffer, long sid) {
             this.buffer = buffer;
             this.sid = sid;
@@ -339,7 +339,7 @@
      * doesn't exist.
      */
     
-    void connectAll(){
+    public void connectAll(){
         long sid;
         for(Enumeration<Long> en = queueSendMap.keys();
             en.hasMoreElements();){
"
zookeeper,8d14195dd1c20e5ed8d648eee6ab5702a7a8e86a,ZOOKEEPER-490. the java docs for session creation are misleading/incomplete,2009.08.08 03:00:48,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index a093df5..a4f1e90 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -60,6 +60,7 @@
  * This is the main class of ZooKeeper client library. To use a ZooKeeper
  * service, an application must first instantiate an object of ZooKeeper class.
  * All the iterations will be done by calling the methods of ZooKeeper class.
+ * The methods of this class are thread-safe unless otherwise noted.
  * <p>
  * Once a connection to a server is established, a session ID is assigned to the
  * client. The client will send heart beats to the server periodically to keep
@@ -324,18 +325,28 @@
      * connection string containing a comma separated list of host:port pairs,
      * each corresponding to a ZooKeeper server.
      * <p>
-     * The client object will pick an arbitrary server and try to connect to it.
-     * If failed, it will try the next one in the list, until a connection is
-     * established, or all the servers have been tried.
+     * Session establishment is asynchronous. This constructor will initiate
+     * connection to the server and return immediately - potentially (usually)
+     * before the session is fully established. The watcher argument specifies
+     * the watcher that will be notified of any changes in state. This
+     * notification can come at any point before or after the constructor call
+     * has returned.
+     * <p>
+     * The instantiated ZooKeeper client object will pick an arbitrary server
+     * from the connectString and attempt to connect to it. If establishment of
+     * the connection fails, another server in the connect string will be tried
+     * (the order is non-deterministic, as we random shuffle the list), until a
+     * connection is established. The client will continue attempts until the
+     * session is explicitly closed.
      * <p>
      * Added in 3.2.0: An optional ""chroot"" suffix may also be appended to the
      * connection string. This will run the client commands while interpreting
      * all paths relative to this root (similar to the unix chroot command).
-     *
+     * 
      * @param connectString
      *            comma separated host:port pairs, each corresponding to a zk
-     *            server. e.g. ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002""
-     *            If the optional chroot suffix is used the example would look
+     *            server. e.g. ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002"" If
+     *            the optional chroot suffix is used the example would look
      *            like: ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a""
      *            where the client would be rooted at ""/app/a"" and all paths
      *            would be relative to this root - ie getting/setting/etc...
@@ -346,9 +357,11 @@
      * @param watcher
      *            a watcher object which will be notified of state changes, may
      *            also be notified for node events
-     *
-     * @throws IOException in cases of network failure
-     * @throws IllegalArgumentException if an invalid chroot path is specified
+     * 
+     * @throws IOException
+     *             in cases of network failure
+     * @throws IllegalArgumentException
+     *             if an invalid chroot path is specified
      */
     public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)
         throws IOException
@@ -366,9 +379,19 @@
      * connection string containing a comma separated list of host:port pairs,
      * each corresponding to a ZooKeeper server.
      * <p>
-     * The client object will pick an arbitrary server and try to connect to it.
-     * If failed, it will try the next one in the list, until a connection is
-     * established, or all the servers have been tried.
+     * Session establishment is asynchronous. This constructor will initiate
+     * connection to the server and return immediately - potentially (usually)
+     * before the session is fully established. The watcher argument specifies
+     * the watcher that will be notified of any changes in state. This
+     * notification can come at any point before or after the constructor call
+     * has returned.
+     * <p>
+     * The instantiated ZooKeeper client object will pick an arbitrary server
+     * from the connectString and attempt to connect to it. If establishment of
+     * the connection fails, another server in the connect string will be tried
+     * (the order is non-deterministic, as we random shuffle the list), until a
+     * connection is established. The client will continue attempts until the
+     * session is explicitly closed (or the session is expired by the server).
      * <p>
      * Added in 3.2.0: An optional ""chroot"" suffix may also be appended to the
      * connection string. This will run the client commands while interpreting
@@ -424,6 +447,8 @@
      * not valid until the client connects to a server and may change after a
      * re-connect.
      *
+     * This method is NOT thread safe
+     * 
      * @return current session id
      */
     public long getSessionId() {
@@ -435,16 +460,32 @@
      * returned is not valid until the client connects to a server and may
      * change after a re-connect.
      *
+     * This method is NOT thread safe
+     * 
      * @return current session password
      */
     public byte[] getSessionPasswd() {
         return cnxn.getSessionPasswd();
     }
 
+    /**
+     * Add the specified scheme:auth information to this connection.
+     * 
+     * This method is NOT thread safe
+     * 
+     * @param scheme
+     * @param auth
+     */
     public void addAuthInfo(String scheme, byte auth[]) {
         cnxn.addAuthInfo(scheme, auth);
     }
 
+    /**
+     * Specify the default watcher for the connection (overrides the one
+     * specified during construction).
+     * 
+     * @param watcher
+     */
     public synchronized void register(Watcher watcher) {
         watchManager.defaultWatcher = watcher;
     }
"
zookeeper,9107bbaf5f94ea0c70bcaae458538c95aeb61454,ZOOKEEPER-484.  Clients get SESSION MOVED exception when switching from follower to a leader. (mahadev),2009.08.07 08:23:32,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index f3b54bb..56140f9 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -70,10 +70,7 @@
 
     private ConnectionBean jmxConnectionBean;
 
-    // This is just an arbitrary object to represent requests issued by
-    // (aka owned by) this class
-    final private static Object me = new Object();
-
+   
     static public class Factory extends Thread {
         ZooKeeperServer zks;
 
@@ -545,7 +542,7 @@
             return;
         } else {
             Request si = new Request(this, sessionId, h.getXid(), h.getType(), incomingBuffer, authInfo);
-            si.setOwner(me);
+            si.setOwner(ServerCnxn.me);
             zk.submitRequest(si);
         }
         if (h.getXid() >= 0) {
"
zookeeper,9107bbaf5f94ea0c70bcaae458538c95aeb61454,ZOOKEEPER-484.  Clients get SESSION MOVED exception when switching from follower to a leader. (mahadev),2009.08.07 08:23:32,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 6bb63d1..5d7ffc0 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -356,7 +356,7 @@
                 txn = new CreateSessionTxn(to);
                 request.request.rewind();
                 zks.sessionTracker.addSession(request.sessionId, to);
-                zks.sessionTracker.setOwner(request.sessionId, request.getOwner());
+                zks.setOwner(request.sessionId, request.getOwner());
                 break;
             case OpCode.closeSession:
                 txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
"
zookeeper,9107bbaf5f94ea0c70bcaae458538c95aeb61454,ZOOKEEPER-484.  Clients get SESSION MOVED exception when switching from follower to a leader. (mahadev),2009.08.07 08:23:32,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
index 4d24ab1..aadce40 100644
--- a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
@@ -55,6 +55,10 @@
     
     final static ByteBuffer imok = ByteBuffer.wrap(""imok"".getBytes());
 
+    // This is just an arbitrary object to represent requests issued by
+    // (aka owned by) this class
+    final public static Object me = new Object();
+
     public abstract int getSessionTimeout();
 
     public abstract void close();
"
zookeeper,9107bbaf5f94ea0c70bcaae458538c95aeb61454,ZOOKEEPER-484.  Clients get SESSION MOVED exception when switching from follower to a leader. (mahadev),2009.08.07 08:23:32,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 0b0c430..6721815 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -38,6 +38,7 @@
 import org.apache.jute.Record;
 import org.apache.log4j.Logger;
 import org.apache.zookeeper.Environment;
+import org.apache.zookeeper.KeeperException.SessionExpiredException;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Id;
@@ -500,6 +501,16 @@
         return sessionId;
     }
 
+    /**
+     * set the owner of this session as owner
+     * @param id the session id
+     * @param owner the owner of the session
+     * @throws SessionExpiredException
+     */
+    public void setOwner(long id, Object owner) throws SessionExpiredException {
+        sessionTracker.setOwner(id, owner);
+    }
+
     protected void revalidateSession(ServerCnxn cnxn, long sessionId,
             int sessionTimeout) throws IOException, InterruptedException {
         boolean rc = sessionTracker.touchSession(sessionId, sessionTimeout);
"
zookeeper,9107bbaf5f94ea0c70bcaae458538c95aeb61454,ZOOKEEPER-484.  Clients get SESSION MOVED exception when switching from follower to a leader. (mahadev),2009.08.07 08:23:32,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
index 8e0ac46..7ea84a5 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
@@ -355,6 +355,9 @@
                     boolean valid = leader.zk.touch(id, to);
                     if (valid) {
                         try {
+                            //set the session owner
+                            // as the follower that
+                            // owns the session
                             leader.zk.setOwner(id, this);
                         } catch (SessionExpiredException e) {
                             LOG.error(""Somehow session "" + Long.toHexString(id) + "" expired right after being renewed! (impossible)"", e);
"
zookeeper,9107bbaf5f94ea0c70bcaae458538c95aeb61454,ZOOKEEPER-484.  Clients get SESSION MOVED exception when switching from follower to a leader. (mahadev),2009.08.07 08:23:32,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
index 55f1b74..48cbcef 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
@@ -154,16 +154,14 @@
         return ""leader"";
     }
 
-    public void setOwner(long id, Object owner) throws SessionExpiredException {
-        sessionTracker.setOwner(id, owner);
-    }
-
     @Override
     protected void revalidateSession(ServerCnxn cnxn, long sessionId,
         int sessionTimeout) throws IOException, InterruptedException {
         super.revalidateSession(cnxn, sessionId, sessionTimeout);
         try {
-            setOwner(sessionId, this);
+            // setowner as the leader itself, unless updated
+            // via the follower handlers
+            setOwner(sessionId, ServerCnxn.me);
         } catch (SessionExpiredException e) {
             // this is ok, it just means that the session revalidation failed.
         }
"
zookeeper,c11645f17c5266d7577ea58cb244a3d6eaaff0e0,ZOOKEEPER-493. patch for command line setquota,2009.08.05 06:38:38,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index ba09f5e..1988409 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -733,11 +733,12 @@
             }
         } else if (cmd.equals(""setquota"") && args.length >= 4) {
             String option = args[1];
+            String val = args[2];
             path = args[3];
             System.err.println(""Comment: the parts are "" +
-                    ""option "" + option + "" path "" +
-                    args[3] + "" val "" + args[2]);
-            String val = args[3];
+                               ""option "" + option +
+                               "" val "" + val +
+                               "" path "" + path);
             if (""-b"".equals(option)) {
                 // we are setting the bytes quota
                 createQuota(zk, path, Long.parseLong(val), -1);
"
zookeeper,358f5122485b7ffa9dcc2e46e0751e88711f2ad9,ZOOKEEPER-491. Prevent zero-weight servers from being elected. (flavio via mahadev),2009.08.05 03:11:16,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index e384569..22ed518 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -577,8 +577,7 @@
                 	        tmpTimeOut : maxNotificationInterval);
                 	LOG.info(""Notification time out: "" + notTimeout);
                 }
-                else { 
-                    //notTimeout = finalizeWait;
+                else{                    
                     switch (n.state) { 
                     case LOOKING:
                         // If notification > current, replace and send messages out
@@ -607,7 +606,11 @@
                         }
                     
                         LOG.info(""Adding vote"");
-                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.epoch));
+                        /*
+                         * Skip zero-weight servers
+                         */
+                        if(self.getQuorumVerifier().getWeight(n.sid) != 0) 
+                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.epoch));
     
                         //If have received from all nodes, then terminate
                         if (self.quorumPeers.size() == recvset.size()) {
"
zookeeper,930380c9407184ba159181c0d8cd08d21ce90766,ZOOKEEPER-480. FLE should perform leader check when node is not leading and add vote of follower (flavio via mahadev),2009.08.05 02:59:58,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 90c8fbb..e384569 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -490,9 +490,20 @@
             long epoch){
         
         boolean predicate = true;
-        if(votes.get(leader) == null) predicate = false;
-        else if(votes.get(leader).state != ServerState.LEADING) predicate = false;
+
+        /*
+         * If everyone else thinks I'm the leader, I must be the leader.
+         * The other two checks are just for the case in which I'm not the
+         * leader. If I'm not the leader and I haven't received a message 
+         * from leader stating that it is leading, then predicate is false.          
+         */
         
+        if(leader != self.getId()){
+            if(votes.get(leader) == null) predicate = false;
+            else if(votes.get(leader).state != ServerState.LEADING) predicate = false;
+        }
+        
+        //LOG.info(""Leader predicate: "" + predicate);
         return predicate;
     }
     
@@ -643,13 +654,18 @@
                          * this leader, then processes will naturally move
                          * to a new epoch.
                          */
-                        if((n.state == ServerState.LEADING) && 
-                                (n.epoch == logicalclock)){
-                            self.setPeerState((n.leader == self.getId()) ? 
-                                    ServerState.LEADING: ServerState.FOLLOWING);
+                        if(n.epoch == logicalclock){
+                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.epoch));
+                            if((n.state == ServerState.LEADING) ||
+                                    (termPredicate(recvset, new Vote(n.leader,
+                                            n.zxid, n.epoch, n.state))
+                                            && checkLeader(outofelection, n.leader, n.epoch)) ){
+                                self.setPeerState((n.leader == self.getId()) ? 
+                                        ServerState.LEADING: ServerState.FOLLOWING);
                        
-                            leaveInstance();
-                            return new Vote(n.leader, n.zxid);
+                                leaveInstance();
+                                return new Vote(n.leader, n.zxid);
+                            } 
                         }
                     
                         LOG.info(""Notification: "" + n.leader + "", "" + n.zxid + 
@@ -671,6 +687,7 @@
                             leaveInstance();
                             return new Vote(n.leader, n.zxid);
                         }
+                        
                         break;
                     }
                 }
"
zookeeper,a92959ed01dc7425cc4fad14950dc1604934f6e2,ZOOKEEPER-479.  QuorumHierarchical does not count groups correctly (flavio via mahadev),2009.08.04 07:28:19,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
index 0b761d2..1e429bd 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
@@ -104,12 +104,15 @@
         LOG.info(serverWeight.size() + "", "" + serverGroup.size() + "", "" + groupWeight.size());
     }
     
-    /**
-     * This contructor takes the two hash maps needed to enable 
-     * validating quorums. We use it with QuorumPeerConfig. That is,
-     * we declare weights and groups in the server configuration
-     * file along with the other parameters.
-     */
+   /**
+    *  This contructor takes the two hash maps needed to enable 
+    *  validating quorums. We use it with QuorumPeerConfig. That is,
+    *  we declare weights and groups in the server configuration
+    *  file along with the other parameters.
+    * @param numGroups
+    * @param serverWeight
+    * @param serverGroup
+    */
     public QuorumHierarchical(int numGroups,
             HashMap<Long, Long> serverWeight,
             HashMap<Long, Long> serverGroup)
@@ -124,6 +127,15 @@
     
     
     /**
+     * Returns the weight of a server.
+     * 
+     * @param id
+     */
+    public long getWeight(long id){
+        return serverWeight.get(id);
+    }
+    
+    /**
      * Reads a configration file. Called from the constructor
      * that takes a file as an input.
      */
@@ -200,9 +212,15 @@
             else {
                 long totalWeight = serverWeight.get(sid) + groupWeight.get(gid);
                 groupWeight.put(gid, totalWeight);
-            }
-            
-        }        
+            } 
+        }    
+        
+        /*
+         * Do not consider groups with weight zero
+         */
+        for(long weight: groupWeight.values()){
+            if(weight == 0) numGroups--;
+        }
     }
     
     /**
@@ -230,14 +248,14 @@
         /*
          * Check if all groups have majority
          */
-        boolean majPerGroup = true;
+        int majGroupCounter = 0;
         for(long gid : expansion.keySet()) {
             LOG.info(""gid: "" + expansion.get(gid));
-            if(expansion.get(gid) <= (groupWeight.get(gid) / 2) )
-                majPerGroup = false;
+            if(expansion.get(gid) > (groupWeight.get(gid) / 2) )
+                majGroupCounter++;
         }
         
-        if((expansion.size() > (numGroups / 2)) && majPerGroup){
+        if((majGroupCounter > (numGroups / 2))){
             LOG.info(""Positive set size: "" + set.size());
             return true;
         }
"
zookeeper,a92959ed01dc7425cc4fad14950dc1604934f6e2,ZOOKEEPER-479.  QuorumHierarchical does not count groups correctly (flavio via mahadev),2009.08.04 07:28:19,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumMaj.java b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumMaj.java
index b75e494..bca84a5 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumMaj.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumMaj.java
@@ -31,12 +31,23 @@
     
     /**
      * Defines a majority to avoid computing it every time.
+     * 
+     * @param n number of servers
      */
     public QuorumMaj(int n){
         this.half = n/2;
     }
     
     /**
+     * Returns weight of 1 by default.
+     * 
+     * @param id 
+     */
+    public long getWeight(long id){
+        return (long) 1;
+    }
+    
+    /**
      * Verifies if a set is a majority.
      */
     public boolean containsQuorum(HashSet<Long> set){
"
zookeeper,a92959ed01dc7425cc4fad14950dc1604934f6e2,ZOOKEEPER-479.  QuorumHierarchical does not count groups correctly (flavio via mahadev),2009.08.04 07:28:19,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumVerifier.java b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumVerifier.java
index 3af531e..0b7e043 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumVerifier.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumVerifier.java
@@ -28,5 +28,6 @@
  */
 
 public interface QuorumVerifier {
+    long getWeight(long id);
     boolean containsQuorum(HashSet<Long> set);
 }
\ No newline at end of file
"
zookeeper,1bc05ce6a3363206fbcf0a4bc6c9bbdee1d361f0,ZOOKEEPER-481. Add lastMessageSent to QuorumCnxManager. (flavio via mahadev),2009.08.04 06:27:09,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 28ae03e..fb5e15f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -78,11 +78,12 @@
      */
     ConcurrentHashMap<Long, SendWorker> senderWorkerMap;
     ConcurrentHashMap<Long, ArrayBlockingQueue<ByteBuffer>> queueSendMap;
+    ConcurrentHashMap<Long, ByteBuffer> lastMessageSent;
 
     /*
      * Reception queue
      */
-    ArrayBlockingQueue<Message> recvQueue;
+    public ArrayBlockingQueue<Message> recvQueue;
 
     /*
      * Shutdown flag
@@ -93,7 +94,7 @@
     /*
      * Listener thread
      */
-    Listener listener;
+    public Listener listener;
 
     static class Message {
         Message(ByteBuffer buffer, long sid) {
@@ -109,6 +110,8 @@
         this.recvQueue = new ArrayBlockingQueue<Message>(CAPACITY);
         this.queueSendMap = new ConcurrentHashMap<Long, ArrayBlockingQueue<ByteBuffer>>();
         this.senderWorkerMap = new ConcurrentHashMap<Long, SendWorker>();
+        this.lastMessageSent = new ConcurrentHashMap<Long, ByteBuffer>();
+        
         this.self = self;
 
         // Starts listener thread that waits for connection requests 
@@ -116,11 +119,25 @@
     }
 
     /**
+     * Invokes initiateConnection for testing purposes
+     * 
+     * @param sid
+     */
+    public void testInitiateConnection(long sid) throws Exception {
+        SocketChannel channel;
+        LOG.debug(""Opening channel to server ""  + sid);
+        channel = SocketChannel
+                .open(self.quorumPeers.get(sid).electionAddr);
+        channel.socket().setTcpNoDelay(true);
+        initiateConnection(channel, sid);
+    }
+    
+    /**
      * If this server has initiated the connection, then it gives up on the
      * connection if it loses challenge. Otherwise, it keeps the connection.
      */
 
-    boolean initiateConnection(SocketChannel s, Long sid) {
+    public boolean initiateConnection(SocketChannel s, Long sid) {
          try {
             // Sending id and challenge
             byte[] msgBytes = new byte[8];
@@ -144,31 +161,26 @@
                         + ""reopen connection: "", e);
             }
         // Otherwise proceed with the connection
-        } else {
-        	SendWorker sw = new SendWorker(s, sid);
-        	RecvWorker rw = new RecvWorker(s, sid);
-        	sw.setRecv(rw);
-        	
-        	if (senderWorkerMap
-        			.containsKey(sid)) {
-        	    SendWorker vsw = senderWorkerMap.get(sid);
-        	    if(vsw != null)
-        	        vsw.finish();
-        	    else LOG.error(""No SendWorker for this identifier ("" + sid + "")"");
-        	} else {
-        	    LOG.error(""Cannot open channel to server ""  + sid);
-        	}
+        } else {    
+            SendWorker sw = new SendWorker(s, sid);
+            RecvWorker rw = new RecvWorker(s, sid);
+            sw.setRecv(rw);
 
-        	if (!queueSendMap.containsKey(sid)) {
-        		queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
-        				CAPACITY));
-        	}
-                    
-        	senderWorkerMap.put(sid, sw);
-        	sw.start();
-        	rw.start();
+            SendWorker vsw = senderWorkerMap.get(sid);
+            senderWorkerMap.put(sid, sw);
+            
+            if(vsw != null)
+                vsw.finish();
 
-        	return true;
+            if (!queueSendMap.containsKey(sid)) {
+                queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
+                        CAPACITY));
+            }
+            
+            sw.start();
+            rw.start();
+            
+            return true;    
             
         }
         return false;
@@ -225,27 +237,25 @@
             }
         //Otherwise start worker threads to receive data.
         } else {
-        	SendWorker sw = new SendWorker(s, sid);
-        	RecvWorker rw = new RecvWorker(s, sid);
-        	sw.setRecv(rw);
+            SendWorker sw = new SendWorker(s, sid);
+            RecvWorker rw = new RecvWorker(s, sid);
+            sw.setRecv(rw);
 
-        	if (senderWorkerMap.containsKey(sid)) {
-        	    SendWorker vsw = senderWorkerMap.get(sid);
-        	    if(vsw != null)
-        	        vsw.finish();
-        	    else LOG.error(""No SendWorker for this identifier ("" + sid + "")"");
-        	}
-                    
-        	senderWorkerMap.put(sid, sw);
-                    
-        	if (!queueSendMap.containsKey(sid)) {
-        		queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
-        				CAPACITY));
-        	}      
-        	sw.start();
-        	rw.start();
+            SendWorker vsw = senderWorkerMap.get(sid);
+            senderWorkerMap.put(sid, sw);
+            
+            if(vsw != null)
+                vsw.finish();
 
-        	return true;    
+            if (!queueSendMap.containsKey(sid)) {
+                queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
+                        CAPACITY));
+            }
+            
+            sw.start();
+            rw.start();
+            
+            return true;    
         }
         return false;
     }
@@ -254,7 +264,7 @@
      * Processes invoke this message to queue a message to send. Currently, 
      * only leader election uses it.
      */
-    void toSend(Long sid, ByteBuffer b) {
+    public void toSend(Long sid, ByteBuffer b) {
         /*
          * If sending message to myself, then simply enqueue it (loopback).
          */
@@ -296,7 +306,7 @@
             } catch (InterruptedException e) {
                 LOG.warn(""Interrupted while waiting to put message in queue."",
                         e);
-            }
+            } 
     }
     
     /**
@@ -306,9 +316,10 @@
      */
     
     synchronized void connectOne(long sid){
-        if ((senderWorkerMap.get(sid) == null)) {
-            SocketChannel channel;
+        
+        if ((senderWorkerMap.get(sid) == null)){ 
             try {
+                SocketChannel channel;
                 LOG.debug(""Opening channel to server ""  + sid);
                 channel = SocketChannel
                         .open(self.quorumPeers.get(sid).electionAddr);
@@ -362,6 +373,9 @@
         softHalt();
     }
    
+    /**
+     * A soft halt simply finishes workers.
+     */
     public void softHalt(){
     	for(SendWorker sw: senderWorkerMap.values()){
     		LOG.debug(""Halting sender: "" + sw);
@@ -372,7 +386,7 @@
     /**
      * Thread to listen on some port
      */
-    class Listener extends Thread {
+    public class Listener extends Thread {
 
         volatile ServerSocketChannel ss = null;
         /**
@@ -380,7 +394,6 @@
          */
         @Override
         public void run() {
-            //ss = null;
             try {
                 ss = ServerSocketChannel.open();
                 int port = self.quorumPeers.get(self.getId()).electionAddr.getPort();
@@ -393,10 +406,10 @@
                     Socket sock = client.socket();
                     sock.setTcpNoDelay(true);
                     
-                    LOG.info(""Connection request ""
+                    LOG.debug(""Connection request ""
                             + sock.getRemoteSocketAddress());
-                    //synchronized(senderWorkerMap){
-                    LOG.info(""Connection request: "" + self.getId());
+                    
+                    LOG.debug(""Connection request: "" + self.getId());
                     receiveConnection(client);
                 }
             } catch (IOException e) {
@@ -404,10 +417,13 @@
             }
         }
         
+        /**
+         * Halts this listener thread.
+         */
         void halt(){
             try{
                 LOG.debug(""Trying to close listener: "" + ss);
-                if(ss != null)/* && (ss.isOpen()))*/{
+                if(ss != null) {
                     LOG.debug(""Closing listener: "" + self.getId());
                     ss.close();
                 }
@@ -423,12 +439,18 @@
      * one.
      */
     class SendWorker extends Thread {
-        // Send msgs to peer
         Long sid;
         SocketChannel channel;
         RecvWorker recvWorker;
         volatile boolean running = true;
 
+        /**
+         * An instance of this thread receives messages to send
+         * through a queue and sends them to the server sid.
+         * 
+         * @param channel SocketChannel
+         * @param sid   Server identifier
+         */
         SendWorker(SocketChannel channel, Long sid) {
             this.sid = sid;
             this.channel = channel;
@@ -437,25 +459,63 @@
             LOG.debug(""Address of remote peer: "" + this.sid);
         }
 
-        void setRecv(RecvWorker recvWorker) {
+        synchronized void setRecv(RecvWorker recvWorker) {
             this.recvWorker = recvWorker;
         }
 
+        /**
+         * Returns RecvWorker that pairs up with this SendWorker.
+         * 
+         * @return RecvWorker 
+         */
+        synchronized RecvWorker getRecvWorker(){
+            return recvWorker;
+        }
+                
         synchronized boolean finish() {
             running = false;
 
             LOG.debug(""Calling finish"");
             this.interrupt();
+            try{
+                channel.close();
+            } catch (IOException e) {
+                LOG.warn(""Exception while closing socket"");
+            }
+            //channel = null;
+            
+            this.interrupt();
             if (recvWorker != null)
                 recvWorker.finish();
             senderWorkerMap.remove(sid);
             return running;
         }
+        
+        synchronized void send(ByteBuffer b) throws IOException {
+            byte[] msgBytes = new byte[b.capacity()
+                                       + (Integer.SIZE / 8)];
+            ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
+            msgBuffer.putInt(b.capacity());
+
+            msgBuffer.put(b.array(), 0, b.capacity());
+            msgBuffer.position(0);
+            if(channel != null)
+                channel.write(msgBuffer);
+            else
+                throw new IOException(""SocketChannel is null"");
+        }
 
         @Override
         public void run() {
-
-            while (running && !shutdown) {
+            try{
+                ByteBuffer b = lastMessageSent.get(sid); 
+                if(b != null) send(b);   
+            } catch (IOException e) {
+                LOG.error(""Failed to send last message. Shutting down thread."");
+                this.finish();
+            }
+            
+            while (running && !shutdown && channel != null) {
 
                 ByteBuffer b = null;
                 try {
@@ -471,37 +531,15 @@
                             e);
                     continue;
                 }
-
+                
+                if(b != null)
+                    lastMessageSent.put(sid, b);
+                
                 try {
-                    byte[] msgBytes = new byte[b.capacity()
-                            + (Integer.SIZE / 8)];
-                    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
-                    msgBuffer.putInt(b.capacity());
-
-                    msgBuffer.put(b.array(), 0, b.capacity());
-                    msgBuffer.position(0);
-                    channel.write(msgBuffer);
-
-                } catch (IOException e) {
-                    /*
-                     * If reconnection doesn't work, then put the
-                     * message back to the beginning of the queue and leave.
-                     */
+                    if(b != null) send(b);
+                } catch (Exception e) {
                     LOG.warn(""Exception when using channel: "" + sid, e);
-                    finish();
-                    recvWorker.finish();
-                    recvWorker = null;
-                    
-                    ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
-                    if(bq != null){
-                        if (bq.size() == 0) {
-                            boolean ret = bq.offer(b);
-                            if (!ret) {
-                                // to appease findbugs
-                                LOG.error(""Not able to add to a quue of size 0"");
-                            }
-                        }
-                    } else LOG.error(""No queue for server "" + sid);
+                    this.finish();
                 }
             }
             LOG.warn(""Send worker leaving thread"");
@@ -521,7 +559,12 @@
             this.sid = sid;
             this.channel = channel;
         }
-
+        
+        /**
+         * Shuts down this worker
+         * 
+         * @return boolean  Value of variable running
+         */
         synchronized boolean finish() {
             running = false;
             this.interrupt();
@@ -533,7 +576,7 @@
             try {
                 byte[] size = new byte[4];
                 ByteBuffer msgLength = ByteBuffer.wrap(size);
-                while (running && !shutdown && channel.isConnected()) {
+                while (running && !shutdown && channel != null) {
                     /**
                      * Reads the first int to determine the length of the
                      * message
"
zookeeper,0a1f589b1ce96c09eb71b5492ece6bc99bfeec13,"ZOOKEEPER-457. Make ZookeeperMain public, support for HBase (and other) embedded clients",2009.08.01 05:32:02,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index c69390a..ba09f5e 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -60,7 +60,7 @@
         return printWatches;
     }
 
-    static void populateCommandMap() {
+    static {
         commandMap.put(""connect"", ""host:port"");
         commandMap.put(""close"","""");
         commandMap.put(""create"", ""[-s] [-e] path data acl"");
@@ -145,12 +145,13 @@
      */
     static private class MyCommandOptions {
 
-        private Map<String,String> options = null;
+        private Map<String,String> options = new HashMap<String,String>();
         private List<String> cmdArgs = null;
         private String command = null;
 
         public MyCommandOptions() {
-            options = null; command = null;
+          options.put(""server"", ""localhost:2181"");
+          options.put(""timeout"", ""30000"");
         }
 
         public String getOption(String opt) {
@@ -173,13 +174,6 @@
             return cmdArgs.toArray(new String[0]);
         }
 
-        private Map<String,String> buildDefaults( ) {
-            options = new HashMap<String,String>( );
-            options.put(""server"", ""localhost:2181"");
-            options.put(""timeout"", ""30000"");
-            return options;
-        }
-
         /**
          * Parses a command line that may contain one or more flags
          * before an optional command string
@@ -187,7 +181,6 @@
          * @return true if parsing succeeded, false otherwise.
          */
         public boolean parseOptions(String[] args) {
-            Map<String, String> ret = buildDefaults();
             List<String> argList = Arrays.asList(args);
             Iterator<String> it = argList.iterator();
 
@@ -195,9 +188,9 @@
                 String opt = it.next();
                 try {
                     if (opt.equals(""-server"")) {
-                        ret.put(""server"", it.next());
+                        options.put(""server"", it.next());
                     } else if (opt.equals(""-timeout"")) {
-                        ret.put(""timeout"", it.next());
+                        options.put(""timeout"", it.next());
                     }
                 } catch (NoSuchElementException e){
                     System.err.println(""Error: no argument found for option ""
@@ -271,7 +264,6 @@
     public static void main(String args[])
         throws KeeperException, IOException, InterruptedException
     {
-        populateCommandMap();
         ZooKeeperMain main = new ZooKeeperMain(args);
         main.run();
     }
@@ -284,6 +276,10 @@
 //                Integer.parseInt(cl.getOption(""timeout"")), new MyWatcher());
     }
 
+    public ZooKeeperMain(ZooKeeper zk) {
+      this.zk = zk;
+    }
+
     @SuppressWarnings(""unchecked"")
     void run() throws KeeperException, IOException, InterruptedException {
         if (cl.getCommand() == null) {
@@ -310,12 +306,7 @@
                 String line;
                 Method readLine = consoleC.getMethod(""readLine"", String.class);
                 while ((line = (String)readLine.invoke(console, getPrompt())) != null) {
-                    if (!line.equals("""")) {
-                        cl.parseCommand(line);
-                        addToHistory(commandCount,line);
-                        processCmd(cl);
-                        commandCount++;
-                    }
+                    executeLine(line);
                 }
             } catch (ClassNotFoundException e) {
                 LOG.debug(""Unable to start jline"", e);
@@ -341,12 +332,7 @@
 
                 String line;
                 while ((line = br.readLine()) != null) {
-                    if (!line.equals("""")) {
-                        cl.parseCommand(line);
-                        addToHistory(commandCount,line);
-                        processCmd(cl);
-                        commandCount++;
-                    }
+                    executeLine(line);
                 }
             }
         }
@@ -357,6 +343,16 @@
         }
     }
 
+    public void executeLine(String line)
+    throws InterruptedException, IOException, KeeperException {
+      if (!line.equals("""")) {
+        cl.parseCommand(line);
+        addToHistory(commandCount,line);
+        processCmd(cl);
+        commandCount++;
+      }
+    }
+
     private static DataCallback dataCallback = new DataCallback() {
 
         public void processResult(int rc, String path, Object ctx, byte[] data,
"
zookeeper,f884f500b035946775edb18baff564eaf5a69fad,ZOOKEEPER-487. setdata on root (/) crashes the servers,2009.08.01 04:07:59,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/common/PathTrie.java b/src/java/main/org/apache/zookeeper/common/PathTrie.java
index f285080..44aefe2 100644
--- a/src/java/main/org/apache/zookeeper/common/PathTrie.java
+++ b/src/java/main/org/apache/zookeeper/common/PathTrie.java
@@ -248,6 +248,9 @@
         if (path == null) {
             return null;
         }
+        if (""/"".equals(path)) {
+            return path;
+        }
         String[] pathComponents = path.split(""/"");
         TrieNode parent = rootNode;
         List<String> components = new ArrayList<String>();
"
zookeeper,4a59fd30d40d1cf2ef4b3c62e1d64047f246dba3,ZOOKEEPER-467.  Change log level in BookieHandle. (flavio via mahadev),2009.07.31 06:52:38,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookieHandle.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookieHandle.java
index 31dc62d..7444381 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookieHandle.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookieHandle.java
@@ -247,7 +247,7 @@
                         else ((SubReadOp) ts.ctx).rcb.readEntryComplete(-1, ts.lh.getId(), ts.entry, null, ts.ctx);
                         break;
                     }
-                } else LOG.warn(""Empty queue: "" + addr);
+                } else LOG.debug(""Empty queue: "" + addr);
             }
         } catch (Exception e){
             LOG.error(""Handling exception before halting BookieHandle"", e);
"
zookeeper,ac0a3bea3c75c074eb5e96a1393845d74c1b1022,ZOOKEEPER-454. allow compilation with jdk1.5,2009.07.01 05:56:35,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
index ad6f2bc..d4ed5a5 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
@@ -232,7 +232,6 @@
 		}
     }
 
-	@Override
 	synchronized public void setOwner(long id, Object owner) throws SessionExpiredException {
 		Session session = sessionsById.get(id);
 		if (session == null) {
"
zookeeper,8d2ae28491342663d9290114b8ecb182d6aa903e,ZOOKEEPER-453. Worker is not removed in QuorumCnxManager upon crash. (flavio via mahadev),2009.07.01 05:47:09,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 975f90f..90c8fbb 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -402,6 +402,7 @@
     }
     
     public void shutdown(){
+        LOG.debug(""Shutting down connection manager"");
         manager.halt();
     }
 
"
zookeeper,8d2ae28491342663d9290114b8ecb182d6aa903e,ZOOKEEPER-453. Worker is not removed in QuorumCnxManager upon crash. (flavio via mahadev),2009.07.01 05:47:09,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index f9426fc..ceb1b47 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -156,7 +156,7 @@
                         sock.connect(addr, self.tickTime * self.syncLimit);
                         sock.setTcpNoDelay(nodelay);
                         break;
-                    } catch (ConnectException e) {
+                    } catch (IOException e) {
                         if (tries == 4) {
                             LOG.error(""Unexpected exception"",e);
                             throw e;
"
zookeeper,8d2ae28491342663d9290114b8ecb182d6aa903e,ZOOKEEPER-453. Worker is not removed in QuorumCnxManager upon crash. (flavio via mahadev),2009.07.01 05:47:09,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 2702ac2..28ae03e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -155,6 +155,8 @@
         	    if(vsw != null)
         	        vsw.finish();
         	    else LOG.error(""No SendWorker for this identifier ("" + sid + "")"");
+        	} else {
+        	    LOG.error(""Cannot open channel to server ""  + sid);
         	}
 
         	if (!queueSendMap.containsKey(sid)) {
@@ -201,9 +203,19 @@
         //If wins the challenge, then close the new connection.
         if (sid < self.getId()) {
             try {
+                /*
+                 * This replica might still believe that the connection to sid
+                 * is up, so we have to shut down the workers before trying to
+                 * open a new connection.
+                 */
                 SendWorker sw = senderWorkerMap.get(sid);
-
-                LOG.info(""Create new connection to server: "" + sid);
+                if(sw != null)
+                    sw.finish();
+                
+                /*
+                 * Now we start a new connection
+                 */
+                LOG.debug(""Create new connection to server: "" + sid);
                 s.socket().close();
                 connectOne(sid);
                 
@@ -297,6 +309,7 @@
         if ((senderWorkerMap.get(sid) == null)) {
             SocketChannel channel;
             try {
+                LOG.debug(""Opening channel to server ""  + sid);
                 channel = SocketChannel
                         .open(self.quorumPeers.get(sid).electionAddr);
                 channel.socket().setTcpNoDelay(true);
@@ -304,6 +317,8 @@
             } catch (IOException e) {
                 LOG.warn(""Cannot open channel to "" + sid, e);
             }
+        } else {
+            LOG.error(""There is a connection for server "" + sid);
         }
     }
     
@@ -412,7 +427,7 @@
         Long sid;
         SocketChannel channel;
         RecvWorker recvWorker;
-        boolean running = true;
+        volatile boolean running = true;
 
         SendWorker(SocketChannel channel, Long sid) {
             this.sid = sid;
@@ -426,7 +441,7 @@
             this.recvWorker = recvWorker;
         }
 
-        boolean finish() {
+        synchronized boolean finish() {
             running = false;
 
             LOG.debug(""Calling finish"");
@@ -473,23 +488,20 @@
                      * message back to the beginning of the queue and leave.
                      */
                     LOG.warn(""Exception when using channel: "" + sid, e);
-                    running = false;
-                    synchronized (senderWorkerMap) {
-                        recvWorker.finish();
-                        recvWorker = null;
+                    finish();
+                    recvWorker.finish();
+                    recvWorker = null;
                     
-                        senderWorkerMap.remove(sid);
-                        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
-                        if(bq != null){
-                            if (bq.size() == 0) {
-                                boolean ret = bq.offer(b);
-                                if (!ret) {
-                                    // to appease findbugs
-                                    LOG.error(""Not able to add to a quue of size 0"");
-                                }
+                    ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
+                    if(bq != null){
+                        if (bq.size() == 0) {
+                            boolean ret = bq.offer(b);
+                            if (!ret) {
+                                // to appease findbugs
+                                LOG.error(""Not able to add to a quue of size 0"");
                             }
-                        } else LOG.error(""No queue for server "" + sid);
-                    }
+                        }
+                    } else LOG.error(""No queue for server "" + sid);
                 }
             }
             LOG.warn(""Send worker leaving thread"");
@@ -503,14 +515,14 @@
     class RecvWorker extends Thread {
         Long sid;
         SocketChannel channel;
-        boolean running = true;
+        volatile boolean running = true;
 
         RecvWorker(SocketChannel channel, Long sid) {
             this.sid = sid;
             this.channel = channel;
         }
 
-        boolean finish() {
+        synchronized boolean finish() {
             running = false;
             this.interrupt();
             return running;
@@ -555,7 +567,6 @@
 
             } catch (IOException e) {
                 LOG.warn(""Connection broken: "", e);
-
             } catch (InterruptedException e) {
                 LOG.warn(""Interrupted while trying to add new ""
                         + ""message to the reception queue"", e);
"
zookeeper,b37b8d6713c630901e46f0191b205061c0273133,ZOOKEEPER-450. emphemeral cleanup not happening with session timeout. (breed via mahadev),2009.06.30 10:32:11,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 735e020..6bb63d1 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -361,7 +361,10 @@
             case OpCode.closeSession:
                 txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
                         .getNextZxid(), zks.getTime(), OpCode.closeSession);
-                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
+                // We don't want to do this check since the session expiration thread
+                // queues up this operation without being the session owner.
+                // this request is the last of the session so it should be ok
+                //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                 HashSet<String> es = zks.dataTree
                         .getEphemerals(request.sessionId);
                 synchronized (zks.outstandingChanges) {
"
zookeeper,ed6a4639e787c8a68f8f4cbca740693927498ebb,ZOOKEEPER-449. sesssionmoved in java code and ZCLOSING in C have the same value. (mahadev),2009.06.27 06:15:58,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/KeeperException.java b/src/java/main/org/apache/zookeeper/KeeperException.java
index 79120e2..8c734ee 100644
--- a/src/java/main/org/apache/zookeeper/KeeperException.java
+++ b/src/java/main/org/apache/zookeeper/KeeperException.java
@@ -269,7 +269,7 @@
         /**
          * This value will be used directly in {@link CODE#SESSIONMOVED}
          */
-        // public static final int SessionMoved = -116;
+        // public static final int SessionMoved = -118;
     }
 
     /** Codes which represent the various KeeperException
@@ -332,7 +332,7 @@
         /** Client authentication failed */
         AUTHFAILED (AuthFailed),
         /** Session moved to another server, so operation is ignored */
-        SESSIONMOVED (-116);
+        SESSIONMOVED (-118);
 
         private static final Map<Integer,Code> lookup
             = new HashMap<Integer,Code>();
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/KeeperException.java b/src/java/main/org/apache/zookeeper/KeeperException.java
index 34ffe40..79120e2 100644
--- a/src/java/main/org/apache/zookeeper/KeeperException.java
+++ b/src/java/main/org/apache/zookeeper/KeeperException.java
@@ -118,7 +118,9 @@
                 return new SessionExpiredException();
             case INVALIDCALLBACK:
                 return new InvalidCallbackException();
-
+            case SESSIONMOVED:
+                return new SessionMovedException();
+            	
             case OK:
             default:
                 throw new IllegalArgumentException(""Invalid exception code"");
@@ -264,6 +266,10 @@
          */
         @Deprecated
         public static final int AuthFailed = -115;
+        /**
+         * This value will be used directly in {@link CODE#SESSIONMOVED}
+         */
+        // public static final int SessionMoved = -116;
     }
 
     /** Codes which represent the various KeeperException
@@ -296,7 +302,7 @@
         OPERATIONTIMEOUT (OperationTimeout),
         /** Invalid arguments */
         BADARGUMENTS (BadArguments),
-
+        
         /** API errors.
          * This is never thrown by the server, it shouldn't be used other than
          * to indicate a range. Specifically error codes greater than this
@@ -324,7 +330,9 @@
         /** Invalid ACL specified */
         INVALIDACL (InvalidACL),
         /** Client authentication failed */
-        AUTHFAILED (AuthFailed);
+        AUTHFAILED (AuthFailed),
+        /** Session moved to another server, so operation is ignored */
+        SESSIONMOVED (-116);
 
         private static final Map<Integer,Code> lookup
             = new HashMap<Integer,Code>();
@@ -397,6 +405,8 @@
                 return ""Session expired"";
             case INVALIDCALLBACK:
                 return ""Invalid callback"";
+            case SESSIONMOVED:
+                return ""Session moved"";
             default:
                 return ""Unknown error "" + code;
         }
@@ -601,6 +611,15 @@
             super(Code.SESSIONEXPIRED);
         }
     }
+    
+    /**
+     * @see Code#SESSIONMOVED
+     */
+    public static class SessionMovedException extends KeeperException {
+        public SessionMovedException() {
+            super(Code.SESSIONMOVED);
+        }
+    }
 
     /**
      * @see Code#SYSTEMERROR
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index 18b29c3..0669158 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -137,6 +137,11 @@
                 throw KeeperException.create(KeeperException.Code.get((
                         (ErrorTxn) request.txn).getErr()));
             }
+            
+            KeeperException ke = request.getException();
+            if (ke != null) {
+                throw ke;
+            }
 
             if (LOG.isDebugEnabled()) {
                 LOG.debug(request);
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 1f61047..7fb0824 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -70,6 +70,10 @@
 
     private ConnectionBean jmxConnectionBean;
 
+    // This is just an arbitrary object to represent requests issued by
+    // (aka owned by) this class
+    final private static Object me = new Object();
+
     static public class Factory extends Thread {
         ZooKeeperServer zks;
 
@@ -280,7 +284,12 @@
 
         synchronized void closeSession(long sessionId) {
             selector.wakeup();
-            synchronized (cnxns) {
+            closeSessionWithoutWakeup(sessionId);
+        }
+
+
+		private void closeSessionWithoutWakeup(long sessionId) {
+			synchronized (cnxns) {
                 for (Iterator<NIOServerCnxn> it = cnxns.iterator(); it
                         .hasNext();) {
                     NIOServerCnxn cnxn = it.next();
@@ -534,8 +543,9 @@
             }
             return;
         } else {
-            zk.submitRequest(this, sessionId, h.getType(), h.getXid(),
-                    incomingBuffer, authInfo);
+            Request si = new Request(this, sessionId, h.getXid(), h.getType(), incomingBuffer, authInfo);
+            si.setOwner(me);
+            zk.submitRequest(si);
         }
         if (h.getXid() >= 0) {
             synchronized (this) {
@@ -599,6 +609,7 @@
         // session is setup
         disableRecv();
         if (connReq.getSessionId() != 0) {
+        	factory.closeSessionWithoutWakeup(connReq.getSessionId());
             setSessionId(connReq.getSessionId());
             zk.reopenSession(this, sessionId, passwd, sessionTimeout);
             LOG.info(""Renewing session 0x"" + Long.toHexString(sessionId));
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index c15f011..735e020 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -208,7 +208,7 @@
             case OpCode.create:
                 txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
                         .getNextZxid(), zks.getTime(), OpCode.create);
-                zks.sessionTracker.checkSession(request.sessionId);
+                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                 CreateRequest createRequest = new CreateRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         createRequest);
@@ -270,7 +270,7 @@
             case OpCode.delete:
                 txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
                         .getNextZxid(), zks.getTime(), OpCode.delete);
-                zks.sessionTracker.checkSession(request.sessionId);
+                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                 DeleteRequest deleteRequest = new DeleteRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         deleteRequest);
@@ -304,7 +304,7 @@
             case OpCode.setData:
                 txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
                         .getNextZxid(), zks.getTime(), OpCode.setData);
-                zks.sessionTracker.checkSession(request.sessionId);
+                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                 SetDataRequest setDataRequest = new SetDataRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         setDataRequest);
@@ -326,7 +326,7 @@
             case OpCode.setACL:
                 txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
                         .getNextZxid(), zks.getTime(), OpCode.setACL);
-                zks.sessionTracker.checkSession(request.sessionId);
+                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                 SetACLRequest setAclRequest = new SetACLRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         setAclRequest);
@@ -356,10 +356,12 @@
                 txn = new CreateSessionTxn(to);
                 request.request.rewind();
                 zks.sessionTracker.addSession(request.sessionId, to);
+                zks.sessionTracker.setOwner(request.sessionId, request.getOwner());
                 break;
             case OpCode.closeSession:
                 txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
                         .getNextZxid(), zks.getTime(), OpCode.closeSession);
+                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                 HashSet<String> es = zks.dataTree
                         .getEphemerals(request.sessionId);
                 synchronized (zks.outstandingChanges) {
@@ -386,6 +388,7 @@
             case OpCode.getChildren:
             case OpCode.ping:
             case OpCode.setWatches:
+            	zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                 break;
             }
         } catch (KeeperException e) {
@@ -393,6 +396,8 @@
                 txnHeader.setType(OpCode.error);
                 txn = new ErrorTxn(e.code().intValue());
             }
+            LOG.warn(""Got exception when processing "" + request.toString(), e);
+            request.setException(e);
         } catch (Exception e) {
             // log at error level as we are returning a marshalling
             // error to the user
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/Request.java b/src/java/main/org/apache/zookeeper/server/Request.java
index b6a1f2f..27f0a26 100644
--- a/src/java/main/org/apache/zookeeper/server/Request.java
+++ b/src/java/main/org/apache/zookeeper/server/Request.java
@@ -23,6 +23,7 @@
 
 import org.apache.jute.Record;
 import org.apache.log4j.Logger;
+import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.data.Id;
 import org.apache.zookeeper.txn.TxnHeader;
@@ -74,6 +75,18 @@
     public List<Id> authInfo;
 
     public long createTime = System.currentTimeMillis();
+    
+    private Object owner;
+    
+    private KeeperException e;
+    
+    public Object getOwner() {
+        return owner;
+    }
+    
+    public void setOwner(Object owner) {
+        this.owner = owner;
+    }
 
     /**
      * is the packet type a valid packet in zookeeper
@@ -194,4 +207,12 @@
 
         return sb.toString();
     }
+
+    public void setException(KeeperException e) {
+        this.e = e;
+    }
+	
+    public KeeperException getException() {
+        return e;
+    }
 }
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTracker.java b/src/java/main/org/apache/zookeeper/server/SessionTracker.java
index 2297245..b494504 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTracker.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTracker.java
@@ -19,6 +19,8 @@
 package org.apache.zookeeper.server;
 
 import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.KeeperException.SessionExpiredException;
+import org.apache.zookeeper.KeeperException.SessionMovedException;
 
 /**
  * This is the basic interface that ZooKeeperServer uses to track sessions. The
@@ -54,5 +56,7 @@
      */
     void removeSession(long sessionId);
 
-    void checkSession(long sessionId) throws KeeperException.SessionExpiredException;
+    void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, SessionMovedException;
+
+    void setOwner(long id, Object owner) throws SessionExpiredException;
 }
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
index fef7b92..ad6f2bc 100644
--- a/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
+++ b/src/java/main/org/apache/zookeeper/server/SessionTrackerImpl.java
@@ -28,6 +28,8 @@
 
 import org.apache.log4j.Logger;
 import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.KeeperException.SessionExpiredException;
+import org.apache.zookeeper.KeeperException.SessionMovedException;
 
 /**
  * This is a full featured SessionTracker. It tracks session in grouped by tick
@@ -57,6 +59,8 @@
         long tickTime;
 
         long sessionId;
+        
+        Object owner;
     }
 
     public static long initializeNextSession(long id) {
@@ -216,9 +220,24 @@
         touchSession(id, sessionTimeout);
     }
 
-    public void checkSession(long sessionId) throws KeeperException.SessionExpiredException {
-        if (sessionsById.get(sessionId) == null) {
+    synchronized public void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException {
+        Session session = sessionsById.get(sessionId);
+		if (session == null) {
             throw new KeeperException.SessionExpiredException();
         }
+		if (session.owner == null) {
+			session.owner = owner;
+		} else if (session.owner != owner) {
+			throw new KeeperException.SessionMovedException();
+		}
     }
+
+	@Override
+	synchronized public void setOwner(long id, Object owner) throws SessionExpiredException {
+		Session session = sessionsById.get(id);
+		if (session == null) {
+            throw new KeeperException.SessionExpiredException();
+        }
+		session.owner = owner;
+	}
 }
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index bed0eb8..0b0c430 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -534,7 +534,7 @@
      * @param xid
      * @param bb
      */
-    public void submitRequest(ServerCnxn cnxn, long sessionId, int type,
+    private void submitRequest(ServerCnxn cnxn, long sessionId, int type,
             int xid, ByteBuffer bb, List<Id> authInfo) {
         Request si = new Request(cnxn, sessionId, xid, type, bb, authInfo);
         submitRequest(si);
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
index 271c4dc..8e0ac46 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
@@ -33,7 +33,9 @@
 import org.apache.jute.BinaryOutputArchive;
 import org.apache.jute.Record;
 import org.apache.log4j.Logger;
+import org.apache.zookeeper.KeeperException.SessionExpiredException;
 import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.ZooTrace;
 import org.apache.zookeeper.server.quorum.Leader.Proposal;
 import org.apache.zookeeper.server.util.SerializeUtils;
@@ -351,6 +353,13 @@
                     DataOutputStream dos = new DataOutputStream(bos);
                     dos.writeLong(id);
                     boolean valid = leader.zk.touch(id, to);
+                    if (valid) {
+                        try {
+                            leader.zk.setOwner(id, this);
+                        } catch (SessionExpiredException e) {
+                            LOG.error(""Somehow session "" + Long.toHexString(id) + "" expired right after being renewed! (impossible)"", e);
+                        }
+                    }
                     if (LOG.isTraceEnabled()) {
                         ZooTrace.logTraceMessage(LOG,
                                                  ZooTrace.SESSION_TRACE_MASK,
@@ -371,8 +380,9 @@
                      	leader.zk.submitRequest(new FollowerSyncRequest(this, sessionId, cxid, type, bb,
                                 qp.getAuthinfo()));
                     } else {
-                    leader.zk.submitRequest(null, sessionId, type, cxid, bb,
-                            qp.getAuthinfo());
+                        Request si = new Request(null, sessionId, cxid, type, bb, qp.getAuthinfo());
+                        si.setOwner(this);
+                        leader.zk.submitRequest(si);
                     }
                     break;
                 default:
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerSessionTracker.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerSessionTracker.java
index 5e0dae0..5da2f50 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerSessionTracker.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerSessionTracker.java
@@ -79,7 +79,11 @@
         return (nextSessionId++);
     }
 
-    public void checkSession(long sessionId)  {
+    public void checkSession(long sessionId, Object owner)  {
+        // Nothing to do here. Sessions are checked at the Leader
+    }
+    
+    public void setOwner(long sessionId, Object owner) {
         // Nothing to do here. Sessions are checked at the Leader
     }
 }
"
zookeeper,0057dcb78313be28ae16b7e84c873191471dceee,ZOOKEEPER-417. stray message problem when changing servers (breed via mahadev),2009.06.27 05:29:54,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
index 82c0fd8..55f1b74 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
@@ -20,11 +20,13 @@
 
 import java.io.IOException;
 
+import org.apache.zookeeper.KeeperException.SessionExpiredException;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.server.DataTreeBean;
 import org.apache.zookeeper.server.FinalRequestProcessor;
 import org.apache.zookeeper.server.PrepRequestProcessor;
 import org.apache.zookeeper.server.RequestProcessor;
+import org.apache.zookeeper.server.ServerCnxn;
 import org.apache.zookeeper.server.SessionTrackerImpl;
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
@@ -151,4 +153,19 @@
     public String getState() {
         return ""leader"";
     }
+
+    public void setOwner(long id, Object owner) throws SessionExpiredException {
+        sessionTracker.setOwner(id, owner);
+    }
+
+    @Override
+    protected void revalidateSession(ServerCnxn cnxn, long sessionId,
+        int sessionTimeout) throws IOException, InterruptedException {
+        super.revalidateSession(cnxn, sessionId, sessionTimeout);
+        try {
+            setOwner(sessionId, this);
+        } catch (SessionExpiredException e) {
+            // this is ok, it just means that the session revalidation failed.
+        }
+    }
 }
"
zookeeper,32b76dabd04b8ee71148dce562919f74b7addfeb,ZOOKEEPER-438.  addauth fails to register auth on new client that's not yet connected (breed via mahadev),2009.06.26 05:41:37,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index bb7dd30..b07267b 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -1130,11 +1130,12 @@
     }
 
     public void addAuthInfo(String scheme, byte auth[]) {
-        authInfo.add(new AuthData(scheme, auth));
-        if (zooKeeper.state == States.CONNECTED) {
-            queuePacket(new RequestHeader(-4, OpCode.auth), null,
-                    new AuthPacket(0, scheme, auth), null, null, null, null,
-                    null, null);
+        if (!zooKeeper.state.isAlive()) {
+            return;
         }
+        authInfo.add(new AuthData(scheme, auth));
+        queuePacket(new RequestHeader(-4, OpCode.auth), null,
+                new AuthPacket(0, scheme, auth), null, null, null, null,
+                null, null);
     }
 }
"
zookeeper,cbd8be492393d9409ac0ee8c2dbb7c1bbad3cab3,ZOOKEEPER-446. some traces of the host auth scheme left (breed via mahadev),2009.06.23 05:53:05,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index ef94145..1f61047 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -780,7 +780,6 @@
         InetAddress addr = ((InetSocketAddress) sock.socket()
                 .getRemoteSocketAddress()).getAddress();
         authInfo.add(new Id(""ip"", addr.getHostAddress()));
-        authInfo.add(new Id(""host"", addr.getCanonicalHostName()));
         sk.interestOps(SelectionKey.OP_READ);
     }
 
"
zookeeper,cbd8be492393d9409ac0ee8c2dbb7c1bbad3cab3,ZOOKEEPER-446. some traces of the host auth scheme left (breed via mahadev),2009.06.23 05:53:05,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java b/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
index c166ff4..948452e 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
@@ -37,10 +37,8 @@
             if (initialized)
                 return;
             IPAuthenticationProvider ipp = new IPAuthenticationProvider();
-            HostAuthenticationProvider hostp = new HostAuthenticationProvider();
             DigestAuthenticationProvider digp = new DigestAuthenticationProvider();
             authenticationProviders.put(ipp.getScheme(), ipp);
-            authenticationProviders.put(hostp.getScheme(), hostp);
             authenticationProviders.put(digp.getScheme(), digp);
             Enumeration<Object> en = System.getProperties().keys();
             while (en.hasMoreElements()) {
"
zookeeper,d41b671bd683600267b68df69beec38f681a189e,ZOOKEEPER-427. ZooKeeper server unexpectedly high CPU utilisation,2009.06.19 05:32:51,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index f788535..2702ac2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -527,7 +527,9 @@
                      * message
                      */
                     while (msgLength.hasRemaining()) {
-                        channel.read(msgLength);
+                        if (channel.read(msgLength) < 0) {
+                            throw new IOException(""Channel eof"");
+                        }
                     }
                     msgLength.position(0);
                     int length = msgLength.getInt();
"
zookeeper,360fc24572f0ba75362253450fea50dd48d2ea13,ZOOKEEPER-433.  getacl on root znode (/) fails. (phunt via mahadev),2009.06.18 10:08:52,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index d9e3928..d3399c1 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -21,6 +21,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -43,7 +44,9 @@
 import org.apache.zookeeper.Watcher.Event;
 import org.apache.zookeeper.Watcher.Event.EventType;
 import org.apache.zookeeper.Watcher.Event.KeeperState;
+import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.ZooDefs.Perms;
 import org.apache.zookeeper.common.PathTrie;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
@@ -193,15 +196,17 @@
         aclKeyMap.put(acls, val);
         return val;
     }
-    
+
     /**
      * converts a list of longs to a list of acls. 
      * @param longs the list of longs 
      * @return a list of ACLs that map to longs
      */
     public synchronized List<ACL> convertLong(Long longVal) {
-        if (longVal == null || longVal == -1L) 
+        if (longVal == null) 
             return null;
+        if (longVal == -1L)
+            return Ids.OPEN_ACL_UNSAFE;
         List<ACL> acls = longKeyMap.get(longVal);
         if (acls == null) {
             LOG.error(""ERROR: ACL not available for long "" + longVal);
"
zookeeper,360fc24572f0ba75362253450fea50dd48d2ea13,ZOOKEEPER-433.  getacl on root znode (/) fails. (phunt via mahadev),2009.06.18 10:08:52,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 1cc3887..119beed 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -439,7 +439,8 @@
                 }
                 boolean authIdValid = false;
                 for (Id cid : authInfo) {
-                    AuthenticationProvider ap = ProviderRegistry.getProvider(cid.getScheme());
+                    AuthenticationProvider ap =
+                        ProviderRegistry.getProvider(cid.getScheme());
                     if (ap == null) {
                         LOG.error(""Missing AuthenticationProvider for ""
                                 + cid.getScheme());
"
zookeeper,094dda343f05b354ac2cf4ede057afd363253a32,ZOOKEEPER-444. perms definition for PERMS_ALL differ in C and java (mahadev),2009.06.18 02:36:39,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooDefs.java b/src/java/main/org/apache/zookeeper/ZooDefs.java
index 55dd9f7..b4aab1a 100644
--- a/src/java/main/org/apache/zookeeper/ZooDefs.java
+++ b/src/java/main/org/apache/zookeeper/ZooDefs.java
@@ -70,7 +70,7 @@
 
         int ADMIN = 1 << 4;
 
-        int ALL = READ | WRITE | CREATE | DELETE;
+        int ALL = READ | WRITE | CREATE | DELETE | ADMIN;
     }
 
     public interface Ids {
@@ -86,7 +86,7 @@
         public final Id AUTH_IDS = new Id(""auth"", """");
 
         /**
-         * This is a completely open ACL with the exception of ADMIN permission.
+         * This is a completely open ACL .
          */
         public final ArrayList<ACL> OPEN_ACL_UNSAFE = new ArrayList<ACL>(
                 Collections.singletonList(new ACL(Perms.ALL, ANYONE_ID_UNSAFE)));
"
zookeeper,601320c3379194eb90a3b57a5f27e703727aa690,"ZOOKEEPER-435. allow ""super"" admin digest based auth to be configurable",2009.06.09 14:21:27,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/DigestAuthenticationProvider.java b/src/java/main/org/apache/zookeeper/server/auth/DigestAuthenticationProvider.java
index 9e3faf1..c2c20e9 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/DigestAuthenticationProvider.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/DigestAuthenticationProvider.java
@@ -18,7 +18,6 @@
 
 package org.apache.zookeeper.server.auth;
 
-import java.io.IOException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
@@ -28,9 +27,16 @@
 import org.apache.zookeeper.server.ServerCnxn;
 
 public class DigestAuthenticationProvider implements AuthenticationProvider {
-    private static final Logger LOG = Logger.getLogger(DigestAuthenticationProvider.class);
+    private static final Logger LOG =
+        Logger.getLogger(DigestAuthenticationProvider.class);
 
-    public final static String superDigest = ""super:1wZ8qIvQBMTq0KPxMc6RQ/PCXKM="";
+    /** specify a command line property with key of 
+     * ""zookeeper.DigestAuthenticationProvider.superDigest""
+     * and value of ""super:<base64encoded(SHA1(password))>"" to enable
+     * super user access (i.e. acls disabled)
+     */
+    private final static String superDigest = System.getProperty(
+        ""zookeeper.DigestAuthenticationProvider.superDigest"");
 
     public String getScheme() {
         return ""digest"";
@@ -119,8 +125,12 @@
         return id.equals(aclExpr);
     }
 
-    public static void main(String args[]) throws IOException,
-            NoSuchAlgorithmException {
+    /** Call with a single argument of user:pass to generate authdata.
+     * Authdata output can be used when setting superDigest for example. 
+     * @param args single argument of user:pass
+     * @throws NoSuchAlgorithmException
+     */
+    public static void main(String args[]) throws NoSuchAlgorithmException {
         for (int i = 0; i < args.length; i++) {
             System.out.println(args[i] + ""->"" + generateDigest(args[i]));
         }
"
zookeeper,32b1f3d03daec38f9c5b29fb003fffe75b02e51c,ZOOKEEPER-192.  trailing whitespace in config file can cause number format exceptions,2009.05.23 04:02:04,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index a1c50b8..6d8475f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -103,8 +103,8 @@
     protected void parseProperties(Properties zkProp)
     throws IOException, ConfigException {
         for (Entry<Object, Object> entry : zkProp.entrySet()) {
-            String key = entry.getKey().toString();
-            String value = entry.getValue().toString();
+            String key = entry.getKey().toString().trim();
+            String value = entry.getValue().toString().trim();
             if (key.equals(""dataDir"")) {
                 dataDir = value;
             } else if (key.equals(""dataLogDir"")) {
"
zookeeper,c611de04703c9f6d27b3349b0d06a297dfc46fc1,ZOOKEEPER-405 nullpointer exception in zookeeper java shell.,2009.05.21 02:58:56,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index de77287..b337cdd 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -613,6 +613,7 @@
         } else if (cmd.equals(""get"") && args.length >= 2) {
             path = args[1];
             byte data[] = zk.getData(path, watch, stat);
+            data = (data == null)? ""null"".getBytes() : data;
             System.out.println(new String(data));
             printStat(stat);
         } else if (cmd.equals(""ls"") && args.length >= 2) {
"
zookeeper,0566dc00b3fe9af48ea856a587ceee56fcc24cd8,ZOOKEEPER-400. Issues with procedure to close ledger. (flavio),2009.05.14 17:21:16,Flavio Paiva Junqueira,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/ClientCBWorker.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/ClientCBWorker.java
index 6305b9f..d27f3ed 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/ClientCBWorker.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/ClientCBWorker.java
@@ -113,10 +113,11 @@
                     case Operation.ADD:
                         AddOp aOp = (AddOp) op;
                     
+                        aOp.getLedger().setAddConfirmed(aOp.entry);
                         aOp.cb.addComplete(aOp.getErrorCode(),
                             aOp.getLedger().getId(), aOp.entry, 
                             aOp.ctx);
-                        aOp.getLedger().setAddConfirmed(aOp.entry);
+                        
                         break;
                     case Operation.READ:
                         ReadOp rOp = (ReadOp) op;
"
zookeeper,0566dc00b3fe9af48ea856a587ceee56fcc24cd8,ZOOKEEPER-400. Issues with procedure to close ledger. (flavio),2009.05.14 17:21:16,Flavio Paiva Junqueira,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
index 4f1bf94..1b0df87 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
@@ -444,8 +444,8 @@
     throws KeeperException, InterruptedException {
         //Set data on zookeeper
         ByteBuffer last = ByteBuffer.allocate(8);
-        last.putLong(getLast());
-        LOG.info(""Last saved on ZK is: "" + getLast());
+        last.putLong(lastAddConfirmed);
+        LOG.info(""Last saved on ZK is: "" + lastAddConfirmed);
         String closePath = BookKeeper.prefix + bk.getZKStringId(getId()) + BookKeeper.close; 
         if(bk.getZooKeeper().exists(closePath, false) == null){
            bk.getZooKeeper().create(closePath, 
"
zookeeper,0566dc00b3fe9af48ea856a587ceee56fcc24cd8,ZOOKEEPER-400. Issues with procedure to close ledger. (flavio),2009.05.14 17:21:16,Flavio Paiva Junqueira,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java
index 00df7d8..91922c4 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java
@@ -150,14 +150,12 @@
                     hasMore = false;
                     LOG.debug(""Recovering: "" + lh.getLast());
                     LedgerSequence ls = lh.readEntries(lh.getLast(), lh.getLast());
-                    //if(ls == null) throw BKException.create(Code.ReadException);
                     LOG.debug(""Received entry for: "" + lh.getLast());
                     
                     byte[] le = ls.nextElement().getEntry();
                     if(le != null){
                         if(notLegitimate) notLegitimate = false;
                         lh.addEntry(le);
-                        //lh.incLast();
                         hasMore = true;
                     }
                 }
@@ -168,7 +166,7 @@
          * Write counter as the last entry of ledger
          */
         if(!notLegitimate){
-            //lh.setLast(readCounter);
+            lh.setAddConfirmed(readCounter);
             lh.close();
             
             return true;
"
zookeeper,79de509219862735d0db1ff966aacb67430e0c89,ZOOKEEPER-391. bookeeper mainline code should not be calling printStackTrace. (flavio via mahadev),2009.05.13 05:59:33,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java
index c84eb8f..4b2cada 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java
@@ -267,10 +267,8 @@
                 }
                 toFlush.add(qe);
             }
-        } catch (InterruptedException e) {
-            LOG.debug(""Bookie thread exiting due to interrupt"");
         } catch (Exception e) {
-            e.printStackTrace();
+            LOG.fatal(""Bookie thread exiting"", e);
         }
     }
 
"
zookeeper,79de509219862735d0db1ff966aacb67430e0c89,ZOOKEEPER-391. bookeeper mainline code should not be calling printStackTrace. (flavio via mahadev),2009.05.13 05:59:33,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookieHandle.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookieHandle.java
index ff0aeb4..63fd3dd 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookieHandle.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/BookieHandle.java
@@ -112,7 +112,7 @@
         try{
             incomingQueue.put(new ToSend(lh, r, entry));
         } catch(InterruptedException e){
-            e.printStackTrace();
+            LOG.warn(""Interrupted while waiting for room in the incoming queue"");
         }
     }
     
@@ -147,7 +147,7 @@
         try{
             incomingQueue.put(new ToSend(lh, r, entry));
         } catch(InterruptedException e){
-            e.printStackTrace();
+            LOG.warn(""Interrupted while waiting for room in the incoming queue"");
         }
     }
     
"
zookeeper,79de509219862735d0db1ff966aacb67430e0c89,ZOOKEEPER-391. bookeeper mainline code should not be calling printStackTrace. (flavio via mahadev),2009.05.13 05:59:33,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/BookieClient.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/BookieClient.java
index e9daf5a..ba603f0 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/BookieClient.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/BookieClient.java
@@ -312,8 +312,7 @@
                 }
             }
         } catch(Exception e) {
-            LOG.error(""Len = "" + len + "", Type = "" + type + "", rc = "" + rc);
-            e.printStackTrace();
+            LOG.error(""Len = "" + len + "", Type = "" + type + "", rc = "" + rc, e);
         }
     }
 
"
zookeeper,79de509219862735d0db1ff966aacb67430e0c89,ZOOKEEPER-391. bookeeper mainline code should not be calling printStackTrace. (flavio via mahadev),2009.05.13 05:59:33,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/NIOServerFactory.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/NIOServerFactory.java
index a3f7a99..79533eb 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/NIOServerFactory.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/proto/NIOServerFactory.java
@@ -118,7 +118,6 @@
                 selected.clear();
             } catch (Exception e) {
                 LOG.warn(e);
-                e.printStackTrace();
             }
         }
         LOG.debug(""NIOServerCnxn factory exitedloop."");
"
zookeeper,79de509219862735d0db1ff966aacb67430e0c89,ZOOKEEPER-391. bookeeper mainline code should not be calling printStackTrace. (flavio via mahadev),2009.05.13 05:59:33,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
index dc39d4c..ff751dc 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/util/LocalBookKeeper.java
@@ -39,8 +39,10 @@
 import org.apache.zookeeper.server.ServerStats;
 import org.apache.zookeeper.server.ZooKeeperServer;
 
+import org.apache.log4j.Logger;
+
 public class LocalBookKeeper {
-	Logger LOG;
+    Logger LOG = Logger.getLogger(LocalBookKeeper.class);
 	ConsoleAppender ca;
 	int numberOfBookies;
 	
@@ -87,13 +89,11 @@
 			zks = new ZooKeeperServer(ZkTmpDir, ZkTmpDir, ZooKeeperDefaultPort);
 			serverFactory =  new NIOServerCnxn.Factory(ZooKeeperDefaultPort);
 			serverFactory.startup(zks);
-		} catch (IOException e1) {
+		} catch (Exception e) {
 			// TODO Auto-generated catch block
-			e1.printStackTrace();
-		} catch (InterruptedException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
+			LOG.fatal(""Exception while instantiating ZooKeeper"", e);
+		} 
+		
         boolean b = ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT);
         LOG.debug(""ZooKeeper server up: "" + b);
 	}
@@ -112,13 +112,13 @@
 			}
 		} catch (KeeperException e) {
 			// TODO Auto-generated catch block
-			e.printStackTrace();
+			LOG.fatal(""Exception while creating znodes"", e);
 		} catch (InterruptedException e) {
 			// TODO Auto-generated catch block
-			e.printStackTrace();
+			LOG.fatal(""Interrupted while creating znodes"", e);
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
-			e.printStackTrace();
+			LOG.fatal(""Exception while creating znodes"", e);
 		}		
 	}
 	private void runBookies() throws IOException{
"
zookeeper,b4510d2b69db980525be0fcb6e11b692c690ac24,ZOOKEEPER-384. keeper exceptions missing path (phunt via mahadev),2009.05.05 13:55:31,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 3fc586d..49fc680 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -585,7 +585,8 @@
         request.setVersion(version);
         ReplyHeader r = cnxn.submitRequest(h, request, null, null);
         if (r.getErr() != 0) {
-            throw KeeperException.create(KeeperException.Code.get(r.getErr()));
+            throw KeeperException.create(KeeperException.Code.get(r.getErr()),
+                    path);
         }
     }
 
@@ -643,7 +644,8 @@
             if (r.getErr() == KeeperException.Code.NONODE.intValue()) {
                 return null;
             }
-            throw KeeperException.create(KeeperException.Code.get(r.getErr()));
+            throw KeeperException.create(KeeperException.Code.get(r.getErr()),
+                    path);
         }
 
         return response.getStat().getCzxid() == -1 ? null : response.getStat();
@@ -743,7 +745,8 @@
         }
         ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);
         if (r.getErr() != 0) {
-            throw KeeperException.create(KeeperException.Code.get(r.getErr()));
+            throw KeeperException.create(KeeperException.Code.get(r.getErr()),
+                    path);
         }
         if (stat != null) {
             DataTree.copyStat(response.getStat(), stat);
@@ -848,7 +851,8 @@
         SetDataResponse response = new SetDataResponse();
         ReplyHeader r = cnxn.submitRequest(h, request, response, null);
         if (r.getErr() != 0) {
-            throw KeeperException.create(KeeperException.Code.get(r.getErr()));
+            throw KeeperException.create(KeeperException.Code.get(r.getErr()),
+                    path);
         }
         return response.getStat();
     }
@@ -901,7 +905,8 @@
         GetACLResponse response = new GetACLResponse();
         ReplyHeader r = cnxn.submitRequest(h, request, response, null);
         if (r.getErr() != 0) {
-            throw KeeperException.create(KeeperException.Code.get(r.getErr()));
+            throw KeeperException.create(KeeperException.Code.get(r.getErr()),
+                    path);
         }
         DataTree.copyStat(response.getStat(), stat);
         return response.getAcl();
@@ -962,7 +967,8 @@
         SetACLResponse response = new SetACLResponse();
         ReplyHeader r = cnxn.submitRequest(h, request, response, null);
         if (r.getErr() != 0) {
-            throw KeeperException.create(KeeperException.Code.get(r.getErr()));
+            throw KeeperException.create(KeeperException.Code.get(r.getErr()),
+                    path);
         }
         return response.getStat();
     }
@@ -1026,7 +1032,8 @@
         }
         ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);
         if (r.getErr() != 0) {
-            throw KeeperException.create(KeeperException.Code.get(r.getErr()));
+            throw KeeperException.create(KeeperException.Code.get(r.getErr()),
+                    path);
         }
         return response.getChildren();
     }
"
zookeeper,7955dea8215faeeedd347654e9b126cae30a1fa8,ZOOKEEPER-365. javadoc is wrong for setLast in LedgerHandle,2009.04.30 04:16:29,Patrick D. Hunt,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
index 5423fca..a2518eb 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerHandle.java
@@ -254,8 +254,10 @@
     }
     
     /**
-     * Returns the last entry identifier submitted and increments it.
-     * @return long
+     * Sets the last entry identifier submitted.
+     * 
+     * @param   last    last entry
+     * @return  long    returns the value just set
      */
     long setLast(long last){
         this.last = last;
"
zookeeper,7955dea8215faeeedd347654e9b126cae30a1fa8,ZOOKEEPER-365. javadoc is wrong for setLast in LedgerHandle,2009.04.30 04:16:29,Patrick D. Hunt,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java
index b88f4e1..23b951d 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java
@@ -229,6 +229,14 @@
         
     }
     
+    /**
+     * Returns one hint at a time. We add a new hint to
+     * the ""hints"" TreeMap used in this method upon a read
+     * callback. Such callbacks correspond to returned values from bookies upon a request
+     * for the last entry written hint.
+     * 
+     * @return long next hint
+     */
     private long getNextHint(){
         if(hints.size() == 0) return -1;
         
"
zookeeper,4a5a9673545474d3d69efc6803005140cdde089e,ZOOKEEPER-346. remove the kill command fro mthe client port. (phunt via mahadev),2009.04.18 05:48:29,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index dfbb90d..a35fe7e 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -564,10 +564,6 @@
                 sendBuffer(NIOServerCnxn.closeConn);
                 k.interestOps(SelectionKey.OP_WRITE);
                 return;
-            } else if (len == killCmd) {
-                LOG.info(""Processing kill command from ""
-                        + sock.socket().getRemoteSocketAddress());
-                System.exit(0);
             } else if (len == getTraceMaskCmd) {
                 LOG.info(""Processing getracemask command from ""
                         + sock.socket().getRemoteSocketAddress());
"
zookeeper,4a5a9673545474d3d69efc6803005140cdde089e,ZOOKEEPER-346. remove the kill command fro mthe client port. (phunt via mahadev),2009.04.18 05:48:29,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
index 89147f4..4d24ab1 100644
--- a/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/ServerCnxn.java
@@ -35,8 +35,6 @@
      * See <a href=""{@docRoot}/../../../docs/zookeeperAdmin.html#sc_zkCommands"">
      * Zk Admin</a>. this link is for all the commands.
      */
-    final static int killCmd = ByteBuffer.wrap(""kill"".getBytes()).getInt();
-    
     final static int ruokCmd = ByteBuffer.wrap(""ruok"".getBytes()).getInt();
 
     final static int dumpCmd = ByteBuffer.wrap(""dump"".getBytes()).getInt();
"
zookeeper,1e1ccdcfb19a60e50b9393feac7c0322048e20e1,ZOOKEEPER-367. RecoveryTest failure - 'unreasonable length' IOException,2009.04.18 03:11:43,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/jute/BinaryInputArchive.java b/src/java/main/org/apache/jute/BinaryInputArchive.java
index e802d45..5471760 100644
--- a/src/java/main/org/apache/jute/BinaryInputArchive.java
+++ b/src/java/main/org/apache/jute/BinaryInputArchive.java
@@ -98,7 +98,7 @@
         int len = readInt(tag);
         if (len == -1) return null;
         if (len < 0 || len > maxBuffer) {
-            throw new RuntimeException(""Unreasonable length = "" + len);
+            throw new IOException(""Unreasonable length = "" + len);
         }
         byte[] arr = new byte[len];
         in.readFully(arr);
"
zookeeper,1e1ccdcfb19a60e50b9393feac7c0322048e20e1,ZOOKEEPER-367. RecoveryTest failure - 'unreasonable length' IOException,2009.04.18 03:11:43,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
index ad0c55b..639db1a 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
@@ -64,22 +64,44 @@
      */
     public long deserialize(DataTree dt, Map<Long, Integer> sessions)
             throws IOException {
-        File snap = findMostRecentSnapshot();
-        if (snap == null) {
+        // we run through 100 snapshots (not all of them)
+        // if we cannot get it running within 100 snapshots
+        // we should  give up
+        List<File> snapList = findNValidSnapshots(100);
+        if (snapList.size() == 0) {
             return -1L;
         }
-        LOG.info(""Reading snapshot "" + snap);
-        InputStream snapIS = new BufferedInputStream(new FileInputStream(snap));
-        CheckedInputStream crcIn = new CheckedInputStream(snapIS, new Adler32());
-        InputArchive ia=BinaryInputArchive.getArchive(crcIn);
-        deserialize(dt,sessions, ia);
-        long checkSum = crcIn.getChecksum().getValue();
-        long val = ia.readLong(""val"");
-        if (val != checkSum) {
-            throw new IOException(""CRC corruption in snapshot :  "" + snap);
+        File snap = null;
+        boolean foundValid = false;
+        for (int i = 0; i < snapList.size(); i++) {
+            snap = snapList.get(i);
+            InputStream snapIS = null;
+            CheckedInputStream crcIn = null;
+            try {
+                LOG.info(""Reading snapshot "" + snap);
+                snapIS = new BufferedInputStream(new FileInputStream(snap));
+                crcIn = new CheckedInputStream(snapIS, new Adler32());
+                InputArchive ia = BinaryInputArchive.getArchive(crcIn);
+                deserialize(dt,sessions, ia);
+                long checkSum = crcIn.getChecksum().getValue();
+                long val = ia.readLong(""val"");
+                if (val != checkSum) {
+                    throw new IOException(""CRC corruption in snapshot :  "" + snap);
+                }
+                foundValid = true;
+                break;
+            } catch(IOException e) {
+                LOG.warn(""problem reading snap file "" + snap, e);
+            } finally {
+                if (snapIS != null) 
+                    snapIS.close();
+                if (crcIn != null) 
+                    crcIn.close();
+            } 
         }
-        snapIS.close();
-        crcIn.close();
+        if (!foundValid) {
+            throw new IOException(""Not able to find valid snapshots in "" + snapDir);
+        }
         dt.lastProcessedZxid = Util.getZxidFromName(snap.getName(), ""snapshot"");
         return dt.lastProcessedZxid;
     }
@@ -91,7 +113,7 @@
      * @param ia the input archive to restore from
      * @throws IOException
      */
-    protected void deserialize(DataTree dt, Map<Long, Integer> sessions,
+    public void deserialize(DataTree dt, Map<Long, Integer> sessions,
             InputArchive ia) throws IOException {
         FileHeader header = new FileHeader();
         header.deserialize(ia, ""fileheader"");
@@ -108,23 +130,51 @@
      * @return the file containing the most recent snapshot
      */
     public File findMostRecentSnapshot() throws IOException {
-        List<File> files = Util.sortDataDir(snapDir.listFiles(), ""snapshot"", false);
-        for (File f : files) {
-            // we should catch the exceptions from 
-            // the valid snapshot and continue
-            // until we find a valid one
-            try {
-                if(Util.isValidSnapshot(f))
-                    return f;
-            } catch(IOException e) {
-                LOG.info(""invalid snapshot "" + f, e);
-            }
+        List<File> files = findNValidSnapshots(1);
+        if (files.size() == 0) {
+            return null;
         }
-        return null;
+        return files.get(0);
     }
     
     /**
-     * find the last n snapshots.
+     * find the last (maybe) valid n snapshots. this does some 
+     * minor checks on the validity of the snapshots. It just
+     * checks for / at the end of the snapshot. This does
+     * not mean that the snapshot is truly valid but is
+     * valid with a high probability. also, the most recent 
+     * will be first on the list. 
+     * @param n the number of most recent snapshots
+     * @return the last n snapshots (the number might be
+     * less than n in case enough snapshots are not available).
+     * @throws IOException
+     */
+    private List<File> findNValidSnapshots(int n) throws IOException {
+        List<File> files = Util.sortDataDir(snapDir.listFiles(),""snapshot"", false);
+        int count = 0;
+        List<File> list = new ArrayList<File>();
+        for (File f : files) {
+            // we should catch the exceptions
+            // from the valid snapshot and continue
+            // until we find a valid one
+            try {
+                if (Util.isValidSnapshot(f)) {
+                    list.add(f);
+                    count++;
+                    if (count == n) {
+                        break;
+                    }
+                }
+            } catch (IOException e) {
+                LOG.info(""invalid snapshot "" + f, e);
+            }
+        }
+        return list;
+    }
+
+    /**
+     * find the last n snapshots. this does not have
+     * any checks if the snapshot might be valid or not
      * @param the number of most recent snapshots 
      * @return the last n snapshots
      * @throws IOException
"
zookeeper,1e1ccdcfb19a60e50b9393feac7c0322048e20e1,ZOOKEEPER-367. RecoveryTest failure - 'unreasonable length' IOException,2009.04.18 03:11:43,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/util/SerializeUtils.java b/src/java/main/org/apache/zookeeper/server/util/SerializeUtils.java
index 4ee3b1f..d9a09e6 100644
--- a/src/java/main/org/apache/zookeeper/server/util/SerializeUtils.java
+++ b/src/java/main/org/apache/zookeeper/server/util/SerializeUtils.java
@@ -78,25 +78,17 @@
 
     public static void deserializeSnapshot(DataTree dt,InputArchive ia,
             Map<Long, Integer> sessions) throws IOException {
-        try {
-            int count = ia.readInt(""count"");
-            while (count > 0) {
-                long id = ia.readLong(""id"");
-                int to = ia.readInt(""timeout"");
-                sessions.put(id, to);
-                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
-                                         ""loadData --- session in archive: "" + id
-                                         + "" with timeout: "" + to);
-                count--;
-            }
-            dt.deserialize(ia, ""tree"");
-        } catch(IOException e) {
-            throw e;
-        } catch(Exception e) {
-            IOException ioe = new IOException(e.getMessage());
-            ioe.initCause(e);
-            throw ioe;
+        int count = ia.readInt(""count"");
+        while (count > 0) {
+            long id = ia.readLong(""id"");
+            int to = ia.readInt(""timeout"");
+            sessions.put(id, to);
+            ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
+                    ""loadData --- session in archive: "" + id
+                    + "" with timeout: "" + to);
+            count--;
         }
+        dt.deserialize(ia, ""tree"");
     }
 
     public static void serializeSnapshot(DataTree dt,OutputArchive oa,
"
zookeeper,764e34ca913283f1059de2055b0aa313c0514c2a,ZOOKEEPER-355. make validatePath non public in Zookeeper client api. (phunt via mahadev),2009.04.10 06:02:49,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index df3b835..3fc586d 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -33,6 +33,7 @@
 import org.apache.zookeeper.AsyncCallback.StatCallback;
 import org.apache.zookeeper.AsyncCallback.StringCallback;
 import org.apache.zookeeper.AsyncCallback.VoidCallback;
+import org.apache.zookeeper.common.PathUtils;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.proto.CreateRequest;
@@ -127,7 +128,7 @@
      * the public methods will not be exposed as part of the ZooKeeper client
      * API.
      */
-    private class ZKWatchManager implements ClientWatchManager {
+    private static class ZKWatchManager implements ClientWatchManager {
         private final Map<String, Set<Watcher>> dataWatches =
             new HashMap<String, Set<Watcher>>();
         private final Map<String, Set<Watcher>> existWatches =
@@ -500,7 +501,8 @@
             CreateMode createMode)
         throws KeeperException, InterruptedException
     {
-        validatePath(path);
+        // also handle the case where server will append name suffix
+        PathUtils.validatePath(path, createMode.isSequential());
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.create);
@@ -522,72 +524,6 @@
     }
 
     /**
-     * Validate the provided znode path string
-     * @param path znode path string
-     * @throws IllegalArgumentException if the path is invalid
-     */
-    public static void validatePath(String path) throws IllegalArgumentException {
-        if (path == null) {
-            throw new IllegalArgumentException(""Path cannot be null"");
-        }
-        if (path.length() == 0) {
-            throw new IllegalArgumentException(""Path length must be > 0"");
-        }
-        if (path.charAt(0) != '/') {
-            throw new IllegalArgumentException(
-                         ""Path must start with / character"");
-        }
-        if (path.length() == 1) { // done checking - it's the root
-            return;
-        }
-        if (path.charAt(path.length() - 1) == '/') {
-            throw new IllegalArgumentException(
-                         ""Path must not end with / character"");
-        }
-
-        String reason = null;
-        char lastc = '/';
-        char chars[] = path.toCharArray();
-        char c;
-        for (int i = 1; i < chars.length; lastc = chars[i], i++) {
-            c = chars[i];
-
-            if (c == 0) {
-                reason = ""null character not allowed @"" + i;
-                break;
-            } else if (c == '/' && lastc == '/') {
-                reason = ""empty node name specified @"" + i;
-                break;
-            } else if (c == '.' && lastc == '.') {
-                if (chars[i-2] == '/' &&
-                        ((i + 1 == chars.length)
-                                || chars[i+1] == '/')) {
-                    reason = ""relative paths not allowed @"" + i;
-                    break;
-                }
-            } else if (c == '.') {
-                if (chars[i-1] == '/' &&
-                        ((i + 1 == chars.length)
-                                || chars[i+1] == '/')) {
-                    reason = ""relative paths not allowed @"" + i;
-                    break;
-                }
-            } else if (c > '\u0000' && c < '\u001f'
-                    || c > '\u007f' && c < '\u009F'
-                    || c > '\ud800' && c < '\uf8ff'
-                    || c > '\ufff0' && c < '\uffff') {
-                reason = ""invalid charater @"" + i;
-                break;
-            }
-        }
-
-        if (reason != null) {
-            throw new IllegalArgumentException(
-                    ""Invalid path string \"""" + path + ""\"" caused by "" + reason);
-        }
-    }
-
-    /**
      * The Asynchronous version of create. The request doesn't actually until
      * the asynchronous callback is called.
      *
@@ -597,7 +533,8 @@
     public void create(String path, byte data[], List<ACL> acl,
             CreateMode createMode,  StringCallback cb, Object ctx)
     {
-        validatePath(path);
+        // also handle the case where server will append name suffix
+        PathUtils.validatePath(path, createMode.isSequential());
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.create);
@@ -639,7 +576,7 @@
      */
     public void delete(String path, int version) throws
             InterruptedException, KeeperException {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.delete);
@@ -659,7 +596,7 @@
      * @see #delete(String, int)
      */
     public void delete(String path, int version, VoidCallback cb, Object ctx) {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.delete);
@@ -689,7 +626,7 @@
     public Stat exists(String path, Watcher watcher) throws KeeperException,
         InterruptedException
     {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.exists);
@@ -745,7 +682,7 @@
     public void exists(String path, Watcher watcher, StatCallback cb,
             Object ctx)
     {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.exists);
@@ -792,7 +729,7 @@
      */
     public byte[] getData(String path, Watcher watcher, Stat stat)
             throws KeeperException, InterruptedException {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getData);
@@ -844,7 +781,7 @@
      * @see #getData(String, Watcher, Stat)
      */
     public void getData(String path, Watcher watcher, DataCallback cb, Object ctx) {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getData);
@@ -900,7 +837,7 @@
      */
     public Stat setData(String path, byte data[], int version)
             throws KeeperException, InterruptedException {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.setData);
@@ -924,7 +861,7 @@
      */
     public void setData(String path, byte data[], int version, StatCallback cb,
             Object ctx) {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.setData);
@@ -955,7 +892,7 @@
      */
     public List<ACL> getACL(String path, Stat stat)
             throws KeeperException, InterruptedException {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getACL);
@@ -977,7 +914,7 @@
      * @see #getACL(String, Stat)
      */
     public void getACL(String path, Stat stat, ACLCallback cb, Object ctx) {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getACL);
@@ -1011,7 +948,7 @@
      */
     public Stat setACL(String path, List<ACL> acl, int version)
             throws KeeperException, InterruptedException {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.setACL);
@@ -1038,7 +975,7 @@
      */
     public void setACL(String path, List<ACL> acl, int version,
             StatCallback cb, Object ctx) {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.setACL);
@@ -1075,7 +1012,7 @@
      */
     public List<String> getChildren(String path, Watcher watcher)
             throws KeeperException, InterruptedException {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getChildren);
@@ -1127,7 +1064,7 @@
      */
     public void getChildren(String path, Watcher watcher, ChildrenCallback cb,
             Object ctx) {
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getChildren);
@@ -1162,7 +1099,7 @@
      * @throws IllegalArgumentException if an invalid path is specified
      */
     public void sync(String path, VoidCallback cb, Object ctx){
-        validatePath(path);
+        PathUtils.validatePath(path);
 
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.sync);
"
zookeeper,764e34ca913283f1059de2055b0aa313c0514c2a,ZOOKEEPER-355. make validatePath non public in Zookeeper client api. (phunt via mahadev),2009.04.10 06:02:49,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index fbe5304..12e1253 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -30,9 +30,9 @@
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.ZooDefs;
-import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.KeeperException.Code;
 import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.common.PathUtils;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Id;
 import org.apache.zookeeper.data.StatPersisted;
@@ -205,13 +205,6 @@
                             Long.toHexString(request.sessionId));
                     throw new KeeperException.BadArgumentsException();
                 }
-                try {
-                    ZooKeeper.validatePath(path);
-                } catch(IllegalArgumentException ie) {
-                    LOG.warn(""Invalid path "" + path + "" with session "" +
-                            Long.toHexString(request.sessionId));
-                    throw new KeeperException.BadArgumentsException();
-                }
                 if (!fixupACL(request.authInfo, createRequest.getAcl())) {
                     throw new KeeperException.InvalidACLException();
                 }
@@ -221,11 +214,19 @@
                 checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE,
                         request.authInfo);
                 int parentCVersion = parentRecord.stat.getCversion();
-                CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());
+                CreateMode createMode =
+                    CreateMode.fromFlag(createRequest.getFlags());
                 if (createMode.isSequential()) {
                     path = path + String.format(""%010d"", parentCVersion);
                 }
                 try {
+                    PathUtils.validatePath(path);
+                } catch(IllegalArgumentException ie) {
+                    LOG.warn(""Invalid path "" + path + "" with session "" +
+                            Long.toHexString(request.sessionId));
+                    throw new KeeperException.BadArgumentsException();
+                }
+                try {
                     if (getRecordForPath(path) != null) {
                         throw new KeeperException.NodeExistsException();
                     }
"
zookeeper,47b16b9612ece90d959f1966f387b91ee4d9b7ed,ZOOKEEPER-370. Fix critical problems reported by findbugs. (flavio via mahadev),2009.04.09 06:09:42,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
index f7496e7..a466d54 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
@@ -39,7 +39,8 @@
 
 public class LeaderElection implements Election  {
     private static final Logger LOG = Logger.getLogger(LeaderElection.class);
-
+    private static Random epochGen = new Random();
+    
     QuorumPeer self;
 
     public LeaderElection(QuorumPeer self) {
@@ -130,7 +131,7 @@
                 responseBytes.length);
         HashMap<InetSocketAddress, Vote> votes = new HashMap<InetSocketAddress, Vote>(
                 self.quorumPeers.size());
-        int xid = new Random().nextInt();
+        int xid = epochGen.nextInt();
         while (self.running) {
             votes.clear();
             requestBuffer.clear();
"
zookeeper,47b16b9612ece90d959f1966f387b91ee4d9b7ed,ZOOKEEPER-370. Fix critical problems reported by findbugs. (flavio via mahadev),2009.04.09 06:09:42,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index b97eada..4e22f6d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -72,12 +72,7 @@
      * Packet size
      */
     int packetSize;
-
-    /*
-     * Port to listen on
-     */
-    int port;
-
+    
     /*
      * Challenge to initiate connections
      */
@@ -126,27 +121,11 @@
         this.senderWorkerMap = new ConcurrentHashMap<Long, SendWorker>();
         this.self = self;
 
-        // Generates a challenge to guarantee one connection between pairs of
-        // servers
-        //genChallenge();
-
         // Starts listener thread that waits for connection requests 
         listener = new Listener();
         listener.start();
     }
 
-    void genChallenge() {
-        try{
-            Random rand = new Random(System.currentTimeMillis()
-                + InetAddress.getLocalHost().hashCode());
-            long newValue = rand.nextLong();
-            challenge = newValue;
-        } catch(UnknownHostException e){
-            LOG.error(""Cannot resolve local address"");
-            challenge = 0;
-        }
-    }
-
     /**
      * If this server has initiated the connection, then it gives up on the
      * connection if it loses challenge. Otherwise, it keeps the connection.
@@ -177,30 +156,25 @@
             }
         // Otherwise proceed with the connection
         } else {
-                if (s != null) {
-                    SendWorker sw = new SendWorker(s, sid);
-                    RecvWorker rw = new RecvWorker(s, sid);
-                    sw.setRecv(rw);
+        	SendWorker sw = new SendWorker(s, sid);
+        	RecvWorker rw = new RecvWorker(s, sid);
+        	sw.setRecv(rw);
+        	
+        	if (senderWorkerMap
+        			.containsKey(sid)) {
+        		senderWorkerMap.get(sid).finish();
+        	}
 
-                    if (senderWorkerMap
-                            .containsKey(sid)) {
-                        senderWorkerMap.get(sid).finish();
-                    }
-
-                    if (!queueSendMap.containsKey(sid)) {
-                        queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
-                                CAPACITY));
-                    }
+        	if (!queueSendMap.containsKey(sid)) {
+        		queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
+        				CAPACITY));
+        	}
                     
-                    senderWorkerMap.put(sid, sw);
-                    sw.start();
-                    rw.start();
+        	senderWorkerMap.put(sid, sw);
+        	sw.start();
+        	rw.start();
 
-                    return true;
-                } else {
-                    LOG.warn(""Channel null"");
-                    return false;
-                }
+        	return true;
             
         }
         return false;
@@ -247,30 +221,24 @@
             }
         //Otherwise start worker threads to receive data.
         } else {
-            
-                if (s != null) {
-                    SendWorker sw = new SendWorker(s, sid);
-                    RecvWorker rw = new RecvWorker(s, sid);
-                    sw.setRecv(rw);
+        	SendWorker sw = new SendWorker(s, sid);
+        	RecvWorker rw = new RecvWorker(s, sid);
+        	sw.setRecv(rw);
 
-                    if (senderWorkerMap.containsKey(sid)) {
-                        senderWorkerMap.get(sid).finish();
-                    }
+        	if (senderWorkerMap.containsKey(sid)) {
+        		senderWorkerMap.get(sid).finish();
+        	}
                     
-                    senderWorkerMap.put(sid, sw);
+        	senderWorkerMap.put(sid, sw);
                     
-                    if (!queueSendMap.containsKey(sid)) {
-                        queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
-                                CAPACITY));
-                    }      
-                    sw.start();
-                    rw.start();
+        	if (!queueSendMap.containsKey(sid)) {
+        		queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
+        				CAPACITY));
+        	}      
+        	sw.start();
+        	rw.start();
 
-                    return true;
-                } else {
-                    LOG.warn(""Channel null"");
-                    return false;
-                }
+        	return true;    
         }
         return false;
     }
"
zookeeper,06d451ad0c982c098458f7a40463b5034708bcfc,ZOOKEEPER-363. NPE when recovering ledger with no hint. (flavio via mahadev),2009.04.07 11:43:38,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java
index 927a79e..b88f4e1 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerRecoveryMonitor.java
@@ -145,8 +145,8 @@
         long readCounter = 0;
         while(notLegitimate){
             readCounter = getNextHint();
-            if(readCounter != -1){
-                lh.setLast(readCounter - 1);
+            if(readCounter > -1){
+                lh.setLast(readCounter);
                 boolean hasMore = true;
                 while(hasMore){
                     hasMore = false;
"
zookeeper,c9e8662617ac5d99cc08f858c21dc9c4ba175881,ZOOKEEPER-362. Issues with FLENewEpochTest. (fix bug in Fast leader election) (flavio via mahadev),2009.04.04 07:01:18,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 7012407..26463ec 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -562,6 +562,7 @@
                             n.epoch + "", "" + self.getId() + "", "" + self.getPeerState() + 
                             "", "" + n.state + "", "" + n.sid);
                     if (n.epoch > logicalclock) {
+                        LOG.debug(""Increasing logical clock: "" + n.epoch);
                         logicalclock = n.epoch;
                         recvset.clear();
                         if(totalOrderPredicate(n.leader, n.zxid, self.getId(), self.getLastLoggedZxid()))
"
zookeeper,c9e8662617ac5d99cc08f858c21dc9c4ba175881,ZOOKEEPER-362. Issues with FLENewEpochTest. (fix bug in Fast leader election) (flavio via mahadev),2009.04.04 07:01:18,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index 200eb3b..b97eada 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -238,13 +238,8 @@
                 SendWorker sw = senderWorkerMap.get(sid);
 
                 LOG.info(""Create new connection to server: "" + sid);
-                //sw.connect();
                 s.socket().close();
-                if(sw != null) sw.finish();
-                SocketChannel channel = SocketChannel.open(self.quorumPeers.get(sid).electionAddr);
-                if (channel.isConnected()) {
-                    initiateConnection(channel, sid);
-                }
+                connectOne(sid);
                 
             } catch (IOException e) {
                 LOG.info(""Error when closing socket or trying to reopen connection: ""
@@ -329,7 +324,7 @@
      *  @param sid  server id
      */
     
-    void connectOne(long sid){
+    synchronized void connectOne(long sid){
         if ((senderWorkerMap.get(sid) == null)) {
             SocketChannel channel;
             try {
@@ -395,13 +390,13 @@
      */
     class Listener extends Thread {
 
-        ServerSocketChannel ss = null;
+        volatile ServerSocketChannel ss = null;
         /**
          * Sleeps on accept().
          */
         @Override
         public void run() {
-            ServerSocketChannel ss = null;
+            //ss = null;
             try {
                 ss = ServerSocketChannel.open();
                 int port = self.quorumPeers.get(self.getId()).electionAddr.getPort();
@@ -421,13 +416,17 @@
                     receiveConnection(client);
                 }
             } catch (IOException e) {
-                System.err.println(""Listener.run: "" + e.getMessage());
+                LOG.error(""Listener.run: "" + e.getMessage());
             }
         }
         
         void halt(){
             try{
-                if((ss != null) && (ss.isOpen())) ss.close();
+                LOG.debug(""Trying to close listener: "" + ss);
+                if(ss != null)/* && (ss.isOpen()))*/{
+                    LOG.debug(""Closing listener: "" + self.getId());
+                    ss.close();
+                }
             } catch (IOException e){
                 LOG.warn(""Exception when shutting down listener: "" + e);
             }
"
zookeeper,1b91bfd187f1a718fc4f596099ca08af15a17971,ZOOKEEPER-360. WeakHashMap in Bookie.java causes NPE (flavio via mahadev),2009.04.04 06:43:38,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java
index 586fbd9..c84eb8f 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java
@@ -27,7 +27,6 @@
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.util.HashMap;
-import java.util.WeakHashMap;
 import java.util.LinkedList;
 import java.util.Random;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -55,8 +54,6 @@
 
     final File ledgerDirectories[];
     
-    WeakHashMap<Long, ByteBuffer> masterKeys = new WeakHashMap<Long, ByteBuffer>();
-    
     public static class NoLedgerException extends IOException {
         private static final long serialVersionUID = 1L;
         private long ledgerId;
@@ -104,7 +101,7 @@
             if (handle == null) {
                 handle = createHandle(ledgerId, readonly);
                 ledgers.put(ledgerId, handle);
-                masterKeys.put(ledgerId, ByteBuffer.wrap(masterKey));
+                handle.setMasterKey(ByteBuffer.wrap(masterKey));
             } 
             handle.incRef();
         }
@@ -291,7 +288,7 @@
         long ledgerId = entry.getLong();
         LedgerDescriptor handle = getHandle(ledgerId, false, masterKey);
         
-        if(!masterKeys.get(ledgerId).equals(ByteBuffer.wrap(masterKey))){
+        if(!handle.cmpMasterKey(ByteBuffer.wrap(masterKey))){
             throw BookieException.create(BookieException.Code.UnauthorizedAccessException);
         }
         try {
"
zookeeper,1b91bfd187f1a718fc4f596099ca08af15a17971,ZOOKEEPER-360. WeakHashMap in Bookie.java causes NPE (flavio via mahadev),2009.04.04 06:43:38,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java
index 75f5401..9927366 100644
--- a/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java
+++ b/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java
@@ -42,6 +42,17 @@
         this.ledger = ledger;
         this.ledgerIndex = ledgerIndex;
     }
+    
+    private ByteBuffer masterKey = null;
+    
+    void setMasterKey(ByteBuffer masterKey){
+        this.masterKey = masterKey;
+    }
+    
+    boolean cmpMasterKey(ByteBuffer masterKey){
+        return this.masterKey.equals(masterKey);
+    }
+    
     private long ledgerId;
     private FileChannel ledger;
     private FileChannel ledgerIndex;
"
zookeeper,534631b066865b1968e2b89cc02adf14c3d2f0de,"ZOOKEEPER-341.  regression in QuorumPeerMain, tickTime from config is lost, cannot start quorum (phunt via mahadev)",2009.03.19 01:37:57,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 3bfa027..69f5a3a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -34,7 +34,6 @@
 public class QuorumPeerConfig extends ServerConfig {
     private static final Logger LOG = Logger.getLogger(QuorumPeerConfig.class);
 
-    private int tickTime;
     private int initLimit;
     private int syncLimit;
     private int electionAlg;
@@ -189,11 +188,6 @@
         return QuorumPeerConfig.getServers().size() <= 1;
     }
 
-    public static int getTickTime() {
-        assert instance instanceof QuorumPeerConfig;
-        return ((QuorumPeerConfig)instance).tickTime;
-    }
-
     public static int getInitLimit() {
         assert instance instanceof QuorumPeerConfig;
         return ((QuorumPeerConfig)instance).initLimit;
"
zookeeper,8b651cfb22985be3a755fb82e3619057e34f49ef,ZOOKEEPER-334. bookkeeper benchmark (testclient.java) has compiling errros. (flavio and mahadev),2009.03.04 07:48:50,Mahadev Konar,"diff --git a/src/contrib/bookkeeper/benchmark/org/apache/bookkeeper/benchmark/TestClient.java b/src/contrib/bookkeeper/benchmark/org/apache/bookkeeper/benchmark/TestClient.java
index b86813f..aa10906 100644
--- a/src/contrib/bookkeeper/benchmark/org/apache/bookkeeper/benchmark/TestClient.java
+++ b/src/contrib/bookkeeper/benchmark/org/apache/bookkeeper/benchmark/TestClient.java
@@ -39,9 +39,15 @@
 
 import org.apache.zookeeper.KeeperException;
 
+/**
+ * This is a simple test program to compare the performance of writing to
+ * BookKeeper and to the local file system.
+ * 
+ */
+
 public class TestClient 
     implements AddCallback, ReadCallback{
-    Logger LOG = Logger.getLogger(QuorumEngine.class);
+    private static final Logger LOG = Logger.getLogger(TestClient.class);
     
     BookKeeper x;
     LedgerHandle lh;
@@ -63,7 +69,7 @@
         try{
         lh = x.createLedger(new byte[] {'a', 'b'});
         } catch (BKException e) {
-            System.out.println(e.toString());
+            LOG.error(e.toString());
         }
     }
     
@@ -72,9 +78,9 @@
         this();
         x = new BookKeeper(servers);
         try{
-        lh = x.createLedger(ensSize, new byte[] {'a', 'b'}, qSize, QMode.VERIFIABLE);
+        lh = x.createLedger(ensSize, qSize, QMode.VERIFIABLE, new byte[] {'a', 'b'});
         } catch (BKException e) {
-            System.out.println(e.toString());
+            LOG.error(e.toString());
         }
     }
     
@@ -95,15 +101,9 @@
     
     public boolean removeEntryId(Integer id){
         boolean retVal = false;
-        //int val;
         synchronized (map) {
-            //val = map.get(id);
-            //if(--val == 0){
                 map.remove(id);
                 retVal = true;
-            //} else {
-                //map.put(id, val);
-            //}
      
             if(map.size() == 0) map.notifyAll();
             else{
@@ -118,8 +118,10 @@
         x.closeLedger(lh);
     }
     /**
-     * First parameter is an integer defining the length of the message 
-     * Second parameter is the number of writes
+     * First says if entries should be written to BookKeeper (0) or to the local
+     * disk (1). Second parameter is an integer defining the length of a ledger entry. 
+     * Third parameter is the number of writes.
+     * 
      * @param args
      */
     public static void main(String[] args) {
@@ -140,23 +142,18 @@
         
             String servers = servers_sb.toString().trim().replace(' ', ',');
             try {
-                /*int lenght = Integer.parseInt(args[1]);
-                StringBuffer sb = new StringBuffer();
-                while(lenght-- > 0){
-                    sb.append('a');
-                }*/
                 TestClient c = new TestClient(servers, Integer.parseInt(args[3]), Integer.parseInt(args[4]));
                 c.writeSameEntryBatch(sb.toString().getBytes(), Integer.parseInt(args[2]));
                 //c.writeConsecutiveEntriesBatch(Integer.parseInt(args[0]));
                 c.closeHandle();
             } catch (NumberFormatException e) {
-                e.printStackTrace();
+                LOG.error(e);
             } catch (InterruptedException e) {
-                e.printStackTrace();
+                LOG.error(e);
             } catch (KeeperException e) {
-                e.printStackTrace();
+                LOG.error(e);
             } catch (IOException e) {
-                e.printStackTrace();
+                LOG.error(e);
             }
             break;
         case 1:
@@ -165,7 +162,7 @@
                 TestClient c = new TestClient(new FileOutputStream(args[2]));
                 c.writeSameEntryBatchFS(sb.toString().getBytes(), Integer.parseInt(args[3]));
             } catch(FileNotFoundException e){
-                e.printStackTrace();
+                LOG.error(e);
             }
             break;
         case 2:
@@ -176,27 +173,18 @@
     void writeSameEntryBatch(byte[] data, int times) throws InterruptedException{
         start = System.currentTimeMillis();
         int count = times;
-        System.out.println(""Data: "" + new String(data) + "", "" + data.length);
+        LOG.debug(""Data: "" + new String(data) + "", "" + data.length);
         while(count-- > 0){
             x.asyncAddEntry(lh, data, this, this.getFreshEntryId(2));
         }
-        System.out.println(""Finished "" + times + "" async writes in ms: "" + (System.currentTimeMillis() - start));       
+        LOG.debug(""Finished "" + times + "" async writes in ms: "" + (System.currentTimeMillis() - start));       
         synchronized (map) {
             if(map.size() != 0)
                 map.wait();
         }
-        System.out.println(""Finished processing in ms: "" + (System.currentTimeMillis() - start));
-        /*Integer mon = Integer.valueOf(0);
-        synchronized(mon){
-            
-                try{                  
-                    x.asyncReadEntries(lh, 0, times - 1, this, mon);
-                    mon.wait();
-                } catch (BKException e){
-                    LOG.error(e);
-                }
-        } */
-        LOG.error(""Ended computation"");
+        LOG.debug(""Finished processing in ms: "" + (System.currentTimeMillis() - start));
+        
+        LOG.debug(""Ended computation"");
     }
     
     void writeConsecutiveEntriesBatch(int times) throws InterruptedException{
@@ -210,12 +198,12 @@
             write[1] = (byte) k;
             x.asyncAddEntry(lh, write, this, this.getFreshEntryId(2));
         }
-        System.out.println(""Finished "" + times + "" async writes in ms: "" + (System.currentTimeMillis() - start));       
+        LOG.debug(""Finished "" + times + "" async writes in ms: "" + (System.currentTimeMillis() - start));       
         synchronized (map) {
             if(map.size() != 0)
                 map.wait();
         }
-        System.out.println(""Finished processing writes (ms): "" + (System.currentTimeMillis() - start));
+        LOG.debug(""Finished processing writes (ms): "" + (System.currentTimeMillis() - start));
         
         Integer mon = Integer.valueOf(0);
         synchronized(mon){
@@ -231,7 +219,7 @@
 
     void writeSameEntryBatchFS(byte[] data, int times) {
         int count = times;
-        System.out.println(""Data: "" + data.length + "", "" + times);
+        LOG.debug(""Data: "" + data.length + "", "" + times);
         try{
             start = System.currentTimeMillis();
             while(count-- > 0){
@@ -239,28 +227,23 @@
                 fStreamLocal.write(data);
                 fStream.flush();
             }
-            //fStream.flush();
             fStream.close();
             System.out.println(""Finished processing writes (ms): "" + (System.currentTimeMillis() - start));
         } catch(IOException e){
-            e.printStackTrace();
+            LOG.error(e);
         }
     }
         
-    @Override
+   
     public void addComplete(int rc, long ledgerId, long entryId, Object ctx) {
         this.removeEntryId((Integer) ctx);
-        //if((entryId - lastId) > 1) LOG.error(""Gap: "" + entryId + "", "" + lastId);
-        //lastId = entryId;
-        //if(entryId > 199000) LOG.error(""Add completed: "" + ledgerId + "", "" + entryId + "", "" + map.toString());
-        //System.out.println((System.currentTimeMillis() - start));
     }
-    @Override
+   
     public void readComplete(int rc, long ledgerId, LedgerSequence seq, Object ctx){
         System.out.println(""Read callback: "" + rc);
         while(seq.hasMoreElements()){
             LedgerEntry le = seq.nextElement();
-            System.out.println(new String(le.getEntry()));
+            LOG.debug(new String(le.getEntry()));
         }
         synchronized(ctx){
             ctx.notify();
"
zookeeper,63e2697d430ce1f7c5b60ddc3ce8f2c65ef861fb,ZOOKEEPER-330. zookeeper standalone server does not startup with just a port and datadir. (chris darroch and mahadev),2009.02.28 04:00:08,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ServerConfig.java b/src/java/main/org/apache/zookeeper/server/ServerConfig.java
index 9bf92b8..8b7addf 100644
--- a/src/java/main/org/apache/zookeeper/server/ServerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/ServerConfig.java
@@ -22,12 +22,15 @@
     private int clientPort;
     private String dataDir;
     private String dataLogDir;
+    private int tickTime;
     
-    protected ServerConfig(int port, String dataDir,String dataLogDir) {
+    protected ServerConfig(int port, String dataDir,String dataLogDir, int tickTime) {
         this.clientPort = port;
         this.dataDir = dataDir;
         this.dataLogDir=dataLogDir;
+        this.tickTime = tickTime;
     }
+    
     protected boolean isStandaloneServer(){
         return true;
     }
@@ -49,16 +52,27 @@
         return instance.isStandaloneServer();
     }
     
+    public static int getTickTime() {
+        assert instance != null;
+        return instance.tickTime;
+    }
+    
     protected static ServerConfig instance=null;
     
     public static void parse(String[] args) throws Exception {
         if(instance!=null)
             return;
-        if (args.length != 2) {
+        if (args.length < 2) {
             throw new IllegalArgumentException(""Invalid usage."");
         }
+        int tickTime = ZooKeeperServer.DEFAULT_TICK_TIME;
+        if (args.length > 2) {
+            // the last parameter ticktime is optional
+            tickTime = Integer.parseInt(args[2]);
+        }
         try {
-              instance=new ServerConfig(Integer.parseInt(args[0]),args[1],args[1]);
+              instance=new ServerConfig(Integer.parseInt(args[0]),args[1],
+                      args[1], tickTime);
         } catch (NumberFormatException e) {
             throw new IllegalArgumentException(args[0] + "" is not a valid port number"");
         }
"
zookeeper,63e2697d430ce1f7c5b60ddc3ce8f2c65ef861fb,ZOOKEEPER-330. zookeeper standalone server does not startup with just a port and datadir. (chris darroch and mahadev),2009.02.28 04:00:08,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 568540c..ac0f588 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -93,7 +93,7 @@
         }
     }
 
-    private static final int DEFAULT_TICK_TIME = 3000;
+    public static final int DEFAULT_TICK_TIME = 3000;
     protected int tickTime = DEFAULT_TICK_TIME;
 
     public static final int commitLogCount = 500;
"
zookeeper,63e2697d430ce1f7c5b60ddc3ce8f2c65ef861fb,ZOOKEEPER-330. zookeeper standalone server does not startup with just a port and datadir. (chris darroch and mahadev),2009.02.28 04:00:08,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
index bcfc037..c879c35 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
@@ -34,7 +34,7 @@
 public class ZooKeeperServerMain {
 
     private static final Logger LOG = Logger.getLogger(ZooKeeperServerMain.class);
-    private static final String USAGE = ""Usage: ZooKeeperServerMain port datadir"";
+    private static final String USAGE = ""Usage: ZooKeeperServerMain configfile | port datadir [ticktime]"";
     /*
      * Start up the ZooKeeper server.
      *
@@ -48,7 +48,11 @@
         }
 
         try {
-            QuorumPeerConfig.parse(args);
+            if (args.length == 1) {
+                QuorumPeerConfig.parse(args);
+            } else {
+                ServerConfig.parse(args);
+            }
         } catch(Exception e) {
             LOG.fatal(""Error in config"", e);
             LOG.info(USAGE);
@@ -67,7 +71,7 @@
                        File(ServerConfig.getDataLogDir()),
                         new File(ServerConfig.getDataDir()));
                zks.setTxnLogFactory(ftxn);
-               zks.setTickTime(QuorumPeerConfig.getTickTime());
+               zks.setTickTime(ServerConfig.getTickTime());
                return zks;
             }
         });
"
zookeeper,63e2697d430ce1f7c5b60ddc3ce8f2c65ef861fb,ZOOKEEPER-330. zookeeper standalone server does not startup with just a port and datadir. (chris darroch and mahadev),2009.02.28 04:00:08,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
index 0826421..de98c7e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
@@ -30,6 +30,7 @@
 import org.apache.log4j.Logger;
 
 import org.apache.zookeeper.server.ServerConfig;
+import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
 
 public class QuorumPeerConfig extends ServerConfig {
@@ -43,8 +44,8 @@
     private HashMap<Long,QuorumServer> servers = null;
     private long serverId;
 
-    private QuorumPeerConfig(int port, String dataDir, String dataLogDir) {
-        super(port, dataDir, dataLogDir);
+    private QuorumPeerConfig(int port, String dataDir, String dataLogDir, int tickTime) {
+        super(port, dataDir, dataLogDir, tickTime);
     }
 
     public static void parse(String[] args) throws Exception {
@@ -137,8 +138,7 @@
             throw new IllegalArgumentException(""syncLimit is not set"");
         }
         QuorumPeerConfig conf = new QuorumPeerConfig(clientPort, dataDir,
-                dataLogDir);
-        conf.tickTime = tickTime;
+                dataLogDir, tickTime);
         conf.initLimit = initLimit;
         conf.syncLimit = syncLimit;
         conf.electionAlg = electionAlg;
"
zookeeper,f36e174ebe11ec7b3da2cfd5b4226d61e1d3f642,ZOOKEEPER-326. standalone server ignores tickTime configuration. (chris darroch via mahadev),2009.02.24 08:52:04,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
index 518ec15..bcfc037 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
@@ -26,6 +26,7 @@
 import org.apache.log4j.Logger;
 import org.apache.zookeeper.jmx.ManagedUtil;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
 
 /**
  * This class starts and runs a standalone ZooKeeperServer.
@@ -47,7 +48,7 @@
         }
 
         try {
-            ServerConfig.parse(args);
+            QuorumPeerConfig.parse(args);
         } catch(Exception e) {
             LOG.fatal(""Error in config"", e);
             LOG.info(USAGE);
@@ -66,6 +67,7 @@
                        File(ServerConfig.getDataLogDir()),
                         new File(ServerConfig.getDataDir()));
                zks.setTxnLogFactory(ftxn);
+               zks.setTickTime(QuorumPeerConfig.getTickTime());
                return zks;
             }
         });
"
zookeeper,c5d28b03b72253f2ca6d9142a17487b253317ec6,ZOOKEEPER-302. Quote values in JMX objectnames. (tom and pat via mahadev),2009.02.07 06:19:03,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java b/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java
index 5569a66..4a7bf1c 100644
--- a/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java
+++ b/src/java/main/org/apache/zookeeper/jmx/MBeanRegistry.java
@@ -22,7 +22,9 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
+import javax.management.JMException;
 import javax.management.MBeanServer;
+import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
 
 import org.apache.log4j.Logger;
@@ -54,7 +56,9 @@
      * @param parent if not null, the new bean will be registered as a child
      * node of this parent.
      */
-    public void register(ZKMBeanInfo bean, ZKMBeanInfo parent) {
+    public void register(ZKMBeanInfo bean, ZKMBeanInfo parent)
+        throws JMException
+    {
         assert bean != null;
         String path = null;
         if (parent != null) {
@@ -70,9 +74,9 @@
         ObjectName oname = makeObjectName(path, bean);
         try {
             mbs.registerMBean(bean, oname);
-        } catch (Exception e) {
-            LOG.error(""Failed to register MBean "" + bean.getName());
-            e.printStackTrace();
+        } catch (JMException e) {
+            LOG.warn(""Failed to register MBean "" + bean.getName());
+            throw e;
         }
     }
 
@@ -81,16 +85,16 @@
      * @param path
      * @param bean
      */
-    private void unregister(String path,ZKMBeanInfo bean){
+    private void unregister(String path,ZKMBeanInfo bean) throws JMException {
         if(path==null)
             return;
         if (!bean.isHidden()) {
             MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
             try {
                 mbs.unregisterMBean(makeObjectName(path, bean));
-            } catch (Exception e) {
-                LOG.error(""Failed to unregister MBean "" + bean.getName());
-                e.printStackTrace();
+            } catch (JMException e) {
+                LOG.warn(""Failed to unregister MBean "" + bean.getName());
+                throw e;
             }
         }        
     }
@@ -99,20 +103,28 @@
      * Unregister MBean.
      * @param bean
      */
-    public void unregister(ZKMBeanInfo bean){
+    public void unregister(ZKMBeanInfo bean) {
         if(bean==null)
             return;
         String path=mapBean2Path.get(bean);
-        unregister(path,bean);
+        try {
+            unregister(path,bean);
+        } catch (JMException e) {
+            LOG.warn(""Error during unregister"", e);
+        }
         mapBean2Path.remove(bean);
         mapName2Bean.remove(bean.getName());
     }
     /**
      * Unregister all currently registered MBeans
      */
-    public void unregisterAll(){
-        for(Map.Entry<ZKMBeanInfo,String> e: mapBean2Path.entrySet()){
-            unregister(e.getValue(),e.getKey());
+    public void unregisterAll() {
+        for(Map.Entry<ZKMBeanInfo,String> e: mapBean2Path.entrySet()) {
+            try {
+                unregister(e.getValue(), e.getKey());
+            } catch (JMException e1) {
+                LOG.warn(""Error during unregister"", e1);
+            }
         }
         mapBean2Path.clear();
         mapName2Bean.clear();
@@ -123,7 +135,7 @@
      * @param name path elements
      * @return absolute path
      */
-    public String makeFullPath(String prefix, String... name){
+    public String makeFullPath(String prefix, String... name) {
         StringBuilder sb=new StringBuilder(prefix == null ? ""/"" : (prefix.equals(""/"")?prefix:prefix+""/""));
         boolean first=true;
         for (String s : name) {
@@ -159,9 +171,11 @@
      * Builds an MBean path and creates an ObjectName instance using the path. 
      * @param path MBean path
      * @param bean the MBean instance
-     * @return ObjectName to be registered with the paltform MBean server
+     * @return ObjectName to be registered with the platform MBean server
      */
-    protected ObjectName makeObjectName(String path, ZKMBeanInfo bean) {
+    protected ObjectName makeObjectName(String path, ZKMBeanInfo bean)
+        throws MalformedObjectNameException
+    {
         if(path==null)
             return null;
         StringBuilder beanName = new StringBuilder(CommonNames.DOMAIN + "":"");
@@ -171,10 +185,10 @@
         beanName.deleteCharAt(beanName.length()-1);
         try {
             return new ObjectName(beanName.toString());
-        } catch (Exception e) {
-            e.printStackTrace();
-            assert false;
+        } catch (MalformedObjectNameException e) {
+            LOG.warn(""Invalid name \"""" + beanName.toString() + ""\"" for class ""
+                    + bean.getClass().toString());
+            throw e;
         }
-        return null;
     }
 }
"
zookeeper,c5d28b03b72253f2ca6d9142a17487b253317ec6,ZOOKEEPER-302. Quote values in JMX objectnames. (tom and pat via mahadev),2009.02.07 06:19:03,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ConnectionBean.java b/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
index ef9304e..b34b626 100644
--- a/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
+++ b/src/java/main/org/apache/zookeeper/server/ConnectionBean.java
@@ -18,9 +18,14 @@
 
 package org.apache.zookeeper.server;
 
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
 import java.util.Arrays;
 import java.util.Date;
 
+import javax.management.ObjectName;
+
 import org.apache.log4j.Logger;
 import org.apache.zookeeper.jmx.MBeanRegistry;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
@@ -44,15 +49,20 @@
         return ""0x"" + Long.toHexString(connection.getSessionId());
     }
 
-    
     public String getSourceIP() {
-        return connection.getRemoteAddress().getAddress().getHostAddress()+
-            "":""+connection.getRemoteAddress().getPort();
+        InetSocketAddress sockAddr = connection.getRemoteAddress();
+        return sockAddr.getAddress().getHostAddress()
+            + "":"" + sockAddr.getPort();
     }
-    
+
     public String getName() {
-        String ip=connection.getRemoteAddress().getAddress().getHostAddress();
-        return MBeanRegistry.getInstance().makeFullPath(""Connections"", ip,getSessionId());
+        InetAddress addr = connection.getRemoteAddress().getAddress();
+        String ip = addr.getHostAddress();
+        if (addr instanceof Inet6Address) {
+            ip = ObjectName.quote(ip);
+        }
+        return MBeanRegistry.getInstance().makeFullPath(""Connections"", ip,
+                getSessionId());
     }
     
     public boolean isHidden() {
@@ -61,7 +71,8 @@
     
     public String[] getEphemeralNodes() {
         if(zk.dataTree!=null){
-            String[] res=zk.dataTree.getEphemerals(connection.getSessionId()).toArray(new String[0]);
+            String[] res=zk.dataTree.getEphemerals(connection.getSessionId())
+                .toArray(new String[0]);
             Arrays.sort(res);
             return res;
         }
@@ -84,10 +95,11 @@
     public void terminateConnection() {
         connection.close();
     }
-    
+
     @Override
     public String toString() {
-        return ""ConnectionBean{ClientIP=""+getSourceIP()+"",SessionId=0x""+getSessionId()+""}"";
+        return ""ConnectionBean{ClientIP="" + ObjectName.quote(getSourceIP())
+            + "",SessionId=0x"" + getSessionId() + ""}"";
     }
     
     public long getOutstandingRequests() {
"
zookeeper,c5d28b03b72253f2ca6d9142a17487b253317ec6,ZOOKEEPER-302. Quote values in JMX objectnames. (tom and pat via mahadev),2009.02.07 06:19:03,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index a261a8c..77abef2 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -861,6 +861,7 @@
             MBeanRegistry.getInstance().register(jmxConnectionBean, zk.jmxServerBean);
         } catch (Exception e) {
             LOG.warn(""Failed to register with JMX"", e);
+            jmxConnectionBean = null;
         }
 
         try {
"
zookeeper,c5d28b03b72253f2ca6d9142a17487b253317ec6,ZOOKEEPER-302. Quote values in JMX objectnames. (tom and pat via mahadev),2009.02.07 06:19:03,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index a02e727..0107ac5 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -334,10 +334,17 @@
         try {
             jmxServerBean = new ZooKeeperServerBean(this);
             MBeanRegistry.getInstance().register(jmxServerBean, null);
-            jmxDataTreeBean = new DataTreeBean(dataTree);
-            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
+            
+            try {
+                jmxDataTreeBean = new DataTreeBean(dataTree);
+                MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
+            } catch (Exception e) {
+                LOG.warn(""Failed to register with JMX"", e);
+                jmxDataTreeBean = null;
+            }
         } catch (Exception e) {
             LOG.warn(""Failed to register with JMX"", e);
+            jmxServerBean = null;
         }
     }
     
@@ -397,6 +404,10 @@
             if (jmxDataTreeBean != null) {
                 MBeanRegistry.getInstance().unregister(jmxDataTreeBean);
             }
+        } catch (Exception e) {
+            LOG.warn(""Failed to unregister with JMX"", e);
+        }
+        try {
             if (jmxServerBean != null) {
                 MBeanRegistry.getInstance().unregister(jmxServerBean);
             }
"
zookeeper,c5d28b03b72253f2ca6d9142a17487b253317ec6,ZOOKEEPER-302. Quote values in JMX objectnames. (tom and pat via mahadev),2009.02.07 06:19:03,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerBean.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerBean.java
index ffceff3..e77d1b0 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerBean.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerBean.java
@@ -24,8 +24,6 @@
 
 import org.apache.zookeeper.Version;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
-import org.apache.zookeeper.server.ServerStats;
-import org.apache.zookeeper.server.ZooKeeperServer;
 
 /**
  * This class implements the ZooKeeper server MBean interface.
@@ -45,7 +43,7 @@
     public String getClientPort() {
         try {
             return InetAddress.getLocalHost().getHostAddress() + "":""
-                    + zks.getClientPort();
+                + zks.getClientPort();
         } catch (UnknownHostException e) {
             return ""localhost:"" + zks.getClientPort();
         }
"
zookeeper,c5d28b03b72253f2ca6d9142a17487b253317ec6,ZOOKEEPER-302. Quote values in JMX objectnames. (tom and pat via mahadev),2009.02.07 06:19:03,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
index dff4346..3e9866f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
@@ -187,6 +187,7 @@
             MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
         } catch (Exception e) {
             LOG.warn(""Failed to register with JMX"", e);
+            jmxDataTreeBean = null;
         }
     }
 
@@ -194,14 +195,21 @@
             LocalPeerBean localPeerBean)
     {
         // register with JMX
-        try {
-            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);
+        if (self.jmxLeaderElectionBean != null) {
+            try {
+                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);
+            } catch (Exception e) {
+                LOG.warn(""Failed to register with JMX"", e);
+            }
             self.jmxLeaderElectionBean = null;
+        }
 
+        try {
             jmxServerBean = followerBean;
             MBeanRegistry.getInstance().register(followerBean, localPeerBean);
         } catch (Exception e) {
             LOG.warn(""Failed to register with JMX"", e);
+            jmxServerBean = null;
         }
     }
 
"
zookeeper,c5d28b03b72253f2ca6d9142a17487b253317ec6,ZOOKEEPER-302. Quote values in JMX objectnames. (tom and pat via mahadev),2009.02.07 06:19:03,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
index 83a23c5..be0c876 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
@@ -96,6 +96,7 @@
             MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
         } catch (Exception e) {
             LOG.warn(""Failed to register with JMX"", e);
+            jmxDataTreeBean = null;
         }
     }
 
@@ -103,14 +104,21 @@
             LocalPeerBean localPeerBean)
     {
         // register with JMX
-        try {
-            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);
+        if (self.jmxLeaderElectionBean != null) {
+            try {
+                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);
+            } catch (Exception e) {
+                LOG.warn(""Failed to register with JMX"", e);
+            }
             self.jmxLeaderElectionBean = null;
+        }
 
+        try {
             jmxServerBean = leaderBean;
             MBeanRegistry.getInstance().register(leaderBean, localPeerBean);
         } catch (Exception e) {
             LOG.warn(""Failed to register with JMX"", e);
+            jmxServerBean = null;
         }
     }
 
"
zookeeper,c5d28b03b72253f2ca6d9142a17487b253317ec6,ZOOKEEPER-302. Quote values in JMX objectnames. (tom and pat via mahadev),2009.02.07 06:19:03,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index baa4eb2..35bd806 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -372,6 +372,7 @@
             MBeanRegistry.getInstance().register(jmxLeaderElectionBean, jmxLocalPeerBean);        
         } catch (Exception e) {
             LOG.warn(""Failed to register with JMX"", e);
+            jmxLeaderElectionBean = null;
         }
 
         if(electionAlg==null)
@@ -407,13 +408,24 @@
                 ZKMBeanInfo p;
                 if (getId() == s.id) {
                     p = jmxLocalPeerBean = new LocalPeerBean(this);
+                    try {
+                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);
+                    } catch (Exception e) {
+                        LOG.warn(""Failed to register with JMX"", e);
+                        jmxLocalPeerBean = null;
+                    }
                 } else {
                     p = new RemotePeerBean(s);
+                    try {
+                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);
+                    } catch (Exception e) {
+                        LOG.warn(""Failed to register with JMX"", e);
+                    }
                 }
-                MBeanRegistry.getInstance().register(p, jmxQuorumBean);
             }
         } catch (Exception e) {
             LOG.warn(""Failed to register with JMX"", e);
+            jmxQuorumBean = null;
         }
 
         try {
"
zookeeper,2890f77b0ea58176e14780d99c4dc3cc0dfa88fd,ZOOKEEPER-291. regression for legacy code using KeeperException.Code constants (due to 246). (pat via mahadev),2009.02.05 04:57:39,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/KeeperException.java b/src/java/main/org/apache/zookeeper/KeeperException.java
index 437194c..d669890 100644
--- a/src/java/main/org/apache/zookeeper/KeeperException.java
+++ b/src/java/main/org/apache/zookeeper/KeeperException.java
@@ -136,60 +136,195 @@
         this.code = Code.get(code);
     }
 
-    public static enum Code {
+    /** This interface contains the original static final int constants
+     * which have now been replaced with an enumeration in Code. Do not
+     * reference this class directly, if necessary (legacy code) continue
+     * to access the constants through Code.
+     * Note: an interface is used here due to the fact that enums cannot
+     * reference constants defined within the same enum as said constants
+     * are considered initialized _after_ the enum itself. By using an
+     * interface as a super type this allows the deprecated constants to
+     * be initialized first and referenced when constructing the enums. I
+     * didn't want to have constants declared twice. This
+     * interface should be private, but it's declared public to enable
+     * javadoc to include in the user API spec.
+     */
+    @Deprecated
+    public interface CodeDeprecated {
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#OK} instead
+         */
+        @Deprecated
+        public static final int Ok = 0;
+
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#SYSTEMERROR} instead
+         */
+        @Deprecated
+        public static final int SystemError = -1;
+        /**
+         * @deprecated deprecated in 3.1.0, use
+         * {@link Code#RUNTIMEINCONSISTENCY} instead
+         */
+        @Deprecated
+        public static final int RuntimeInconsistency = -2;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#DATAINCONSISTENCY}
+         * instead
+         */
+        @Deprecated
+        public static final int DataInconsistency = -3;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#CONNECTIONLOSS}
+         * instead
+         */
+        @Deprecated
+        public static final int ConnectionLoss = -4;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#MARSHALLINGERROR}
+         * instead
+         */
+        @Deprecated
+        public static final int MarshallingError = -5;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#UNIMPLEMENTED}
+         * instead
+         */
+        @Deprecated
+        public static final int Unimplemented = -6;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#OPERATIONTIMEOUT}
+         * instead
+         */
+        @Deprecated
+        public static final int OperationTimeout = -7;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#BADARGUMENTS}
+         * instead
+         */
+        @Deprecated
+        public static final int BadArguments = -8;
+
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#APIERROR} instead
+         */
+        @Deprecated
+        public static final int APIError = -100;
+
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#NONODE} instead
+         */
+        @Deprecated
+        public static final int NoNode = -101;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#NOAUTH} instead
+         */
+        @Deprecated
+        public static final int NoAuth = -102;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#BADVERSION} instead
+         */
+        @Deprecated
+        public static final int BadVersion = -103;
+        /**
+         * @deprecated deprecated in 3.1.0, use
+         * {@link Code#NOCHILDRENFOREPHEMERALS}
+         * instead
+         */
+        @Deprecated
+        public static final int NoChildrenForEphemerals = -108;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#NODEEXISTS} instead
+         */
+        @Deprecated
+        public static final int NodeExists = -110;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#NOTEMPTY} instead
+         */
+        @Deprecated
+        public static final int NotEmpty = -111;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#SESSIONEXPIRED} instead
+         */
+        @Deprecated
+        public static final int SessionExpired = -112;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#INVALIDCALLBACK}
+         * instead
+         */
+        @Deprecated
+        public static final int InvalidCallback = -113;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#INVALIDACL} instead
+         */
+        @Deprecated
+        public static final int InvalidACL = -114;
+        /**
+         * @deprecated deprecated in 3.1.0, use {@link Code#AUTHFAILED} instead
+         */
+        @Deprecated
+        public static final int AuthFailed = -115;
+    }
+
+    /** Codes which represent the various KeeperException
+     * types. This enum replaces the deprecated earlier static final int
+     * constants. The old, deprecated, values are in ""camel case"" while the new
+     * enum values are in all CAPS.
+     */
+    public static enum Code implements CodeDeprecated {
         /** Everything is OK */
-        OK (0),
+        OK (Ok),
 
         /** System and server-side errors.
          * This is never thrown by the server, it shouldn't be used other than
          * to indicate a range. Specifically error codes greater than this
          * value, but lesser than {@link #APIERROR}, are system errors.
          */
-        SYSTEMERROR (-1),
+        SYSTEMERROR (SystemError),
 
         /** A runtime inconsistency was found */
-        RUNTIMEINCONSISTENCY (-2),
+        RUNTIMEINCONSISTENCY (RuntimeInconsistency),
         /** A data inconsistency was found */
-        DATAINCONSISTENCY (-3),
+        DATAINCONSISTENCY (DataInconsistency),
         /** Connection to the server has been lost */
-        CONNECTIONLOSS (-4),
+        CONNECTIONLOSS (ConnectionLoss),
         /** Error while marshalling or unmarshalling data */
-        MARSHALLINGERROR (-5),
+        MARSHALLINGERROR (MarshallingError),
         /** Operation is unimplemented */
-        UNIMPLEMENTED (-6),
+        UNIMPLEMENTED (Unimplemented),
         /** Operation timeout */
-        OPERATIONTIMEOUT (-7),
+        OPERATIONTIMEOUT (OperationTimeout),
         /** Invalid arguments */
-        BADARGUMENTS (-8),
+        BADARGUMENTS (BadArguments),
 
         /** API errors.
          * This is never thrown by the server, it shouldn't be used other than
          * to indicate a range. Specifically error codes greater than this
-         * value are API errors (while values less than this indicate a 
+         * value are API errors (while values less than this indicate a
          * {@link #SYSTEMERROR}).
          */
-        APIERROR (-100),
+        APIERROR (APIError),
 
         /** Node does not exist */
-        NONODE (-101),
+        NONODE (NoNode),
         /** Not authenticated */
-        NOAUTH (-102),
+        NOAUTH (NoAuth),
         /** Version conflict */
-        BADVERSION (-103),
+        BADVERSION (BadVersion),
         /** Ephemeral nodes may not have children */
-        NOCHILDRENFOREPHEMERALS (-108),
+        NOCHILDRENFOREPHEMERALS (NoChildrenForEphemerals),
         /** The node already exists */
-        NODEEXISTS (-110),
+        NODEEXISTS (NodeExists),
         /** The node has children */
-        NOTEMPTY (-111),
+        NOTEMPTY (NotEmpty),
         /** The session has been expired by the server */
-        SESSIONEXPIRED (-112),
+        SESSIONEXPIRED (SessionExpired),
         /** Invalid callback specified */
-        INVALIDCALLBACK (-113),
+        INVALIDCALLBACK (InvalidCallback),
         /** Invalid ACL specified */
-        INVALIDACL (-114),
+        INVALIDACL (InvalidACL),
         /** Client authentication failed */
-        AUTHFAILED (-115);
+        AUTHFAILED (AuthFailed);
 
         private static final Map<Integer,Code> lookup
             = new HashMap<Integer,Code>();
@@ -218,116 +353,6 @@
         public static Code get(int code) {
             return lookup.get(code);
         }
-
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #OK} instead
-         */
-        @Deprecated
-        public static final int Ok = OK.code;
-
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #SYSTEMERROR} instead
-         */
-        @Deprecated
-        public static final int SystemError = SYSTEMERROR.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #RUNTIMEINCONSISTENCY} instead
-         */
-        @Deprecated
-        public static final int RuntimeInconsistency = RUNTIMEINCONSISTENCY.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #DATAINCONSISTENCY}
-         * instead
-         */
-        @Deprecated
-        public static final int DataInconsistency = DATAINCONSISTENCY.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #CONNECTIONLOSS}
-         * instead
-         */
-        @Deprecated
-        public static final int ConnectionLoss = CONNECTIONLOSS.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #MARSHALLINGERROR}
-         * instead
-         */
-        @Deprecated
-        public static final int MarshallingError = MARSHALLINGERROR.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #UNIMPLEMENTED} instead
-         */
-        @Deprecated
-        public static final int Unimplemented = UNIMPLEMENTED.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #OPERATIONTIMEOUT}
-         * instead
-         */
-        @Deprecated
-        public static final int OperationTimeout = OPERATIONTIMEOUT.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #BADARGUMENTS} instead
-         */
-        @Deprecated
-        public static final int BadArguments = BADARGUMENTS.code;
-
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #APIERROR} instead
-         */
-        @Deprecated
-        public static final int APIError = APIERROR.code;
-
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #NONODE} instead
-         */
-        @Deprecated
-        public static final int NoNode = NONODE.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #NOAUTH} instead
-         */
-        @Deprecated
-        public static final int NoAuth = NOAUTH.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #BADVERSION} instead
-         */
-        @Deprecated
-        public static final int BadVersion = BADVERSION.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #NOCHILDRENFOREPHEMERALS}
-         * instead
-         */
-        @Deprecated
-        public static final int
-            NoChildrenForEphemerals = NOCHILDRENFOREPHEMERALS.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #NODEEXISTS} instead
-         */
-        @Deprecated
-        public static final int NodeExists = NODEEXISTS.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #NOTEMPTY} instead
-         */
-        @Deprecated
-        public static final int NotEmpty = NOTEMPTY.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #SESSIONEXPIRED} instead
-         */
-        @Deprecated
-        public static final int SessionExpired = SESSIONEXPIRED.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #INVALIDCALLBACK} instead
-         */
-        @Deprecated
-        public static final int InvalidCallback = INVALIDCALLBACK.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #INVALIDACL} instead
-         */
-        @Deprecated
-        public static final int InvalidACL = INVALIDACL.code;
-        /**
-         * @deprecated deprecated in 3.1.0, use {@link #AUTHFAILED} instead
-         */
-        @Deprecated
-        public static final int AuthFailed = AUTHFAILED.code;
     }
 
     static String getCodeMessage(Code code) {
"
zookeeper,bdcdc82e97512d6094ea25775a8d77c1597e1223,ZOOKEEPER-252. PurgeTxnLog is not handling the new dataDir directory structure,2009.01.31 10:18:30,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
index cbe496e..065bde5 100644
--- a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
@@ -28,38 +28,55 @@
 import java.util.List;
 import java.util.Set;
 
+import org.apache.log4j.Logger;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
 import org.apache.zookeeper.server.persistence.Util;
 
+/**
+ * this class is used to clean up the 
+ * snapshot and data log dir's. This is usually
+ * run as a cronjob on the zookeeper server machine.
+ * Invocation of this class will clean up the datalogdir
+ * files and snapdir files keeping the last ""-n"" snapshot files
+ * and the corresponding logs.
+ */
 public class PurgeTxnLog {
+    private static final Logger LOG = Logger.getLogger(PurgeTxnLog.class);
 
     static void printUsage(){
-        System.out.println(""PurgeTxnLog dataLogDir [snapDir]"");
+        System.out.println(""PurgeTxnLog dataLogDir [snapDir] -n count"");
         System.out.println(""\tdataLogDir -- path to the txn log directory"");
         System.out.println(""\tsnapDir -- path to the snapshot directory"");
+        System.out.println(""\tcount -- the number of old snaps/logs you want to keep"");
         System.exit(1);
     }
+    
     /**
-     * @param args PurgeTxnLog dataLogDir
-     *     dataLogDir -- txn log directory
+     * purges the snapshot and logs keeping the last num snapshots 
+     * and the corresponding logs.
+     * @param dataDir the dir that has the logs
+     * @param snapDir the dir that has the snapshots
+     * @param num the number of snapshots to keep
+     * @throws IOException
      */
-    public static void main(String[] args) throws IOException {
-        if(args.length<1 || args.length>2)
-            printUsage();
+    public static void purge(File dataDir, File snapDir, int num) throws IOException {
+        if (num < 3) {
+            throw new IllegalArgumentException(""count should be greater than 3"");
+        }
 
-        File dataDir=new File(args[0]);
-        File snapDir=dataDir;
-        if(args.length==2){
-            snapDir=new File(args[1]);
-            }
         FileTxnSnapLog txnLog = new FileTxnSnapLog(dataDir, snapDir);
         
         // found any valid recent snapshots?
         
         // files to exclude from deletion
         Set<File> exc=new HashSet<File>();
-        File snapShot = txnLog.findMostRecentSnapshot();
-        exc.add(txnLog.findMostRecentSnapshot());
+        List<File> snaps = txnLog.findNRecentSnapshots(num);
+        if (snaps.size() == 0) 
+            return;
+        File snapShot = snaps.get(snaps.size() -1);
+        for (File f: snaps) {
+            exc.add(f);
+        }
         long zxid = Util.getZxidFromName(snapShot.getName(),""snapshot"");
         exc.addAll(Arrays.asList(txnLog.getSnapshotLogs(zxid)));
 
@@ -77,9 +94,9 @@
         }
         // add all non-excluded log files
         List<File> files=new ArrayList<File>(
-                Arrays.asList(dataDir.listFiles(new MyFileFilter(""log.""))));
+                Arrays.asList(txnLog.getDataDir().listFiles(new MyFileFilter(""log.""))));
         // add all non-excluded snapshot files to the deletion list
-        files.addAll(Arrays.asList(snapDir.listFiles(new MyFileFilter(""snapshot.""))));
+        files.addAll(Arrays.asList(txnLog.getSnapDir().listFiles(new MyFileFilter(""snapshot.""))));
         // remove the old files
         for(File f: files)
         {
@@ -90,5 +107,26 @@
                 System.err.println(""Failed to remove ""+f.getPath());
             }
         }
+
+    }
+    
+    /**
+     * @param args PurgeTxnLog dataLogDir
+     *     dataLogDir -- txn log directory
+     *     -n num (number of snapshots to keep)
+     */
+    public static void main(String[] args) throws IOException {
+        if(args.length<3 || args.length>4)
+            printUsage();
+        int i = 0;
+        File dataDir=new File(args[0]);
+        File snapDir=dataDir;
+        if(args.length==4){
+            i++;
+            snapDir=new File(args[i]);
+        }
+        i++; i++;
+        int num = Integer.parseInt(args[i]);
+        purge(dataDir, snapDir, num);
     }
 }
"
zookeeper,bdcdc82e97512d6094ea25775a8d77c1597e1223,ZOOKEEPER-252. PurgeTxnLog is not handling the new dataDir directory structure,2009.01.31 10:18:30,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
index 4206198..ad0c55b 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
@@ -26,6 +26,7 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.zip.Adler32;
@@ -121,6 +122,25 @@
         }
         return null;
     }
+    
+    /**
+     * find the last n snapshots.
+     * @param the number of most recent snapshots 
+     * @return the last n snapshots
+     * @throws IOException
+     */
+    public List<File> findNRecentSnapshots(int n) throws IOException {
+        List<File> files = Util.sortDataDir(snapDir.listFiles(), ""snapshot"", false);
+        int i = 0;
+        List<File> list = new ArrayList<File>();
+        for (File f: files) {
+            if (i==n)
+                break;
+            i++;
+            list.add(f);
+        }
+        return list;
+    }
 
     /**
      * serialize the datatree and sessions
"
zookeeper,bdcdc82e97512d6094ea25775a8d77c1597e1223,ZOOKEEPER-252. PurgeTxnLog is not handling the new dataDir directory structure,2009.01.31 10:18:30,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index e5707e1..76d2c73 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -20,6 +20,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
@@ -224,6 +225,18 @@
         FileSnap snaplog = new FileSnap(snapDir);
         return snaplog.findMostRecentSnapshot();
     }
+    
+    /**
+     * the n most recent snapshots
+     * @param n the number of recent snapshots
+     * @return the list of n most recent snapshots, with
+     * the most recent in front
+     * @throws IOException
+     */
+    public List<File> findNRecentSnapshots(int n) throws IOException {
+        FileSnap snaplog = new FileSnap(snapDir);
+        return snaplog.findNRecentSnapshots(n);
+    }
 
     /**
      * get the snapshot logs that are greater than
"
zookeeper,85fc47a95dc4cd72a5ea79bcb3ab87613fa8535b,"ZOOKEEPER-16. Need to do path validation. (pat, mahadev)",2009.01.31 08:01:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index e2b1b3a..852e50f 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -97,10 +97,10 @@
  */
 public class ZooKeeper {
     private static final Logger LOG;
-    
+
     static {
         LOG = Logger.getLogger(ZooKeeper.class);
-        
+
         Environment.logEnv(""Client environment:"", LOG);
     }
 
@@ -134,7 +134,7 @@
             new HashMap<String, Set<Watcher>>();
         private final Map<String, Set<Watcher>> childWatches =
             new HashMap<String, Set<Watcher>>();
-        
+
         private volatile Watcher defaultWatcher;
 
         final private void addTo(Set<Watcher> from, Set<Watcher> to) {
@@ -142,7 +142,7 @@
                 to.addAll(from);
             }
         }
-        
+
         /* (non-Javadoc)
          * @see org.apache.zookeeper.ClientWatchManager#materialize(Event.KeeperState, Event.EventType, java.lang.String)
          */
@@ -219,7 +219,7 @@
             return result;
         }
     }
-    
+
     /**
      * Register a watcher for a particular path.
      */
@@ -233,7 +233,7 @@
         }
 
         abstract protected Map<String, Set<Watcher>> getWatches(int rc);
-        
+
         /**
          * Register the watcher with the set of watches on path.
          * @param rc the result code of the operation that attempted to
@@ -270,12 +270,12 @@
         public ExistsWatchRegistration(Watcher watcher, String path) {
             super(watcher, path);
         }
-        
+
         @Override
         protected Map<String, Set<Watcher>> getWatches(int rc) {
             return rc == 0 ?  watchManager.dataWatches : watchManager.existWatches;
         }
-        
+
         @Override
         protected boolean shouldAddWatch(int rc) {
             return rc == 0 || rc == KeeperException.Code.NONODE.intValue();
@@ -292,7 +292,7 @@
             return watchManager.dataWatches;
         }
     }
-    
+
     class ChildWatchRegistration extends WatchRegistration {
         public ChildWatchRegistration(Watcher watcher, String path) {
             super(watcher, path);
@@ -493,12 +493,15 @@
      * @return the actual path of the created node
      * @throws KeeperException if the server returns a non-zero error code
      * @throws org.apache.zookeeper.KeeperException.InvalidACLException if the ACL is invalid
-     * @throws InterruptedException if the transaction is interrrupted
+     * @throws InterruptedException if the transaction is interrupted
+     * @throws IllegalArgumentException if an invalid path is specified
      */
     public String create(String path, byte data[], List<ACL> acl,
             CreateMode createMode)
         throws KeeperException, InterruptedException
     {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.create);
         CreateRequest request = new CreateRequest();
@@ -519,6 +522,72 @@
     }
 
     /**
+     * Validate the provided znode path string
+     * @param path znode path string
+     * @throws IllegalArgumentException if the path is invalid
+     */
+    public static void validatePath(String path) throws IllegalArgumentException {
+        if (path == null) {
+            throw new IllegalArgumentException(""Path cannot be null"");
+        }
+        if (path.length() == 0) {
+            throw new IllegalArgumentException(""Path length must be > 0"");
+        }
+        if (path.charAt(0) != '/') {
+            throw new IllegalArgumentException(
+                         ""Path must start with / character"");
+        }
+        if (path.length() == 1) { // done checking - it's the root
+            return;
+        }
+        if (path.charAt(path.length() - 1) == '/') {
+            throw new IllegalArgumentException(
+                         ""Path must not end with / character"");
+        }
+
+        String reason = null;
+        char lastc = '/';
+        char chars[] = path.toCharArray();
+        char c;
+        for (int i = 1; i < chars.length; lastc = chars[i], i++) {
+            c = chars[i];
+
+            if (c == 0) {
+                reason = ""null character not allowed @"" + i;
+                break;
+            } else if (c == '/' && lastc == '/') {
+                reason = ""empty node name specified @"" + i;
+                break;
+            } else if (c == '.' && lastc == '.') {
+                if (chars[i-2] == '/' &&
+                        ((i + 1 == chars.length)
+                                || chars[i+1] == '/')) {
+                    reason = ""relative paths not allowed @"" + i;
+                    break;
+                }
+            } else if (c == '.') {
+                if (chars[i-1] == '/' &&
+                        ((i + 1 == chars.length)
+                                || chars[i+1] == '/')) {
+                    reason = ""relative paths not allowed @"" + i;
+                    break;
+                }
+            } else if (c > '\u0000' && c < '\u001f'
+                    || c > '\u007f' && c < '\u009F'
+                    || c > '\ud800' && c < '\uf8ff'
+                    || c > '\ufff0' && c < '\uffff') {
+                reason = ""invalid charater @"" + i;
+                break;
+            }
+        }
+
+        if (reason != null) {
+            throw new IllegalArgumentException(
+                    ""Invalid path string \"""" + path + ""\"" caused by "" + reason);
+        }
+    }
+
+    /**
      * The Asynchronous version of create. The request doesn't actually until
      * the asynchronous callback is called.
      *
@@ -528,6 +597,8 @@
     public void create(String path, byte data[], List<ACL> acl,
             CreateMode createMode,  StringCallback cb, Object ctx)
     {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.create);
         CreateRequest request = new CreateRequest();
@@ -564,9 +635,12 @@
      *                the expected node version.
      * @throws InterruptedException IF the server transaction is interrupted
      * @throws KeeperException If the server signals an error with a non-zero return code.
+     * @throws IllegalArgumentException if an invalid path is specified
      */
     public void delete(String path, int version) throws
             InterruptedException, KeeperException {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.delete);
         DeleteRequest request = new DeleteRequest();
@@ -585,6 +659,8 @@
      * @see #delete(String, int)
      */
     public void delete(String path, int version, VoidCallback cb, Object ctx) {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.delete);
         DeleteRequest request = new DeleteRequest();
@@ -608,10 +684,13 @@
      *         node exists.
      * @throws KeeperException If the server signals an error
      * @throws InterruptedException If the server transaction is interrupted.
+     * @throws IllegalArgumentException if an invalid path is specified
      */
     public Stat exists(String path, Watcher watcher) throws KeeperException,
         InterruptedException
     {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.exists);
         ExistsRequest request = new ExistsRequest();
@@ -666,6 +745,8 @@
     public void exists(String path, Watcher watcher, StatCallback cb,
             Object ctx)
     {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.exists);
         ExistsRequest request = new ExistsRequest();
@@ -707,9 +788,12 @@
      * @return the data of the node
      * @throws KeeperException If the server signals an error with a non-zero error code
      * @throws InterruptedException If the server transaction is interrupted.
+     * @throws IllegalArgumentException if an invalid path is specified
      */
     public byte[] getData(String path, Watcher watcher, Stat stat)
             throws KeeperException, InterruptedException {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getData);
         GetDataRequest request = new GetDataRequest();
@@ -760,6 +844,8 @@
      * @see #getData(String, Watcher, Stat)
      */
     public void getData(String path, Watcher watcher, DataCallback cb, Object ctx) {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getData);
         GetDataRequest request = new GetDataRequest();
@@ -810,9 +896,12 @@
      * @return the state of the node
      * @throws InterruptedException If the server transaction is interrupted.
      * @throws KeeperException If the server signals an error with a non-zero error code.
+     * @throws IllegalArgumentException if an invalid path is specified
      */
     public Stat setData(String path, byte data[], int version)
             throws KeeperException, InterruptedException {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.setData);
         SetDataRequest request = new SetDataRequest();
@@ -835,6 +924,8 @@
      */
     public void setData(String path, byte data[], int version, StatCallback cb,
             Object ctx) {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.setData);
         SetDataRequest request = new SetDataRequest();
@@ -860,9 +951,12 @@
      * @return the ACL array of the given node.
      * @throws InterruptedException If the server transaction is interrupted.
      * @throws KeeperException If the server signals an error with a non-zero error code.
+     * @throws IllegalArgumentException if an invalid path is specified
      */
     public List<ACL> getACL(String path, Stat stat)
             throws KeeperException, InterruptedException {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getACL);
         GetACLRequest request = new GetACLRequest();
@@ -883,6 +977,8 @@
      * @see #getACL(String, Stat)
      */
     public void getACL(String path, Stat stat, ACLCallback cb, Object ctx) {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getACL);
         GetACLRequest request = new GetACLRequest();
@@ -911,9 +1007,12 @@
      * @throws InterruptedException If the server transaction is interrupted.
      * @throws KeeperException If the server signals an error with a non-zero error code.
      * @throws org.apache.zookeeper.KeeperException.InvalidACLException If the acl is invalide.
+     * @throws IllegalArgumentException if an invalid path is specified
      */
     public Stat setACL(String path, List<ACL> acl, int version)
             throws KeeperException, InterruptedException {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.setACL);
         SetACLRequest request = new SetACLRequest();
@@ -939,6 +1038,8 @@
      */
     public void setACL(String path, List<ACL> acl, int version,
             StatCallback cb, Object ctx) {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.setACL);
         SetACLRequest request = new SetACLRequest();
@@ -970,9 +1071,12 @@
      * @return an unordered array of children of the node with the given path
      * @throws InterruptedException If the server transaction is interrupted.
      * @throws KeeperException If the server signals an error with a non-zero error code.
+     * @throws IllegalArgumentException if an invalid path is specified
      */
     public List<String> getChildren(String path, Watcher watcher)
             throws KeeperException, InterruptedException {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getChildren);
         GetChildrenRequest request = new GetChildrenRequest();
@@ -1023,6 +1127,8 @@
      */
     public void getChildren(String path, Watcher watcher, ChildrenCallback cb,
             Object ctx) {
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getChildren);
         GetChildrenRequest request = new GetChildrenRequest();
@@ -1050,8 +1156,14 @@
 
     /**
      * Asynchronous sync. Flushes channel between process and leader.
+     * @param path
+     * @param cb a handler for the callback
+     * @param ctx context to be provided to the callback
+     * @throws IllegalArgumentException if an invalid path is specified
      */
     public void sync(String path, VoidCallback cb, Object ctx){
+        validatePath(path);
+
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.sync);
         SyncRequest request = new SyncRequest();
"
zookeeper,85fc47a95dc4cd72a5ea79bcb3ab87613fa8535b,"ZOOKEEPER-16. Need to do path validation. (pat, mahadev)",2009.01.31 08:01:33,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index b0f9fd7..b25f328 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -30,6 +30,7 @@
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.KeeperException.Code;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.data.ACL;
@@ -67,7 +68,13 @@
             LOG.info(""zookeeper.skipACL==\""yes\"", ACL checks will be skipped"");
         }
     }
-
+    
+    /**
+     * this is only for testing purposes.
+     * should never be useed otherwise
+     */
+    public static boolean failCreate = false;
+    
     LinkedBlockingQueue<Request> submittedRequests = new LinkedBlockingQueue<Request>();
 
     RequestProcessor nextProcessor;
@@ -189,7 +196,16 @@
                         createRequest);
                 String path = createRequest.getPath();
                 int lastSlash = path.lastIndexOf('/');
-                if (lastSlash == -1 || path.indexOf('\0') != -1) {
+                if (lastSlash == -1 || path.indexOf('\0') != -1 || failCreate) {
+                    LOG.warn(""Invalid path "" + path + "" with session "" +
+                            Long.toHexString(request.sessionId));
+                    throw new KeeperException.BadArgumentsException();
+                }
+                try {
+                    ZooKeeper.validatePath(path);
+                } catch(IllegalArgumentException ie) {
+                    LOG.warn(""Invalid path "" + path + "" with session "" +
+                            Long.toHexString(request.sessionId));
                     throw new KeeperException.BadArgumentsException();
                 }
                 if (!fixupACL(request.authInfo, createRequest.getAcl())) {
"
zookeeper,bd67906b1daa622e2c78032f453c0cc2e777b8cb,ZOOKEEPER-272. getchildren can fail for large number of children. (mahadev),2009.01.30 08:21:37,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index abdb629..d056310 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -81,12 +81,15 @@
      * option allows the client to turn off this behavior by setting
      * the environment variable ""zookeeper.disableAutoWatchReset"" to ""true"" */
     public static boolean disableAutoWatchReset;
+   
+    public static int packetLen;
     static {
         // this var should not be public, but otw there is no easy way 
         // to test
         disableAutoWatchReset = 
             Boolean.getBoolean(""zookeeper.disableAutoWatchReset"");
         LOG.info(""zookeeper.disableAutoWatchReset is "" + disableAutoWatchReset);
+        packetLen = Integer.getInteger(""jute.maxbuffer"", 4096 * 1024);
     }
 
     private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
@@ -502,7 +505,7 @@
 
         void readLength() throws IOException {
             int len = incomingBuffer.getInt();
-            if (len < 0 || len >= 4096 * 1024) {
+            if (len < 0 || len >= packetLen) {
                 throw new IOException(""Packet len"" + len + "" is out of range!"");
             }
             incomingBuffer = ByteBuffer.allocate(len);
"
zookeeper,7d8d199a4662ab710c8f3a12745b86dbdb4c7520," ZOOKEEPER-275. Bug in FastLeaderElection. (flavio via mahadev)",2009.01.30 08:11:02,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index c997807..7012407 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -186,6 +186,7 @@
             			response = manager.recvQueue.take();
             			
             			// Receive new message
+            			LOG.debug(""Receive new message."");
             			if (response.buffer.capacity() < 28) {
             				LOG.error(""Got a short response: ""
             						+ response.buffer.capacity());
@@ -246,7 +247,7 @@
             			    Vote current = self.getCurrentVote();
             			    if(ackstate == QuorumPeer.ServerState.LOOKING){
 
-            			        
+            			     	LOG.info(""Sending new notification."");   
             			        ToSend notmsg = new ToSend(
             			                ToSend.mType.notification, 
             			                current.id, 
@@ -395,11 +396,16 @@
     private void leaveInstance() {
         recvqueue.clear();
     }
-
+    
+    public QuorumCnxManager getCnxManager(){
+    	return manager;
+    }
+    
     public void shutdown(){
         manager.halt();
     }
 
+    
     /**
      * Send notifications to all peers upon a change in our vote
      */
@@ -425,9 +431,10 @@
      * @param id    Server identifier
      * @param zxid  Last zxid observed by the issuer of this vote
      */
-    private boolean totalOrderPredicate(long id, long zxid) {
-        if ((zxid > proposedZxid)
-                || ((zxid == proposedZxid) && (id > proposedLeader)))
+    private boolean totalOrderPredicate(long newId, long newZxid, long curId, long curZxid) {
+        LOG.debug(""id: "" + newId + "", proposed id: "" + curId + "", zxid: "" + newZxid + "", proposed zxid: "" + curZxid);
+        if ((newZxid > curZxid)
+                || ((newZxid == curZxid) && (newId > curId)))
             return true;
         else
             return false;
@@ -557,15 +564,21 @@
                     if (n.epoch > logicalclock) {
                         logicalclock = n.epoch;
                         recvset.clear();
-                        updateProposal(self.getId(), self.getLastLoggedZxid());
+                        if(totalOrderPredicate(n.leader, n.zxid, self.getId(), self.getLastLoggedZxid()))
+                            updateProposal(n.leader, n.zxid);
+                        else
+                            updateProposal(self.getId(), self.getLastLoggedZxid());
                         sendNotifications();
                     } else if (n.epoch < logicalclock) {
+                        LOG.info(""n.epoch < logicalclock"");
                         break;
-                    } else if (totalOrderPredicate(n.leader, n.zxid)) {
+                    } else if (totalOrderPredicate(n.leader, n.zxid, proposedLeader, proposedZxid)) {
+                        LOG.info(""Updating proposal"");
                         updateProposal(n.leader, n.zxid);
                         sendNotifications();
                     }
                 
+                    LOG.info(""Adding vote"");
                     recvset.put(n.sid, new Vote(n.leader, n.zxid, n.epoch));
 
                     //If have received from all nodes, then terminate
@@ -581,7 +594,7 @@
 
                         // Verify if there is any change in the proposed leader
                         while((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null){
-                            if(totalOrderPredicate(n.leader, n.zxid)){
+                            if(totalOrderPredicate(n.leader, n.zxid, proposedLeader, proposedZxid)){
                                 recvqueue.put(n);
                                 break;
                             }
"
zookeeper,7d8d199a4662ab710c8f3a12745b86dbdb4c7520," ZOOKEEPER-275. Bug in FastLeaderElection. (flavio via mahadev)",2009.01.30 08:11:02,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index e78d7b1..200eb3b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -128,7 +128,7 @@
 
         // Generates a challenge to guarantee one connection between pairs of
         // servers
-        genChallenge();
+        //genChallenge();
 
         // Starts listener thread that waits for connection requests 
         listener = new Listener();
@@ -364,11 +364,12 @@
      */
     boolean haveDelivered() {
         for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {
-            if (queue.size() != 0)
-                return false;
+            LOG.debug(""Queue size: "" + queue.size());
+            if (queue.size() == 0)
+                return true;
         }
 
-        return true;
+        return false;
     }
 
     /**
@@ -376,13 +377,17 @@
      */
     public void halt() {
         shutdown = true;
-        LOG.info(""Halting listener"");
+        LOG.debug(""Halting listener"");
         listener.halt();
         
-        for(SendWorker sw: senderWorkerMap.values()){
-            LOG.info(""Halting sender: "" + sw);
-            sw.finish();
-        }
+        softHalt();
+    }
+   
+    public void softHalt(){
+    	for(SendWorker sw: senderWorkerMap.values()){
+    		LOG.debug(""Halting sender: "" + sw);
+    		sw.finish();
+    	}   	
     }
 
     /**
@@ -401,6 +406,7 @@
                 ss = ServerSocketChannel.open();
                 int port = self.quorumPeers.get(self.getId()).electionAddr.getPort();
                 LOG.info(""My election bind port: "" + port);
+                ss.socket().setReuseAddress(true); 
                 ss.socket().bind(new InetSocketAddress(port));
 
                 while (!shutdown) {
@@ -410,6 +416,8 @@
                     
                     LOG.info(""Connection request ""
                             + sock.getRemoteSocketAddress());
+                    //synchronized(senderWorkerMap){
+                    LOG.info(""Connection request: "" + self.getId());
                     receiveConnection(client);
                 }
             } catch (IOException e) {
@@ -419,7 +427,7 @@
         
         void halt(){
             try{
-                if(ss != null) ss.close();
+                if((ss != null) && (ss.isOpen())) ss.close();
             } catch (IOException e){
                 LOG.warn(""Exception when shutting down listener: "" + e);
             }
@@ -453,6 +461,7 @@
         boolean finish() {
             running = false;
 
+            LOG.debug(""Calling finish"");
             this.interrupt();
             if (recvWorker != null)
                 recvWorker.finish();
"
zookeeper,7d8d199a4662ab710c8f3a12745b86dbdb4c7520," ZOOKEEPER-275. Bug in FastLeaderElection. (flavio via mahadev)",2009.01.30 08:11:02,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 3c5a58d..baa4eb2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -483,7 +483,9 @@
             follower.shutdown();
         }
         cnxnFactory.shutdown();
-        udpSocket.close();
+        if(udpSocket != null) {
+            udpSocket.close();
+        }
     }
 
     public String[] getQuorumPeers() {
"
zookeeper,e5b90d600c69107da88d1758c1e66eba7cc1abad,ZOOKEEPER-267.  java client incorrectly generating syncdisconnected event when in  disconnected state,2009.01.28 09:15:33,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index aaa8f53..abdb629 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -45,6 +45,8 @@
 import org.apache.zookeeper.AsyncCallback.StringCallback;
 import org.apache.zookeeper.AsyncCallback.VoidCallback;
 import org.apache.zookeeper.Watcher.Event;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.Watcher.Event.KeeperState;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.ZooKeeper.States;
 import org.apache.zookeeper.ZooKeeper.WatchRegistration;
@@ -307,6 +309,12 @@
         private final LinkedBlockingQueue<Object> waitingEvents = 
             new LinkedBlockingQueue<Object>();
 
+        /** This is really the queued session state until the event
+         * thread actually processes the event and hands it to the watcher.
+         * But for all intents and purposes this is the state.
+         */
+        private volatile KeeperState sessionState = KeeperState.Disconnected;
+
         EventThread() {
             super(currentThread().getName() + ""-EventThread"");
             setUncaughtExceptionHandler(uncaughtExceptionHandler);
@@ -314,6 +322,12 @@
         }
         
         public void queueEvent(WatchedEvent event) {
+            if (event.getType() == EventType.None 
+                    && sessionState == event.getState()) {
+                return;
+            }
+            sessionState = event.getState();
+
             // materialize the watchers based on the event
             WatcherSetEventPair pair = new WatcherSetEventPair(
                     watcher.materialize(event.getState(), event.getType(),
"
zookeeper,e5b90d600c69107da88d1758c1e66eba7cc1abad,ZOOKEEPER-267.  java client incorrectly generating syncdisconnected event when in  disconnected state,2009.01.28 09:15:33,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 9a48687..c7f51ae 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -45,7 +45,6 @@
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
 import org.apache.zookeeper.data.StatPersisted;
-import org.apache.zookeeper.proto.WatcherEvent;
 import org.apache.zookeeper.txn.CreateTxn;
 import org.apache.zookeeper.txn.DeleteTxn;
 import org.apache.zookeeper.txn.ErrorTxn;
"
zookeeper,e5b90d600c69107da88d1758c1e66eba7cc1abad,ZOOKEEPER-267.  java client incorrectly generating syncdisconnected event when in  disconnected state,2009.01.28 09:15:33,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
index cf0f70d..95551ed 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
@@ -22,11 +22,9 @@
 import java.util.LinkedList;
 
 import org.apache.log4j.Logger;
-
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.server.Request;
 import org.apache.zookeeper.server.RequestProcessor;
-import org.apache.zookeeper.server.ZooTrace;
 
 /**
  * This RequestProcessor matches the incoming committed requests with the
"
zookeeper,f340e569fe7c33985298397d31b89638a397bf19,ZOOKEEPER-268.  tostring on jute generated objects can cause NPE. (pat via mahadev),2009.01.27 04:21:38,Mahadev Konar,"diff --git a/src/java/main/org/apache/jute/Utils.java b/src/java/main/org/apache/jute/Utils.java
index 7dae860..ec21c41 100644
--- a/src/java/main/org/apache/jute/Utils.java
+++ b/src/java/main/org/apache/jute/Utils.java
@@ -19,20 +19,17 @@
 package org.apache.jute;
 
 import java.io.ByteArrayOutputStream;
-import java.io.DataInput;
-import java.io.DataOutput;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.nio.charset.CharacterCodingException;
 
 /**
- * Various utility functions for Hadooop record I/O runtime.
+ * Various utility functions for Hadoop record I/O runtime.
  * @author Milind Bhandarkar
  */
 public class Utils {
     
     /** Cannot create a new instance of Utils */
     private Utils() {
+        super();
     }
    
     /**
@@ -56,7 +53,7 @@
         return true;
     }
     
-    public static final char[] hexchars = { '0', '1', '2', '3', '4', '5',
+    private static final char[] hexchars = { '0', '1', '2', '3', '4', '5',
                                             '6', '7', '8', '9', 'A', 'B',
                                             'C', 'D', 'E', 'F' };
     /**
@@ -64,8 +61,10 @@
      * @param s 
      * @return 
      */
-    static String toXMLString(String t) {
-        String s = t.toString();
+    static String toXMLString(String s) {
+        if (s == null)
+            return """";
+
         StringBuffer sb = new StringBuffer();
         for (int idx = 0; idx < s.length(); idx++) {
           char ch = s.charAt(idx);
@@ -197,9 +196,12 @@
      * @return 
      */
     static String toXMLBuffer(byte barr[]) {
+        if (barr == null || barr.length == 0) {
+            return """";
+        }
         StringBuffer sb = new StringBuffer(2*barr.length);
         for (int idx = 0; idx < barr.length; idx++) {
-            sb.append(Integer.toHexString((int)barr[idx]));
+            sb.append(Integer.toHexString(barr[idx]));
         }
         return sb.toString();
     }
@@ -231,10 +233,13 @@
      * @return 
      */
     static String toCSVBuffer(byte barr[]) {
-        StringBuffer sb = new StringBuffer(barr.length+1);
+        if (barr == null || barr.length == 0) {
+            return """";
+        }
+        StringBuffer sb = new StringBuffer(barr.length + 1);
         sb.append('#');
         for(int idx = 0; idx < barr.length; idx++) {
-            sb.append(Integer.toHexString((int)barr[idx]));
+            sb.append(Integer.toHexString(barr[idx]));
         }
         return sb.toString();
     }
"
zookeeper,2e135ab9287f8babeeeddcfb7cd362f4d2b4278f,ZOOKEEPER-250. isvalidsnapshot should handle the case of 0 snapshot files better,2008.12.12 06:16:41,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
index 059ea80..4206198 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
@@ -109,8 +109,15 @@
     public File findMostRecentSnapshot() throws IOException {
         List<File> files = Util.sortDataDir(snapDir.listFiles(), ""snapshot"", false);
         for (File f : files) {
-            if(Util.isValidSnapshot(f))
-                return f;
+            // we should catch the exceptions from 
+            // the valid snapshot and continue
+            // until we find a valid one
+            try {
+                if(Util.isValidSnapshot(f))
+                    return f;
+            } catch(IOException e) {
+                LOG.info(""invalid snapshot "" + f, e);
+            }
         }
         return null;
     }
"
zookeeper,2e135ab9287f8babeeeddcfb7cd362f4d2b4278f,ZOOKEEPER-250. isvalidsnapshot should handle the case of 0 snapshot files better,2008.12.12 06:16:41,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/Util.java b/src/java/main/org/apache/zookeeper/server/persistence/Util.java
index 1414f7c..c20456a 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/Util.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/Util.java
@@ -162,6 +162,11 @@
 
         // Check for a valid snapshot
         RandomAccessFile raf = new RandomAccessFile(f, ""r"");
+        // including the header and the last / bytes
+        // the snapshot should be atleast 10 bytes
+        if (raf.length() < 10) {
+            return false;
+        }
         try {
             raf.seek(raf.length() - 5);
             byte bytes[] = new byte[5];
"
zookeeper,2e135ab9287f8babeeeddcfb7cd362f4d2b4278f,ZOOKEEPER-250. isvalidsnapshot should handle the case of 0 snapshot files better,2008.12.12 06:16:41,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java b/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java
index 5e62d15..c92aacb 100644
--- a/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java
+++ b/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java
@@ -224,8 +224,12 @@
         List<File> files = Util.sortDataDir(snapShotDir.listFiles(),
                 ""snapshot"", false);
         for (File f: files) {
-            if (Util.isValidSnapshot(f))
-                return f;
+            try {
+                if (Util.isValidSnapshot(f))
+                    return f;
+            } catch(IOException e) {
+                LOG.info(""Invalid snapshot "" + f, e);
+            }
         }
         return null;
     }
"
zookeeper,9f7759d73f44901226873cdf2da685877fa06f62,ZOOKEEPER-251. NullPointerException stopping and starting Zookeeper servers,2008.12.11 06:55:21,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index b38d0fb..93bfd0b 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -355,7 +355,8 @@
             if (!next())
                 return;
             while (hdr.getZxid() < zxid) {
-                next();
+                if (!next())
+                    return;
             }
         }
         
@@ -446,6 +447,7 @@
                 LOG.debug(""EOF excepton "" + e);
                 inputStream.close();
                 inputStream = null;
+                ia = null;
                 // thsi means that the file has ended 
                 // we shoud go to the next file
                 if (!goToNextLog()) {
"
zookeeper,9f7759d73f44901226873cdf2da685877fa06f62,ZOOKEEPER-251. NullPointerException stopping and starting Zookeeper servers,2008.12.11 06:55:21,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index a1e9171..697442b 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -85,6 +85,24 @@
     }
     
     /**
+     * get the datadir used by this filetxn
+     * snap log
+     * @return the data dir
+     */
+    public File getDataDir() {
+        return this.dataDir;
+    }
+    
+    /**
+     * get the snap dir used by this 
+     * filetxn snap log
+     * @return the snap dir
+     */
+    public File getSnapDir() {
+        return this.snapDir;
+    }
+    
+    /**
      * this function restors the server 
      * database after reading from the 
      * snapshots and transaction logs
"
zookeeper,4ee7c1d3a904d164ff6f12c862043a03d98101bd,ZOOKEEPER-241. Build of a distro fails after clean target is run. (patrick hunt via mahadev),2008.12.10 07:16:05,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/version/util/VerGen.java b/src/java/main/org/apache/zookeeper/version/util/VerGen.java
index 6996273..e85f4e1 100644
--- a/src/java/main/org/apache/zookeeper/version/util/VerGen.java
+++ b/src/java/main/org/apache/zookeeper/version/util/VerGen.java
@@ -59,6 +59,9 @@
             w.write(""    public static final int MAJOR="" + maj + "";\n"");
             w.write(""    public static final int MINOR="" + min + "";\n"");
             w.write(""    public static final int MICRO="" + micro + "";\n"");
+            if (rev < 0) {
+                System.out.println(""Unknown REVISION number, using "" + rev);
+            }
             w.write(""    public static final int REVISION="" + rev + "";\n"");
             w.write(""    public static final String BUILD_DATE=\"""" + buildDate
                     + ""\"";\n"");
@@ -108,7 +111,12 @@
             int maj = Integer.parseInt(v[0]);
             int min = Integer.parseInt(v[1]);
             int micro = Integer.parseInt(v[2]);
-            int rev = Integer.parseInt(args[1]);
+            int rev;
+            try {
+                rev = Integer.parseInt(args[1]);
+            } catch (NumberFormatException e) {
+                rev = -1;
+            }
             generateFile(new File("".""), maj, min, micro, rev, args[2]);
         } catch (NumberFormatException e) {
             System.err
"
zookeeper,4e482a0e8c2e79ea39ac98a422b604d5bd861250,ZOOKEEPER-249. QuorumPeer.getClientPort() always returns -1. (nitay joffe via mahadev),2008.12.09 14:09:48,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index c204cda..0765374 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -574,7 +574,7 @@
     }
 
     public int getClientPort() {
-        return -1;
+        return cnxnFactory.getLocalPort();
     }
 
     public void setClientPort(int clientPort) {
"
zookeeper,3fcc62dae5f63a64f68b5d36f8d22e3ecf751a78,ZOOKEEPER-204. SetWatches needs to be the first message after auth messages to the server (ben via mahadev),2008.11.19 19:20:35,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index e1cd548..6b1d664 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -336,87 +336,96 @@
             try {
                 while (true) {
                     Object event = waitingEvents.take();
-                    if (event == eventOfDeath) {
-                        break;
-                    }
+                    try {
+                        if (event == eventOfDeath) {
+                            break;
+                        }
 
-                    if (event instanceof WatcherSetEventPair) {
-                        // each watcher will process the event
-                        WatcherSetEventPair pair = (WatcherSetEventPair)event;
-                        for (Watcher watcher: pair.watchers) {
-                            watcher.process(pair.event);
-                        }
-                    } else {
-                        Packet p = (Packet) event;
-                        int rc = 0;
-                        String path = p.path;
-                        if (p.replyHeader.getErr() != 0) {
-                            rc = p.replyHeader.getErr();
-                        }
-                        if (p.cb == null) {
-                            LOG.warn(""Somehow a null cb got to EventThread!"");
-                        } else if (p.response instanceof ExistsResponse
-                                || p.response instanceof SetDataResponse
-                                || p.response instanceof SetACLResponse) {
-                            StatCallback cb = (StatCallback) p.cb;
-                            if (rc == 0) {
-                                if (p.response instanceof ExistsResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((ExistsResponse) p.response)
-                                                    .getStat());
-                                } else if (p.response instanceof SetDataResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((SetDataResponse) p.response)
-                                                    .getStat());
-                                } else if (p.response instanceof SetACLResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((SetACLResponse) p.response)
-                                                    .getStat());
+                        if (event instanceof WatcherSetEventPair) {
+                            // each watcher will process the event
+                            WatcherSetEventPair pair = (WatcherSetEventPair) event;
+                            for (Watcher watcher : pair.watchers) {
+                                try {
+                                    watcher.process(pair.event);
+                                } catch (Throwable t) {
+                                    LOG.error(""Error while calling watcher "", t);
                                 }
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
                             }
-                        } else if (p.response instanceof GetDataResponse) {
-                            DataCallback cb = (DataCallback) p.cb;
-                            GetDataResponse rsp = (GetDataResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx,
-                                        rsp.getData(), rsp.getStat());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null, null);
+                        } else {
+                            Packet p = (Packet) event;
+                            int rc = 0;
+                            String path = p.path;
+                            if (p.replyHeader.getErr() != 0) {
+                                rc = p.replyHeader.getErr();
                             }
-                        } else if (p.response instanceof GetACLResponse) {
-                            ACLCallback cb = (ACLCallback) p.cb;
-                            GetACLResponse rsp = (GetACLResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx, rsp.getAcl(),
-                                        rsp.getStat());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null, null);
+                            if (p.cb == null) {
+                                LOG.warn(""Somehow a null cb got to EventThread!"");
+                            } else if (p.response instanceof ExistsResponse
+                                    || p.response instanceof SetDataResponse
+                                    || p.response instanceof SetACLResponse) {
+                                StatCallback cb = (StatCallback) p.cb;
+                                if (rc == 0) {
+                                    if (p.response instanceof ExistsResponse) {
+                                        cb.processResult(rc, path, p.ctx,
+                                                ((ExistsResponse) p.response)
+                                                        .getStat());
+                                    } else if (p.response instanceof SetDataResponse) {
+                                        cb.processResult(rc, path, p.ctx,
+                                                ((SetDataResponse) p.response)
+                                                        .getStat());
+                                    } else if (p.response instanceof SetACLResponse) {
+                                        cb.processResult(rc, path, p.ctx,
+                                                ((SetACLResponse) p.response)
+                                                        .getStat());
+                                    }
+                                } else {
+                                    cb.processResult(rc, path, p.ctx, null);
+                                }
+                            } else if (p.response instanceof GetDataResponse) {
+                                DataCallback cb = (DataCallback) p.cb;
+                                GetDataResponse rsp = (GetDataResponse) p.response;
+                                if (rc == 0) {
+                                    cb.processResult(rc, path, p.ctx, rsp
+                                            .getData(), rsp.getStat());
+                                } else {
+                                    cb.processResult(rc, path, p.ctx, null,
+                                            null);
+                                }
+                            } else if (p.response instanceof GetACLResponse) {
+                                ACLCallback cb = (ACLCallback) p.cb;
+                                GetACLResponse rsp = (GetACLResponse) p.response;
+                                if (rc == 0) {
+                                    cb.processResult(rc, path, p.ctx, rsp
+                                            .getAcl(), rsp.getStat());
+                                } else {
+                                    cb.processResult(rc, path, p.ctx, null,
+                                            null);
+                                }
+                            } else if (p.response instanceof GetChildrenResponse) {
+                                ChildrenCallback cb = (ChildrenCallback) p.cb;
+                                GetChildrenResponse rsp = (GetChildrenResponse) p.response;
+                                if (rc == 0) {
+                                    cb.processResult(rc, path, p.ctx, rsp
+                                            .getChildren());
+                                } else {
+                                    cb.processResult(rc, path, p.ctx, null);
+                                }
+                            } else if (p.response instanceof CreateResponse) {
+                                StringCallback cb = (StringCallback) p.cb;
+                                CreateResponse rsp = (CreateResponse) p.response;
+                                if (rc == 0) {
+                                    cb.processResult(rc, path, p.ctx, rsp
+                                            .getPath());
+                                } else {
+                                    cb.processResult(rc, path, p.ctx, null);
+                                }
+                            } else if (p.cb instanceof VoidCallback) {
+                                VoidCallback cb = (VoidCallback) p.cb;
+                                cb.processResult(rc, path, p.ctx);
                             }
-                        } else if (p.response instanceof GetChildrenResponse) {
-                            ChildrenCallback cb = (ChildrenCallback) p.cb;
-                            GetChildrenResponse rsp = (GetChildrenResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx, rsp
-                                        .getChildren());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.response instanceof CreateResponse) {
-                            StringCallback cb = (StringCallback) p.cb;
-                            CreateResponse rsp = (CreateResponse) p.response;
-                            if (rc == 0) {
-                                cb
-                                        .processResult(rc, path, p.ctx, rsp
-                                                .getPath());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.cb instanceof VoidCallback) {
-                            VoidCallback cb = (VoidCallback) p.cb;
-                            cb.processResult(rc, path, p.ctx);
                         }
+                    } catch (Throwable t) {
+                        LOG.error(""Caught unexpected throwable"", t);
                     }
                 }
             } catch (InterruptedException e) {
@@ -504,15 +513,6 @@
             sessionPasswd = conRsp.getPasswd();
             eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None,
                     Watcher.Event.KeeperState.SyncConnected, null));
-            if (!disableAutoWatchReset) {
-                SetWatches sw = new SetWatches(lastZxid,
-                        zooKeeper.getDataWatches(),
-                        zooKeeper.getExistWatches(),
-                        zooKeeper.getChildWatches());
-                RequestHeader h = new RequestHeader();
-                h.setType(ZooDefs.OpCode.setWatches);
-                queuePacket(h, new ReplyHeader(), sw, null, null, null, null, null);
-            }
         }
 
         void readResponse() throws IOException {
@@ -702,6 +702,20 @@
             bb.putInt(bb.capacity() - 4);
             bb.rewind();
             synchronized (outgoingQueue) {
+                // We add backwards since we are pushing into the front
+                if (!disableAutoWatchReset) {
+                    SetWatches sw = new SetWatches(lastZxid,
+                            zooKeeper.getDataWatches(),
+                            zooKeeper.getExistWatches(),
+                            zooKeeper.getChildWatches());
+                    RequestHeader h = new RequestHeader();
+                    h.setType(ZooDefs.OpCode.setWatches);
+                    h.setXid(-8);
+                    Packet packet = new Packet(h, new ReplyHeader(), sw, null, null,
+                                null);
+                    outgoingQueue.addFirst(packet);
+                }
+
                 for (AuthData id : authInfo) {
                     outgoingQueue.addFirst(new Packet(new RequestHeader(-4,
                             OpCode.auth), null, new AuthPacket(0, id.scheme,
"
zookeeper,3fcc62dae5f63a64f68b5d36f8d22e3ecf751a78,ZOOKEEPER-204. SetWatches needs to be the first message after auth messages to the server (ben via mahadev),2008.11.19 19:20:35,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index ece61e0..eed3421 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -192,8 +192,11 @@
                 }
                 // XXX This shouldn't be needed, but just in case
                 synchronized (existWatches) {
-                    addTo(existWatches.remove(path), result);
-                    LOG.warn(""We are triggering an exists watch for delete! Shouldn't happen!"");
+                    Set<Watcher> list = existWatches.remove(path);
+                    if (list != null) {
+                        addTo(existWatches.remove(path), result);
+                        LOG.warn(""We are triggering an exists watch for delete! Shouldn't happen!"");
+                    }
                 }
                 synchronized (childWatches) {
                     addTo(childWatches.remove(path), result);
"
zookeeper,1b7dbc1c523d4105899340b064f169e88a727081,ZOOKEEPER-226. fix exists calls that fail on server if node has null data. (mahadev),2008.11.19 08:42:22,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/DataNode.java b/src/java/main/org/apache/zookeeper/server/DataNode.java
index 2558996..552b7e7 100644
--- a/src/java/main/org/apache/zookeeper/server/DataNode.java
+++ b/src/java/main/org/apache/zookeeper/server/DataNode.java
@@ -96,7 +96,7 @@
         to.setPzxid(stat.getPzxid());
         to.setVersion(stat.getVersion());
         to.setEphemeralOwner(stat.getEphemeralOwner());
-        to.setDataLength(data.length);
+        to.setDataLength(data == null ? 0 : data.length);
         to.setNumChildren(children.size());
     }
 
"
zookeeper,f7673ae440408e4107c3a7874caf3e4df91b078c,ZOOKEEPER-212. fix the snapshot to be asynchronous. (mahadev and ben),2008.11.18 08:18:47,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index 92b7988..730922b 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -37,6 +37,8 @@
     private LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();
     private RequestProcessor nextProcessor;
     boolean timeToDie = false;
+    Thread snapInProcess = null;
+    
     /**
      * Transactions that have been written and are waiting to be flushed to
      * disk. Basically this is the list of SyncItems whose callbacks will be
@@ -60,10 +62,6 @@
         start();
     }
 
-    private void startSnapshot() throws IOException {
-        zks.takeSnapshot();
-    }
-
     @Override
     public void run() {
         try {
@@ -89,7 +87,21 @@
                             // roll the log
                             zks.getLogWriter().rollLog();
                             // take a snapshot
-                            startSnapshot();
+                            if (snapInProcess != null && snapInProcess.isAlive()) {
+                                LOG.warn(""Too busy to snap, skipping"");
+                            }
+                            else {
+                                snapInProcess = new Thread(""Snapshot Thread"") {
+                                    public void run() {
+                                     try {
+                                         zks.takeSnapshot();
+                                     } catch(Exception e) {
+                                         LOG.warn(""Unexpected exception"", e);
+                                     }
+                                    }
+                                };
+                                snapInProcess.start();
+                            }
                             logCount = 0;
                         }
                     toFlush.add(si);
"
zookeeper,a79aaf38e4842f419269bdebf3bd1409bac81f7e,ZOOKEEPER-201. validate magic number when reading snapshot and transaction,2008.10.22 03:45:20,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
index 67bd888..059ea80 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
@@ -94,6 +94,11 @@
             InputArchive ia) throws IOException {
         FileHeader header = new FileHeader();
         header.deserialize(ia, ""fileheader"");
+        if (header.getMagic() != SNAP_MAGIC) {
+            throw new IOException(""mismatching magic headers ""
+                    + header.getMagic() + 
+                    "" !=  "" + FileSnap.SNAP_MAGIC);
+        }
         SerializeUtils.deserializeSnapshot(dt,ia,sessions);
     }
 
"
zookeeper,a79aaf38e4842f419269bdebf3bd1409bac81f7e,ZOOKEEPER-201. validate magic number when reading snapshot and transaction,2008.10.22 03:45:20,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 1c29930..b38d0fb 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -384,6 +384,10 @@
             throws IOException{
             FileHeader header= new FileHeader();
             header.deserialize(ia, ""fileheader"");
+            if (header.getMagic() != FileTxnLog.TXNLOG_MAGIC) {
+                throw new IOException(""Invalid magic number "" + header.getMagic() 
+                        + "" != "" + FileTxnLog.TXNLOG_MAGIC);
+            }  
         }
         
         /**
@@ -395,10 +399,10 @@
         protected InputArchive createInputArchive(File logFile) throws IOException {
             if(inputStream==null){
                 inputStream= new FileInputStream(logFile);
-                LOG.info(""Created new input stream "" + logFile);
+                LOG.debug(""Created new input stream "" + logFile);
                 ia  = BinaryInputArchive.getArchive(new BufferedInputStream(inputStream));
                 inStreamCreated(ia,inputStream);
-                LOG.info(""created new input archive "" + logFile);
+                LOG.debug(""created new input archive "" + logFile);
             }
             return ia;
         }
"
zookeeper,4a1154ac082506a3269e47e51ff2f600b6d28d07,ZOOKEEPER-200. the magic number for snapshot and log must be different,2008.10.22 02:30:07,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
index b002ee4..67bd888 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
@@ -51,11 +51,12 @@
     private static final int VERSION=2;
     private static final long dbId=-1;
     private static final Logger LOG = Logger.getLogger(FileSnap.class);
-    public final static int MAGIC = ByteBuffer.wrap(""AK47"".getBytes()).getInt();
+    public final static int SNAP_MAGIC
+        = ByteBuffer.wrap(""ZKSN"".getBytes()).getInt();
     public FileSnap(File snapDir) {
         this.snapDir = snapDir;
     }
-    
+
     /**
      * deserialize a data tree from the most recent snapshot
      * @return the zxid of the snapshot
@@ -81,7 +82,7 @@
         dt.lastProcessedZxid = Util.getZxidFromName(snap.getName(), ""snapshot"");
         return dt.lastProcessedZxid;
     }
-    
+
     /**
      * deserialize the datatree from an inputarchive
      * @param dt the datatree to be serialized into
@@ -95,7 +96,7 @@
         header.deserialize(ia, ""fileheader"");
         SerializeUtils.deserializeSnapshot(dt,ia,sessions);
     }
-    
+
     /**
      * find the most recent snapshot in the database.
      * @return the file containing the most recent snapshot
@@ -119,7 +120,7 @@
      */
     protected void serialize(DataTree dt,Map<Long, Integer> sessions,
             OutputArchive oa, FileHeader header) throws IOException {
-        // this is really a programmatic error and not something that can 
+        // this is really a programmatic error and not something that can
         // happen at runtime
         if(header==null)
             throw new IllegalStateException(
@@ -127,7 +128,7 @@
         header.serialize(oa, ""fileheader"");
         SerializeUtils.serializeSnapshot(dt,oa,sessions);
     }
-    
+
     /**
      * serialize the datatree and session into the file snapshot
      * @param dt the datatree to be serialized
@@ -140,7 +141,7 @@
         CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());
         //CheckedOutputStream cout = new CheckedOutputStream()
         OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);
-        FileHeader header = new FileHeader(MAGIC, VERSION, dbId);
+        FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);
         serialize(dt,sessions,oa, header);
         long val = crcOut.getChecksum().getValue();
         oa.writeLong(val, ""val"");
@@ -149,5 +150,5 @@
         crcOut.close();
         sessOS.close();
     }
-   
+
  }
\ No newline at end of file
"
zookeeper,4a1154ac082506a3269e47e51ff2f600b6d28d07,ZOOKEEPER-200. the magic number for snapshot and log must be different,2008.10.22 02:30:07,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 9de69ed..1c29930 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -53,7 +53,8 @@
     volatile OutputArchive oa;
     
     File logDir;
-    public final static int MAGIC = ByteBuffer.wrap(""AK47"".getBytes()).getInt();
+    public final static int TXNLOG_MAGIC =
+        ByteBuffer.wrap(""ZKLG"".getBytes()).getInt();
     public final static int VERSION = 2;
     private boolean forceSync = true;
     long dbId;
@@ -127,7 +128,7 @@
                        Long.toHexString(hdr.getZxid())));
                logStream=new FileOutputStream(logFileWrite);
                oa = BinaryOutputArchive.getArchive(logStream);
-               FileHeader fhdr = new FileHeader(MAGIC,VERSION, dbId);
+               FileHeader fhdr = new FileHeader(TXNLOG_MAGIC,VERSION, dbId);
                fhdr.serialize(oa, ""fileheader"");
                currentSize = logStream.getChannel().position();
                streamsToFlush.add(logStream);
"
zookeeper,c6acf2c2e3504b057195e434791dc5a60a80f5fe,ZOOKEEPER-199. fix log messages in persistence code,2008.10.21 13:36:28,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
index 92a0479..9de69ed 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java
@@ -438,7 +438,7 @@
                 hdr = new TxnHeader();
                 record = SerializeUtils.deserializeTxn(iab, hdr);
             } catch (EOFException e) {
-                LOG.info(""EOF excepton "" + e);
+                LOG.debug(""EOF excepton "" + e);
                 inputStream.close();
                 inputStream = null;
                 // thsi means that the file has ended 
@@ -477,4 +477,4 @@
         }
     }
 
-}
\ No newline at end of file
+}
"
zookeeper,c6acf2c2e3504b057195e434791dc5a60a80f5fe,ZOOKEEPER-199. fix log messages in persistence code,2008.10.21 13:36:28,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
index df89f9f..a1e9171 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileTxnSnapLog.java
@@ -110,8 +110,8 @@
                 //empty logs 
                 return dt.lastProcessedZxid;
             }
-            if (hdr.getZxid() <= highestZxid && highestZxid != 0) {
-                LOG.error(highestZxid + ""(higestZxid) >= ""
+            if (hdr.getZxid() < highestZxid && highestZxid != 0) {
+                LOG.error(highestZxid + ""(higestZxid) > ""
                         + hdr.getZxid() + ""(next log) for type ""
                         + hdr.getType());
             } else {
@@ -243,4 +243,4 @@
         txnLog.rollLog();
     }
     
-}
\ No newline at end of file
+}
"
zookeeper,60808e0a7312525e2d3dfb82c5535582d1de391b,ZOOKEEPER-198. apache license header missing from FollowerSyncRequest.java,2008.10.21 06:07:27,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerSyncRequest.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerSyncRequest.java
index 9bd9014..ca9ecec 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerSyncRequest.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerSyncRequest.java
@@ -1,3 +1,21 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package org.apache.zookeeper.server.quorum;
 
 import java.nio.ByteBuffer;
"
zookeeper,d768ace716fcf01e9f699355ec8e6876d0a2a9bf,ZOOKEEPER-178 FLE Test,2008.10.11 08:15:55,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index b06cc27..86c3c6d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -587,6 +587,19 @@
                 }
                 break;
             case LEADING:
+                /*
+                 * There is at most one leader for each epoch, so if a peer claims to
+                 * be the leader for an epoch, then that peer must be the leader (no
+                 * arbitrary failures assumed). Now, if there is no quorum supporting 
+                 * this leader, then processes will naturally move to a new epoch.
+                 */
+                if(n.epoch == logicalclock){
+                    self.setPeerState((n.leader == self.getId()) ? 
+                            ServerState.LEADING: ServerState.FOLLOWING);
+                   
+                    leaveInstance();
+                    return new Vote(n.leader, n.zxid);
+                }
             case FOLLOWING:
                 LOG.info(""Notification: "" + n.leader + "", "" + n.zxid + "", "" + n.epoch + "", "" + self.getId() + "", "" + self.getPeerState() + "", "" + n.state + "", "" + n.sid);
        
"
zookeeper,109a15859be9184ab677c8db371084535e412212,ZOOKEEPER-159. Cover two corner cases of leader election,2008.10.09 03:00:33,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index c601b33..b06cc27 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -445,20 +445,21 @@
      *  @param zxid     zxid of the the vote received last
      */
     private boolean termPredicate(
-            HashMap<Long, Vote> votes, long l,
-            long zxid) {
+            HashMap<Long, Vote> votes, 
+            Vote vote) {
 
-        int count = 0;
         Collection<Vote> votesCast = votes.values();
+        int count = 0;
+        
         /*
          * First make the views consistent. Sometimes peers will have
          * different zxids for a server depending on timing.
          */
         for (Vote v : votesCast) {
-            if ((v.id == l) && (v.zxid == zxid))
+            if (v.equals(vote))
                 count++;
         }
-        
+                      
         if (count > (self.quorumPeers.size() / 2))
             return true;
         else
@@ -466,6 +467,29 @@
 
     }
 
+    /**
+     * In the case there is a leader elected, and a quorum supporting 
+     * this leader, we have to check if the leader has voted and acked
+     * that it is leading. We need this check to avoid that peers keep
+     * electing over and over a peer that has crashed and it is no
+     * longer leading.
+     * 
+     * @param votes set of votes
+     * @param   leader  leader id
+     * @param   epoch   epoch id
+     */
+    private boolean checkLeader(
+            HashMap<Long, Vote> votes,
+            long leader,
+            long epoch){
+        
+        boolean predicate = true;
+        if(votes.get(leader) == null) predicate = false;
+        else if(votes.get(leader).state != ServerState.LEADING) predicate = false;
+        
+        return predicate;
+    }
+    
     synchronized void updateProposal(long leader, long zxid){
         proposedLeader = leader;
         proposedZxid = zxid;
@@ -522,7 +546,7 @@
                 if (n.epoch > logicalclock) {
                     logicalclock = n.epoch;
                     recvset.clear();
-                    updateProposal(n.leader, n.zxid);
+                    updateProposal(self.getId(), self.getLastLoggedZxid());
                     sendNotifications();
                 } else if (n.epoch < logicalclock) {
                     break;
@@ -531,7 +555,7 @@
                     sendNotifications();
                 }
                 
-                recvset.put(n.sid, new Vote(n.leader, n.zxid));
+                recvset.put(n.sid, new Vote(n.leader, n.zxid, n.epoch));
 
                 //If have received from all nodes, then terminate
                 if (self.quorumPeers.size() == recvset.size()) {
@@ -540,7 +564,7 @@
                     leaveInstance();
                     return new Vote(proposedLeader, proposedZxid);
 
-                } else if (termPredicate(recvset, proposedLeader, proposedZxid)) {
+                } else if (termPredicate(recvset, new Vote(proposedLeader, proposedZxid, logicalclock))) {
                     //Otherwise, wait for a fixed amount of time
                     LOG.debug(""Passed predicate"");
 
@@ -565,15 +589,16 @@
             case LEADING:
             case FOLLOWING:
                 LOG.info(""Notification: "" + n.leader + "", "" + n.zxid + "", "" + n.epoch + "", "" + self.getId() + "", "" + self.getPeerState() + "", "" + n.state + "", "" + n.sid);
-              
-                if(n.epoch >= logicalclock) 
-                    outofelection.put(n.sid, new Vote(n.leader, n.zxid));
+       
+                outofelection.put(n.sid, new Vote(n.leader, n.zxid, n.epoch, n.state));
 
-                if (termPredicate(outofelection, n.leader, n.zxid)) {
-                    
-                    self.setPeerState((n.leader == self.getId()) ? 
+                if (termPredicate(outofelection, new Vote(n.leader, n.zxid, n.epoch, n.state))
+                        && checkLeader(outofelection, n.leader, n.epoch)) {
+                    synchronized(this){
+                        logicalclock = n.epoch;
+                        self.setPeerState((n.leader == self.getId()) ? 
                             ServerState.LEADING: ServerState.FOLLOWING);
-
+                    }
                     leaveInstance();
                     return new Vote(n.leader, n.zxid);
                 }
"
zookeeper,109a15859be9184ab677c8db371084535e412212,ZOOKEEPER-159. Cover two corner cases of leader election,2008.10.09 03:00:33,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Vote.java b/src/java/main/org/apache/zookeeper/server/quorum/Vote.java
index 7697596..b0f3d0f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Vote.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Vote.java
@@ -18,6 +18,8 @@
 
 package org.apache.zookeeper.server.quorum;
 
+import org.apache.zookeeper.server.quorum.QuorumPeer.ServerState;
+
 
 public class Vote {
     public Vote(long id, long zxid) {
@@ -25,17 +27,34 @@
         this.zxid = zxid;
     }
 
+    public Vote(long id, long zxid, long epoch) {
+        this.id = id;
+        this.zxid = zxid;
+        this.epoch = epoch;
+    }
+    
+    public Vote(long id, long zxid, long epoch, ServerState state) {
+        this.id = id;
+        this.zxid = zxid;
+        this.epoch = epoch;
+        this.state = state;
+    }
+    
     public long id;
     
     public long zxid;
     
+    public long epoch = -1;
+    
+    public ServerState state = ServerState.LOOKING;
+    
     @Override
     public boolean equals(Object o) {
         if (!(o instanceof Vote)) {
             return false;
         }
         Vote other = (Vote) o;
-        return id == other.id && zxid == other.zxid;
+        return (id == other.id && zxid == other.zxid && epoch == other.epoch);
 
     }
 
"
zookeeper,ff98502017f564c14008f5e55ba536bef7d60b78,ZOOKEEPER-8. Stat enchaned to include num of children and size,2008.10.08 03:51:49,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/DataNode.java b/src/java/main/org/apache/zookeeper/server/DataNode.java
index 028d2d4..b9ddc3d 100644
--- a/src/java/main/org/apache/zookeeper/server/DataNode.java
+++ b/src/java/main/org/apache/zookeeper/server/DataNode.java
@@ -29,6 +29,7 @@
 import org.apache.jute.Record;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.data.StatPersisted;
 
 /**
  * This class contains the data for a node in the data tree.
@@ -42,7 +43,7 @@
         // default rather than public constructor
     }
 
-    DataNode(DataNode parent, byte data[], List<ACL> acl, Stat stat) {
+    DataNode(DataNode parent, byte data[], List<ACL> acl, StatPersisted stat) {
         this.parent = parent;
         this.data = data;
         this.acl = acl;
@@ -56,10 +57,23 @@
 
     List<ACL> acl;
 
-    public Stat stat;
+    public StatPersisted stat;
 
     HashSet<String> children = new HashSet<String>();
 
+    public void copyStat(Stat to) {
+        to.setAversion(stat.getAversion());
+        to.setCtime(stat.getCtime());
+        to.setCversion(stat.getCversion());
+        to.setCzxid(stat.getCzxid());
+        to.setMtime(stat.getMtime());
+        to.setMzxid(stat.getMzxid());
+        to.setVersion(stat.getVersion());
+        to.setEphemeralOwner(stat.getEphemeralOwner());
+        to.setDataLength(data.length);
+        to.setNumChildren(children.size());
+    }
+
     public void deserialize(InputArchive archive, String tag)
             throws IOException {
         archive.startRecord(""node"");
@@ -75,8 +89,8 @@
             }
         }
         archive.endVector(""acl"");
-        stat = new Stat();
-        stat.deserialize(archive, ""stat"");
+        stat = new StatPersisted();
+        stat.deserialize(archive, ""statpersisted"");
         archive.endRecord(""node"");
     }
 
@@ -91,7 +105,7 @@
             }
         }
         archive.endVector(acl, ""acl"");
-        stat.serialize(archive, ""stat"");
+        stat.serialize(archive, ""statpersisted"");
         archive.endRecord(this, ""node"");
     }
 }
"
zookeeper,ff98502017f564c14008f5e55ba536bef7d60b78,ZOOKEEPER-8. Stat enchaned to include num of children and size,2008.10.08 03:51:49,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 5fc31f6..aa54a74 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -32,13 +32,13 @@
 import org.apache.log4j.Logger;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.Watcher;
-import org.apache.zookeeper.Watcher.Event.EventType;
-import org.apache.zookeeper.Watcher.Event.KeeperState;
 import org.apache.zookeeper.KeeperException.Code;
 import org.apache.zookeeper.Watcher.Event;
+import org.apache.zookeeper.Watcher.Event.EventType;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.data.StatPersisted;
 import org.apache.zookeeper.txn.CreateTxn;
 import org.apache.zookeeper.txn.DeleteTxn;
 import org.apache.zookeeper.txn.ErrorTxn;
@@ -109,7 +109,8 @@
      * This is a pointer to the root of the DataTree. It is the source of truth,
      * but we usually use the nodes hashmap to find nodes in the tree.
      */
-    private DataNode root = new DataNode(null, new byte[0], null, new Stat());
+    private DataNode root =
+        new DataNode(null, new byte[0], null, new StatPersisted());
 
     public DataTree() {
         /* Rather than fight it, let root have an alias */
@@ -117,6 +118,17 @@
         nodes.put(""/"", root);
     }
 
+    static public void copyStatPersisted(StatPersisted from, StatPersisted to) {
+        to.setAversion(from.getAversion());
+        to.setCtime(from.getCtime());
+        to.setCversion(from.getCversion());
+        to.setCzxid(from.getCzxid());
+        to.setMtime(from.getMtime());
+        to.setMzxid(from.getMzxid());
+        to.setVersion(from.getVersion());
+        to.setEphemeralOwner(from.getEphemeralOwner());
+    }
+
     static public void copyStat(Stat from, Stat to) {
         to.setAversion(from.getAversion());
         to.setCtime(from.getCtime());
@@ -126,6 +138,8 @@
         to.setMzxid(from.getMzxid());
         to.setVersion(from.getVersion());
         to.setEphemeralOwner(from.getEphemeralOwner());
+        to.setDataLength(from.getDataLength());
+        to.setNumChildren(from.getNumChildren());
     }
 
     // public void remooveInterest(String path, Watcher nw) {
@@ -161,7 +175,7 @@
         int lastSlash = path.lastIndexOf('/');
         String parentName = path.substring(0, lastSlash);
         String childName = path.substring(lastSlash + 1);
-        Stat stat = new Stat();
+        StatPersisted stat = new StatPersisted();
         stat.setCtime(time);
         stat.setMtime(time);
         stat.setCzxid(zxid);
@@ -250,7 +264,7 @@
             n.stat.setMtime(time);
             n.stat.setMzxid(zxid);
             n.stat.setVersion(version);
-            copyStat(n.stat, s);
+            n.copyStat(s);
         }
         dataWatches.triggerWatch(path, EventType.NodeDataChanged);
         return s;
@@ -262,7 +276,7 @@
             throw new KeeperException.NoNodeException();
         }
         synchronized (n) {
-            copyStat(n.stat, stat);
+            n.copyStat(stat);
             if (watcher != null) {
                 dataWatches.addWatch(path, watcher);
             }
@@ -280,7 +294,7 @@
             throw new KeeperException.NoNodeException();
         }
         synchronized (n) {
-            copyStat(n.stat, stat);
+            n.copyStat(stat);
             return stat;
         }
     }
@@ -310,7 +324,7 @@
         synchronized (n) {
             n.stat.setAversion(version);
             n.acl = acl;
-            copyStat(n.stat, stat);
+            n.copyStat(stat);
             return stat;
         }
     }
@@ -322,7 +336,7 @@
             throw new KeeperException.NoNodeException();
         }
         synchronized (n) {
-            copyStat(n.stat, stat);
+            n.copyStat(stat);
             return new ArrayList<ACL>(n.acl);
         }
     }
"
zookeeper,ff98502017f564c14008f5e55ba536bef7d60b78,ZOOKEEPER-8. Stat enchaned to include num of children and size,2008.10.08 03:51:49,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 39e5db3..163a818 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -35,6 +35,7 @@
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Id;
 import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.data.StatPersisted;
 import org.apache.zookeeper.proto.CreateRequest;
 import org.apache.zookeeper.proto.DeleteRequest;
 import org.apache.zookeeper.proto.SetACLRequest;
@@ -220,7 +221,7 @@
                 txn = new CreateTxn(path, createRequest.getData(),
                         createRequest.getAcl(),
                         createMode.isEphemeral());
-                Stat s = new Stat();
+                StatPersisted s = new StatPersisted();
                 if (createMode.isEphemeral()) {
                     s.setEphemeralOwner(request.sessionId);
                 }
"
zookeeper,ff98502017f564c14008f5e55ba536bef7d60b78,ZOOKEEPER-8. Stat enchaned to include num of children and size,2008.10.08 03:51:49,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index 8c72571..549a319 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -40,6 +40,7 @@
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Id;
 import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.data.StatPersisted;
 import org.apache.zookeeper.proto.RequestHeader;
 import org.apache.zookeeper.server.SessionTracker.SessionExpirer;
 import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
@@ -378,7 +379,7 @@
      * and FinalRP.
      */
     static class ChangeRecord {
-        ChangeRecord(long zxid, String path, Stat stat, int childCount,
+        ChangeRecord(long zxid, String path, StatPersisted stat, int childCount,
                 List<ACL> acl) {
             this.zxid = zxid;
             this.path = path;
@@ -391,7 +392,7 @@
 
         String path;
 
-        Stat stat; /* Make sure to create a new object when changing */
+        StatPersisted stat; /* Make sure to create a new object when changing */
 
         int childCount;
 
@@ -399,9 +400,9 @@
 
         @SuppressWarnings(""unchecked"")
         ChangeRecord duplicate(long zxid) {
-            Stat stat = new Stat();
+            StatPersisted stat = new StatPersisted();
             if (this.stat != null) {
-                DataTree.copyStat(this.stat, stat);
+                DataTree.copyStatPersisted(this.stat, stat);
             }
             return new ChangeRecord(zxid, path, stat, childCount,
                     acl == null ? new ArrayList<ACL>() : new ArrayList(acl));
"
zookeeper,3fd36ef74684e63eb69b10ac51e2970a1f0cdc02,ZOOKEEPER-157.patch,2008.10.05 18:45:00,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index 79df8b4..c601b33 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -563,8 +563,6 @@
                 }
                 break;
             case LEADING:
-                leaveInstance();
-                return new Vote(n.leader, n.zxid);
             case FOLLOWING:
                 LOG.info(""Notification: "" + n.leader + "", "" + n.zxid + "", "" + n.epoch + "", "" + self.getId() + "", "" + self.getPeerState() + "", "" + n.state + "", "" + n.sid);
               
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/jute/CsvOutputArchive.java b/src/java/main/org/apache/jute/CsvOutputArchive.java
index b21841d..973af6f 100644
--- a/src/java/main/org/apache/jute/CsvOutputArchive.java
+++ b/src/java/main/org/apache/jute/CsvOutputArchive.java
@@ -103,6 +103,9 @@
     }
     
     public void writeRecord(Record r, String tag) throws IOException {
+        if (r == null) {
+            return;
+        }
         r.serialize(this, tag);
     }
     
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index b874f14..7d551f0 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -73,8 +73,7 @@
 public class ClientCnxn {
     private static final Logger LOG = Logger.getLogger(ClientCnxn.class);
 
-    private ArrayList<InetSocketAddress> serverAddrs =
-        new ArrayList<InetSocketAddress>();
+    private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
 
     static class AuthData {
         AuthData(String scheme, byte data[]) {
@@ -121,10 +120,12 @@
 
     final Selector selector = Selector.open();
     
-    /** Set to true when close is called. Latches the connection such that
-     * we don't attempt to re-connect to the server if in the middle of
-     * closing the connection (client sends session disconnect to server
-     * as part of close operation) */
+    /**
+     * Set to true when close is called. Latches the connection such that we
+     * don't attempt to re-connect to the server if in the middle of closing the
+     * connection (client sends session disconnect to server as part of close
+     * operation)
+     */
     volatile boolean closing = false;
 
     public long getSessionId() {
@@ -138,7 +139,8 @@
     @Override
     public String toString() {
         StringBuffer sb = new StringBuffer();
-        sb.append(""sessionId: 0x"").append(Long.toHexString(getSessionId())).append(""\n"");
+        sb.append(""sessionId: 0x"").append(Long.toHexString(getSessionId()))
+          .append(""\n"");
         sb.append(""lastZxid: "").append(lastZxid).append(""\n"");
         sb.append(""xid: "").append(xid).append(""\n"");
         sb.append(""nextAddrToTry: "").append(nextAddrToTry).append(""\n"");
@@ -200,8 +202,25 @@
             }
             this.watchRegistration = watchRegistration;
         }
+
+        @Override
+        public String toString() {
+            StringBuffer sb = new StringBuffer();
+
+            sb.append(""path:"" + path);
+            sb.append("" finished:"" + finished);
+
+            sb.append("" header:: "" + header);
+            sb.append("" replyHeader:: "" + replyHeader);
+            sb.append("" request:: "" + request);
+            sb.append("" response:: "" + response);
+
+            // jute toString is horrible, remove unnecessary newlines
+            return sb.toString().replaceAll(""\r*\n+"", "" "");
+        }
     }
 
+
     public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
             ClientWatchManager watcher)
         throws IOException
@@ -224,8 +243,7 @@
      */
     public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
             ClientWatchManager watcher, long sessionId, byte[] sessionPasswd)
-        throws IOException
-    {
+        throws IOException {
         this.zooKeeper = zooKeeper;
         this.watcher = watcher;
         this.sessionId = sessionId;
@@ -477,20 +495,28 @@
             ByteBufferInputStream bbis = new ByteBufferInputStream(
                     incomingBuffer);
             BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
-            ReplyHeader r = new ReplyHeader();
+            ReplyHeader replyHdr = new ReplyHeader();
 
-            r.deserialize(bbia, ""header"");
-            if (r.getXid() == -2) {
+            replyHdr.deserialize(bbia, ""header"");
+            if (replyHdr.getXid() == -2) {
                 // -2 is the xid for pings
+                LOG
+                    .debug(""Got ping sessionid:0x""
+                    + Long.toHexString(sessionId));
                 return;
             }
-            if (r.getXid() == -4) {
+            if (replyHdr.getXid() == -4) {
                 // -2 is the xid for AuthPacket
                 // TODO: process AuthPacket here
+                LOG
+                    .debug(""Got auth sessionid:0x""
+                        + Long.toHexString(sessionId));
                 return;
             }
-            if (r.getXid() == -1) {
+            if (replyHdr.getXid() == -1) {
                 // -1 means notification
+                LOG.debug(""Got notification sessionid:0x""
+                    + Long.toHexString(sessionId));
                 WatcherEvent event = new WatcherEvent();
                 event.deserialize(bbia, ""response"");
                 WatchedEvent we = new WatchedEvent(event);
@@ -504,29 +530,37 @@
             }
             if (pendingQueue.size() == 0) {
                 throw new IOException(""Nothing in the queue, but got ""
-                        + r.getXid());
+                        + replyHdr.getXid());
             }
-            Packet p = null;
+            Packet packet = null;
             synchronized (pendingQueue) {
-                p = pendingQueue.remove();
+                packet = pendingQueue.remove();
             }
             /*
              * Since requests are processed in order, we better get a response
              * to the first request!
              */
-            if (p.header.getXid() != r.getXid()) {
-                throw new IOException(""Xid out of order. Got "" + r.getXid()
-                        + "" expected "" + p.header.getXid());
+         if (packet.header.getXid() != replyHdr.getXid()) {
+         throw new IOException(""Xid out of order. Got ""
+                  + replyHdr.getXid() + "" expected ""
+                  + packet.header.getXid());
             }
-            p.replyHeader.setXid(r.getXid());
-            p.replyHeader.setErr(r.getErr());
-            p.replyHeader.setZxid(r.getZxid());
-            lastZxid = r.getZxid();
-            if (p.response != null && r.getErr() == 0) {
-                p.response.deserialize(bbia, ""response"");
+
+         packet.replyHeader.setXid(replyHdr.getXid());
+         packet.replyHeader.setErr(replyHdr.getErr());
+         packet.replyHeader.setZxid(replyHdr.getZxid());
+         lastZxid = replyHdr.getZxid();
+         if (packet.response != null && replyHdr.getErr() == 0) {
+             packet.response.deserialize(bbia, ""response"");
             }
-            p.finished = true;
-            finishPacket(p);
+            packet.finished = true;
+
+            if (LOG.isDebugEnabled()) {
+            LOG.debug(""Reading reply sessionid:0x""
+                + Long.toHexString(sessionId) + "", packet:: "" + packet);
+        }
+
+            finishPacket(packet);
         }
 
         /**
@@ -789,14 +823,15 @@
                 } catch (Exception e) {
                     if (closing) {
                         // closing so this is expected
-                        LOG.info(""Exception while closing send thread for session 0x"" 
+                        LOG
+                           .info(""Exception while closing send thread for session 0x""
                                 + Long.toHexString(getSessionId())
                                 + "" : "" + e.getMessage());
                         break;
                     } else {
                         LOG.warn(""Exception closing session 0x"" 
-                                + Long.toHexString(getSessionId()),
-                                e);
+                                + Long.toHexString(getSessionId()) + "" to ""
+                                + sockKey, e);
                         cleanup();
                         if (zooKeeper.state.isAlive()) {
                             eventThread.queueEvent(new WatchedEvent(
@@ -889,8 +924,8 @@
     }
 
     /**
-     * Close the connection, which includes; send session disconnect to
-     * the server, shutdown the send/event threads.
+     * Close the connection, which includes; send session disconnect to the
+     * server, shutdown the send/event threads.
      * 
      * @throws IOException
      */
@@ -919,13 +954,10 @@
     }
 
     public ReplyHeader submitRequest(RequestHeader h, Record request,
-            Record response,
-            WatchRegistration watchRegistration)
-        throws InterruptedException
-    {
+            Record response, WatchRegistration watchRegistration)
+            throws InterruptedException {
         ReplyHeader r = new ReplyHeader();
-        Packet packet =
-            queuePacket(h, r, request, response, null, null, null,
+        Packet packet = queuePacket(h, r, request, response, null, null, null,
                     watchRegistration);
         synchronized (packet) {
             while (!packet.finished) {
@@ -937,8 +969,7 @@
 
     Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
             Record response, AsyncCallback cb, String path, Object ctx,
-            WatchRegistration watchRegistration)
-    {
+            WatchRegistration watchRegistration) {
         Packet packet = null;
         synchronized (outgoingQueue) {
             if (h.getType() != OpCode.ping && h.getType() != OpCode.auth) {
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index 9a5f999..e454f18 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -69,9 +69,9 @@
     }
 
     public void processRequest(Request request) {
-        // LOG.info(""Zoo>>> cxid = "" + request.cxid + "" type = "" +
-        // request.type + "" id = "" + request.sessionId + "" cnxn "" +
-        // request.cnxn);
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Processing request:: "" + request);
+        }
         // request.addRQRec("">final"");
         long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;
         if (request.type == OpCode.ping) {
@@ -130,6 +130,10 @@
             if (request.hdr != null && request.hdr.getType() == OpCode.error) {
                 throw KeeperException.create(((ErrorTxn) request.txn).getErr());
             }
+
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(request);
+            }
             switch (request.type) {
             case OpCode.ping:
                 request.cnxn.sendResponse(new ReplyHeader(-2,
@@ -157,7 +161,6 @@
                 err = rc.err;
                 break;
             case OpCode.sync:
-                LOG.debug(""OpCode.sync "" + request);
                 SyncRequest syncRequest = new SyncRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         syncRequest);
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index dd414a5..487e21e 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -84,7 +84,7 @@
         int outstandingLimit = 1;
 
         public Factory(int port) throws IOException {
-            super(""NIOServerCxn.Factory"");
+            super(""NIOServerCxn.Factory:"" + port);
             setDaemon(true);
             this.ss = ServerSocketChannel.open();
             ss.socket().bind(new InetSocketAddress(port));
@@ -421,7 +421,7 @@
                     || ap.handleAuthentication(this, authPacket.getAuth()) != KeeperException.Code.Ok) {
                 if (ap == null)
                     LOG.error(""No authentication provider for scheme: ""
-                            + scheme);
+                            + scheme + "" has "" + ProviderRegistry.listProviders());
                 else
                     LOG.debug(""Authentication failed for scheme: ""
                             + scheme);
@@ -449,6 +449,7 @@
                 outstandingRequests++;
                 // check throttling
                 if (zk.getInProcess() > factory.outstandingLimit) {
+                    LOG.warn(""Throttling recv "" + zk.getInProcess());
                     disableRecv();
                     // following lines should not be needed since we are already
                     // reading
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index cb75cc8..39e5db3 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -76,7 +76,7 @@
 
     public PrepRequestProcessor(ZooKeeperServer zks,
             RequestProcessor nextProcessor) {
-        super(""ProcessThread"");
+        super(""ProcessThread:"" + zks.getClientPort());
         this.nextProcessor = nextProcessor;
         this.zks = zks;
 
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/Request.java b/src/java/main/org/apache/zookeeper/server/Request.java
index cd2514b..71cdeb4 100644
--- a/src/java/main/org/apache/zookeeper/server/Request.java
+++ b/src/java/main/org/apache/zookeeper/server/Request.java
@@ -163,19 +163,19 @@
     @Override
     public String toString() {
         StringBuffer sb = new StringBuffer();
-        sb.append(""session 0x"").append(Long.toHexString(sessionId));
-        sb.append("" cxid 0x"").append(Long.toHexString(cxid));
-        sb.append(""zxid 0x"").append(Long.toHexString((hdr == null ? -2 : hdr.getZxid()))).append(
-                "" "");
-        sb
-                .append(
-                        "" txn type = ""
-                                + (hdr == null ? ""unknown"" : """" + hdr.getType()))
-                .append("" "");
-        sb.append(op2String(type)).append("" "");
+        sb.append(""sessionid:0x"").append(Long.toHexString(sessionId));
+        sb.append("" type:"").append(op2String(type));
+        sb.append("" cxid:0x"").append(Long.toHexString(cxid));
+        sb.append("" zxid:0x"").append(Long.toHexString((hdr == null ?
+                -2 : hdr.getZxid())));
+        sb.append("" txntype:"" + (hdr == null ?
+                ""unknown"" : """" + hdr.getType()));
+        sb.append("" "");
 
         String path = ""n/a"";
-        if (type != OpCode.createSession) {
+        if (type != OpCode.createSession && request != null
+                && request.remaining() >= 4)
+        {
             try {
                 request.clear();
                 int pathLen = request.getInt();
@@ -188,6 +188,7 @@
             }
         }
         sb.append(path).append("" "");
+
         return sb.toString();
     }
 }
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
index b756886..92b7988 100644
--- a/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/SyncRequestProcessor.java
@@ -54,7 +54,7 @@
 
     public SyncRequestProcessor(ZooKeeperServer zks,
             RequestProcessor nextProcessor) {
-        super(""SyncThread"");
+        super(""SyncThread:"" + zks.getClientPort());
         this.zks = zks;
         this.nextProcessor = nextProcessor;
         start();
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index dbda38e..8c72571 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -467,6 +467,11 @@
      */
     public void submitRequest(ServerCnxn cnxn, long sessionId, int type,
             int xid, ByteBuffer bb, List<Id> authInfo) {
+        Request si = new Request(cnxn, sessionId, xid, type, bb, authInfo);
+        submitRequest(si);
+    }
+    
+    public void submitRequest(Request si) {
         if (firstProcessor == null) {
             synchronized (this) {
                 try {
@@ -482,16 +487,15 @@
             }
         }
         try {
-            touch(cnxn);
-            Request si = new Request(cnxn, sessionId, xid, type, bb, authInfo);
-            boolean validpacket = Request.isValid(type);
+            touch(si.cnxn);
+            boolean validpacket = Request.isValid(si.type);
             if (validpacket) {
                 firstProcessor.processRequest(si);
-                if (cnxn != null) {
+                if (si.cnxn != null) {
                     incInProcess();
                 }
             } else {
-                LOG.warn(""Dropping packet at server of type "" + type);
+                LOG.warn(""Dropping packet at server of type "" + si.type);
                 // if unvalid packet drop the packet.
             }
         } catch (IOException e) {
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java b/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
index f21bf3f..c166ff4 100644
--- a/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
+++ b/src/java/main/org/apache/zookeeper/server/auth/ProviderRegistry.java
@@ -36,7 +36,6 @@
         synchronized (ProviderRegistry.class) {
             if (initialized)
                 return;
-            initialized = true;
             IPAuthenticationProvider ipp = new IPAuthenticationProvider();
             HostAuthenticationProvider hostp = new HostAuthenticationProvider();
             DigestAuthenticationProvider digp = new DigestAuthenticationProvider();
@@ -59,6 +58,7 @@
                     }
                 }
             }
+            initialized = true;
         }
     }
 
@@ -67,4 +67,12 @@
             initialize();
         return authenticationProviders.get(scheme);
     }
+
+    public static String listProviders() {
+        StringBuilder sb = new StringBuilder();
+        for(String s: authenticationProviders.keySet()) {
+        sb.append(s + "" "");
+}
+        return sb.toString();
+    }
 }
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
index 8b9008e..c43ce30 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
@@ -49,8 +49,17 @@
 
     RequestProcessor nextProcessor;
 
-    public CommitProcessor(RequestProcessor nextProcessor) {
+    /**
+     * This flag indicates whether we need to wait for a response to come back from the
+     * leader or we just let the sync operation flow through like a read. The flag will
+     * be true if the CommitProcessor is in a Leader pipeline.
+     */
+    boolean matchSyncs;
+
+    public CommitProcessor(RequestProcessor nextProcessor, String id, boolean matchSyncs) {
+        super(""CommitProcessor:"" + id);
         this.nextProcessor = nextProcessor;
+        this.matchSyncs = matchSyncs;
         start();
     }
 
@@ -122,8 +131,11 @@
                             nextPending = request;
                             break;
                         case OpCode.sync:
-                            nextPending = request;
-                            //pendingSyncs.add(request);
+                            if (matchSyncs) {
+                                nextPending = request;
+                            } else {
+                                toProcess.add(request);
+                            }
                             break;
                         default:
                             toProcess.add(request);
@@ -145,7 +157,9 @@
                          new Exception(""committing a null! ""));
                 return;
             }
-            LOG.debug(""Committing"" + request.cxid);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""Committing request:: "" + request);
+            }
             committedRequests.add(request);
             notifyAll();
         }
@@ -153,9 +167,10 @@
 
     synchronized public void processRequest(Request request) {
         // request.addRQRec("">commit"");
-        // LOG.info(""Zoo processReq>>> cxid = "" + request.cxid + "" type =
-        // "" + request.type + "" id = "" + request.sessionId + "" cnxn "" +
-        // request.cnxn);
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Processing request:: "" + request);
+        }
+        
         if (!finished) {
             queuedRequests.add(request);
             notifyAll();
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
index 52b7cf1..91d9676 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java
@@ -330,10 +330,12 @@
                     type = bb.getInt();
                     bb = bb.slice();
                     if(type == OpCode.sync){
-                        leader.setSyncHandler(this, sessionId);
-                    }
+                     	leader.zk.submitRequest(new FollowerSyncRequest(this, sessionId, cxid, type, bb,
+                                qp.getAuthinfo()));
+                    } else {
                     leader.zk.submitRequest(null, sessionId, type, cxid, bb,
                             qp.getAuthinfo());
+                    }
                     break;
                 default:
                 }
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
index 361b1cc..ee76fca 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
@@ -45,6 +45,7 @@
 
     public FollowerRequestProcessor(FollowerZooKeeperServer zks,
             RequestProcessor nextProcessor) {
+        super(""FollowerRequestProcessor:"" + zks.getClientPort());
         this.zks = zks;
         this.nextProcessor = nextProcessor;
         start();
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerSyncRequest.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerSyncRequest.java
new file mode 100644
index 0000000..9bd9014
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerSyncRequest.java
@@ -0,0 +1,16 @@
+package org.apache.zookeeper.server.quorum;
+
+import java.nio.ByteBuffer;
+import java.util.List;
+
+import org.apache.zookeeper.data.Id;
+import org.apache.zookeeper.server.Request;
+
+public class FollowerSyncRequest extends Request {
+	FollowerHandler fh;
+	public FollowerSyncRequest(FollowerHandler fh, long sessionId, int xid, int type,
+			ByteBuffer bb, List<Id> authInfo) {
+		super(null, sessionId, xid, type, bb, authInfo);
+		this.fh = fh;
+	}
+}
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
index 8216e18..2ed0a03 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
@@ -80,7 +80,8 @@
     @Override
     protected void setupRequestProcessors() {
         RequestProcessor finalProcessor = new FinalRequestProcessor(this);
-        commitProcessor = new CommitProcessor(finalProcessor);
+        commitProcessor = new CommitProcessor(finalProcessor,
+                Integer.toString(getClientPort()), true);
         firstProcessor = new FollowerRequestProcessor(this, commitProcessor);
         syncProcessor = new SyncRequestProcessor(this,
                 new SendAckRequestProcessor(getFollower()));
@@ -135,16 +136,16 @@
         commitProcessor.commit(request);
     }
     
-    public void sync(){
+    synchronized public void sync(){
         if(pendingSyncs.size() ==0){
             LOG.warn(""Not expecting a sync."");
             return;
         }
                 
-        commitProcessor.commit(pendingSyncs.remove());
+        Request r = pendingSyncs.remove();
+		commitProcessor.commit(r);
     }
              
-         
     @Override
     public int getGlobalOutstandingLimit() {
         return super.getGlobalOutstandingLimit() / (self.getQuorumSize() - 1);
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 5b81314..ba92653 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -25,9 +25,11 @@
 import java.net.Socket;
 import java.net.SocketAddress;
 import java.net.SocketException;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
 import org.apache.log4j.Logger;
@@ -70,11 +72,8 @@
     public HashSet<FollowerHandler> forwardingFollowers = new HashSet<FollowerHandler>();
     
     //Pending sync requests
-    public HashMap<Long,Request> pendingSyncs = new HashMap<Long,Request>();
+    public HashMap<Long,List<FollowerSyncRequest>> pendingSyncs = new HashMap<Long,List<FollowerSyncRequest>>();
                
-    //Map sync request to FollowerHandler
-    public HashMap<Long,FollowerHandler> syncHandler = new HashMap<Long,FollowerHandler>();
-       
     /**
      * Adds follower to the leader.
      * 
@@ -253,7 +252,7 @@
         newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),
                 null, null);
         if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {
-            LOG.error(""NEWLEADER proposal has Zxid of ""
+            LOG.warn(""NEWLEADER proposal has Zxid of ""
                     + newLeaderProposal.packet.getZxid());
         }
         outstandingProposals.add(newLeaderProposal);
@@ -373,17 +372,29 @@
      */
     synchronized public void processAck(long zxid, SocketAddress followerAddr) {
         boolean first = true;
-        /*
-         * LOG.error(""Ack zxid: "" + Long.toHexString(zxid)); for (Proposal
-         * p : outstandingProposals) { long packetZxid = p.packet.getZxid();
-         * LOG.error(""outstanding proposal: "" +
-         * Long.toHexString(packetZxid)); } LOG.error(""outstanding
-         * proposals all"");
-         */
+        
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Ack zxid: 0x"" + Long.toHexString(zxid));
+            for (Proposal p : outstandingProposals) {
+                long packetZxid = p.packet.getZxid();
+                LOG.debug(""outstanding proposal: 0x""
+                        + Long.toHexString(packetZxid));
+            }
+            LOG.debug(""outstanding proposals all"");
+        }
+        
         if (outstandingProposals.size() == 0) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""outstanding is 0"");
+            }
             return;
         }
         if (outstandingProposals.peek().packet.getZxid() > zxid) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""proposal has already been committed, pzxid:""
+                        + outstandingProposals.peek().packet.getZxid()
+                        + "" zxid:"" + zxid);
+            }
             // The proposal has already been committed
             return;
         }
@@ -391,13 +402,16 @@
             long packetZxid = p.packet.getZxid();
             if (packetZxid == zxid) {
                 p.ackCount++;
-                // LOG.error(""FIXMSG"",new RuntimeException(), ""Count for "" +
-                // Long.toHexString(zxid) + "" is "" + p.ackCount);
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Count for zxid: 0x"" + Long.toHexString(zxid)
+                            + "" is "" + p.ackCount);
+                }
+                
                 if (p.ackCount > self.quorumPeers.size() / 2){
                     if (!first) {
-                        LOG.error(""Commiting zxid 0x"" + Long.toHexString(zxid)
+                        LOG.fatal(""Commiting zxid 0x"" + Long.toHexString(zxid)
                                 + "" from "" + followerAddr + "" not first!"");
-                        LOG.error(""First is ""
+                        LOG.fatal(""First is ""
                                 + outstandingProposals.element().packet);
                         System.exit(13);
                     }
@@ -408,23 +422,23 @@
                     // We don't commit the new leader proposal
                     if ((zxid & 0xffffffffL) != 0) {
                         if (p.request == null) {
-                            LOG.error(""Going to commmit null: "" + p);
+                            LOG.warn(""Going to commmit null: "" + p);
                         }
                         commit(zxid);
                         zk.commitProcessor.commit(p.request);
                         if(pendingSyncs.containsKey(zxid)){
-                            sendSync(syncHandler.get(pendingSyncs.get(zxid).sessionId), pendingSyncs.get(zxid));
-                            syncHandler.remove(pendingSyncs.get(zxid));
-                            pendingSyncs.remove(zxid);
+                           for(FollowerSyncRequest r: pendingSyncs.remove(zxid)) {
+                               sendSync(r);
                         }
                     }
                 }
+                }
                 return;
             } else {
                 first = false;
             }
         }
-        LOG.error(""Trying to commit future proposal: zxid 0x""
+        LOG.warn(""Trying to commit future proposal: zxid 0x""
                 + Long.toHexString(zxid) + "" from "" + followerAddr);
     }
 
@@ -528,8 +542,7 @@
             }
             baos.close();
         } catch (IOException e) {
-            // This really should be impossible
-            LOG.error(""FIXMSG"",e);
+            LOG.warn(""This really should be impossible"", e);
         }
         QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, baos
                 .toByteArray(), null);
@@ -538,6 +551,10 @@
         p.packet = pp;
         p.request = request;
         synchronized (this) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""Proposing:: "" + request);
+            }
+
             outstandingProposals.add(p);
             lastProposed = p.packet.getZxid();
             sendPacket(pp);
@@ -551,44 +568,29 @@
      * @param r the request
      */
     
-    public void processSync(Request r){
+    synchronized public void processSync(FollowerSyncRequest r){
         if(outstandingProposals.isEmpty()){
-            LOG.warn(""No outstanding proposal"");
-            sendSync(syncHandler.get(r.sessionId), r);
-                syncHandler.remove(r.sessionId);
-        }
-        else{
-            pendingSyncs.put(lastProposed, r);
+            sendSync(r);
+        } else {
+            List<FollowerSyncRequest> l = pendingSyncs.get(lastProposed);
+            if (l == null) {
+                l = new ArrayList<FollowerSyncRequest>();
+            }
+            l.add(r);
+            pendingSyncs.put(lastProposed, l);
         }
     }
         
     /**
-     * Set FollowerHandler for sync.
-     * 
-     * @param f
-     * @param s
-     */
-        
-    synchronized public void setSyncHandler(FollowerHandler f, long s){
-        syncHandler.put(s, f);
-    }
-            
-    /**
      * Sends a sync message to the appropriate server
      * 
      * @param f
      * @param r
      */
             
-    public void sendSync(FollowerHandler f, Request r){
-        if(f != null){
-            QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);
-            f.queuePacket(qp);
-        }
-        else{
-            LOG.warn(""Committing sync: "" + r.cxid );
-            zk.commitProcessor.commit(r);
-        }
+    public void sendSync(FollowerSyncRequest r){
+        QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);
+        r.fh.queuePacket(qp);
     }
                 
     /**
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
index e404556..24186e3 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java
@@ -59,7 +59,8 @@
         RequestProcessor finalProcessor = new FinalRequestProcessor(this);
         RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(
                 finalProcessor, getLeader().toBeApplied);
-        commitProcessor = new CommitProcessor(toBeAppliedProcessor);
+        commitProcessor = new CommitProcessor(toBeAppliedProcessor,
+                Integer.toString(getClientPort()), false);
         RequestProcessor proposalProcessor = new ProposalRequestProcessor(this,
                 commitProcessor);
         firstProcessor = new PrepRequestProcessor(this, proposalProcessor);
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java
index 6efa221..0476713 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java
@@ -56,17 +56,10 @@
          * call processRequest on the next processor.
          */
         
-        if(request.type == ZooDefs.OpCode.sync){
-            zks.getLeader().processSync(request);
-
-            if(!zks.getLeader().syncHandler.containsKey(request.sessionId)){
-                zks.getLeader().syncHandler.put(request.sessionId, null);
+        if(request instanceof FollowerSyncRequest){
+            zks.getLeader().processSync((FollowerSyncRequest)request);
+        } else {
                 nextProcessor.processRequest(request);
-            }
-            
-        }
-        else{
-            nextProcessor.processRequest(request);
             if (request.hdr != null) {
                 // We need to sync and get consensus on any transactions
                 zks.getLeader().propose(request);
"
zookeeper,ea54ef0825c6670cc6714e749d391f477420b118,ZOOKEEPER-136.patch,2008.10.03 22:06:39,Flavio Paiva Junqueira,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index d97b527..396dc35 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -384,6 +384,8 @@
 
     @Override
     public void run() {
+        setName(""QuorumPeer:"" + cnxnFactory.getLocalAddress());
+
         /*
          * Main loop
          */
"
zookeeper,67c4e4533d0762ebb4cb77976df12304705fecb1,ZOOKEEPER-150. zookeeper build broken,2008.10.02 04:05:48,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/persistence/Util.java b/src/java/main/org/apache/zookeeper/server/persistence/Util.java
index cf32f51..d094142 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/Util.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/Util.java
@@ -126,37 +126,7 @@
     public static String getFormatConversionPolicy(Properties props){
         return props.getProperty(DB_FORMAT_CONV);
     }
-    
-    /**
-     * The routine parses the scheme-specific part and returns the attributes 
-     * values (if any) as an instance of Properties.
-     * @param uri the persistence provider URI
-     * @return URI attributes
-     */
-    public static Properties parseUrl(URI uri){
-        Properties props=new Properties();        
-        for(String s: uri.getSchemeSpecificPart().split("";"")){
-            String[] pair=s.split(""="");
-            if(pair.length==2){
-                if(pair[0].equals(SNAP_DIR)){
-                    props.setProperty(SNAP_DIR,pair[1]);
-                }else if(pair[0].equals(LOG_DIR)){
-                    props.setProperty(LOG_DIR,pair[1]);                        
-                }else if(pair[0].equals(DB_FORMAT_CONV)){
-                    props.setProperty(DB_FORMAT_CONV,pair[1]);                        
-                }else{
-                    LOG.warn(""Unknown parameter [""+pair[0]+""] ignored"");
-                }
-            }
-        }
-        Set<String> pp=props.stringPropertyNames();
-        if(!pp.contains(SNAP_DIR) || !pp.contains(LOG_DIR)){
-            throw new IllegalArgumentException(
-                    ""Both snapDir and logDir must be specified"");
-        }
-        return props;
-    }
-
+   
     /**
      * Extracts zxid from the file name. The file name should have been created
      * using one of the {@link makeLogName} or {@link makeSnapshotName}.
"
zookeeper,ad482ad24cc864686f268b71896606091d92a00f,"ZOOKEEPER-21. Improve zk ctor/watcher (state transition) docs ",2008.09.27 03:09:25,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 9cf4720..53c43f1 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -45,8 +45,6 @@
 import org.apache.zookeeper.AsyncCallback.StringCallback;
 import org.apache.zookeeper.AsyncCallback.VoidCallback;
 import org.apache.zookeeper.Watcher.Event;
-import org.apache.zookeeper.Watcher.Event.EventType;
-import org.apache.zookeeper.Watcher.Event.KeeperState;
 import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.ZooKeeper.States;
 import org.apache.zookeeper.ZooKeeper.WatchRegistration;
"
zookeeper,ad482ad24cc864686f268b71896606091d92a00f,"ZOOKEEPER-21. Improve zk ctor/watcher (state transition) docs ",2008.09.27 03:09:25,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ClientWatchManager.java b/src/java/main/org/apache/zookeeper/ClientWatchManager.java
index 0c224a3..fe6d83e 100644
--- a/src/java/main/org/apache/zookeeper/ClientWatchManager.java
+++ b/src/java/main/org/apache/zookeeper/ClientWatchManager.java
@@ -20,9 +20,6 @@
 
 import java.util.Set;
 
-import org.apache.zookeeper.Watcher.Event.EventType;
-import org.apache.zookeeper.Watcher.Event.KeeperState;
-
 /**
  */
 public interface ClientWatchManager {
"
zookeeper,ad482ad24cc864686f268b71896606091d92a00f,"ZOOKEEPER-21. Improve zk ctor/watcher (state transition) docs ",2008.09.27 03:09:25,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/Watcher.java b/src/java/main/org/apache/zookeeper/Watcher.java
index baaf47b..fef4cea 100644
--- a/src/java/main/org/apache/zookeeper/Watcher.java
+++ b/src/java/main/org/apache/zookeeper/Watcher.java
@@ -18,8 +18,6 @@
 
 package org.apache.zookeeper;
 
-import org.apache.zookeeper.proto.WatcherEvent;
-
 /**
  * This interface specifies the public interface an event handler class must
  * implement. A ZooKeeper client will get various events from the ZooKeepr
"
zookeeper,ad482ad24cc864686f268b71896606091d92a00f,"ZOOKEEPER-21. Improve zk ctor/watcher (state transition) docs ",2008.09.27 03:09:25,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 5ffc969..17a4399 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -52,24 +52,13 @@
 import org.apache.zookeeper.proto.SetDataResponse;
 import org.apache.zookeeper.proto.SyncRequest;
 import org.apache.zookeeper.proto.SyncResponse;
-import org.apache.zookeeper.proto.WatcherEvent;
 import org.apache.zookeeper.server.DataTree;
-import org.apache.zookeeper.Watcher.Event.EventType;
-import org.apache.zookeeper.Watcher.Event.KeeperState;
 
 /**
  * This is the main class of ZooKeeper client library. To use a ZooKeeper
  * service, an application must first instantiate an object of ZooKeeper class.
  * All the iterations will be done by calling the methods of ZooKeeper class.
  * <p>
- * To create a client(ZooKeeper) object, the application needs to pass a string
- * containing a list of host:port pairs, each corresponding to a ZooKeeper
- * server; a sessionTimeout; and an object of Watcher type.
- * <p>
- * The client object will pick an arbitrary server and try to connect to it. If
- * failed, it will try the next one in the list, until a connection is
- * established, or all the servers have been tried.
- * <p>
  * Once a connection to a server is established, a session ID is assigned to the
  * client. The client will send heart beats to the server periodically to keep
  * the session valid.
@@ -109,10 +98,10 @@
     private static final Logger LOG = Logger.getLogger(ZooKeeper.class);
 
     private final ZKWatchManager watchManager = new ZKWatchManager();
-    
+
     /**
      * Manage watchers & handle events generated by the ClientCnxn object.
-     * 
+     *
      * We are implementing this as a nested class of ZooKeeper so that
      * the public methods will not be exposed as part of the ZooKeeper client
      * API.
@@ -128,10 +117,10 @@
         /* (non-Javadoc)
          * @see org.apache.zookeeper.ClientWatchManager#materialize(Event.KeeperState, Event.EventType, java.lang.String)
          */
-        public Set<Watcher> materialize(Watcher.Event.KeeperState state, 
+        public Set<Watcher> materialize(Watcher.Event.KeeperState state,
                                         Watcher.Event.EventType type, String path) {
             Set<Watcher> result = new HashSet<Watcher>();
-            
+
             // clear the watches if we are not connected
 
             if (state != Watcher.Event.KeeperState.SyncConnected) {
@@ -152,9 +141,9 @@
                     childWatches.clear();
                 }
             }
-    
+
             Set<Watcher> watchers = null;
-    
+
             switch (type) {
             case None:
                 result.add(defaultWatcher);
@@ -192,7 +181,7 @@
                 LOG.error(msg);
                 throw new RuntimeException(msg);
             }
-    
+
             result.addAll(watchers);
             return result;
         }
@@ -268,12 +257,46 @@
 
     protected ClientCnxn cnxn;
 
+    /**
+     * @see ZooKeeper(String, int, Watcher, long, byte[])
+     */
     public ZooKeeper(String host, int sessionTimeout, Watcher watcher)
             throws IOException {
         watchManager.defaultWatcher = watcher;
         cnxn = new ClientCnxn(host, sessionTimeout, this, watchManager);
     }
 
+    /**
+     * To create a client(ZooKeeper) object, the application needs to pass a
+     * string containing a list of host:port pairs, each corresponding to a
+     * ZooKeeper server.
+     * <p>
+     * The client object will pick an arbitrary server and try to connect to it.
+     * If failed, it will try the next one in the list, until a connection is
+     * established, or all the servers have been tried.
+     * <p>
+     * Use {@link #getSessionId} and {@link #getSessionPasswd} on an established
+     * client connection, these values must be passed as sessionId and
+     * sessionPasswd respectively if reconnecting. Otherwise, if not
+     * reconnecting, use the other constructor which does not require these
+     * parameters.
+     *
+     * @param host
+     *            comma separated host:port pairs, each corresponding to a zk
+     *            server. eg. ""127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002""
+     * @param sessionTimeout
+     *            session timeout in milliseconds
+     * @param watcher
+     *            a watcher object which will be notified of state changes, may
+     *            also be notified for node events
+     * @param sessionId
+     *            specific session id to use if reconnecting
+     * @param sessionPasswd
+     *            password for this session
+     *
+     * @throws IOException
+     *             in cases of network failure
+     */
     public ZooKeeper(String host, int sessionTimeout, Watcher watcher,
             long sessionId, byte[] sessionPasswd) throws IOException {
         watchManager.defaultWatcher = watcher;
@@ -282,16 +305,23 @@
     }
 
     /**
-     * The session id for this ZooKeeper client instance. The value returned
-     * is not valid until the client connects to a server and may change
-     * after a re-connect.
-     * 
+     * The session id for this ZooKeeper client instance. The value returned is
+     * not valid until the client connects to a server and may change after a
+     * re-connect.
+     *
      * @return current session id
      */
     public long getSessionId() {
         return cnxn.getSessionId();
     }
 
+    /**
+     * The session password for this ZooKeeper client instance. The value
+     * returned is not valid until the client connects to a server and may
+     * change after a re-connect.
+     *
+     * @return current session password
+     */
     public byte[] getSessionPasswd() {
         return cnxn.getSessionPasswd();
     }
@@ -363,7 +393,7 @@
      * watches on the path left by exists calls, and the watches on the parent
      * of the node by getChildren calls.
      * <p>
-     * The maximum allowable size of the data array is 1 MB (1,048,576 bytes). 
+     * The maximum allowable size of the data array is 1 MB (1,048,576 bytes).
      * Arrays larger than this will cause a KeeperExecption to be thrown.
      *
      * @param path
@@ -402,7 +432,7 @@
         return response.getPath();
     }
 
-	/**
+    /**
      * The Asynchronous version of create. The request doesn't actually until
      * the asynchronous callback is called.
      *
@@ -686,7 +716,7 @@
      * A KeeperException with error code KeeperException.BadVersion will be
      * thrown if the given version does not match the node's version.
      * <p>
-     * The maximum allowable size of the data array is 1 MB (1,048,576 bytes). 
+     * The maximum allowable size of the data array is 1 MB (1,048,576 bytes).
      * Arrays larger than this will cause a KeeperExecption to be thrown.
      *
      * @param path
"
zookeeper,ad482ad24cc864686f268b71896606091d92a00f,"ZOOKEEPER-21. Improve zk ctor/watcher (state transition) docs ",2008.09.27 03:09:25,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index 3e18114..d024757 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -23,13 +23,12 @@
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
+
+import org.apache.zookeeper.AsyncCallback.DataCallback;
+import org.apache.zookeeper.ZooDefs.Ids;
 import org.apache.zookeeper.data.ACL;
 import org.apache.zookeeper.data.Id;
 import org.apache.zookeeper.data.Stat;
-import org.apache.zookeeper.proto.WatcherEvent;
-import org.apache.zookeeper.AsyncCallback.DataCallback;
-import org.apache.zookeeper.ZooDefs.Ids;
-import org.apache.zookeeper.CreateMode;
 
 /**
  * The command line client to ZooKeeper.
"
zookeeper,d284d6fdae9c826bea44414a4f8f7b811eb0657f,ZOOKEEPER-117 threading issues in Leader election,2008.09.25 06:27:50,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index c0ec7dc..5b81314 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -24,6 +24,7 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketAddress;
+import java.net.SocketException;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -59,6 +60,9 @@
 
     QuorumPeer self;
 
+    // the follower acceptor thread
+    FollowerCnxAcceptor cnxAcceptor;
+    
     // list of all the followers
     public HashSet<FollowerHandler> followers = new HashSet<FollowerHandler>();
 
@@ -194,6 +198,42 @@
     ConcurrentLinkedQueue<Proposal> toBeApplied = new ConcurrentLinkedQueue<Proposal>();
 
     Proposal newLeaderProposal = new Proposal();
+    
+    class FollowerCnxAcceptor extends Thread{
+        private volatile boolean stop = false;
+        
+        @Override
+        public void run() {
+            try {
+                while (!stop) {
+                    try{
+                        Socket s = ss.accept();
+                        s.setSoTimeout(self.tickTime * self.syncLimit);
+                        s.setTcpNoDelay(true);
+                        new FollowerHandler(s, Leader.this);
+                    } catch (SocketException e) {
+                        if (stop) {
+                            LOG.info(""exception while shutting down acceptor: ""
+                                    + e);
+
+                            // When Leader.shutdown() calls ss.close(),
+                            // the call to accept throws an exception.
+                            // We catch and set stop to true.
+                            stop = true;
+                        } else {
+                            throw e;
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                LOG.warn(""Exception while accepting follower"", e);
+            }
+        }
+        
+        public void halt() {
+            stop = true;
+        }
+    }
 
     /**
      * This method is main function that is called to lead
@@ -217,21 +257,12 @@
                     + newLeaderProposal.packet.getZxid());
         }
         outstandingProposals.add(newLeaderProposal);
-        new Thread() {
-            @Override
-            public void run() {
-                try {
-                    while (true) {
-                        Socket s = ss.accept();
-                        s.setSoTimeout(self.tickTime * self.syncLimit);
-                        s.setTcpNoDelay(true);
-                        new FollowerHandler(s, Leader.this);
-                    }
-                } catch (Exception e) {
-                    LOG.warn(""Exception while accepting follower"", e);
-                }
-            }
-        }.start();
+        
+        // Start thread that waits for connection requests from 
+        // new followers.
+        cnxAcceptor = new FollowerCnxAcceptor();
+        cnxAcceptor.start();
+        
         // We have to get at least a majority of servers in sync with
         // us. We do this by waiting for the NEWLEADER packet to get
         // acknowledged
@@ -256,9 +287,12 @@
             self.cnxnFactory.setZooKeeperServer(zk);
         }
         // Everything is a go, simply start counting the ticks
-        synchronized (this) {
-            notifyAll();
-        }
+        // WARNING: I couldn't find any wait statement on a synchronized
+        // block that would be notified by this notifyAll() call, so
+        // I commented it out
+        //synchronized (this) {
+        //    notifyAll();
+        //}
         // We ping twice a tick, so we only update the tick every other
         // iteration
         boolean tickSkip = true;
@@ -299,9 +333,12 @@
         if (isShutdown) {
             return;
         }
+        
+        LOG.info(""Shutdown called"",
+                new Exception(""shutdown Leader! reason: "" + reason));
 
-        LOG.error(""FIXMSG"",new Exception(""shutdown Leader! reason: ""
-                        + reason));
+        cnxAcceptor.halt();
+        
         // NIO should not accept conenctions
         self.cnxnFactory.setZooKeeperServer(null);
         // clear all the connections
"
zookeeper,d1fa7aa702b4c9474ecbed78da9f8ca0638b6d04,ZOOKEEPER-137 client watcher objects can lose events,2008.09.25 06:05:26,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 8000d2a..e1b45fe 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -94,9 +94,6 @@
      */
     private LinkedList<Packet> pendingQueue = new LinkedList<Packet>();
 
-    private LinkedBlockingQueue<Object> waitingEvents = 
-        new LinkedBlockingQueue<Object>();
-
     /**
      * These are the packets that need to be sent.
      */
@@ -112,7 +109,7 @@
 
     private final ZooKeeper zooKeeper;
 
-    private final Watcher watcher;
+    private final ClientWatchManager watcher;
 
     private long sessionId;
 
@@ -206,7 +203,7 @@
     }
 
     public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
-            Watcher watcher)
+            ClientWatchManager watcher)
         throws IOException
     {
         this(hosts, sessionTimeout, zooKeeper, watcher, 0, new byte[16]);
@@ -226,7 +223,7 @@
      * @throws IOException
      */
     public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
-            Watcher watcher, long sessionId, byte[] sessionPasswd)
+            ClientWatchManager watcher, long sessionId, byte[] sessionPasswd)
         throws IOException
     {
         this.zooKeeper = zooKeeper;
@@ -251,11 +248,11 @@
         readTimeout = sessionTimeout * 2 / 3;
         Collections.shuffle(serverAddrs);
         sendThread = new SendThread();
-        sendThread.start();
         eventThread = new EventThread();
+        sendThread.start();
         eventThread.start();
     }
-
+    
     WatcherEvent eventOfDeath = new WatcherEvent();
 
     final static UncaughtExceptionHandler uncaughtExceptionHandler = new UncaughtExceptionHandler() {
@@ -264,12 +261,43 @@
         }
     };
 
+    private class WatcherSetEventPair {
+        private final Set<Watcher> watchers;
+        private final WatcherEvent event;
+        
+        public WatcherSetEventPair(Set<Watcher> watchers, WatcherEvent event) {
+            this.watchers = watchers;
+            this.event = event;
+        }
+    }
+    
     class EventThread extends Thread {
+        private final LinkedBlockingQueue<Object> waitingEvents = 
+            new LinkedBlockingQueue<Object>();
+
         EventThread() {
             super(currentThread().getName() + ""-EventThread"");
             setUncaughtExceptionHandler(uncaughtExceptionHandler);
             setDaemon(true);
         }
+        
+        public void queueEvent(WatcherEvent event) {
+            // materialize the watchers based on the event
+            WatcherSetEventPair pair = new WatcherSetEventPair(
+                    watcher.materialize(event.getState(), event.getType(),
+                            event.getPath()),
+                            event);
+            // queue the pair (watch set & event) for later processing
+            waitingEvents.add(pair);
+        }
+        
+        public void queuePacket(Packet packet) {
+            waitingEvents.add(packet);
+        }
+
+        public void queueEventOfDeath() {
+            waitingEvents.add(eventOfDeath);
+        }
 
         @Override
         public void run() {
@@ -279,8 +307,12 @@
                     if (event == eventOfDeath) {
                         break;
                     }
-                    if (event instanceof WatcherEvent) {
-                        watcher.process((WatcherEvent) event);
+                    if (event instanceof WatcherSetEventPair) {
+                        // each watcher will process the event
+                        WatcherSetEventPair pair = (WatcherSetEventPair)event;
+                        for (Watcher watcher: pair.watchers) {
+                            watcher.process(pair.event);
+                        }
                     } else {
                         Packet p = (Packet) event;
                         int rc = 0;
@@ -362,7 +394,6 @@
         }
     }
 
-    @SuppressWarnings(""unchecked"")
     private void finishPacket(Packet p) {
         if (p.watchRegistration != null) {
             p.watchRegistration.register(p.replyHeader.getErr());
@@ -375,7 +406,7 @@
             }
         } else {
             p.finished = true;
-            waitingEvents.add(p);
+            eventThread.queuePacket(p);
         }
     }
 
@@ -428,7 +459,7 @@
             int sessionTimeout = conRsp.getTimeOut();
             if (sessionTimeout <= 0) {
                 zooKeeper.state = States.CLOSED;
-                waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
+                eventThread.queueEvent(new WatcherEvent(Watcher.Event.EventNone,
                         Watcher.Event.KeeperStateExpired, null));
                 throw new IOException(""Session Expired"");
             }
@@ -436,11 +467,10 @@
             connectTimeout = sessionTimeout / serverAddrs.size();
             sessionId = conRsp.getSessionId();
             sessionPasswd = conRsp.getPasswd();
-            waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
+            eventThread.queueEvent(new WatcherEvent(Watcher.Event.EventNone,
                     Watcher.Event.KeeperStateSyncConnected, null));
         }
 
-        @SuppressWarnings(""unchecked"")
         void readResponse() throws IOException {
             ByteBufferInputStream bbis = new ByteBufferInputStream(
                     incomingBuffer);
@@ -461,9 +491,13 @@
                 // -1 means notification
                 WatcherEvent event = new WatcherEvent();
                 event.deserialize(bbia, ""response"");
-                // System.out.println(""Got an event: "" + event + "" for "" +
-                // sessionId + "" through"" + _cnxn);
-                waitingEvents.add(event);
+                
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Got an event: "" + event + "" for sessionid 0x""
+                            + Long.toHexString(sessionId));
+                }
+                
+                eventThread.queueEvent(event);
                 return;
             }
             if (pendingQueue.size() == 0) {
@@ -763,8 +797,10 @@
                                 e);
                         cleanup();
                         if (zooKeeper.state.isAlive()) {
-                            waitingEvents.add(new WatcherEvent(Event.EventNone,
-                                    Event.KeeperStateDisconnected, null));
+                            eventThread.queueEvent(new WatcherEvent(
+                                    Event.EventNone,
+                                    Event.KeeperStateDisconnected,
+                                    null));
                         }
     
                         now = System.currentTimeMillis();
@@ -842,13 +878,12 @@
      * method is primarily here to allow the tests to verify disconnection
      * behavior.
      */
-    @SuppressWarnings(""unchecked"")
     public void disconnect() {
         LOG.info(""Disconnecting ClientCnxn for session: 0x"" 
                 + Long.toHexString(getSessionId()));
 
         sendThread.close();
-        waitingEvents.add(eventOfDeath);
+        eventThread.queueEventOfDeath();
     }
 
     /**
"
zookeeper,d1fa7aa702b4c9474ecbed78da9f8ca0638b6d04,ZOOKEEPER-137 client watcher objects can lose events,2008.09.25 06:05:26,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 8108fae..e579615 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -106,37 +106,35 @@
 public class ZooKeeper {
     private static final Logger LOG = Logger.getLogger(ZooKeeper.class);
 
-    private volatile Watcher defaultWatcher;
-
-    private final Map<String, Set<Watcher>> dataWatches =
-        new HashMap<String, Set<Watcher>>();
-    private final Map<String, Set<Watcher>> childWatches =
-        new HashMap<String, Set<Watcher>>();
-
+    private final ZKWatchManager watchManager = new ZKWatchManager();
+    
     /**
-     * Process watch events generated by the ClientCnxn object.
+     * Manage watchers & handle events generated by the ClientCnxn object.
      * 
      * We are implementing this as a nested class of ZooKeeper so that
-     * the public Watcher.process(event) method will not be exposed as part 
-     * of the ZooKeeper client API.
+     * the public methods will not be exposed as part of the ZooKeeper client
+     * API.
      */
-    private class ZKWatcher implements Watcher {
-        /**
-         * Process a WatchEvent.
-         *
-         * Looks up the watch in the set of watches, processes the event
-         * if found, otw uses the default watcher (registered during instance
-         * creation) to process the watch.
-         *
-         * @param event the event to process.
+    private class ZKWatchManager implements ClientWatchManager {
+        private final Map<String, Set<Watcher>> dataWatches =
+            new HashMap<String, Set<Watcher>>();
+        private final Map<String, Set<Watcher>> childWatches =
+            new HashMap<String, Set<Watcher>>();
+
+        private volatile Watcher defaultWatcher;
+
+        /* (non-Javadoc)
+         * @see org.apache.zookeeper.ClientWatchManager#materialize(int, int, java.lang.String)
          */
-        public void process(WatcherEvent event) {
+        public Set<Watcher> materialize(int state, int type, String path) {
+            Set<Watcher> result = new HashSet<Watcher>();
+            
             // clear the watches if we are not connected
-            if (event.getState() != Watcher.Event.KeeperStateSyncConnected) {
+            if (state != Watcher.Event.KeeperStateSyncConnected) {
                 synchronized (dataWatches) {
                     for (Set<Watcher> watchers : dataWatches.values()) {
                         for (Watcher watcher : watchers) {
-                            watcher.process(event);
+                            result.add(watcher);
                         }
                     }
                     dataWatches.clear();
@@ -144,7 +142,7 @@
                 synchronized (childWatches) {
                     for (Set<Watcher> watchers : childWatches.values()) {
                         for (Watcher watcher : watchers) {
-                            watcher.process(event);
+                            result.add(watcher);
                         }
                     }
                     childWatches.clear();
@@ -153,28 +151,28 @@
     
             Set<Watcher> watchers = null;
     
-            switch (event.getType()) {
+            switch (type) {
             case Watcher.Event.EventNone:
-                defaultWatcher.process(event);
-                return;
+                result.add(defaultWatcher);
+                return result;
             case Watcher.Event.EventNodeDataChanged:
             case Watcher.Event.EventNodeCreated:
                 synchronized (dataWatches) {
-                    watchers = dataWatches.remove(event.getPath());
+                    watchers = dataWatches.remove(path);
                 }
                 break;
             case Watcher.Event.EventNodeChildrenChanged:
                 synchronized (childWatches) {
-                    watchers = childWatches.remove(event.getPath());
+                    watchers = childWatches.remove(path);
                 }
                 break;
             case Watcher.Event.EventNodeDeleted:
                 synchronized (dataWatches) {
-                    watchers = dataWatches.remove(event.getPath());
+                    watchers = dataWatches.remove(path);
                 }
                 Set<Watcher> cwatches;
                 synchronized (childWatches) {
-                    cwatches = childWatches.remove(event.getPath());
+                    cwatches = childWatches.remove(path);
                 }
                 if (cwatches != null) {
                     if (watchers == null) {
@@ -185,16 +183,14 @@
                 }
                 break;
             default:
-                String msg = ""Unhandled watch event type "" + event.getType();
+                String msg = ""Unhandled watch event type "" + type
+                    + "" with state "" + state + "" on path "" + path;
                 LOG.error(msg);
                 throw new RuntimeException(msg);
             }
     
-            if (watchers != null) {
-                for (Watcher watcher : watchers) {
-                    watcher.process(event);
-                }
-            }
+            result.addAll(watchers);
+            return result;
         }
     }
 
@@ -270,14 +266,14 @@
 
     public ZooKeeper(String host, int sessionTimeout, Watcher watcher)
             throws IOException {
-        this.defaultWatcher = watcher;
-        cnxn = new ClientCnxn(host, sessionTimeout, this, new ZKWatcher());
+        watchManager.defaultWatcher = watcher;
+        cnxn = new ClientCnxn(host, sessionTimeout, this, watchManager);
     }
 
     public ZooKeeper(String host, int sessionTimeout, Watcher watcher,
             long sessionId, byte[] sessionPasswd) throws IOException {
-        this.defaultWatcher = watcher;
-        cnxn = new ClientCnxn(host, sessionTimeout, this, new ZKWatcher(),
+        watchManager.defaultWatcher = watcher;
+        cnxn = new ClientCnxn(host, sessionTimeout, this, watchManager,
                 sessionId, sessionPasswd);
     }
 
@@ -301,7 +297,7 @@
     }
 
     public synchronized void register(Watcher watcher) {
-        this.defaultWatcher = watcher;
+        watchManager.defaultWatcher = watcher;
     }
 
     /**
@@ -503,7 +499,8 @@
         SetDataResponse response = new SetDataResponse();
         WatchRegistration wcb = null;
         if (watcher != null) {
-            wcb = new ExistsWatchRegistration(dataWatches, watcher, path);
+            wcb = new ExistsWatchRegistration(watchManager.dataWatches, watcher,
+                    path);
         }
         ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);
         if (r.getErr() != 0) {
@@ -537,7 +534,7 @@
     public Stat exists(String path, boolean watch) throws KeeperException,
         InterruptedException
     {
-        return exists(path, watch ? defaultWatcher : null);
+        return exists(path, watch ? watchManager.defaultWatcher : null);
     }
 
     /**
@@ -557,7 +554,8 @@
         SetDataResponse response = new SetDataResponse();
         WatchRegistration wcb = null;
         if (watcher != null) {
-            wcb = new ExistsWatchRegistration(dataWatches, watcher, path);
+            wcb = new ExistsWatchRegistration(watchManager.dataWatches, watcher,
+                    path);
         }
         cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path,
                         ctx, wcb);
@@ -570,7 +568,7 @@
      * @see #exists(String, boolean)
      */
     public void exists(String path, boolean watch, StatCallback cb, Object ctx) {
-        exists(path, watch ? defaultWatcher : null, cb, ctx);
+        exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);
     }
 
     /**
@@ -601,7 +599,8 @@
         GetDataResponse response = new GetDataResponse();
         WatchRegistration wcb = null;
         if (watcher != null) {
-            wcb = new WatchRegistration(dataWatches, watcher, path);
+            wcb = new WatchRegistration(watchManager.dataWatches, watcher,
+                    path);
         }
         ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);
         if (r.getErr() != 0) {
@@ -633,7 +632,7 @@
      */
     public byte[] getData(String path, boolean watch, Stat stat)
             throws KeeperException, InterruptedException {
-        return getData(path, watch ? defaultWatcher : null, stat);
+        return getData(path, watch ? watchManager.defaultWatcher : null, stat);
     }
 
     /**
@@ -651,7 +650,8 @@
         GetDataResponse response = new GetDataResponse();
         WatchRegistration wcb = null;
         if (watcher != null) {
-            wcb = new WatchRegistration(dataWatches, watcher, path);
+            wcb = new WatchRegistration(watchManager.dataWatches, watcher,
+                    path);
         }
         cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path,
                         ctx, wcb);
@@ -664,7 +664,7 @@
      * @see #getData(String, boolean, Stat)
      */
     public void getData(String path, boolean watch, DataCallback cb, Object ctx) {
-        getData(path, watch ? defaultWatcher : null, cb, ctx);
+        getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);
     }
 
     /**
@@ -862,7 +862,8 @@
         GetChildrenResponse response = new GetChildrenResponse();
         WatchRegistration wcb = null;
         if (watcher != null) {
-            wcb = new WatchRegistration(childWatches, watcher, path);
+            wcb = new WatchRegistration(watchManager.childWatches, watcher,
+                    path);
         }
         ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);
         if (r.getErr() != 0) {
@@ -893,7 +894,7 @@
      */
     public List<String> getChildren(String path, boolean watch)
             throws KeeperException, InterruptedException {
-        return getChildren(path, watch ? defaultWatcher : null);
+        return getChildren(path, watch ? watchManager.defaultWatcher : null);
     }
 
     /**
@@ -912,7 +913,8 @@
         GetChildrenResponse response = new GetChildrenResponse();
         WatchRegistration wcb = null;
         if (watcher != null) {
-            wcb = new WatchRegistration(childWatches, watcher, path);
+            wcb = new WatchRegistration(watchManager.childWatches, watcher,
+                    path);
         }
         cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path,
                         ctx, wcb);
@@ -926,7 +928,7 @@
      */
     public void getChildren(String path, boolean watch, ChildrenCallback cb,
             Object ctx) {
-        getChildren(path, watch ? defaultWatcher : null, cb, ctx);
+        getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);
     }
 
     /**
"
zookeeper,3553137b9a7e8d804fdb378be23196a74afaf731,ZOOKEEPER-131. Fix Old leader election can elect a dead leader over and over again. (breed via mahadev),2008.09.19 10:24:25,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
index bfc198f..2731343 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
@@ -26,6 +26,8 @@
 import java.nio.ByteBuffer;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
 import java.util.Random;
 import java.util.Map.Entry;
 
@@ -54,7 +56,7 @@
         public int winningCount;
     }
 
-    private ElectionResult countVotes(HashMap<InetSocketAddress, Vote> votes) {
+    private ElectionResult countVotes(HashMap<InetSocketAddress, Vote> votes, HashSet<Long> heardFrom) {
         ElectionResult result = new ElectionResult();
         // Initialize with null vote
         result.vote = new Vote(Long.MIN_VALUE, Long.MIN_VALUE);
@@ -62,7 +64,13 @@
         Collection<Vote> votesCast = votes.values();
         // First make the views consistent. Sometimes peers will have
         // different zxids for a server depending on timing.
-        for (Vote v : votesCast) {
+        for (Iterator<Vote> i = votesCast.iterator(); i.hasNext();) {
+            Vote v = i.next();
+            if (!heardFrom.contains(v.id)) {
+                // Discard votes for machines that we didn't hear from
+                i.remove();
+                continue;
+            }
             for (Vote w : votesCast) {
                 if (v.id == w.id) {
                     if (v.zxid < w.zxid) {
@@ -71,6 +79,7 @@
                 }
             }
         }
+        
         HashMap<Vote, Integer> countTable = new HashMap<Vote, Integer>();
         // Now do the tally
         for (Vote v : votesCast) {
@@ -127,6 +136,7 @@
             requestBuffer.clear();
             requestBuffer.putInt(xid);
             requestPacket.setLength(4);
+            HashSet<Long> heardFrom = new HashSet<Long>();
             for (QuorumServer server : self.quorumPeers) {
                 requestPacket.setSocketAddress(server.addr);
                 try {
@@ -145,7 +155,8 @@
                                 + "" got "" + recvedXid);
                         continue;
                     }
-                    responseBuffer.getLong();
+                    long peerId = responseBuffer.getLong();
+                    heardFrom.add(peerId);
                     //if(server.id != peerId){
                         Vote vote = new Vote(responseBuffer.getLong(),
                             responseBuffer.getLong());
@@ -154,12 +165,13 @@
                         votes.put(addr, vote);
                     //}
                 } catch (IOException e) {
+                    LOG.error(""Error in looking for leader"", e);
                     // Errors are okay, since hosts may be
                     // down
                     // ZooKeeperServer.logException(e);
                 }
             }
-            ElectionResult result = countVotes(votes);
+            ElectionResult result = countVotes(votes, heardFrom);
             if (result.winner.id >= 0) {
                 self.setCurrentVote(result.vote);
                 if (result.winningCount > (self.quorumPeers.size() / 2)) {
"
zookeeper,3553137b9a7e8d804fdb378be23196a74afaf731,ZOOKEEPER-131. Fix Old leader election can elect a dead leader over and over again. (breed via mahadev),2008.09.19 10:24:25,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 0bfe284..9b930e7 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -160,13 +160,15 @@
             super(""ResponderThread"");
         }
 
+        volatile boolean running = true;
+        
         @Override
         public void run() {
             try {
                 byte b[] = new byte[36];
                 ByteBuffer responseBuffer = ByteBuffer.wrap(b);
                 DatagramPacket packet = new DatagramPacket(b, b.length);
-                while (true) {
+                while (running) {
                     udpSocket.receive(packet);
                     if (packet.getLength() != 4) {
                         LOG.warn(""Got more than just an xid! Len = ""
@@ -273,7 +275,17 @@
 
     @Override
     public synchronized void start() {
-        
+        startLeaderElection();
+        super.start();
+    }
+
+    ResponderThread responder;
+    
+    public void stopLeaderElection() {
+        responder.running = false;
+        responder.interrupt();
+    }
+    public void startLeaderElection() {
         currentVote = new Vote(myid, getLastLoggedZxid());
         for (QuorumServer p : quorumPeers) {
             if (p.id == myid) {
@@ -287,13 +299,14 @@
         if (electionType == 0) {
             try {
                 udpSocket = new DatagramSocket(myQuorumAddr.getPort());
-                new ResponderThread().start();
+                responder = new ResponderThread();
+                responder.start();
             } catch (SocketException e) {
                 throw new RuntimeException(e);
             }
         }
         this.electionAlg = createElectionAlgorithm(electionType);
-        super.start();
+       
     }
     
     /**
"
zookeeper,3553137b9a7e8d804fdb378be23196a74afaf731,ZOOKEEPER-131. Fix Old leader election can elect a dead leader over and over again. (breed via mahadev),2008.09.19 10:24:25,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Vote.java b/src/java/main/org/apache/zookeeper/server/quorum/Vote.java
index 7cca0a6..7697596 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Vote.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Vote.java
@@ -44,4 +44,7 @@
         return (int) (id & zxid);
     }
 
+    public String toString() {
+        return ""("" + id + "", "" + Long.toHexString(zxid) + "")"";
+    }
 }
\ No newline at end of file
"
zookeeper,a6078d424766ba7ca60821ae802f3acb9e2c7758,ZOOKEEPER-112 src/java/main ZooKeeper.java has test code embedded into it.,2008.09.06 05:30:49,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 867a5ee..8000d2a 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -70,7 +70,7 @@
  * connected to as needed.
  *
  */
-class ClientCnxn {
+public class ClientCnxn {
     private static final Logger LOG = Logger.getLogger(ClientCnxn.class);
 
     private ArrayList<InetSocketAddress> serverAddrs =
@@ -112,6 +112,8 @@
 
     private final ZooKeeper zooKeeper;
 
+    private final Watcher watcher;
+
     private long sessionId;
 
     private byte sessionPasswd[] = new byte[16];
@@ -203,9 +205,11 @@
         }
     }
 
-    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper)
-            throws IOException {
-        this(hosts, sessionTimeout, zooKeeper, 0, new byte[16]);
+    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
+            Watcher watcher)
+        throws IOException
+    {
+        this(hosts, sessionTimeout, zooKeeper, watcher, 0, new byte[16]);
     }
 
     /**
@@ -222,8 +226,11 @@
      * @throws IOException
      */
     public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
-            long sessionId, byte[] sessionPasswd) throws IOException {
+            Watcher watcher, long sessionId, byte[] sessionPasswd)
+        throws IOException
+    {
         this.zooKeeper = zooKeeper;
+        this.watcher = watcher;
         this.sessionId = sessionId;
         this.sessionPasswd = sessionPasswd;
         String hostsList[] = hosts.split("","");
@@ -273,7 +280,7 @@
                         break;
                     }
                     if (event instanceof WatcherEvent) {
-                        zooKeeper.processWatchEvent((WatcherEvent) event);
+                        watcher.process((WatcherEvent) event);
                     } else {
                         Packet p = (Packet) event;
                         int rc = 0;
"
zookeeper,a6078d424766ba7ca60821ae802f3acb9e2c7758,ZOOKEEPER-112 src/java/main ZooKeeper.java has test code embedded into it.,2008.09.06 05:30:49,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index cc90cb9..86967f8 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -114,77 +114,86 @@
         new HashMap<String, Set<Watcher>>();
 
     /**
-     * Process a WatchEvent.
-     *
-     * Looks up the watch in the set of watches, processes the event
-     * if found, otw uses the default watcher (registered during instance
-     * creation) to process the watch.
-     *
-     * @param event the event to process.
+     * Process watch events generated by the ClientCnxn object.
+     * 
+     * We are implementing this as a nested class of ZooKeeper so that
+     * the public Watcher.process(event) method will not be exposed as part 
+     * of the ZooKeeper client API.
      */
-    public void processWatchEvent(WatcherEvent event) {
-        // clear the watches if we are not connected
-        if (event.getState() != Watcher.Event.KeeperStateSyncConnected) {
-            synchronized (dataWatches) {
-                for (Set<Watcher> watchers : dataWatches.values()) {
-                    for (Watcher watcher : watchers) {
-                        watcher.process(event);
+    private class ZKWatcher implements Watcher {
+        /**
+         * Process a WatchEvent.
+         *
+         * Looks up the watch in the set of watches, processes the event
+         * if found, otw uses the default watcher (registered during instance
+         * creation) to process the watch.
+         *
+         * @param event the event to process.
+         */
+        public void process(WatcherEvent event) {
+            // clear the watches if we are not connected
+            if (event.getState() != Watcher.Event.KeeperStateSyncConnected) {
+                synchronized (dataWatches) {
+                    for (Set<Watcher> watchers : dataWatches.values()) {
+                        for (Watcher watcher : watchers) {
+                            watcher.process(event);
+                        }
+                    }
+                    dataWatches.clear();
+                }
+                synchronized (childWatches) {
+                    for (Set<Watcher> watchers : childWatches.values()) {
+                        for (Watcher watcher : watchers) {
+                            watcher.process(event);
+                        }
+                    }
+                    childWatches.clear();
+                }
+            }
+    
+            Set<Watcher> watchers = null;
+    
+            switch (event.getType()) {
+            case Watcher.Event.EventNone:
+                defaultWatcher.process(event);
+                return;
+            case Watcher.Event.EventNodeDataChanged:
+            case Watcher.Event.EventNodeCreated:
+                synchronized (dataWatches) {
+                    watchers = dataWatches.remove(event.getPath());
+                }
+                break;
+            case Watcher.Event.EventNodeChildrenChanged:
+                synchronized (childWatches) {
+                    watchers = childWatches.remove(event.getPath());
+                }
+                break;
+            case Watcher.Event.EventNodeDeleted:
+                synchronized (dataWatches) {
+                    watchers = dataWatches.remove(event.getPath());
+                }
+                Set<Watcher> cwatches;
+                synchronized (childWatches) {
+                    cwatches = childWatches.remove(event.getPath());
+                }
+                if (cwatches != null) {
+                    if (watchers == null) {
+                        watchers = cwatches;
+                    } else {
+                        watchers.addAll(cwatches);
                     }
                 }
-                dataWatches.clear();
+                break;
+            default:
+                String msg = ""Unhandled watch event type "" + event.getType();
+                LOG.error(msg);
+                throw new RuntimeException(msg);
             }
-            synchronized (childWatches) {
-                for (Set<Watcher> watchers : childWatches.values()) {
-                    for (Watcher watcher : watchers) {
-                        watcher.process(event);
-                    }
+    
+            if (watchers != null) {
+                for (Watcher watcher : watchers) {
+                    watcher.process(event);
                 }
-                childWatches.clear();
-            }
-        }
-
-        Set<Watcher> watchers = null;
-
-        switch (event.getType()) {
-        case Watcher.Event.EventNone:
-            defaultWatcher.process(event);
-            return;
-        case Watcher.Event.EventNodeDataChanged:
-        case Watcher.Event.EventNodeCreated:
-            synchronized (dataWatches) {
-                watchers = dataWatches.remove(event.getPath());
-            }
-            break;
-        case Watcher.Event.EventNodeChildrenChanged:
-            synchronized (childWatches) {
-                watchers = childWatches.remove(event.getPath());
-            }
-            break;
-        case Watcher.Event.EventNodeDeleted:
-            synchronized (dataWatches) {
-                watchers = dataWatches.remove(event.getPath());
-            }
-            Set<Watcher> cwatches;
-            synchronized (childWatches) {
-                cwatches = childWatches.remove(event.getPath());
-            }
-            if (cwatches != null) {
-                if (watchers == null) {
-                    watchers = cwatches;
-                } else {
-                    watchers.addAll(cwatches);
-                }
-            }
-            break;
-        default:
-            String msg = ""Unhandled watch event type "" + event.getType();
-            LOG.error(msg);
-            throw new RuntimeException(msg);
-        }
-
-        if (watchers != null) {
-            for (Watcher watcher : watchers) {
-                watcher.process(event);
             }
         }
     }
@@ -257,19 +266,19 @@
 
     volatile States state;
 
-    ClientCnxn cnxn;
+    protected ClientCnxn cnxn;
 
     public ZooKeeper(String host, int sessionTimeout, Watcher watcher)
             throws IOException {
         this.defaultWatcher = watcher;
-        cnxn = new ClientCnxn(host, sessionTimeout, this);
+        cnxn = new ClientCnxn(host, sessionTimeout, this, new ZKWatcher());
     }
 
     public ZooKeeper(String host, int sessionTimeout, Watcher watcher,
             long sessionId, byte[] sessionPasswd) throws IOException {
         this.defaultWatcher = watcher;
-        cnxn = new ClientCnxn(host, sessionTimeout, this, sessionId,
-                sessionPasswd);
+        cnxn = new ClientCnxn(host, sessionTimeout, this, new ZKWatcher(),
+                sessionId, sessionPasswd);
     }
 
     /**
@@ -291,10 +300,6 @@
         cnxn.addAuthInfo(scheme, auth);
     }
 
-    public String describeCNXN() {
-        return cnxn.toString();
-    }
-
     public synchronized void register(Watcher watcher) {
         this.defaultWatcher = watcher;
     }
@@ -935,13 +940,4 @@
     public States getState() {
         return state;
     }
-
-    // Everything below this line is for testing!
-
-    /** Testing only!!! Really this needs to be moved into a stub in the
-     * tests - pending JIRA for that.
-     */
-    public void disconnect() throws IOException {
-        cnxn.disconnect();
-    }
 }
"
zookeeper,e3e0db789177a2e77882545dbdd9eed9a23eb392," ZOOKEEPER-63. Race condition in client close() operation. (phunt via breed)",2008.08.28 08:36:40,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 7ab6b61..d312338 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -34,11 +34,10 @@
 import java.util.Set;
 import java.util.concurrent.LinkedBlockingQueue;
 
-import org.apache.log4j.Logger;
-
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.BinaryOutputArchive;
 import org.apache.jute.Record;
+import org.apache.log4j.Logger;
 import org.apache.zookeeper.AsyncCallback.ACLCallback;
 import org.apache.zookeeper.AsyncCallback.ChildrenCallback;
 import org.apache.zookeeper.AsyncCallback.DataCallback;
@@ -63,7 +62,6 @@
 import org.apache.zookeeper.proto.SetDataResponse;
 import org.apache.zookeeper.proto.WatcherEvent;
 import org.apache.zookeeper.server.ByteBufferInputStream;
-import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.server.ZooTrace;
 
 /**
@@ -75,7 +73,8 @@
 class ClientCnxn {
     private static final Logger LOG = Logger.getLogger(ClientCnxn.class);
 
-    private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
+    private ArrayList<InetSocketAddress> serverAddrs =
+        new ArrayList<InetSocketAddress>();
 
     static class AuthData {
         AuthData(String scheme, byte data[]) {
@@ -122,6 +121,12 @@
     final EventThread eventThread;
 
     final Selector selector = Selector.open();
+    
+    /** Set to true when close is called. Latches the connection such that
+     * we don't attempt to re-connect to the server if in the middle of
+     * closing the connection (client sends session disconnect to server
+     * as part of close operation) */
+    volatile boolean closing = false;
 
     public long getSessionId() {
         return sessionId;
@@ -253,7 +258,7 @@
 
     class EventThread extends Thread {
         EventThread() {
-            super(""EventThread"");
+            super(currentThread().getName() + ""-EventThread"");
             setUncaughtExceptionHandler(uncaughtExceptionHandler);
             setDaemon(true);
         }
@@ -341,7 +346,10 @@
                     }
                 }
             } catch (InterruptedException e) {
+                LOG.warn(""Event thread exiting due to interruption"", e);
             }
+            
+            LOG.info(""EventThread shut down"");
         }
     }
 
@@ -566,7 +574,7 @@
         }
 
         SendThread() {
-            super(""SendThread"");
+            super(currentThread().getName() + ""-SendThread"");
             zooKeeper.state = States.CONNECTING;
             setUncaughtExceptionHandler(uncaughtExceptionHandler);
             setDaemon(true);
@@ -666,6 +674,10 @@
             while (zooKeeper.state.isAlive()) {
                 try {
                     if (sockKey == null) {
+                        // don't re-establish connection if we are closing
+                        if (closing) {
+                            break;
+                        }
                         startConnect();
                         lastSend = now;
                         lastHeard = now;
@@ -730,21 +742,34 @@
                     }
                     selected.clear();
                 } catch (Exception e) {
-                    LOG.warn(""Closing session 0x"" 
-                            + Long.toHexString(getSessionId()),
-                            e);
-                    cleanup();
-                    if (zooKeeper.state.isAlive()) {
-                        waitingEvents.add(new WatcherEvent(Event.EventNone,
-                                Event.KeeperStateDisconnected, null));
+                    if (closing) {
+                        // closing so this is expected
+                        LOG.info(""Exception while closing send thread for session 0x"" 
+                                + Long.toHexString(getSessionId())
+                                + "" : "" + e.getMessage());
+                        break;
+                    } else {
+                        LOG.warn(""Exception closing session 0x"" 
+                                + Long.toHexString(getSessionId()),
+                                e);
+                        cleanup();
+                        if (zooKeeper.state.isAlive()) {
+                            waitingEvents.add(new WatcherEvent(Event.EventNone,
+                                    Event.KeeperStateDisconnected, null));
+                        }
+    
+                        now = System.currentTimeMillis();
+                        lastHeard = now;
+                        lastSend = now;
                     }
-
-                    now = System.currentTimeMillis();
-                    lastHeard = now;
-                    lastSend = now;
                 }
             }
             cleanup();
+            try {
+                selector.close();
+            } catch (IOException e) {
+                LOG.warn(""Ignoring exception during selector close"", e);
+            }
             ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
                                      ""SendThread exitedloop."");
         }
@@ -755,25 +780,29 @@
                 sockKey.cancel();
                 try {
                     sock.socket().shutdownInput();
-                } catch (IOException e2) {
+                } catch (IOException e) {
+                    LOG.warn(""Ignoring exception during shutdown input"", e);
                 }
                 try {
                     sock.socket().shutdownOutput();
-                } catch (IOException e2) {
+                } catch (IOException e) {
+                    LOG.warn(""Ignoring exception during shutdown output"", e);
                 }
                 try {
                     sock.socket().close();
-                } catch (IOException e1) {
+                } catch (IOException e) {
+                    LOG.warn(""Ignoring exception during socket close"", e);
                 }
                 try {
                     sock.close();
-                } catch (IOException e1) {
+                } catch (IOException e) {
+                    LOG.warn(""Ignoring exception during channel close"", e);
                 }
             }
             try {
                 Thread.sleep(100);
-            } catch (InterruptedException e1) {
-                e1.printStackTrace();
+            } catch (InterruptedException e) {
+                LOG.warn(""SendThread interrupted during sleep, ignoring"");
             }
             sockKey = null;
             synchronized (pendingQueue) {
@@ -798,15 +827,44 @@
         }
     }
 
-    @SuppressWarnings(""unchecked"")
-    public void close() throws IOException {
-        LOG.info(""Closing ClientCnxn for session: 0x"" 
+    /**
+     * Shutdown the send/event threads. This method should not be called
+     * directly - rather it should be called as part of close operation. This
+     * method is primarily here to allow the tests to verify disconnection
+     * behavior.
+     */
+    public void disconnect() {
+        LOG.info(""Disconnecting ClientCnxn for session: 0x"" 
                 + Long.toHexString(getSessionId()));
 
         sendThread.close();
         waitingEvents.add(eventOfDeath);
     }
 
+    /**
+     * Close the connection, which includes; send session disconnect to
+     * the server, shutdown the send/event threads.
+     * 
+     * @throws IOException
+     */
+    public void close() throws IOException {
+        LOG.info(""Closing ClientCnxn for session: 0x"" 
+                + Long.toHexString(getSessionId()));
+
+        closing = true;
+        
+        try {
+            RequestHeader h = new RequestHeader();
+            h.setType(ZooDefs.OpCode.closeSession);
+            
+            submitRequest(h, null, null, null);
+        } catch (InterruptedException e) {
+            // ignore, close the send/event threads
+        } finally {
+            disconnect();
+        }
+    }
+
     private int xid = 1;
 
     synchronized private int getXid() {
"
zookeeper,e3e0db789177a2e77882545dbdd9eed9a23eb392," ZOOKEEPER-63. Race condition in client close() operation. (phunt via breed)",2008.08.28 08:36:40,Benjamin Reed,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index b83f4bb..b8e7e00 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -312,9 +312,6 @@
     public synchronized void close() throws InterruptedException {
         LOG.info(""Closing session: 0x"" + Long.toHexString(getSessionId()));
 
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.closeSession);
-        cnxn.submitRequest(h, null, null, null);
         try {
             cnxn.close();
         } catch (IOException e) {
@@ -940,7 +937,10 @@
 
     // Everything below this line is for testing!
 
+    /** Testing only!!! Really this needs to be moved into a stub in the
+     * tests - pending JIRA for that.
+     */
     public void disconnect() throws IOException {
-        cnxn.close();
+        cnxn.disconnect();
     }
 }
"
zookeeper,3a6a4ba7fc538f066d7b691777320fb9b92a5f93,ZOOKEEPER-2. Fix synchronization issues in QuorumPeer and FastLeader election. (Flavio Paiva Junqueira via mahadev),2008.08.26 06:13:01,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
index b8a05e8..0eb8664 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/AuthFastLeaderElection.java
@@ -264,11 +264,13 @@
                         break;
                     }
 
+                    Vote current = self.getCurrentVote();
+
                     switch (type) {
                     case 0:
                         // Receive challenge request
                         ToSend c = new ToSend(ToSend.mType.challenge, tag,
-                                self.currentVote.id, self.currentVote.zxid,
+                                current.id, current.zxid,
                                 logicalclock, self.getPeerState(),
                                 (InetSocketAddress) responsePacket
                                         .getSocketAddress());
@@ -309,8 +311,8 @@
                                     recvqueue.offer(n);
 
                                     ToSend a = new ToSend(ToSend.mType.ack,
-                                            tag, self.currentVote.id,
-                                            self.currentVote.zxid,
+                                            tag, current.id,
+                                            current.zxid,
                                             logicalclock, self.getPeerState(),
                                             (InetSocketAddress) addr);
 
@@ -328,7 +330,7 @@
                             recvqueue.offer(n);
 
                             ToSend a = new ToSend(ToSend.mType.ack, tag,
-                                    self.currentVote.id, self.currentVote.zxid,
+                                    current.id, current.zxid,
                                     logicalclock, self.getPeerState(),
                                     (InetSocketAddress) responsePacket
                                             .getSocketAddress());
@@ -685,7 +687,7 @@
 
     QuorumPeer self;
     int port;
-    long logicalclock; /* Election instance */
+    volatile long logicalclock; /* Election instance */
     DatagramSocket mySocket;
     long proposedLeader;
     long proposedZxid;
"
zookeeper,3a6a4ba7fc538f066d7b691777320fb9b92a5f93,ZOOKEEPER-2. Fix synchronization issues in QuorumPeer and FastLeader election. (Flavio Paiva Junqueira via mahadev),2008.08.26 06:13:01,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
index c929557..20a4c34 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java
@@ -49,26 +49,36 @@
 	/* Sequence numbers for messages */
     static int sequencer = 0;
 
-    /*
+    /**
      * Determine how much time a process has to wait
      * once it believes that it has reached the end of
      * leader election.
      */
     static int finalizeWait = 100;
 
-    /*
+    /**
 	 * Challenge counter to avoid replay attacks
 	 */
 	
 	static int challengeCounter = 0;
 	
     
-	/*
-	 * Connection manager
+	/**
+	 * Connection manager. Fast leader election uses TCP for 
+	 * communication between peers, and QuorumCnxManager manages
+	 * such connections. 
 	 */
 	
 	QuorumCnxManager manager;
 
+	
+	/**
+	 * Notifications are messages that let other peers know that
+	 * a given peer has changed its vote, either because it has
+	 * joined leader election or because it learned of another 
+	 * peer with higher zxid or same zxid and higher server id
+	 */
+	
     static public class Notification {
         /*
          * Proposed leader
@@ -96,8 +106,10 @@
         InetAddress addr;
     }
 
-    /*
-     * Messages to send, both Notifications and Acks
+    /**
+     * Messages that a peer wants to send to other peers.
+     * These messages can be both Notifications and Acks
+     * of reception of notification.
      */
     static public class ToSend {
     	static enum mType {crequest, challenge, notification, ack};
@@ -145,12 +157,24 @@
     LinkedBlockingQueue<ToSend> sendqueue;
     LinkedBlockingQueue<Notification> recvqueue;
 
+    /**
+     * Multi-threaded implementation of message handler. Messenger
+     * implements two sub-classes: WorkReceiver and  WorkSender. The
+     * functionality of each is obvious from the name. Each of these
+     * spawns a new thread.
+     */
+    
     private class Messenger {
     	
         long lastProposedLeader;
         long lastProposedZxid;
         long lastEpoch;
         
+        /**
+         * Receives messages from instance of QuorumCnxManager on
+         * method run(), and processes such messages.
+         */
+        
         class WorkerReceiver implements Runnable {
 
         	QuorumCnxManager manager;
@@ -175,7 +199,7 @@
             			}
             			response.buffer.clear();
                
-
+            			// State of peer that sent this message
             			QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;
             			switch (response.buffer.getInt()) {
             			case 0:
@@ -189,6 +213,7 @@
             				break;
             			}
                     	
+            			// Instantiate Notification and set its attributes
             			Notification n = new Notification();
             			n.leader = response.buffer.getLong();
             			n.zxid = response.buffer.getLong();
@@ -196,6 +221,12 @@
             			n.state = ackstate;
             			n.addr = response.addr;
 
+            			/*
+            			 * Accept the values of this notification
+            			 * if we are at right epoch and the new notification
+            			 * contains a vote that succeeds our current vote
+            			 * in our order of votes.
+            			 */
             			if ((messenger.lastEpoch <= n.epoch)
             					&& ((n.zxid > messenger.lastProposedZxid) 
             					|| ((n.zxid == messenger.lastProposedZxid) 
@@ -205,10 +236,18 @@
             				messenger.lastEpoch = n.epoch;
             			}
 
-            			//InetAddress addr = (InetAddress) responsePacket.getSocketAddress();
+            			/*
+            			 * If this server is looking, then send proposed leader
+            			 */
+
             			if(self.getPeerState() == QuorumPeer.ServerState.LOOKING){
             				recvqueue.offer(n);
-            				if(recvqueue.size() == 0) LOG.warn(""Message: "" + n.addr);
+            				if(recvqueue.size() == 0) LOG.debug(""Message: "" + n.addr);
+            				/*
+            				 * Send a notification back if the peer that sent this
+            				 * message is also looking and its logical clock is 
+            				 * lagging behind.
+            				 */
             				if((ackstate == QuorumPeer.ServerState.LOOKING)
             						&& (n.epoch < logicalclock)){
             					ToSend notmsg = new ToSend(ToSend.mType.notification, 
@@ -219,16 +258,21 @@
                 						response.addr);
                 				sendqueue.offer(notmsg);
             				}
-            			} else { 	           				
-            				if((ackstate == QuorumPeer.ServerState.LOOKING) &&
-            						(self.getPeerState() != QuorumPeer.ServerState.LOOKING)){
-            					ToSend notmsg = new ToSend(ToSend.mType.notification, 
-            						self.currentVote.id, 
-            						self.currentVote.zxid,
-            						logicalclock,
-            						self.getPeerState(),
-            						response.addr);
-            					sendqueue.offer(notmsg);
+            			} else {
+            			    /*
+            			     * If this server is not looking, but the one that sent the ack
+            			     * is looking, then send back what it believes to be the leader.
+            			     */
+            			    Vote current = self.getCurrentVote();
+            			    if(ackstate == QuorumPeer.ServerState.LOOKING){
+
+            			        ToSend notmsg = new ToSend(ToSend.mType.notification, 
+            			                current.id, 
+            			                current.zxid,
+            			                logicalclock,
+            			                self.getPeerState(),
+            			                response.addr);
+            			        sendqueue.offer(notmsg);
             				}
             			}
             			
@@ -240,6 +284,12 @@
             }
         }
 
+        
+        /**
+         * This worker simply dequeues a message to send and
+         * and queues it on the manager's queue. 
+         */
+        
         class WorkerSender implements Runnable {
         	
             QuorumCnxManager manager;
@@ -260,6 +310,11 @@
                 }
             }
 
+            /**
+             * Called by run() once there is a new message to send.
+             * 
+             * @param m     message to send
+             */
             private void process(ToSend m) {
                 byte requestBytes[] = new byte[28];
                 ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);  
@@ -279,10 +334,18 @@
             }
         }
 
+        /**
+         * Test if both send and receive queues are empty.
+         */
         public boolean queueEmpty() {
             return (sendqueue.isEmpty() || recvqueue.isEmpty());
         }
 
+        /**
+         * Constructor of class Messenger.
+         * 
+         * @param manager   Connection manager
+         */
         Messenger(QuorumCnxManager manager) {
             lastProposedLeader = 0;
             lastProposedZxid = 0;
@@ -303,17 +366,36 @@
 
     QuorumPeer self;
     int port;
-    long logicalclock; /* Election instance */
+    volatile long logicalclock; /* Election instance */
     Messenger messenger;
     long proposedLeader;
     long proposedZxid;
 
-        
+    
+    /**
+     * Constructor of FastLeaderElection. It takes two parameters, one
+     * is the QuorumPeer object that instantiated this object, and the other
+     * is the connection manager. Such an object should be created only once 
+     * by each peer during an instance of the ZooKeeper service.
+     * 
+     * @param self  QuorumPeer that created this object
+     * @param manager   Connection manager
+     */
     public FastLeaderElection(QuorumPeer self, QuorumCnxManager manager){
     	this.manager = manager;
     	starter(self, manager);
     }
     
+    /**
+     * This method is invoked by the constructor. Because it is a
+     * part of the starting procedure of the object that must be on
+     * any constructor of this class, it is probably best to keep as
+     * a separate method. As we have a single constructor currently, 
+     * it is not strictly necessary to have it separate.
+     * 
+     * @param self      QuorumPeer that created this object
+     * @param manager   Connection manager   
+     */
     private void starter(QuorumPeer self, QuorumCnxManager manager) {
         this.self = self;
         proposedLeader = -1;
@@ -328,6 +410,7 @@
         recvqueue.clear();
     }
 
+    
     public static class ElectionResult {
         public Vote vote;
 
@@ -338,6 +421,9 @@
         public int winningCount;
     }
 
+    /**
+     * Send notifications to all peers upon a change in our vote
+     */
     private void sendNotifications() {
         for (QuorumServer server : self.quorumPeers) {
             InetAddress saddr = server.addr.getAddress();
@@ -353,6 +439,13 @@
         }
     }
 
+    /**
+     * Check if a pair (server id, zxid) succeeds our
+     * current vote.
+     * 
+     * @param id    Server identifier
+     * @param zxid  Last zxid observed by the issuer of this vote
+     */
     private boolean totalOrderPredicate(long id, long zxid) {
         if ((zxid > proposedZxid)
                 || ((zxid == proposedZxid) && (id > proposedLeader)))
@@ -362,6 +455,14 @@
 
     }
 
+    /**
+     * Termination predicate. Given a set of votes, determines if
+     * have sufficient to declare the end of the election round.
+     * 
+     *  @param votes    Set of votes
+     *  @param l        Identifier of the vote received last
+     *  @param zxid     zxid of the the vote received last
+     */
     private boolean termPredicate(
             HashMap<InetAddress, Vote> votes, long l,
             long zxid) {
@@ -384,6 +485,11 @@
 
     }
 
+    /**
+     * Starts a new round of leader election. Whenever our QuorumPeer 
+     * changes its state to LOOKING, this method is invoked, and it 
+     * sends notifications to al other peers.
+     */
     public Vote lookForLeader() throws InterruptedException {
         HashMap<InetAddress, Vote> recvset = new HashMap<InetAddress, Vote>();
 
@@ -394,7 +500,7 @@
         proposedLeader = self.getId();
         proposedZxid = self.getLastLoggedZxid();
 
-        LOG.warn(""Election tally: "" + proposedZxid);
+        LOG.warn(""New election: "" + proposedZxid);
         sendNotifications();
 
         /*
@@ -449,7 +555,7 @@
 
                 } else if (termPredicate(recvset, proposedLeader, proposedZxid)) {
                     //Otherwise, wait for a fixed amount of time
-                    LOG.warn(""Passed predicate"");
+                    LOG.debug(""Passed predicate"");
                     Thread.sleep(finalizeWait);
 
                     // Verify if there is any change in the proposed leader
"
zookeeper,3a6a4ba7fc538f066d7b691777320fb9b92a5f93,ZOOKEEPER-2. Fix synchronization issues in QuorumPeer and FastLeader election. (Flavio Paiva Junqueira via mahadev),2008.08.26 06:13:01,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index a681f80..9b5539a 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -114,15 +114,16 @@
     void followLeader() throws InterruptedException {
         InetSocketAddress addr = null;
         // Find the leader by id
+        Vote current = self.getCurrentVote();
         for (QuorumServer s : self.quorumPeers) {
-            if (s.id == self.currentVote.id) {
+            if (s.id == current.id) {
                 addr = s.addr;
                 break;
             }
         }
         if (addr == null) {
             LOG.warn(""Couldn't find the leader with id = ""
-                    + self.currentVote.id);
+                    + current.id);
         }
         LOG.info(""Following "" + addr);
         sock = new Socket();
"
zookeeper,3a6a4ba7fc538f066d7b691777320fb9b92a5f93,ZOOKEEPER-2. Fix synchronization issues in QuorumPeer and FastLeader election. (Flavio Paiva Junqueira via mahadev),2008.08.26 06:13:01,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
index 5bb22f3..f7ace4f 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LeaderElection.java
@@ -100,7 +100,7 @@
     }
 
     public Vote lookForLeader() throws InterruptedException {
-        self.currentVote = new Vote(self.getId(), self.getLastLoggedZxid());
+        self.setCurrentVote(new Vote(self.getId(), self.getLastLoggedZxid()));
         // We are going to look for a leader by casting a vote for ourself
         byte requestBytes[] = new byte[4];
         ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);
@@ -161,16 +161,17 @@
             }
             ElectionResult result = countVotes(votes);
             if (result.winner.id >= 0) {
-                self.currentVote = result.vote;
+                self.setCurrentVote(result.vote);
                 if (result.winningCount > (self.quorumPeers.size() / 2)) {
-                    self.currentVote = result.winner;
+                    self.setCurrentVote(result.winner);
                     s.close();
-                    self.setPeerState((self.currentVote.id == self.getId()) 
+                    Vote current = self.getCurrentVote();
+                    self.setPeerState((current.id == self.getId()) 
                             ? ServerState.LEADING: ServerState.FOLLOWING);
                     if (self.getPeerState() == ServerState.FOLLOWING) {
                         Thread.sleep(100);
                     }
-                    return self.currentVote;
+                    return current;
                 }
             }
             Thread.sleep(1000);
"
zookeeper,3a6a4ba7fc538f066d7b691777320fb9b92a5f93,ZOOKEEPER-2. Fix synchronization issues in QuorumPeer and FastLeader election. (Flavio Paiva Junqueira via mahadev),2008.08.26 06:13:01,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
index ad4a3f4..9f7635b 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
@@ -493,6 +493,8 @@
             this.addr = channel.socket().getInetAddress();
             this.channel = channel;
             recvWorker = null;
+            
+            LOG.debug(""Address of remote peer: "" + this.addr);
         }
 
         void setRecv(RecvWorker recvWorker) {
"
zookeeper,3a6a4ba7fc538f066d7b691777320fb9b92a5f93,ZOOKEEPER-2. Fix synchronization issues in QuorumPeer and FastLeader election. (Flavio Paiva Junqueira via mahadev),2008.08.26 06:13:01,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
index 2f66e01..ebff8bb 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
@@ -111,7 +111,15 @@
     /**
      * This is who I think the leader currently is.
      */
-    volatile Vote currentVote;
+    volatile private Vote currentVote;
+        
+    public synchronized Vote getCurrentVote(){
+        return currentVote;
+    }
+       
+    public synchronized void setCurrentVote(Vote v){
+        currentVote = v;
+    }    
 
     volatile boolean running = true;
 
@@ -167,10 +175,11 @@
                         responseBuffer.clear();
                         responseBuffer.getInt(); // Skip the xid
                         responseBuffer.putLong(myid);
-                        switch (state) {
+                        Vote current = getCurrentVote();
+                        switch (getPeerState()) {
                         case LOOKING:
-                            responseBuffer.putLong(currentVote.id);
-                            responseBuffer.putLong(currentVote.zxid);
+                            responseBuffer.putLong(current.id);
+                            responseBuffer.putLong(current.zxid);
                             break;
                         case LEADING:
                             responseBuffer.putLong(myid);
@@ -182,7 +191,7 @@
                             }
                             break;
                         case FOLLOWING:
-                            responseBuffer.putLong(currentVote.id);
+                            responseBuffer.putLong(current.id);
                             try {
                                 responseBuffer.putLong(follower.getZxid());
                             } catch (NullPointerException npe) {
@@ -205,11 +214,11 @@
 
     private ServerState state = ServerState.LOOKING;
 
-    public void setPeerState(ServerState newState){
+    public synchronized void setPeerState(ServerState newState){
         state=newState;
     }
 
-    public ServerState getPeerState(){
+    public synchronized ServerState getPeerState(){
         return state;
     }
 
@@ -364,14 +373,14 @@
          * Main loop
          */
         while (running) {
-            switch (state) {
+            switch (getPeerState()) {
             case LOOKING:
                 try {
                     LOG.info(""LOOKING"");
-                    currentVote = makeLEStrategy().lookForLeader();
+                    setCurrentVote(makeLEStrategy().lookForLeader());
                 } catch (Exception e) {
                     LOG.warn(""Unexpected exception"",e);
-                    state = ServerState.LOOKING;
+                    setPeerState(ServerState.LOOKING);
                 }
                 break;
             case FOLLOWING:
@@ -384,7 +393,7 @@
                 } finally {
                     follower.shutdown();
                     setFollower(null);
-                    state = ServerState.LOOKING;
+                    setPeerState(ServerState.LOOKING);
                 }
                 break;
             case LEADING:
@@ -400,7 +409,7 @@
                         leader.shutdown(""Forcing shutdown"");
                         setLeader(null);
                     }
-                    state = ServerState.LOOKING;
+                    setPeerState(ServerState.LOOKING);
                 }
                 break;
             }
@@ -504,7 +513,7 @@
     }
 
     public String getServerState() {
-        switch (state) {
+        switch (getPeerState()) {
         case LOOKING:
             return QuorumStats.Provider.LOOKING_STATE;
         case LEADING:
"
zookeeper,92c538d4d830d61fcaa4346c356e63d8f23bd2f3,ZOOKEEPER-123. Fix  the wrong class specified for the logger. (Jakob Homan via mahadev),2008.08.26 03:16:45,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ClientCnxn.java b/src/java/main/org/apache/zookeeper/ClientCnxn.java
index 8298c42..7ab6b61 100644
--- a/src/java/main/org/apache/zookeeper/ClientCnxn.java
+++ b/src/java/main/org/apache/zookeeper/ClientCnxn.java
@@ -73,7 +73,7 @@
  *
  */
 class ClientCnxn {
-    private static final Logger LOG = Logger.getLogger(ZooKeeperServer.class);
+    private static final Logger LOG = Logger.getLogger(ClientCnxn.class);
 
     private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
 
"
zookeeper,a07a03d70b56ab26f4a790ef1e9941a06b478b84,ZOOKEEPER-122. Fix  NPE in jute's Utils.toCSVString. (Anthony Urso via mahadev),2008.08.20 02:58:30,Mahadev Konar,"diff --git a/src/java/main/org/apache/jute/Utils.java b/src/java/main/org/apache/jute/Utils.java
index b7eeac1..7dae860 100644
--- a/src/java/main/org/apache/jute/Utils.java
+++ b/src/java/main/org/apache/jute/Utils.java
@@ -124,8 +124,10 @@
      * @param s 
      * @return 
      */
-    static String toCSVString(String t) {
-        String s = t.toString();
+    static String toCSVString(String s) {
+        if (s == null)
+            return """";
+
         StringBuffer sb = new StringBuffer(s.length()+1);
         sb.append('\'');
         int len = s.length();
"
zookeeper,8a22ee2a08d3d00a2085459c5f1941648a12ec98,ZOOKEEPER-108. Fix sync operation reordering on a Quorum. (Flavio Paiva Junqueira via mahadev),2008.08.08 05:34:41,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
index 0f9c436..9dc7331 100644
--- a/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java
@@ -158,6 +158,7 @@
                 err = rc.err;
                 break;
             case OpCode.sync:
+                LOG.debug(""OpCode.sync "" + request);
                 SyncRequest syncRequest = new SyncRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         syncRequest);
"
zookeeper,8a22ee2a08d3d00a2085459c5f1941648a12ec98,ZOOKEEPER-108. Fix sync operation reordering on a Quorum. (Flavio Paiva Junqueira via mahadev),2008.08.08 05:34:41,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
index 0b610b8..949861c 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java
@@ -47,11 +47,6 @@
      */
     LinkedList<Request> committedRequests = new LinkedList<Request>();
 
-    /*
-     * Pending sync requests
-     */
-    LinkedList<Request> pendingSyncs = new LinkedList<Request>();
-
     RequestProcessor nextProcessor;
 
     public CommitProcessor(RequestProcessor nextProcessor) {
@@ -127,7 +122,7 @@
                             break;
                         case OpCode.sync:
                             nextPending = request;
-                            pendingSyncs.add(request);
+                            //pendingSyncs.add(request);
                             break;
                         default:
                             toProcess.add(request);
@@ -149,6 +144,7 @@
                          new Exception(""committing a null! ""));
                 return;
             }
+            LOG.debug(""Committing"" + request.cxid);
             committedRequests.add(request);
             notifyAll();
         }
"
zookeeper,8a22ee2a08d3d00a2085459c5f1941648a12ec98,ZOOKEEPER-108. Fix sync operation reordering on a Quorum. (Flavio Paiva Junqueira via mahadev),2008.08.08 05:34:41,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
index 7422a1e..8e59ab2 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerRequestProcessor.java
@@ -64,10 +64,11 @@
                 // the response
                 nextProcessor.processRequest(request);
                 switch (request.type) {
+                case OpCode.sync:
+                    zks.pendingSyncs.add(request);
                 case OpCode.create:
                 case OpCode.delete:
                 case OpCode.setData:
-                case OpCode.sync:
                 case OpCode.setACL:
                 case OpCode.createSession:
                 case OpCode.closeSession:
"
zookeeper,8a22ee2a08d3d00a2085459c5f1941648a12ec98,ZOOKEEPER-108. Fix sync operation reordering on a Quorum. (Flavio Paiva Junqueira via mahadev),2008.08.08 05:34:41,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
index a621af1..0d93ebf 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java
@@ -22,6 +22,7 @@
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 import org.apache.log4j.Logger;
 
@@ -50,6 +51,11 @@
 
     SyncRequestProcessor syncProcessor;
 
+    /*
+     * Pending sync requests
+     */
+    ConcurrentLinkedQueue<Request> pendingSyncs;
+    
     /**
      * @param port
      * @param dataDir
@@ -59,6 +65,7 @@
             QuorumPeer self,DataTreeBuilder treeBuilder) throws IOException {
         super(dataDir, dataLogDir, self.tickTime,treeBuilder);
         this.self = self;
+        this.pendingSyncs = new ConcurrentLinkedQueue<Request>();
     }
 
     public Follower getFollower(){
@@ -131,12 +138,12 @@
     }
     
     public void sync(){
-        if(commitProcessor.pendingSyncs.size() ==0){
+        if(pendingSyncs.size() ==0){
             LOG.warn(""Not expecting a sync."");
             return;
         }
                 
-        commitProcessor.commit(commitProcessor.pendingSyncs.remove());
+        commitProcessor.commit(pendingSyncs.remove());
     }
              
          
"
zookeeper,8a22ee2a08d3d00a2085459c5f1941648a12ec98,ZOOKEEPER-108. Fix sync operation reordering on a Quorum. (Flavio Paiva Junqueira via mahadev),2008.08.08 05:34:41,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index 7da0450..6bc2c86 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -373,6 +373,11 @@
                         }
                         commit(zxid);
                         zk.commitProcessor.commit(p.request);
+                        if(pendingSyncs.containsKey(zxid)){
+                            sendSync(syncHandler.get(pendingSyncs.get(zxid).sessionId), pendingSyncs.get(zxid));
+                            syncHandler.remove(pendingSyncs.get(zxid));
+                            pendingSyncs.remove(zxid);
+                        }
                     }
                 }
                 return;
@@ -462,12 +467,6 @@
         lastCommitted = zxid;
         QuorumPacket qp = new QuorumPacket(Leader.COMMIT, zxid, null, null);
         sendPacket(qp);
-               
-        if(pendingSyncs.containsKey(zxid)){
-            sendSync(syncHandler.get(pendingSyncs.get(zxid).sessionId), pendingSyncs.get(zxid));
-            syncHandler.remove(pendingSyncs.get(zxid));
-            pendingSyncs.remove(zxid);
-        }
     }
 
     long lastProposed;
@@ -544,8 +543,14 @@
      */
             
     public void sendSync(FollowerHandler f, Request r){
-        QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);
-        f.queuePacket(qp);
+        if(f != null){
+            QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);
+            f.queuePacket(qp);
+        }
+        else{
+            LOG.warn(""Committing sync: "" + r.cxid );
+            zk.commitProcessor.commit(r);
+        }
     }
                 
     /**
"
zookeeper,8a22ee2a08d3d00a2085459c5f1941648a12ec98,ZOOKEEPER-108. Fix sync operation reordering on a Quorum. (Flavio Paiva Junqueira via mahadev),2008.08.08 05:34:41,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java
index 44fda9f..6efa221 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java
@@ -48,14 +48,22 @@
         // request.addRQRec("">prop"");
                 
         
+        /* In the following IF-THEN-ELSE block, we process syncs on the leader. 
+         * If the sync is coming from a follower, then the follower
+         * handler adds it to syncHandler. Otherwise, if it is a client of
+         * the leader that issued the sync command, then syncHandler won't 
+         * contain the handler. In this case, we add it to syncHandler, and 
+         * call processRequest on the next processor.
+         */
+        
         if(request.type == ZooDefs.OpCode.sync){
-            if(zks.getLeader().syncHandler.containsKey(request.sessionId)){
-                zks.getLeader().processSync(request);
-            }
-            else{
+            zks.getLeader().processSync(request);
+
+            if(!zks.getLeader().syncHandler.containsKey(request.sessionId)){
+                zks.getLeader().syncHandler.put(request.sessionId, null);
                 nextProcessor.processRequest(request);
-                zks.commitProcessor.commit(request);
             }
+            
         }
         else{
             nextProcessor.processRequest(request);
"
zookeeper,3740b7c730e6e4ccccd78c35694689292bca4ddb,Fixed ZOOKEEPER-48 - auth_id now handled correctly when no auth ids present,2008.08.01 05:10:24,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index c8489a9..23d1d72 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -417,7 +417,7 @@
                     LOG.error(""No authentication provider for scheme: ""
                             + scheme);
                 else
-                    LOG.error(""Authentication failed for scheme: ""
+                    LOG.debug(""Authentication failed for scheme: ""
                             + scheme);
                 // send a response...
                 ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
@@ -427,7 +427,7 @@
                 sendBuffer(NIOServerCnxn.closeConn);
                 disableRecv();
             } else {
-                LOG.error(""Authentication succeeded for scheme: ""
+                LOG.debug(""Authentication succeeded for scheme: ""
                         + scheme);
                 ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
                         KeeperException.Code.Ok);
"
zookeeper,3740b7c730e6e4ccccd78c35694689292bca4ddb,Fixed ZOOKEEPER-48 - auth_id now handled correctly when no auth ids present,2008.08.01 05:10:24,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
index 66ff5c4..1757687 100644
--- a/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
+++ b/src/java/main/org/apache/zookeeper/server/PrepRequestProcessor.java
@@ -65,6 +65,9 @@
     static boolean skipACL;
     static {
         skipACL = System.getProperty(""zookeeper.skipACL"", ""no"").equals(""yes"");
+        if (skipACL) {
+            LOG.info(""zookeeper.skipACL==\""yes\"", ACL checks will be skipped"");
+        }
     }
 
     LinkedBlockingQueue<Request> submittedRequests = new LinkedBlockingQueue<Request>();
@@ -291,11 +294,11 @@
                         .getNextZxid(), zks.getTime(), OpCode.setACL);
                 zks.sessionTracker.checkSession(request.sessionId);
                 SetACLRequest setAclRequest = new SetACLRequest();
+                ZooKeeperServer.byteBuffer2Record(request.request,
+                        setAclRequest);
                 if (!fixupACL(request.authInfo, setAclRequest.getAcl())) {
                     throw new KeeperException.InvalidACLException();
                 }
-                ZooKeeperServer.byteBuffer2Record(request.request,
-                        setAclRequest);
                 path = setAclRequest.getPath();
                 nodeRecord = getRecordForPath(path);
                 checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN,
@@ -382,6 +385,9 @@
     }
 
     /**
+     * This method checks out the acl making sure it isn't null or empty,
+     * it has valid schemes and ids, and expanding any relative ids that
+     * depend on the requestor's authentication information.
      *
      * @param authInfo list of ACL IDs associated with the client connection
      * @param acl list of ACLs being assigned to the node (create or setACL operation)
@@ -401,19 +407,26 @@
             Id id = a.getId();
             if (id.getScheme().equals(""world"") && id.getId().equals(""anyone"")) {
             } else if (id.getScheme().equals(""auth"")) {
+                // This is the ""auth"" id, so we have to expand it to the
+                // authenticated ids of the requestor
                 it.remove();
                 if (toAdd == null) {
                     toAdd = new LinkedList<ACL>();
                 }
+                boolean authIdValid = false;
                 for (Id cid : authInfo) {
                     AuthenticationProvider ap = ProviderRegistry.getProvider(cid.getScheme());
                     if (ap == null) {
                         LOG.error(""Missing AuthenticationProvider for ""
                                 + cid.getScheme());
                     } else if (ap.isAuthenticated()) {
+                        authIdValid = true;
                         toAdd.add(new ACL(a.getPerms(), cid));
                     }
                 }
+                if (!authIdValid) {
+                    return false;
+                }
             } else {
                 AuthenticationProvider ap = ProviderRegistry.getProvider(id
                         .getScheme());
@@ -430,7 +443,7 @@
                 acl.add(a);
             }
         }
-        return true;
+        return acl.size() > 0;
     }
 
     public void processRequest(Request request) {
"
zookeeper,774bda809bf4c17941eacddccf6298d57f1737a9,ZOOKEEPER-105. Catch Zookeeper exceptions and print on the stderr. (Anthony Urso via Mahadev),2008.07.29 03:19:53,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index f272119..606fa77 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -1036,45 +1036,51 @@
         String path = args[2];
         List<ACL> acl = Ids.OPEN_ACL_UNSAFE;
         System.out.println(""Processing "" + cmd);
-        if (cmd.equals(""create"") && args.length >= 4) {
-            if (args.length == 5) {
-                acl = parseACLs(args[4]);
-            }
-            String newPath = zooKeeper.create(path, args[3].getBytes(), acl, 0);
-            System.err.println(""Created "" + newPath);
-        } else if (cmd.equals(""delete"") && args.length >= 3) {
-            zooKeeper.delete(path, watch ? Integer.parseInt(args[3]) : -1);
-        } else if (cmd.equals(""set"") && args.length >= 4) {
-            stat = zooKeeper.setData(path, args[3].getBytes(),
-                    args.length > 4 ? Integer.parseInt(args[4]) : -1);
-            printStat(stat);
-        } else if (cmd.equals(""aget"") && args.length >= 3) {
-            zooKeeper.getData(path, watch, dataCallback, path);
-        } else if (cmd.equals(""get"") && args.length >= 3) {
-            byte data[] = zooKeeper.getData(path, watch, stat);
-            System.out.println(new String(data));
-            printStat(stat);
-        } else if (cmd.equals(""ls"") && args.length >= 3) {
-            List<String> children = zooKeeper.getChildren(path, watch);
-            System.out.println(children);
-        } else if (cmd.equals(""getAcl"") && args.length >= 2) {
-            acl = zooKeeper.getACL(path, stat);
-            for (ACL a : acl) {
-                System.out.println(a.getId() + "": ""
-                        + getPermString(a.getPerms()));
-            }
-        } else if (cmd.equals(""setAcl"") && args.length >= 4) {
+        try {
+            if (cmd.equals(""create"") && args.length >= 4) {
+                if (args.length == 5) {
+                    acl = parseACLs(args[4]);
+                }
+                String newPath = zooKeeper.create(path, args[3].getBytes(), acl, 0);
+                System.err.println(""Created "" + newPath);
+            } else if (cmd.equals(""delete"") && args.length >= 3) {
+                zooKeeper.delete(path, watch ? Integer.parseInt(args[3]) : -1);
+            } else if (cmd.equals(""set"") && args.length >= 4) {
+                stat = zooKeeper.setData(path, args[3].getBytes(),
+                        args.length > 4 ? Integer.parseInt(args[4]) : -1);
+                printStat(stat);
+            } else if (cmd.equals(""aget"") && args.length >= 3) {
+                zooKeeper.getData(path, watch, dataCallback, path);
+            } else if (cmd.equals(""get"") && args.length >= 3) {
+                byte data[] = zooKeeper.getData(path, watch, stat);
+                System.out.println(new String(data));
+                printStat(stat);
+            } else if (cmd.equals(""ls"") && args.length >= 3) {
+                List<String> children = zooKeeper.getChildren(path, watch);
+                System.out.println(children);
+            } else if (cmd.equals(""getAcl"") && args.length >= 2) {
+                acl = zooKeeper.getACL(path, stat);
+                for (ACL a : acl) {
+                    System.out.println(a.getId() + "": ""
+                            + getPermString(a.getPerms()));
+                }
+            } else if (cmd.equals(""setAcl"") && args.length >= 4) {
 
-            stat = zooKeeper.setACL(path, parseACLs(args[3]),
-                    args.length > 4 ? Integer.parseInt(args[4]) : -1);
-            printStat(stat);
-        } else if (cmd.equals(""stat"") && args.length >= 3) {
-            stat = zooKeeper.exists(path, watch);
-            printStat(stat);
-        } else {
-            usage();
-        }
-        return watch;
+                stat = zooKeeper.setACL(path, parseACLs(args[3]),
+                        args.length > 4 ? Integer.parseInt(args[4]) : -1);
+                printStat(stat);
+            } else if (cmd.equals(""stat"") && args.length >= 3) {
+                stat = zooKeeper.exists(path, watch);
+                printStat(stat);
+            } else {
+                usage();
+            }
+
+            return watch;
+        } catch (KeeperException e) {
+            System.err.println(e.getClass().getName() + "": "" + e.getMessage());
+            return false;
+	}
     }
 
     private static String getPermString(int perms) {
"
zookeeper,31d99a300ad9b0c66905333c7775321a58345ed6,"Fixed ZOOKEEPER-75, addressed some license issues and also removed the cobertura library (gpl). Moved from junit 4.1 to junit 4.4 at the same time (tests still pass).",2008.07.16 08:49:31,Patrick D. Hunt,"diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Election.java b/src/java/main/org/apache/zookeeper/server/quorum/Election.java
index 7bb6525..31531e8 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Election.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Election.java
@@ -1,3 +1,21 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package org.apache.zookeeper.server.quorum;
 
 
"
zookeeper,0da7e6a3a699284df263484496fa16ca0f67e32a,ZOOKEEPER-68. Fix command line parsing for zookeeper barebone java client for acls. (Jakob Homan via mahadev),2008.07.08 08:02:21,Mahadev Konar,"diff --git a/src/java/main/org/apache/zookeeper/ZooKeeper.java b/src/java/main/org/apache/zookeeper/ZooKeeper.java
index 291219b..f272119 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeper.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeper.java
@@ -1103,7 +1103,7 @@
         acl = new ArrayList<ACL>();
         for (String a : acls) {
             int firstColon = a.indexOf(':');
-            int lastColon = a.indexOf(':');
+            int lastColon = a.lastIndexOf(':');
             if (firstColon == -1 || lastColon == -1 || firstColon == lastColon) {
                 System.err
                         .println(a + "" does not have the form scheme:id:perm"");
"
