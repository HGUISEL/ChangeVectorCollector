<SOC>
                     int type = bb.getInt();
                     bb = bb.slice();
                     leader.zk.submitRequest(null, sessionId, type, cxid, bb,
-                            null);
+                            qp.getAuthinfo());
                     break;
                 default:
                 }
<EOC>
<SOC>
 				String struct_name = JVector.extractVectorName(jvType);
 				if (vectorStructs.get(struct_name) == null) {
 					vectorStructs.put(struct_name, struct_name);
-					h.write("struct " + struct_name + " {\n    int count;\n" + jv.getElementType().genCDecl("*data") + ";\n};\n");
+					h.write("struct " + struct_name + " {\n    int32_t count;\n" + jv.getElementType().genCDecl("*data") + ";\n};\n");
 					h.write("int serialize_" + struct_name + "(struct oarchive *out, const char *tag, struct " + struct_name + " *v);\n");
 					h.write("int deserialize_" + struct_name + "(struct iarchive *in, const char *tag, struct " + struct_name + " *v);\n");
-					h.write("int allocate_" + struct_name + "(struct " + struct_name + " *v, int len);\n");
+					h.write("int allocate_" + struct_name + "(struct " + struct_name + " *v, int32_t len);\n");
 					h.write("int deallocate_" + struct_name + "(struct " + struct_name + " *v);\n");
-					c.write("int allocate_" + struct_name + "(struct " + struct_name + " *v, int len) {\n");
+					c.write("int allocate_" + struct_name + "(struct " + struct_name + " *v, int32_t len) {\n");
 					c.write("    if (!len) {\n");
 					c.write("        v->count = 0;\n");
 					c.write("        v->data = 0;\n");

 					c.write("}\n");
 					c.write("int deallocate_" + struct_name + "(struct " + struct_name + " *v) {\n");
 					c.write("    if (v->data) {\n");
-					c.write("        int i;\n");
+					c.write("        int32_t i;\n");
 					c.write("        for(i=0;i<v->count; i++) {\n");
 					c.write("            deallocate_"+JRecord.extractMethodSuffix(jvType)+"(&v->data[i]);\n");
 					c.write("        }\n");

 					c.write("}\n");
 					c.write("int serialize_" + struct_name + "(struct oarchive *out, const char *tag, struct " + struct_name + " *v)\n");
 					c.write("{\n");
-					c.write("    int count = v->count;\n");
+					c.write("    int32_t count = v->count;\n");
 					c.write("    int rc = 0;\n");
-					c.write("    int i;\n");
+					c.write("    int32_t i;\n");
 					c.write("    rc = out->start_vector(out, tag, &count);\n");
 					c.write("    for(i=0;i<v->count;i++) {\n");
 					genSerialize(c, jvType, "data", "data[i]");

 					c.write("int deserialize_" + struct_name + "(struct iarchive *in, const char *tag, struct " + struct_name + " *v)\n");
 					c.write("{\n");
 					c.write("    int rc = 0;\n");
-					c.write("    int i;\n");
+					c.write("    int32_t i;\n");
 					c.write("    rc = in->start_vector(in, tag, &v->count);\n");
 					c.write("    v->data = calloc(v->count, sizeof(*v->data));\n");
 					c.write("    for(i=0;i<v->count;i++) {\n");
<EOC>
<SOC>
 import com.yahoo.zookeeper.proto.GetChildrenResponse;
 import com.yahoo.zookeeper.proto.GetDataRequest;
 import com.yahoo.zookeeper.proto.GetDataResponse;
+import com.yahoo.zookeeper.proto.SyncRequest;
+import com.yahoo.zookeeper.proto.SyncResponse;
 import com.yahoo.zookeeper.proto.ReplyHeader;
 import com.yahoo.zookeeper.proto.SetACLResponse;
 import com.yahoo.zookeeper.proto.SetDataResponse;

             case OpCode.closeSession:
                 err = rc.err;
                 break;
+            case OpCode.sync:
+            	SyncRequest syncRequest = new SyncRequest();
+            	ZooKeeperServer.byteBuffer2Record(request.request,
+            			syncRequest);
+            	rsp = new SyncResponse(syncRequest.getPath());
+            	break;
             case OpCode.exists:
                 // TODO we need to figure out the security requirement for this!
                 ExistsRequest existsRequest = new ExistsRequest();
<EOC>
<SOC>
      */
     LinkedList<Request> committedRequests = new LinkedList<Request>();
 
+    /*
+     * Pending sync requests
+     */
+    LinkedList<Request> pendingSyncs = new LinkedList<Request>();
+    
     RequestProcessor nextProcessor;
 
     public CommitProcessor(RequestProcessor nextProcessor) {

                         case OpCode.closeSession:
                             nextPending = request;
                             break;
+                        case OpCode.sync:
+                        	nextPending = request;
+                        	pendingSyncs.add(request);
+                        	break;
                         default:
                             toProcess.add(request);
                         }
<EOC>
<SOC>
 import com.yahoo.jute.BinaryInputArchive;
 import com.yahoo.jute.BinaryOutputArchive;
 import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.ZooDefs.OpCode;
 import com.yahoo.zookeeper.server.ZooKeeperServer;
 import com.yahoo.zookeeper.server.ZooLog;
 import com.yahoo.zookeeper.txn.TxnHeader;

                 }
                 ZooLog.logQuorumPacket('i', qp, traceMask);
                 tickOfLastAck = leader.self.tick;
+                
+                                
+                ByteBuffer bb;
+                long sessionId;
+                int cxid;
+                int type;
+                
                 switch (qp.getType()) {
                 case Leader.ACK:
                     leader.processAck(qp.getZxid(), s.getLocalSocketAddress());

                     queuedPackets.add(qp);
                     break;
                 case Leader.REQUEST:
-                    ByteBuffer bb = ByteBuffer.wrap(qp.getData());
-                    long sessionId = bb.getLong();
-                    int cxid = bb.getInt();
-                    int type = bb.getInt();
+                    bb = ByteBuffer.wrap(qp.getData());
+                    sessionId = bb.getLong();
+                    cxid = bb.getInt();
+                    type = bb.getInt();
                     bb = bb.slice();
+                    if(type == OpCode.sync){
+                    	leader.setSyncHandler(this, sessionId);
+                    }
                     leader.zk.submitRequest(null, sessionId, type, cxid, bb,
                             qp.getAuthinfo());
                     break;
<EOC>
<SOC>
                 case OpCode.create:
                 case OpCode.delete:
                 case OpCode.setData:
+                case OpCode.sync:
                 case OpCode.setACL:
                 case OpCode.createSession:
                 case OpCode.closeSession:
<EOC>
<SOC>
         Request request = pendingTxns.remove();
         commitProcessor.commit(request);
     }
-
+    
+    public void sync(){
+    	if(commitProcessor.pendingSyncs.size() ==0){
+    		ZooLog.logWarn("Not expecting a sync.");
+    		return;
+    	}
+    	    	
+    	commitProcessor.commit(commitProcessor.pendingSyncs.remove());
+    }
+    	     
+    	 
     @Override
     public int getGlobalOutstandingLimit() {
         return super.getGlobalOutstandingLimit()
<EOC>
<SOC>
 import java.net.Socket;
 import java.net.SocketAddress;
 import java.util.HashSet;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.concurrent.ConcurrentLinkedQueue;
 

 import com.yahoo.zookeeper.server.RequestProcessor;
 import com.yahoo.zookeeper.server.ZooLog;
 import com.yahoo.zookeeper.server.quorum.QuorumPeer.ServerState;
+import com.yahoo.zookeeper.ZooDefs.OpCode;
 
 /**
  * This class has the control logic for the Leader.

 
     // list of followers that are ready to follow (i.e synced with the leader)
     public HashSet<FollowerHandler> forwardingFollowers = new HashSet<FollowerHandler>();
-
+    
+    //Pending sync requests
+    public HashMap<Long,Request> pendingSyncs = new HashMap<Long,Request>();
+               
+    //Map sync request to FollowerHandler
+    public HashMap<Long,FollowerHandler> syncHandler = new HashMap<Long,FollowerHandler>();
+       
     /**
      * Adds follower to the leader.
      * 

      */
     final static int REVALIDATE = 6;
 
+    /**
+     * This message is a reply to a synchronize command flushing the pipe
+     * between the leader and the follower.
+     */
+    final static int SYNC = 7;
+     
     private ConcurrentLinkedQueue<Proposal> outstandingProposals = new ConcurrentLinkedQueue<Proposal>();
 
     ConcurrentLinkedQueue<Proposal> toBeApplied = new ConcurrentLinkedQueue<Proposal>();

                 p.ackCount++;
                 // ZooLog.logException(new RuntimeException(), "Count for " +
                 // Long.toHexString(zxid) + " is " + p.ackCount);
-                if (p.ackCount > self.quorumPeers.size() / 2) {
+                if (p.ackCount > self.quorumPeers.size() / 2){
                     if (!first) {
                         ZooLog.logError("Commiting " + Long.toHexString(zxid)
                                 + " from " + followerAddr + " not first!");

         lastCommitted = zxid;
         QuorumPacket qp = new QuorumPacket(Leader.COMMIT, zxid, null, null);
         sendPacket(qp);
+               
+        if(pendingSyncs.containsKey(zxid)){
+        	sendSync(syncHandler.get(pendingSyncs.get(zxid).sessionId), pendingSyncs.get(zxid));
+        	syncHandler.remove(pendingSyncs.get(zxid));
+        	pendingSyncs.remove(zxid);
+        }
     }
 
     long lastProposed;

      * @return the proposal that is queued to send to all the members
      */
     public Proposal propose(Request request) {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
-        try {
-            request.hdr.serialize(boa, "hdr");
-            if (request.txn != null) {
-                request.txn.serialize(boa, "txn");
-            }
-            baos.close();
-        } catch (IOException e) {
-            // This really should be impossible
-            ZooLog.logException(e);
-        }
-        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, baos
+    	
+    	
+    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    	BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
+    	try {
+    		request.hdr.serialize(boa, "hdr");
+    		if (request.txn != null) {
+    			request.txn.serialize(boa, "txn");
+    		}
+    		baos.close();
+    	} catch (IOException e) {
+    		// This really should be impossible
+    		ZooLog.logException(e);
+    	}
+    	QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, baos
                 .toByteArray(), null);
+    	
         Proposal p = new Proposal();
         p.packet = pp;
         p.request = request;

         }
         return p;
     }
-
+            
+    /**
+     * Process sync requests
+     * 
+     * @param QuorumPacket p
+     * @return void
+     */
+    
+    public void processSync(Request r){
+    	if(outstandingProposals.isEmpty()){
+    		ZooLog.logWarn("No outstanding proposal");
+    		sendSync(syncHandler.get(r.sessionId), r);
+    			syncHandler.remove(r.sessionId);
+    	}
+    	else{
+    		pendingSyncs.put(lastProposed, r);
+    	}
+    }
+        
+    /**
+     * Set FollowerHandler for sync.
+     * 
+     * @param QuorumPacket p
+     * @return void
+     */
+        
+    synchronized public void setSyncHandler(FollowerHandler f, long s){
+    	syncHandler.put(s, f);
+    }
+            
+    /**
+     * Sends a sync message to the appropriate server
+     * 
+     * @param request
+     * @return void
+     */
+            
+    public void sendSync(FollowerHandler f, Request r){
+    	QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);
+    	f.queuePacket(qp);
+    }
+                
     /**
      * lets the leader know that a follower is capable of following and is done
      * syncing
<EOC>
<SOC>
 
 package com.yahoo.zookeeper.server.quorum;
 
+import com.yahoo.zookeeper.ZooDefs;
 import com.yahoo.zookeeper.server.Request;
 import com.yahoo.zookeeper.server.RequestProcessor;
 import com.yahoo.zookeeper.server.SyncRequestProcessor;

         // ZooLog.logWarn("Ack>>> cxid = " + request.cxid + " type = " +
         // request.type + " id = " + request.sessionId);
         // request.addRQRec(">prop");
-        nextProcessor.processRequest(request);
-        if (request.hdr != null) {
-            // We need to sync and get consensus on any transactions
-            zks.leader.propose(request);
-            syncProcessor.processRequest(request);
-        }
+    	    	
+    	
+    	if(request.type == ZooDefs.OpCode.sync){
+    		if(zks.leader.syncHandler.containsKey(request.sessionId)){
+    			zks.leader.processSync(request);
+    		}
+    		else{
+    			nextProcessor.processRequest(request);
+    			zks.commitProcessor.commit(request);
+    		}
+    	}
+    	else{
+    		nextProcessor.processRequest(request);
+    		if (request.hdr != null) {
+    			// We need to sync and get consensus on any transactions
+    			zks.leader.propose(request);
+    			syncProcessor.processRequest(request);
+    		}
+    	}
     }
 
     public void shutdown() {
<EOC>
<SOC>
                 int to = request.request.getInt();
                 txn = new CreateSessionTxn(to);
                 request.request.rewind();
+                zks.sessionTracker.addSession(request.sessionId, to);
                 break;
             case OpCode.closeSession:
                 txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
<EOC>
<SOC>
     HashMap<Long, SessionSet> sessionSets = new HashMap<Long, SessionSet>();
 
     ConcurrentHashMap<Long, Integer> sessionsWithTimeout;
-
+    long nextSessionId = 0;
+    long serverId;
     long nextExpirationTime;
 
     int expirationInterval;

 
         long sessionId;
     }
-
+    
+    public static long initializeNextSession(long id) {
+    	long nextSid = 0;
+    	nextSid = (System.currentTimeMillis() << 24) >> 8;
+    	nextSid =  nextSid | (id <<56);
+    	return nextSid;
+    }
+    
     static class SessionSet {
         long expireTime;
 

     }
 
     public SessionTrackerImpl(SessionExpirer expirer,
-            ConcurrentHashMap<Long, Integer> sessionsWithTimeout, int tickTime) {
+            ConcurrentHashMap<Long, Integer> sessionsWithTimeout, int tickTime, long sid) {
         super("SessionTracker");
         this.expirer = expirer;
         this.expirationInterval = tickTime;
         this.sessionsWithTimeout = sessionsWithTimeout;
         nextExpirationTime = roundToInterval(System.currentTimeMillis());
+        this.serverId = sid;
+        this.nextSessionId = initializeNextSession(sid);
         for (long id : sessionsWithTimeout.keySet()) {
             addSession(id, sessionsWithTimeout.get(id));
         }

                 ZooLog.textTraceMask);
     }
 
-    long nextSessionId = System.currentTimeMillis() << 24;
-
+   
     synchronized public long createSession(int sessionTimeout) {
         addSession(nextSessionId, sessionTimeout);
         return nextSessionId++;
<EOC>
<SOC>
 import com.yahoo.zookeeper.server.FinalRequestProcessor;
 import com.yahoo.zookeeper.server.PrepRequestProcessor;
 import com.yahoo.zookeeper.server.RequestProcessor;
+import com.yahoo.zookeeper.server.SessionTrackerImpl;
 import com.yahoo.zookeeper.server.ZooKeeperServer;
 
 /**

         return super.getGlobalOutstandingLimit()
                 / (leader.self.quorumPeers.size() - 1);
     }
+    
+    protected void createSessionTracker() {
+        sessionTracker = new SessionTrackerImpl(this, sessionsWithTimeouts,
+                tickTime, this.serverId);
+    }
+
 
     public boolean touch(long sess, int to) {
         return sessionTracker.touchSession(sess, to);
<EOC>
<SOC>
                 throw new IOException("Nothing in the queue, but got "
                         + r.getXid());
             }
-            Packet p = pendingQueue.remove();
+            Packet p = null;
+            synchronized(pendingQueue) {
+                p = pendingQueue.remove();
+            }
             /*
              * Since requests are processed in order, we better get a response
              * to the first request!
<EOC>
<SOC>
 import com.yahoo.zookeeper.proto.SetACLResponse;
 import com.yahoo.zookeeper.proto.SetDataResponse;
 import com.yahoo.zookeeper.server.DataTree.ProcessTxnResult;
+import com.yahoo.zookeeper.server.NIOServerCnxn.Factory;
 import com.yahoo.zookeeper.txn.CreateSessionTxn;
 import com.yahoo.zookeeper.txn.ErrorTxn;
 

                     zks.sessionTracker.removeSession(request.sessionId);
                 }
             }
+            // do not add non quorum packets to the queue.
+            if (Request.isQuorum(request.type)) {
+                zks.addCommittedProposal(request);
+            }
         }
 
         if (request.hdr != null && request.hdr.getType() == OpCode.closeSession) {
-            zks.getServerCnxnFactory().closeSession(request.sessionId);
+            Factory scxn = zks.getServerCnxnFactory();
+            // this might be possible since
+            // we might just be playing diffs from the leader
+            if (scxn != null) {
+                scxn.closeSession(request.sessionId);
+            }
         }
+        
         if (request.cnxn == null) {
             return;
         }
<EOC>
<SOC>
-/*
+ /*
  * Copyright 2008, Yahoo! Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");

 package com.yahoo.zookeeper.server;
 
 import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.EOFException;
 import java.io.File;
 import java.io.FileInputStream;

 import java.io.RandomAccessFile;
 import java.io.SyncFailedException;
 import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;

 import com.yahoo.zookeeper.server.auth.DigestAuthenticationProvider;
 import com.yahoo.zookeeper.server.auth.HostAuthenticationProvider;
 import com.yahoo.zookeeper.server.auth.IPAuthenticationProvider;
+import com.yahoo.zookeeper.server.quorum.Leader;
+import com.yahoo.zookeeper.server.quorum.QuorumPacket;
+import com.yahoo.zookeeper.server.quorum.Leader.Proposal;
 import com.yahoo.zookeeper.txn.CreateSessionTxn;
 import com.yahoo.zookeeper.txn.CreateTxn;
 import com.yahoo.zookeeper.txn.DeleteTxn;

 public class ZooKeeperServer implements SessionExpirer {
     protected int tickTime = 3000;
 
+    public static final int commitLogCount = 500;
+    public int commitLogBuffer = 700;
+    public LinkedList<Proposal> committedLog = new LinkedList<Proposal>();
+    public long minCommittedLog, maxCommittedLog;
+
     HashMap<String, AuthenticationProvider> authenticationProviders = new HashMap<String, AuthenticationProvider>();
 
     /*

                 default:
                     dataTree.processTxn(hdr, txn);
                 }
+                Request r = new Request(null, 0, 
+                        hdr.getCxid(),  hdr.getType(), 
+                        null,null);
+                r.txn = txn;
+                r.hdr = hdr;
+                r.zxid = hdr.getZxid();
+                addCommittedProposal(r);
             }
         } catch (EOFException e) {
         }
         return highestZxid;
     }
+    
+    /** 
+     * maintains a list of last 500 or so committed requests. 
+     * This is used for fast follower synchronization. 
+     * @param r committed request
+     */
 
+    public void addCommittedProposal(Request request){
+        synchronized(committedLog) {
+            if (committedLog.size() > commitLogCount) {
+                committedLog.removeFirst();
+                minCommittedLog = 
+                    committedLog.getFirst().packet.getZxid();
+            }
+            if (committedLog.size() == 0) {
+                minCommittedLog = request.zxid;
+                maxCommittedLog = request.zxid;
+            }
+            
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
+            try {
+                request.hdr.serialize(boa, "hdr");
+                if (request.txn != null) {
+                    request.txn.serialize(boa, "txn");
+                }
+                baos.close();
+            } catch (IOException e) {
+                // This really should be impossible
+                ZooLog.logException(e);
+            }
+            QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, baos
+                    .toByteArray(), null);
+            Proposal p = new Proposal();
+            p.packet = pp;
+            p.request = request;
+            committedLog.add(p);
+            maxCommittedLog = p.packet.getZxid();
+        }
+    }
+    
     static public Record deserializeTxn(InputArchive ia, TxnHeader hdr)
             throws IOException {
         hdr.deserialize(ia, "hdr");

         return txn;
     }
 
+    public void truncateLog(long finalZxid) throws IOException {
+    	long highestZxid = 0;
+        for (File f : dataDir.listFiles()) {
+            long zxid = isValidSnapshot(f);
+            if (zxid == -1) {
+                ZooLog.logWarn("Skipping " + f);
+                continue;
+            }
+            if (zxid > highestZxid) {
+                highestZxid = zxid;
+            }
+        }
+        File[] files = getLogFiles(dataLogDir, highestZxid);
+        boolean truncated = false;
+        for (File f: files) {
+            FileInputStream fin = new FileInputStream(f);
+            InputArchive ia = BinaryInputArchive.getArchive(fin);
+            FileChannel fchan = fin.getChannel();
+            try {
+                while (true) {
+                    byte[] bytes = ia.readBuffer("txtEntry");
+                    if (bytes.length == 0) {
+                        throw new EOFException();
+                    }
+                    InputArchive iab = BinaryInputArchive.getArchive(
+                            new ByteArrayInputStream(bytes));
+                    TxnHeader hdr = new TxnHeader();
+                    Record txn = deserializeTxn(iab, hdr);
+                    if (ia.readByte("EOF") != 'B') {
+                        throw new EOFException();
+                    }
+                    if (hdr.getZxid() == finalZxid) {
+                        //this is where we need to truncate
+                        
+                        long pos = fchan.position();
+                        fin.close();
+                        FileOutputStream fout = new FileOutputStream(f);
+                        FileChannel fchanOut = fout.getChannel();
+                        fchanOut.truncate(pos);                     
+                        truncated = true;
+                        break;
+                    }
+                }
+            } catch(EOFException eof){
+            }   
+            if (truncated == true) {
+                break;
+            }
+        }
+        if (truncated == false) {
+            //not able to truncate the log
+            ZooLog.logError("Not able to truncate the log " + 
+                    Long.toHexString(finalZxid));
+            System.exit(13);
+        }
+     
+    }
+
     public void snapshot(BinaryOutputArchive oa) throws IOException,
             InterruptedException {
         HashMap<Long, Integer> sessSnap = new HashMap<Long, Integer>(

         if (firstProcessor != null) {
             firstProcessor.shutdown();
         }
-        dataTree.clear();
+        if (dataTree != null) {
+            dataTree.clear();
+        }
     }
 
     /**

         return limit;
     }
 
+    
     public void setServerCnxnFactory(Factory factory) {
         this.serverCnxnFactory = factory;
     }
<EOC>
<SOC>
 import com.yahoo.zookeeper.ZooDefs.OpCode;
 import com.yahoo.zookeeper.server.ZooKeeperServer;
 import com.yahoo.zookeeper.server.ZooLog;
+import com.yahoo.zookeeper.server.quorum.Leader.Proposal;
 import com.yahoo.zookeeper.txn.TxnHeader;
 
 /**

                 return;
             }
             long peerLastZxid = qp.getZxid();
+            int packetToSend = Leader.SNAP;
+            boolean logTxns = true;
+          
+            long zxidToSend = 0;
+            // we are sending the diff
+            synchronized(leader.zk.committedLog) {
+                if (leader.zk.committedLog.size() != 0) {
+                    if ((leader.zk.maxCommittedLog >= peerLastZxid) 
+                            && (leader.zk.minCommittedLog <= peerLastZxid)) {
+                        packetToSend = Leader.DIFF;
+                        zxidToSend = leader.zk.maxCommittedLog;
+                        for (Proposal propose: leader.zk.committedLog) {
+                            if (propose.packet.getZxid() > peerLastZxid) {
+                                queuePacket(propose.packet);
+                                QuorumPacket qcommit = new QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),
+                                        null, null);
+                                queuePacket(qcommit);
+                              
+                            }
+                        }
+                    }
+                }
+                else {
+                    logTxns = false;
+                }            }
             long leaderLastZxid = leader.startForwarding(this, peerLastZxid);
             QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,
                     leaderLastZxid, null, null);
             oa.writeRecord(newLeaderQP, "packet");
-            if (leaderLastZxid != peerLastZxid) {
-                ZooLog.logWarn("sending Snapshot");
+            bufferedOutput.flush();
+            // a special case when both the ids are the same
+            if (peerLastZxid == leaderLastZxid) {
+                packetToSend = Leader.DIFF;
+                zxidToSend = leaderLastZxid;
+            }
+            //check if we decided to send a diff or we need to send a truncate
+            // we avoid using epochs for truncating because epochs make things 
+            // complicated. Two epochs might have the last 32 bits as same.
+            // only if we know that there is a committed zxid in the queue that
+            // is less than the one the peer has we send a trunc else to make
+            // things simple we just send sanpshot.
+            if (logTxns && (peerLastZxid > leader.zk.maxCommittedLog)) {
+                // this is the only case that we are sure that
+                // we can ask the follower to truncate the log
+                packetToSend = Leader.TRUNC;
+                zxidToSend = leader.zk.maxCommittedLog;
+                
+            }
+            oa.writeRecord(new QuorumPacket(packetToSend, zxidToSend, null, null), "packet");
+            bufferedOutput.flush();
+            // only if we are not truncating or fast sycning
+            if (packetToSend == Leader.SNAP) {
+                ZooLog.logWarn("Sending snapshot last zxid of peer is " 
+                        + Long.toHexString(peerLastZxid) + " " + " zxid of leader is " 
+                        + Long.toHexString(leaderLastZxid));
                 // Dump data to follower
                 leader.zk.snapshot(oa);
                 oa.writeString("BenWasHere", "signature");

     void queuePacket(QuorumPacket p) {
         queuedPackets.add(p);
     }
-
+    
     public boolean synced() {
         return isAlive()
                 && tickOfLastAck >= leader.self.tick - leader.self.syncLimit;
<EOC>
<SOC>
     	return new String(b, "UTF8");
     }
     
+    static public final int maxBuffer = determineMaxBuffer();
+    private static int determineMaxBuffer() {
+        String maxBufferString = System.getProperty("jute.maxbuffer");
+        try {
+            return Integer.parseInt(maxBufferString);
+        } catch(Exception e) {
+            return 0xfffff;
+        }
+        
+    }
     public byte[] readBuffer(String tag) throws IOException {
         int len = readInt(tag);
         if (len == -1) return null;
-        if (len < 0 || len > 128*1024) {
+        if (len < 0 || len > maxBuffer) {
             throw new RuntimeException("Unreasonable length = " + len);
         }
         byte[] arr = new byte[len];
<EOC>
<SOC>
 package com.yahoo.zookeeper;
 
-public class Version {
-	public static final String revisionDate="$Date$";
-	public static final String revision="$Revision$";	
+public class Version implements com.yahoo.zookeeper.version.Info{
+
+	public static int getRevision() {
+		return REVISION;
+	}
+
+	public static String getBuildDate() {
+		return BUILD_DATE;
+	}
+
+	public static String getVersion() {
+		return MAJOR + "." + MINOR + "." + MICRO;
+	}
+
+	public static String getVersionRevision() {
+		return getVersion() + "-" + getRevision();
+	}
+
+	public static String getFullVersion() {
+		return getVersionRevision() + ", built on " + getBuildDate();
+	}
+
+	public static void printUsage() {
+		System.out
+				.print("Usage:\tjava -cp ... com.yahoo.zookeeper.Version "
+						+ "[--full | --short | --revision],\n\tPrints --full version "
+						+ "info if no arg specified.");
+		System.exit(1);
+	}
+
+	/**
+	 * Prints the current version, revision and build date to the standard out.
+	 * 
+	 * @param args
+	 *            <ul>
+	 *            <li> --short - prints a short version string "1.2.3"
+	 *            <li> --revision - prints a short version string with the SVN
+	 *            repository revision "1.2.3-94"
+	 *            <li> --full - prints the revision and the build date
+	 *            </ul>
+	 */
+	public static void main(String[] args) {
+		if (args.length > 1) {
+			printUsage();
+		}
+		if (args.length == 0 || (args.length == 1 && args[0].equals("--full"))) {
+			System.out.println(getFullVersion());
+			System.exit(0);
+		}
+		if (args[0].equals("--short"))
+			System.out.println(getVersion());
+		else if (args[0].equals("--revision"))
+			System.out.println(getVersionRevision());
+		else
+			printUsage();
+		System.exit(0);
+	}
 }
<EOC>
<SOC>
     }
 
     public Vote lookForLeader() throws InterruptedException {
-        self.currentVote = new Vote(self.myid, self.getLastLoggedZxid());
+        self.currentVote = new Vote(self.getId(), self.getLastLoggedZxid());
         // We are going to look for a leader by casting a vote for ourself
         byte requestBytes[] = new byte[4];
         ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);

                 if (result.winningCount > (self.quorumPeers.size() / 2)) {
                     self.currentVote = result.winner;
                     s.close();
-                    self.state = (self.currentVote.id == self.myid) ? ServerState.LEADING
-                            : ServerState.FOLLOWING;
+                    self.state = (self.currentVote.id == self.getId()) 
+							? ServerState.LEADING: ServerState.FOLLOWING;
                     if (self.state == ServerState.FOLLOWING) {
                         Thread.sleep(100);
                     }
<EOC>
<SOC>
             RequestProcessor nextProcessor) {
         this.zks = zks;
         this.nextProcessor = nextProcessor;
-        AckRequestProcessor ackProcessor = new AckRequestProcessor(zks.leader);
+        AckRequestProcessor ackProcessor = new AckRequestProcessor(zks.getLeader());
         syncProcessor = new SyncRequestProcessor(zks, ackProcessor);
     }
 

     	    	
     	
     	if(request.type == ZooDefs.OpCode.sync){
-    		if(zks.leader.syncHandler.containsKey(request.sessionId)){
-    			zks.leader.processSync(request);
+    		if(zks.getLeader().syncHandler.containsKey(request.sessionId)){
+    			zks.getLeader().processSync(request);
     		}
     		else{
     			nextProcessor.processRequest(request);

     		nextProcessor.processRequest(request);
     		if (request.hdr != null) {
     			// We need to sync and get consensus on any transactions
-    			zks.leader.propose(request);
+    			zks.getLeader().propose(request);
     			syncProcessor.processRequest(request);
     		}
     	}
<EOC>
<SOC>
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.lang.Thread.UncaughtExceptionHandler;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;

     }
 
     WatcherEvent eventOfDeath = new WatcherEvent();
-
+    final static UncaughtExceptionHandler uncaughtExceptionHandler = new UncaughtExceptionHandler() {
+        public void uncaughtException(Thread t, Throwable e) {
+            ZooLog.logException(e, "from " + t.getName());
+        }};
+    
+    
     class EventThread extends Thread {
         EventThread() {
             super("EventThread");
+            setUncaughtExceptionHandler(uncaughtExceptionHandler);
             setDaemon(true);
         }
 

         SendThread() {
             super("SendThread");
             zooKeeper.state = States.CONNECTING;
+            setUncaughtExceptionHandler(uncaughtExceptionHandler);
             setDaemon(true);
         }
 
<EOC>
<SOC>
 import java.io.InputStream;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.Socket;
 import java.nio.ByteBuffer;
 import java.nio.channels.CancelledKeyException;
 import java.nio.channels.Channel;

 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;

 import com.yahoo.jute.BinaryOutputArchive;
 import com.yahoo.jute.Record;
 import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.Version;
 import com.yahoo.zookeeper.Watcher;
 import com.yahoo.zookeeper.ZooDefs.OpCode;
 import com.yahoo.zookeeper.data.Id;

 import com.yahoo.zookeeper.proto.RequestHeader;
 import com.yahoo.zookeeper.proto.WatcherEvent;
 import com.yahoo.zookeeper.server.auth.AuthenticationProvider;
-import com.yahoo.zookeeper.server.quorum.FollowerHandler;
-import com.yahoo.zookeeper.server.quorum.QuorumPeer;
+import com.yahoo.zookeeper.server.auth.ProviderRegistry;
 
 /**
  * This class handles communication with clients using NIO. There is one per

 
         Selector selector = Selector.open();
 
-        int packetsSent;
-
-        int packetsReceived;
+        /**
+         * We use this buffer to do efficient socket I/O. Since there is a single
+         * sender thread per NIOServerCnxn instance, we can use a member variable to
+         * only allocate it once.
+        */
+        ByteBuffer directBuffer = ByteBuffer.allocateDirect(64 * 1024);
 
         HashSet<NIOServerCnxn> cnxns = new HashSet<NIOServerCnxn>();
 
-        QuorumPeer self;
-
-        long avgLatency;
-
-        long maxLatency;
-
-        long minLatency = 99999999;
-
         int outstandingLimit = 1;
 
-        void setStats(long latency, long avg) {
-            this.avgLatency = avg;
-            if (latency < minLatency) {
-                minLatency = latency;
-            }
-            if (latency > maxLatency) {
-                maxLatency = latency;
-            }
-        }
-
         public Factory(int port) throws IOException {
             super("NIOServerCxn.Factory");
             setDaemon(true);

             start();
         }
 
-        public Factory(int port, QuorumPeer self) throws IOException {
-            this(port);
-            this.self = self;
-        }
-
         public void startup(ZooKeeperServer zks) throws IOException,
                 InterruptedException {
             zks.startup();

         }
         
         public InetSocketAddress getLocalAddress(){
-        	return (InetSocketAddress)ss.socket().getLocalSocketAddress();
+            return (InetSocketAddress)ss.socket().getLocalSocketAddress();
         }
-        
+
         private void addCnxn(NIOServerCnxn cnxn) {
             synchronized (cnxns) {
                 cnxns.add(cnxn);
             }
         }
 
+        protected NIOServerCnxn createConnection(SocketChannel sock,
+                SelectionKey sk) throws IOException {
+            return new NIOServerCnxn(zks, sock, sk, this);
+        }
+        
         public void run() {
             while (!ss.socket().isClosed()) {
                 try {

                     synchronized (this) {
                         selected = selector.selectedKeys();
                     }
-                    for (SelectionKey k : selected) {
+                    ArrayList<SelectionKey> selectedList = new ArrayList<SelectionKey>(
+                            selected);
+                    Collections.shuffle(selectedList);
+                    for (SelectionKey k : selectedList) {
                         if ((k.readyOps() & SelectionKey.OP_ACCEPT) != 0) {
                             SocketChannel sc = ((ServerSocketChannel) k
                                     .channel()).accept();
                             sc.configureBlocking(false);
                             SelectionKey sk = sc.register(selector,
                                     SelectionKey.OP_READ);
-                            NIOServerCnxn cnxn = new NIOServerCnxn(zks, sc, sk,
-                                    this);
+                            NIOServerCnxn cnxn = createConnection(sc, sk);
                             sk.attach(cnxn);
                             addCnxn(cnxn);
                         } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {

                 clear();
                 this.interrupt();
                 this.join();
+            } catch (InterruptedException e) {
             } catch (Exception e) {
                 ZooLog.logException(e);
             }

 
     int sessionTimeout;
 
-    int packetsSent;
-
-    int packetsReceived;
-
     ArrayList<Id> authInfo = new ArrayList<Id>();
 
     LinkedList<Request> outstanding = new LinkedList<Request>();

                     if (incomingBuffer == lenBuffer) {
                         readLength(k);
                     } else if (!initialized) {
-                        packetsReceived++;
-                        factory.packetsReceived++;
+                        stats.packetsReceived++;
+                        ServerStats.getInstance().incrementPacketsReceived();
                         readConnectRequest();
                         lenBuffer.clear();
                         incomingBuffer = lenBuffer;
                     } else {
-                        packetsReceived++;
-                        factory.packetsReceived++;
+                        stats.packetsReceived++;
+                        ServerStats.getInstance().incrementPacketsReceived();
                         readRequest();
                         lenBuffer.clear();
                         incomingBuffer = lenBuffer;

                 if (outgoingBuffers.size() > 0) {
                     // ZooLog.logTextTraceMessage("sk " + k + " is valid: " +
                     // k.isValid(), ZooLog.CLIENT_DATA_PACKET_TRACE_MASK);
-                    ByteBuffer bbs[] = outgoingBuffers
-                            .toArray(new ByteBuffer[0]);
-                    // Write as much as we can
-                    long i = sock.write(bbs);
+
+                    /*
+                     * This is going to reset the buffer position to 0 and the
+                     * limit to the size of the buffer, so that we can fill it
+                     * with data from the non-direct buffers that we need to
+                     * send.
+                     */
+                    ByteBuffer directBuffer = factory.directBuffer;
+                    directBuffer.clear();
+
+                    for (ByteBuffer b : outgoingBuffers) {
+                        if (directBuffer.remaining() < b.remaining()) {
+                            /*
+                             * When we call put later, if the directBuffer is to
+                             * small to hold everything, nothing will be copied,
+                             * so we've got to slice the buffer if it's too big.
+                             */
+                            b = (ByteBuffer) b.slice().limit(
+                                    directBuffer.remaining());
+                        }
+                        /*
+                         * put() is going to modify the positions of both
+                         * buffers, put we don't want to change the position of
+                         * the source buffers (we'll do that after the send, if
+                         * needed), so we save and reset the position after the
+                         * copy
+                         */
+                        int p = b.position();
+                        directBuffer.put(b);
+                        b.position(p);
+                        if (directBuffer.remaining() == 0) {
+                            break;
+                        }
+                    }
+                    /*
+                     * Do the flip: limit becomes position, position gets set to
+                     * 0. This sets us up for the write.
+                     */
+                    directBuffer.flip();
+
+                    int sent = sock.write(directBuffer);
                     ByteBuffer bb;
+
                     // Remove the buffers that we have sent
-                    while (outgoingBuffers.size() > 0
-                            && (bb = outgoingBuffers.peek()).remaining() == 0) {
+                    while (outgoingBuffers.size() > 0) {
+                        bb = outgoingBuffers.peek();
                         if (bb == closeConn) {
                             throw new IOException("closing");
                         }
-                        if (bb.remaining() > 0) {
+                        int left = bb.remaining() - sent;
+                        if (left > 0) {
+                            /*
+                             * We only partially sent this buffer, so we update
+                             * the position and exit the loop.
+                             */
+                            bb.position(bb.position() + sent);
                             break;
                         }
-                        packetsSent++;
-                        factory.packetsSent++;
+                        stats.packetsSent++;
+                        /* We've sent the whole buffer, so drop the buffer */
+                        sent -= bb.remaining();
+                        ServerStats.getInstance().incrementPacketsSent();
                         outgoingBuffers.remove();
                     }
                     // ZooLog.logTextTraceMessage("after send,

                         sk.interestOps(sk.interestOps()
                                 & (~SelectionKey.OP_WRITE));
                     } else {
-                        sk
-                                .interestOps(sk.interestOps()
+                        sk.interestOps(sk.interestOps()
                                         | SelectionKey.OP_WRITE);
                     }
                 }

             AuthPacket authPacket = new AuthPacket();
             ZooKeeperServer.byteBuffer2Record(incomingBuffer, authPacket);
             String scheme = authPacket.getScheme();
-            AuthenticationProvider ap = zk.authenticationProviders.get(scheme);
+            AuthenticationProvider ap = ProviderRegistry.getProvider(scheme);
             if (ap == null
                     || ap.handleAuthentication(this, authPacket.getAuth()) != KeeperException.Code.Ok) {
                 if (ap == null)

             throw new IOException("We are out of date");
         }
         sessionTimeout = connReq.getTimeOut();
-        sessionId = connReq.getSessionId();
         byte passwd[] = connReq.getPasswd();
         if (sessionTimeout < zk.tickTime * 2) {
             sessionTimeout = zk.tickTime * 2;

         // We don't want to receive any packets until we are sure that the
         // session is setup
         disableRecv();
-        if (sessionId != 0) {
+        if (connReq.getSessionId() != 0) {
+            setSessionId(connReq.getSessionId());
             zk.reopenSession(this, sessionId, passwd, sessionTimeout);
             ZooLog.logWarn("Renewing session " + Long.toHexString(sessionId));
         } else {

                 return;
             } else if (len == statCmd) {
                 StringBuffer sb = new StringBuffer();
-                sb.append("Clients:\n");
-                for (SelectionKey sk : factory.selector.keys()) {
-                    Channel channel = sk.channel();
-                    if (channel instanceof SocketChannel) {
-                        NIOServerCnxn cnxn = (NIOServerCnxn) sk.attachment();
-                        sb.append(" "
-                                + ((SocketChannel) channel).socket()
-                                        .getRemoteSocketAddress() + "["
-                                + Integer.toHexString(sk.interestOps())
-                                + "](queued=" + cnxn.outstandingRequests
-                                + ",recved=" + cnxn.packetsReceived + ",sent="
-                                + cnxn.packetsSent + ")\n");
-                    }
-                }
-                sb.append("\n");
-                sb.append("Latency min/avg/max: " + factory.minLatency + "/"
-                        + factory.avgLatency + "/" + factory.maxLatency + "\n");
-                sb.append("Received: " + factory.packetsReceived + "\n");
-                sb.append("Sent: " + factory.packetsSent + "\n");
-                if (zk != null) {
-                    sb.append("Outstanding: " + zk.getInProcess() + "\n");
-                    sb.append("Zxid: "
-                            + Long.toHexString(zk.dataTree.lastProcessedZxid)
-                            + "\n");
-                }
-                // sb.append("Done: " + ZooKeeperServer.getRequests() + "\n");
-                if (factory.self == null) {
-                    sb.append("Mode: standalone\n");
-                } else {
-                    switch (factory.self.state) {
-                    case LOOKING:
-                        sb.append("Mode: leaderelection\n");
-                        break;
-                    case LEADING:
-                        sb.append("Mode: leading\n");
-                        sb.append("Followers:");
-                        for (FollowerHandler fh : factory.self.leader.followers) {
-                            if (fh.s == null) {
-                                continue;
-                            }
-                            sb.append(" ");
-                            sb.append(fh.s.getRemoteSocketAddress());
-                            if (factory.self.leader.forwardingFollowers
-                                    .contains(fh)) {
-                                sb.append("*");
-                            }
-                        }
-                        sb.append("\n");
-                        break;
-                    case FOLLOWING:
-                        sb.append("Mode: following\n");
-                        sb.append("Leader: ");
-                        Socket s = factory.self.follower.sock;
-                        if (s == null) {
-                            sb.append("not connected\n");
-                        } else {
-                            sb.append(s.getRemoteSocketAddress() + "\n");
+                if(zk!=null){
+                    sb.append("Zookeeper version: ").append(Version.getFullVersion())
+                        .append("\n");
+                    sb.append("Clients:\n");
+                    synchronized(factory.cnxns){
+                        for(NIOServerCnxn c : factory.cnxns){
+                            sb.append(c.getStats().toString());
                         }
                     }
-                }
+                    sb.append("\n");
+                    sb.append(ServerStats.getInstance().toString());
+                    sb.append("Node count: ").append(zk.dataTree.getNodeCount()).
+                        append("\n");
+                }else
+                    sb.append("ZooKeeperServer not running\n");
+
                 sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));
                 k.interestOps(SelectionKey.OP_WRITE);
                 return;

         try {
             ConnectResponse rsp = new ConnectResponse(0, valid ? sessionTimeout
                     : 0, valid ? sessionId : 0, // send 0 if session is no
-                                                // longer valid
+                    // longer valid
                     valid ? zk.generatePasswd(sessionId) : new byte[16]);
             ByteArrayOutputStream baos = new ByteArrayOutputStream();
             BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);

         return (InetSocketAddress) sock.socket().getRemoteSocketAddress();
     }
 
-    public void setStats(long latency, long avg) {
-        factory.setStats(latency, avg);
+    private class CnxnStats implements ServerCnxn.Stats{
+        long packetsReceived;
+        long packetsSent;
+        
+        /**
+         * The number of requests that have been submitted but not yet responded to.
+         */
+        public long getOutstandingRequests() {
+            return outstandingRequests;
+        }
+        public long getPacketsReceived() {
+            return packetsReceived;
+        }
+        public long getPacketsSent() {
+            return packetsSent;
+        }
+        public String toString(){
+            StringBuilder sb=new StringBuilder();
+            Channel channel = sk.channel();
+            if (channel instanceof SocketChannel) {
+                sb.append(" ").append(((SocketChannel)channel).socket()
+                                .getRemoteSocketAddress())
+                  .append("[").append(Integer.toHexString(sk.interestOps()))
+                  .append("](queued=").append(getOutstandingRequests())
+                  .append(",recved=").append(getPacketsReceived())
+                  .append(",sent=").append(getPacketsSent()).append(")\n");
+            }
+            return sb.toString();
+        }
     }
+
+    private CnxnStats stats=new CnxnStats();
+    public Stats getStats() {
+        return stats;
+    }
+
 }
<EOC>
<SOC>
 import com.yahoo.zookeeper.proto.DeleteRequest;
 import com.yahoo.zookeeper.proto.SetACLRequest;
 import com.yahoo.zookeeper.proto.SetDataRequest;
-import com.yahoo.zookeeper.proto.SyncRequest;
 import com.yahoo.zookeeper.server.ZooKeeperServer.ChangeRecord;
 import com.yahoo.zookeeper.server.auth.AuthenticationProvider;
+import com.yahoo.zookeeper.server.auth.ProviderRegistry;
 import com.yahoo.zookeeper.txn.CreateSessionTxn;
 import com.yahoo.zookeeper.txn.CreateTxn;
 import com.yahoo.zookeeper.txn.DeleteTxn;

                         && id.getId().equals("anyone")) {
                     return;
                 }
-                AuthenticationProvider ap = zks.authenticationProviders.get(id
+                AuthenticationProvider ap = ProviderRegistry.getProvider(id
                         .getScheme());
                 if (ap != null) {
                     for (Id authId : ids) {

             ZooLog.logWarn("*********************************" + request);
             StringBuffer sb = new StringBuffer();
             ByteBuffer bb = request.request;
-            bb.rewind();
-            while (bb.hasRemaining()) {
-                sb.append(Integer.toHexString(bb.get() & 0xff));
-            }
+            if(bb!=null){
+                bb.rewind();
+                while (bb.hasRemaining()) {
+                    sb.append(Integer.toHexString(bb.get() & 0xff));
+                }
+            }else
+                sb.append("request buffer is null");
             ZooLog.logWarn(sb.toString());
             ZooLog.logException(e);
             if (txnHeader != null) {

                     toAdd = new LinkedList<ACL>();
                 }
                 for (Id cid : authInfo) {
-                    AuthenticationProvider ap = zks.authenticationProviders
-                            .get(cid.getScheme());
+                    AuthenticationProvider ap = ProviderRegistry.getProvider(cid.getScheme());
                     if (ap == null) {
                         ZooLog.logError("Missing AuthenticationProvider for "
                                 + cid.getScheme());

                     }
                 }
             } else {
-                AuthenticationProvider ap = zks.authenticationProviders.get(id
+                AuthenticationProvider ap = ProviderRegistry.getProvider(id
                         .getScheme());
                 if (ap == null) {
                     return false;
<EOC>
<SOC>
     public abstract ArrayList<Id> getAuthInfo();
 
     public InetSocketAddress getRemoteAddress();
-
-    public void setStats(long latency, long avgLatency);
+    
+    public interface Stats{
+        public long getOutstandingRequests();
+        public long getPacketsReceived();
+        public long getPacketsSent();
+    }
+    
+    public Stats getStats();
 }
<EOC>
<SOC>
- /*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.EOFException;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.io.SyncFailedException;
-import java.nio.ByteBuffer;
-import java.nio.channels.FileChannel;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Random;
-import java.util.Map.Entry;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.BinaryOutputArchive;
-import com.yahoo.jute.InputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.KeeperException;
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.data.ACL;
-import com.yahoo.zookeeper.data.Id;
-import com.yahoo.zookeeper.data.Stat;
-import com.yahoo.zookeeper.proto.RequestHeader;
-import com.yahoo.zookeeper.server.SessionTracker.SessionExpirer;
-import com.yahoo.zookeeper.server.auth.AuthenticationProvider;
-import com.yahoo.zookeeper.server.auth.DigestAuthenticationProvider;
-import com.yahoo.zookeeper.server.auth.HostAuthenticationProvider;
-import com.yahoo.zookeeper.server.auth.IPAuthenticationProvider;
-import com.yahoo.zookeeper.server.quorum.Leader;
-import com.yahoo.zookeeper.server.quorum.QuorumPacket;
-import com.yahoo.zookeeper.server.quorum.Leader.Proposal;
-import com.yahoo.zookeeper.txn.CreateSessionTxn;
-import com.yahoo.zookeeper.txn.CreateTxn;
-import com.yahoo.zookeeper.txn.DeleteTxn;
-import com.yahoo.zookeeper.txn.ErrorTxn;
-import com.yahoo.zookeeper.txn.SetACLTxn;
-import com.yahoo.zookeeper.txn.SetDataTxn;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-/**
- * This class implements a simple standalone ZooKeeperServer. It sets up the
- * following chain of RequestProcessors to process requests:
- * PrepRequestProcessor -> SyncRequestProcessor -> FinalRequestProcessor
- */
-public class ZooKeeperServer implements SessionExpirer {
-	/**
-	 * Create an instance of Zookeeper server 
-	 */
-    public interface Factory {
-    	public ZooKeeperServer create() throws IOException;
-	}
-
-    public static final int DEFAULT_TICK_TIME=3000;
-	protected int tickTime = DEFAULT_TICK_TIME;
-
-    public static final int commitLogCount = 500;
-    public int commitLogBuffer = 700;
-    public LinkedList<Proposal> committedLog = new LinkedList<Proposal>();
-    public long minCommittedLog, maxCommittedLog;
-
-    HashMap<String, AuthenticationProvider> authenticationProviders = new HashMap<String, AuthenticationProvider>();
-
-    
-    /*
-     * Start up the ZooKeeper server.
-     * 
-     * @param args the port and data directory
-     */
-    public static void main(String[] args) {
-		ServerConfig.parse(args);
-		runStandalone(new Factory() {
-			public ZooKeeperServer create() throws IOException {
-				return new ZooKeeperServer();
-			}
-		});
-	}
-
-    public static void runStandalone(Factory factory){
-        try {
-            // Note that this thread isn't going to be doing anything else,
-            // so rather than spawning another thread, we will just call
-            // run() in this thread.
-            ZooKeeperServer zk = factory.create();
-            zk.startup();
-            NIOServerCnxn.Factory t = new NIOServerCnxn.Factory(ServerConfig.getClientPort());
-            t.setZooKeeperServer(zk);
-            t.join();
-            zk.shutdown();
-        } catch (Exception e) {
-            ZooLog.logException(e);
-        }
-        System.exit(0);    	
-    }
-    
-    public DataTree dataTree;
-
-    protected SessionTracker sessionTracker;
-
-    /**
-     * directory for storing the snapshot
-     */
-    File dataDir;
-
-    /**
-     * directoy for storing the log tnxns
-     */
-    File dataLogDir;
-
-    protected ConcurrentHashMap<Long, Integer> sessionsWithTimeouts;
-
-    void removeCnxn(ServerCnxn cnxn) {
-        dataTree.removeCnxn(cnxn);
-    }
-
-    /**
-     * Creates a ZooKeeperServer instance. It sets everything up, but doesn't
-     * actually start listening for clients until run() is invoked.
-     * 
-     * @param dataDir
-     *                the directory to put the data
-     * @throws IOException
-     */
-    public ZooKeeperServer(File dataDir, File dataLogDir, int tickTime) throws IOException {
-        this.dataDir = dataDir;
-        this.dataLogDir = dataLogDir;
-        this.tickTime = tickTime;
-        if (!dataDir.isDirectory()) {
-            throw new IOException("data directory does not exist");
-        }
-        IPAuthenticationProvider ipp = new IPAuthenticationProvider();
-        HostAuthenticationProvider hostp = new HostAuthenticationProvider();
-        DigestAuthenticationProvider digp = new DigestAuthenticationProvider();
-        authenticationProviders.put(ipp.getScheme(), ipp);
-        authenticationProviders.put(hostp.getScheme(), hostp);
-        authenticationProviders.put(digp.getScheme(), digp);
-        Enumeration<Object> en = System.getProperties().keys();
-        while (en.hasMoreElements()) {
-            String k = (String) en.nextElement();
-            if (k.startsWith("zookeeper.authProvider.")) {
-                String className = System.getProperty(k);
-                try {
-                    Class c = ZooKeeperServer.class.getClassLoader().loadClass(
-                            className);
-                    AuthenticationProvider ap = (AuthenticationProvider) c
-                            .newInstance();
-                    authenticationProviders.put(ap.getScheme(), ap);
-                } catch (Exception e) {
-                    ZooLog.logException(e, "Problems loading " + className);
-                }
-            }
-        }
-    }
-    /**
-     * Default constructor, relies on the config for its agrument values 
-     * @throws IOException
-     */
-    public ZooKeeperServer() throws IOException {
-    	this(new File(ServerConfig.getDataDir()), 
-    			new File(ServerConfig.getDataLogDir()), 
-    			DEFAULT_TICK_TIME);
-    }
-
-    public static long getZxidFromName(String name, String prefix) {
-        long zxid = -1;
-        String nameParts[] = name.split("\\.");
-        if (nameParts.length == 2 && nameParts[0].equals(prefix)) {
-            try {
-                zxid = Long.parseLong(nameParts[1], 16);
-            } catch (NumberFormatException e) {
-            }
-        }
-        return zxid;
-    }
-
-    static public long isValidSnapshot(File f) throws IOException {
-        long zxid = getZxidFromName(f.getName(), "snapshot");
-        if (zxid == -1)
-            return -1;
-    
-        // Check for a valid snapshot
-        RandomAccessFile raf = new RandomAccessFile(f, "r");
-        try {
-            raf.seek(raf.length() - 5);
-            byte bytes[] = new byte[5];
-            raf.read(bytes);
-            ByteBuffer bb = ByteBuffer.wrap(bytes);
-            int len = bb.getInt();
-            byte b = bb.get();
-            if (len != 1 || b != '/') {
-                ZooLog.logWarn("Invalid snapshot " + f + " len = " + len
-                        + " byte = " + (b & 0xff));
-                return -1;
-            }
-        } finally {
-            raf.close();
-        }
-    
-        return zxid;
-    }
-    
-    static File[] getLogFiles(File logDir,long snapshotZxid){
-        List<File> files = Arrays.asList(logDir.listFiles());
-        Collections.sort(files, new Comparator<File>() {
-            public int compare(File o1, File o2) {
-                long z1 = getZxidFromName(o1.getName(), "log");
-                long z2 = getZxidFromName(o2.getName(), "log");
-                return z1 < z2 ? -1 : (z1 > z2 ? 1 : 0);
-            }
-        });
-        // Find the log file that starts before or at the same time as the
-        // zxid of the snapshot
-        long logZxid = 0;
-        for (File f : files) {
-            long fzxid = getZxidFromName(f.getName(), "log");
-            if (fzxid > snapshotZxid) {
-                continue;
-            }
-            if (fzxid > logZxid) {
-                logZxid = fzxid;
-            }
-        }
-        List<File> v=new ArrayList<File>(5);
-        // Apply the logs
-        for (File f : files) {
-            long fzxid = getZxidFromName(f.getName(), "log");
-            if (fzxid < logZxid) {
-                continue;
-            }
-            v.add(f);
-        }
-        return v.toArray(new File[0]);
-    }
-    
-    public void loadData() throws IOException, FileNotFoundException,
-            SyncFailedException, InterruptedException {
-        long highestZxid = 0;
-        for (File f : dataDir.listFiles()) {
-            long zxid = isValidSnapshot(f);
-            if (zxid == -1) {
-                ZooLog.logWarn("Skipping " + f);
-                continue;
-            }
-            if (zxid > highestZxid) {
-                highestZxid = zxid;
-            }
-        }
-        // Restore sessions and data
-        // Find the latest snapshot
-        File snapshot = new File(dataDir, "snapshot."
-                + Long.toHexString(highestZxid));
-        if (snapshot.exists()) {
-            long snapShotZxid = highestZxid;
-            ZooLog.logWarn("Processing snapshot: " + snapshot);
-            FileInputStream fis = new FileInputStream(snapshot);
-            loadData(BinaryInputArchive.getArchive(fis));
-            fis.close();
-            dataTree.lastProcessedZxid = highestZxid;
-            File[] files=getLogFiles(dataLogDir,snapShotZxid);
-            // Apply the logs
-            for (File f : files) {
-                ZooLog.logWarn("Processing log file: " + f);
-                FileInputStream logStream = new FileInputStream(f);
-                highestZxid = playLog(BinaryInputArchive.getArchive(logStream));
-                logStream.close();
-            }
-            hzxid = highestZxid;
-        } else {
-            sessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();
-            dataTree = new DataTree();
-        }
-        // Clean up dead sessions
-        LinkedList<Long> deadSessions = new LinkedList<Long>();
-        for (long session : dataTree.getSessions()) {
-            if (sessionsWithTimeouts.get(session) == null) {
-                deadSessions.add(session);
-            }
-        }
-        dataTree.initialized = true;
-        for (long session : deadSessions) {
-            killSession(session);
-        }
-//        try {
-//			JMXRegistry.register(new com.yahoo.zookeeper.jmx.server.ZooKeeperServer(this));
-//			JMXRegistry.register(new com.yahoo.zookeeper.jmx.server.DataTree(dataTree));
-//		} catch (Exception e) {
-//            ZooLog.logError("Failed to register DataTreeMBean "+e.getMessage());
-//		}
-        // Make a clean snapshot
-        snapshot();
-    }
-
-    public void loadData(InputArchive ia) throws IOException {
-        sessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();
-        dataTree = new DataTree();
-        
-        int count = ia.readInt("count");
-        while (count > 0) {
-            long id = ia.readLong("id");
-            int to = ia.readInt("timeout");
-            sessionsWithTimeouts.put(id, to);
-            ZooLog.logTextTraceMessage("loadData --- session in archive: " + id
-                    + " with timeout: " + to, ZooLog.SESSION_TRACE_MASK);
-            count--;
-        }
-        dataTree.deserialize(ia, "tree");
-    }
-
-    public long playLog(InputArchive logStream) throws IOException {
-        long highestZxid = 0;
-        try {
-            while (true) {
-                byte[] bytes = logStream.readBuffer("txnEntry");
-                if (bytes.length == 0) {
-                    // Since we preallocate, we define EOF to be an
-                    // empty transaction
-                    throw new EOFException();
-                }
-                InputArchive ia = BinaryInputArchive
-                        .getArchive(new ByteArrayInputStream(bytes));
-                TxnHeader hdr = new TxnHeader();
-                Record txn = deserializeTxn(ia, hdr);
-                if (logStream.readByte("EOR") != 'B') {
-                    ZooLog.logError("Last transaction was partial.");
-                    throw new EOFException();
-                }
-                if (hdr.getZxid() <= highestZxid && highestZxid != 0) {
-                    ZooLog.logError(highestZxid + "(higestZxid) >= "
-                            + hdr.getZxid() + "(next log) for type "
-                            + hdr.getType());
-                } else {
-                    highestZxid = hdr.getZxid();
-                }
-                switch (hdr.getType()) {
-                case OpCode.createSession:
-                    sessionsWithTimeouts.put(hdr.getClientId(),
-                            ((CreateSessionTxn) txn).getTimeOut());
-                    ZooLog.logTextTraceMessage(
-                            "playLog --- create session in log: "
-                                    + Long.toHexString(hdr.getClientId()) + " with timeout: "
-                                    + ((CreateSessionTxn) txn).getTimeOut(),
-                            ZooLog.SESSION_TRACE_MASK);
-                    // give dataTree a chance to sync its lastProcessedZxid
-                    dataTree.processTxn(hdr, txn);
-                    break;
-                case OpCode.closeSession:
-                    sessionsWithTimeouts.remove(hdr.getClientId());
-                    ZooLog.logTextTraceMessage(
-                            "playLog --- close session in log: "
-                                    + Long.toHexString(hdr.getClientId()),
-                            ZooLog.SESSION_TRACE_MASK);
-                    dataTree.processTxn(hdr, txn);
-                    break;
-                default:
-                    dataTree.processTxn(hdr, txn);
-                }
-                Request r = new Request(null, 0, 
-                        hdr.getCxid(),  hdr.getType(), 
-                        null,null);
-                r.txn = txn;
-                r.hdr = hdr;
-                r.zxid = hdr.getZxid();
-                addCommittedProposal(r);
-            }
-        } catch (EOFException e) {
-        }
-        return highestZxid;
-    }
-    
-    /** 
-     * maintains a list of last 500 or so committed requests. 
-     * This is used for fast follower synchronization. 
-     * @param r committed request
-     */
-
-    public void addCommittedProposal(Request request){
-        synchronized(committedLog) {
-            if (committedLog.size() > commitLogCount) {
-                committedLog.removeFirst();
-                minCommittedLog = 
-                    committedLog.getFirst().packet.getZxid();
-            }
-            if (committedLog.size() == 0) {
-                minCommittedLog = request.zxid;
-                maxCommittedLog = request.zxid;
-            }
-            
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
-            try {
-                request.hdr.serialize(boa, "hdr");
-                if (request.txn != null) {
-                    request.txn.serialize(boa, "txn");
-                }
-                baos.close();
-            } catch (IOException e) {
-                // This really should be impossible
-                ZooLog.logException(e);
-            }
-            QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, baos
-                    .toByteArray(), null);
-            Proposal p = new Proposal();
-            p.packet = pp;
-            p.request = request;
-            committedLog.add(p);
-            maxCommittedLog = p.packet.getZxid();
-        }
-    }
-    
-    static public Record deserializeTxn(InputArchive ia, TxnHeader hdr)
-            throws IOException {
-        hdr.deserialize(ia, "hdr");
-        Record txn = null;
-        switch (hdr.getType()) {
-        case OpCode.createSession:
-            // This isn't really an error txn; it just has the same
-            // format. The error represents the timeout
-            txn = new CreateSessionTxn();
-            break;
-        case OpCode.closeSession:
-            return null;
-        case OpCode.create:
-            txn = new CreateTxn();
-            break;
-        case OpCode.delete:
-            txn = new DeleteTxn();
-            break;
-        case OpCode.setData:
-            txn = new SetDataTxn();
-            break;
-        case OpCode.setACL:
-            txn = new SetACLTxn();
-            break;
-        case OpCode.error:
-            txn = new ErrorTxn();
-            break;
-        }
-        if (txn != null) {
-            txn.deserialize(ia, "txn");
-        }
-        return txn;
-    }
-
-    public void truncateLog(long finalZxid) throws IOException {
-    	long highestZxid = 0;
-        for (File f : dataDir.listFiles()) {
-            long zxid = isValidSnapshot(f);
-            if (zxid == -1) {
-                ZooLog.logWarn("Skipping " + f);
-                continue;
-            }
-            if (zxid > highestZxid) {
-                highestZxid = zxid;
-            }
-        }
-        File[] files = getLogFiles(dataLogDir, highestZxid);
-        boolean truncated = false;
-        for (File f: files) {
-            FileInputStream fin = new FileInputStream(f);
-            InputArchive ia = BinaryInputArchive.getArchive(fin);
-            FileChannel fchan = fin.getChannel();
-            try {
-                while (true) {
-                    byte[] bytes = ia.readBuffer("txtEntry");
-                    if (bytes.length == 0) {
-                        throw new EOFException();
-                    }
-                    InputArchive iab = BinaryInputArchive.getArchive(
-                            new ByteArrayInputStream(bytes));
-                    TxnHeader hdr = new TxnHeader();
-                    Record txn = deserializeTxn(iab, hdr);
-                    if (ia.readByte("EOF") != 'B') {
-                        throw new EOFException();
-                    }
-                    if (hdr.getZxid() == finalZxid) {
-                        //this is where we need to truncate
-                        
-                        long pos = fchan.position();
-                        fin.close();
-                        FileOutputStream fout = new FileOutputStream(f);
-                        FileChannel fchanOut = fout.getChannel();
-                        fchanOut.truncate(pos);                     
-                        truncated = true;
-                        break;
-                    }
-                }
-            } catch(EOFException eof){
-            }   
-            if (truncated == true) {
-                break;
-            }
-        }
-        if (truncated == false) {
-            //not able to truncate the log
-            ZooLog.logError("Not able to truncate the log " + 
-                    Long.toHexString(finalZxid));
-            System.exit(13);
-        }
-     
-    }
-
-    public void snapshot(BinaryOutputArchive oa) throws IOException,
-            InterruptedException {
-        HashMap<Long, Integer> sessSnap = new HashMap<Long, Integer>(
-                sessionsWithTimeouts);
-        oa.writeInt(sessSnap.size(), "count");
-        for (Entry<Long, Integer> entry : sessSnap.entrySet()) {
-            oa.writeLong(entry.getKey().longValue(), "id");
-            oa.writeInt(entry.getValue().intValue(), "timeout");
-        }
-        dataTree.serialize(oa, "tree");
-    }
-
-    public void snapshot() throws InterruptedException {
-
-        long lastZxid = dataTree.lastProcessedZxid;
-        ZooLog.logTextTraceMessage(
-                "Snapshoting: " + Long.toHexString(lastZxid),
-                ZooLog.textTraceMask);
-        try {
-            FileOutputStream sessStream = new FileOutputStream(new File(
-                    dataDir, "snapshot." + Long.toHexString(lastZxid)));
-            BinaryOutputArchive oa = BinaryOutputArchive.getArchive(sessStream);
-            snapshot(oa);
-            sessStream.flush();
-            // sessStream.getChannel().force(false);
-            sessStream.close();
-        } catch (IOException e) {
-            ZooLog.logException(e, "Severe error, exiting");
-            // This is a severe error that we cannot recover from,
-            // so we need to exit
-            System.exit(10);
-        }
-    }
-
-    protected long hzxid = 0;
-
-    /**
-     * This should be called from a synchronized block on this!
-     */
-    public long getZxid() {
-        return hzxid;
-    }
-
-    synchronized long getNextZxid() {
-        return ++hzxid;
-    }
-
-    long getTime() {
-        return System.currentTimeMillis();
-    }
-
-    static String getLogName(long zxid) {
-        return "log." + Long.toHexString(zxid);
-    }
-
-    final public static Exception ok = new Exception("No prob");
-
-    protected RequestProcessor firstProcessor;
-
-    LinkedBlockingQueue<Long> sessionsToDie = new LinkedBlockingQueue<Long>();
-
-    public void closeSession(long sessionId) throws KeeperException,
-            InterruptedException {
-        ZooLog.logTextTraceMessage("ZooKeeperServer --- Session to be closed: "
-                + sessionId, ZooLog.SESSION_TRACE_MASK);
-        // we do not want to wait for a session close. send it as soon as we
-        // detect it!
-        submitRequest(null, sessionId, OpCode.closeSession, 0, null, null);
-    }
-
-    protected void killSession(long sessionId) {
-        dataTree.killSession(sessionId);
-        ZooLog.logTextTraceMessage("ZooKeeperServer --- killSession: "
-                + sessionId, ZooLog.SESSION_TRACE_MASK);
-        if (sessionTracker != null) {
-            sessionTracker.removeSession(sessionId);
-        }
-    }
-
-    public void expire(long sessionId) {
-        try {
-            ZooLog.logTextTraceMessage(
-                    "ZooKeeperServer --- Session to expire: " + sessionId,
-                    ZooLog.SESSION_TRACE_MASK);
-            closeSession(sessionId);
-        } catch (Exception e) {
-            ZooLog.logException(e);
-        }
-    }
-
-    void touch(ServerCnxn cnxn) throws IOException {
-        if (cnxn == null) {
-            return;
-        }
-        long id = cnxn.getSessionId();
-        int to = cnxn.getSessionTimeout();
-        if (!sessionTracker.touchSession(id, to)) {
-            throw new IOException("Missing session " + Long.toHexString(id));
-        }
-    }
-
-    public void startup() throws IOException, InterruptedException {
-        if (dataTree == null) {
-            loadData();
-        }
-        createSessionTracker();
-        setupRequestProcessors();
-        running = true;
-        synchronized (this) {
-            notifyAll();
-        }
-    }
-
-    protected void setupRequestProcessors() {
-        RequestProcessor finalProcessor = new FinalRequestProcessor(this);
-        RequestProcessor syncProcessor = new SyncRequestProcessor(this,
-                finalProcessor);
-        firstProcessor = new PrepRequestProcessor(this, syncProcessor);
-    }
-
-    protected void createSessionTracker() {
-        sessionTracker = new SessionTrackerImpl(this, sessionsWithTimeouts,
-                tickTime, 1);
-    }
-
-    protected boolean running;
-
-    public boolean isRunning() {
-        return running;
-    }
-
-    public void shutdown() {
-        // new RuntimeException("Calling shutdown").printStackTrace();
-        this.running = false;
-        // Since sessionTracker and syncThreads poll we just have to
-        // set running to false and they will detect it during the poll
-        // interval.
-        if (sessionTracker != null) {
-            sessionTracker.shutdown();
-        }
-        if (firstProcessor != null) {
-            firstProcessor.shutdown();
-        }
-        if (dataTree != null) {
-            dataTree.clear();
-        }
-    }
-
-    /**
-     * This is the secret that we use to generate passwords, for the moment it
-     * is more of a sanity check.
-     */
-    final private long superSecret = 0XB3415C00L;
-
-    int requestsInProcess;
-
-    synchronized public void incInProcess() {
-        requestsInProcess++;
-    }
-
-    synchronized public void decInProcess() {
-        requestsInProcess--;
-    }
-
-    public int getInProcess() {
-        return requestsInProcess;
-    }
-
-    /**
-     * This structure is used to facilitate information sharing between PrepRP
-     * and FinalRP.
-     */
-    static class ChangeRecord {
-        ChangeRecord(long zxid, String path, Stat stat, int childCount,
-                ArrayList<ACL> acl) {
-            this.zxid = zxid;
-            this.path = path;
-            this.stat = stat;
-            this.childCount = childCount;
-            this.acl = acl;
-        }
-
-        long zxid;
-
-        String path;
-
-        Stat stat; /* Make sure to create a new object when changing */
-
-        int childCount;
-
-        ArrayList<ACL> acl; /* Make sure to create a new object when changing */
-
-        @SuppressWarnings("unchecked")
-        ChangeRecord duplicate(long zxid) {
-            Stat stat = new Stat();
-            if (this.stat != null) {
-                DataTree.copyStat(this.stat, stat);
-            }
-            return new ChangeRecord(zxid, path, stat, childCount,
-                    acl == null ? new ArrayList<ACL>() : (ArrayList<ACL>) acl
-                            .clone());
-        }
-    }
-
-    ArrayList<ChangeRecord> outstandingChanges = new ArrayList<ChangeRecord>();
-
-    private NIOServerCnxn.Factory serverCnxnFactory;
-
-    byte[] generatePasswd(long id) {
-        Random r = new Random(id ^ superSecret);
-        byte p[] = new byte[16];
-        r.nextBytes(p);
-        return p;
-    }
-
-    protected boolean checkPasswd(long sessionId, byte[] passwd) {
-        return sessionId != 0
-                && Arrays.equals(passwd, generatePasswd(sessionId));
-    }
-
-    long createSession(ServerCnxn cnxn, byte passwd[], int timeout)
-            throws InterruptedException {
-        long sessionId = sessionTracker.createSession(timeout);
-        Random r = new Random(sessionId ^ superSecret);
-        r.nextBytes(passwd);
-        ByteBuffer to = ByteBuffer.allocate(4);
-        to.putInt(timeout);
-        cnxn.setSessionId(sessionId);
-        submitRequest(cnxn, sessionId, OpCode.createSession, 0, to, null);
-        return sessionId;
-    }
-
-    protected void revalidateSession(ServerCnxn cnxn, long sessionId,
-            int sessionTimeout) throws IOException, InterruptedException {
-        boolean rc = sessionTracker.touchSession(sessionId, sessionTimeout);
-        ZooLog.logTextTraceMessage("Session " + sessionId + " is valid: " + rc,
-                ZooLog.SESSION_TRACE_MASK);
-        cnxn.finishSessionInit(rc);
-    }
-
-    public void reopenSession(ServerCnxn cnxn, long sessionId, byte[] passwd,
-            int sessionTimeout) throws IOException, InterruptedException {
-        if (!checkPasswd(sessionId, passwd)) {
-            cnxn.finishSessionInit(false);
-        } else {
-            revalidateSession(cnxn, sessionId, sessionTimeout);
-        }
-    }
-
-    public void closeSession(ServerCnxn cnxn, RequestHeader requestHeader)
-            throws KeeperException, InterruptedException {
-        closeSession(cnxn.getSessionId());
-    }
-
-    public long getServerId() {
-        return 0;
-    }
-
-    /**
-     * @param cnxn
-     * @param sessionId
-     * @param xid
-     * @param bb
-     */
-    public void submitRequest(ServerCnxn cnxn, long sessionId, int type,
-            int xid, ByteBuffer bb, ArrayList<Id> authInfo) {
-        if (firstProcessor == null) {
-            synchronized (this) {
-                try {
-                    while (!running) {
-                        wait(1000);
-                    }
-                } catch (InterruptedException e) {
-                    ZooLog.logException(e);
-                }
-                if (firstProcessor == null) {
-                    throw new RuntimeException("Not started");
-                }
-            }
-        }
-        try {
-            touch(cnxn);
-            Request si = new Request(cnxn, sessionId, xid, type, bb, authInfo);
-            boolean validpacket = Request.isValid(type);
-            if (validpacket) {
-                firstProcessor.processRequest(si);
-                if (cnxn != null) {
-                    incInProcess();
-                }
-            } else {
-                ZooLog.logWarn("Dropping packet at server of type " + type);
-                // if unvalid packet drop the packet.
-            }
-        } catch (IOException e) {
-            ZooLog.logException(e);
-        }
-    }
-
-    static public void byteBuffer2Record(ByteBuffer bb, Record record)
-            throws IOException {
-        BinaryInputArchive ia;
-        ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));
-        record.deserialize(ia, "request");
-    }
-
-    public static int getSnapCount() {
-        String sc = System.getProperty("zookeeper.snapCount");
-        try {
-            return Integer.parseInt(sc);
-        } catch (Exception e) {
-            return 10000;
-        }
-    }
-
-    public int getGlobalOutstandingLimit() {
-        String sc = System.getProperty("zookeeper.globalOutstandingLimit");
-        int limit;
-        try {
-            limit = Integer.parseInt(sc);
-        } catch (Exception e) {
-            limit = 1000;
-        }
-        return limit;
-    }
-
-    
-    public void setServerCnxnFactory(NIOServerCnxn.Factory factory) {
-        this.serverCnxnFactory = factory;
-    }
-
-    public NIOServerCnxn.Factory getServerCnxnFactory() {
-        return this.serverCnxnFactory;
-    }
-
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.EOFException;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.RandomAccessFile;
+import java.io.SyncFailedException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Random;
+import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.BinaryOutputArchive;
+import com.yahoo.jute.InputArchive;
+import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.ZooDefs.OpCode;
+import com.yahoo.zookeeper.data.ACL;
+import com.yahoo.zookeeper.data.Id;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.RequestHeader;
+import com.yahoo.zookeeper.server.SessionTracker.SessionExpirer;
+import com.yahoo.zookeeper.server.quorum.Leader;
+import com.yahoo.zookeeper.server.quorum.QuorumPacket;
+import com.yahoo.zookeeper.server.quorum.Leader.Proposal;
+import com.yahoo.zookeeper.txn.CreateSessionTxn;
+import com.yahoo.zookeeper.txn.CreateTxn;
+import com.yahoo.zookeeper.txn.DeleteTxn;
+import com.yahoo.zookeeper.txn.ErrorTxn;
+import com.yahoo.zookeeper.txn.SetACLTxn;
+import com.yahoo.zookeeper.txn.SetDataTxn;
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+/**
+ * This class implements a simple standalone ZooKeeperServer. It sets up the
+ * following chain of RequestProcessors to process requests:
+ * PrepRequestProcessor -> SyncRequestProcessor -> FinalRequestProcessor
+ */
+public class ZooKeeperServer implements SessionExpirer, ServerStats.Provider {
+    /**
+     * Create an instance of Zookeeper server
+     */
+    public interface Factory {
+        public ZooKeeperServer createServer() throws IOException;
+
+        public NIOServerCnxn.Factory createConnectionFactory()
+                throws IOException;
+    }
+
+    /**
+     * The server delegates loading of the tree to an instance of the interface
+     */
+    public interface DataTreeBuilder {
+        public DataTree build();
+    }
+
+    static public class BasicDataTreeBuilder implements DataTreeBuilder {
+        public DataTree build() {
+            return new DataTree();
+        }
+    }
+
+    private static final int DEFAULT_TICK_TIME = 3000;
+    protected int tickTime = DEFAULT_TICK_TIME;
+
+    public static final int commitLogCount = 500;
+    public int commitLogBuffer = 700;
+    public LinkedList<Proposal> committedLog = new LinkedList<Proposal>();
+    public long minCommittedLog, maxCommittedLog;
+    private DataTreeBuilder treeBuilder;
+    public DataTree dataTree;
+    protected SessionTracker sessionTracker;
+    /**
+     * directory for storing the snapshot
+     */
+    File dataDir;
+    /**
+     * directoy for storing the log tnxns
+     */
+    File dataLogDir;
+    protected ConcurrentHashMap<Long, Integer> sessionsWithTimeouts;
+    protected long hzxid = 0;
+    final public static Exception ok = new Exception("No prob");
+    protected RequestProcessor firstProcessor;
+    LinkedBlockingQueue<Long> sessionsToDie = new LinkedBlockingQueue<Long>();
+    protected boolean running;
+    /**
+     * This is the secret that we use to generate passwords, for the moment it
+     * is more of a sanity check.
+     */
+    final private long superSecret = 0XB3415C00L;
+    int requestsInProcess;
+    ArrayList<ChangeRecord> outstandingChanges = new ArrayList<ChangeRecord>();
+    private NIOServerCnxn.Factory serverCnxnFactory;
+
+    /*
+     * Start up the ZooKeeper server.
+     * 
+     * @param args the port and data directory
+     */
+    public static void main(String[] args) {
+        ServerConfig.parse(args);
+        runStandalone(new Factory() {
+            public NIOServerCnxn.Factory createConnectionFactory()
+                    throws IOException {
+                return new NIOServerCnxn.Factory(ServerConfig.getClientPort());
+            }
+
+            public ZooKeeperServer createServer() throws IOException {
+                return new ZooKeeperServer(new BasicDataTreeBuilder());
+            }
+        });
+    }
+
+    public static void runStandalone(Factory factory) {
+        try {
+            // Note that this thread isn't going to be doing anything else,
+            // so rather than spawning another thread, we will just call
+            // run() in this thread.
+            ServerStats.registerAsConcrete();
+            ZooKeeperServer zk = factory.createServer();
+            zk.startup();
+            NIOServerCnxn.Factory t = factory.createConnectionFactory();
+            t.setZooKeeperServer(zk);
+            t.join();
+            if (zk.isRunning())
+                zk.shutdown();
+        } catch (Exception e) {
+            ZooLog.logException(e);
+        }
+        System.exit(0);
+    }
+
+    void removeCnxn(ServerCnxn cnxn) {
+        dataTree.removeCnxn(cnxn);
+    }
+
+    /**
+     * Creates a ZooKeeperServer instance. It sets everything up, but doesn't
+     * actually start listening for clients until run() is invoked.
+     * 
+     * @param dataDir
+     *            the directory to put the data
+     * @throws IOException
+     */
+    public ZooKeeperServer(File dataDir, File dataLogDir, int tickTime,
+            DataTreeBuilder treeBuilder) throws IOException {
+        this.treeBuilder = treeBuilder;
+        this.dataDir = dataDir;
+        this.dataLogDir = dataLogDir;
+        this.tickTime = tickTime;
+        if (!dataDir.isDirectory()) {
+            throw new IOException("data directory does not exist");
+        }
+        ServerStats.getInstance().setStatsProvider(this);
+    }
+
+    /**
+     * This constructor is for backward comaptibility with the existing unit
+     * test code.
+     */
+    public ZooKeeperServer(File dataDir, File dataLogDir, int tickTime)
+            throws IOException {
+        this.treeBuilder = new BasicDataTreeBuilder();
+        this.dataDir = dataDir;
+        this.dataLogDir = dataLogDir;
+        this.tickTime = tickTime;
+        if (!dataDir.isDirectory()) {
+            throw new IOException("data directory does not exist");
+        }
+        ServerStats.getInstance().setStatsProvider(this);
+    }
+
+    /**
+     * Default constructor, relies on the config for its agrument values
+     * 
+     * @throws IOException
+     */
+    public ZooKeeperServer(DataTreeBuilder treeBuilder) throws IOException {
+        this(new File(ServerConfig.getDataDir()), new File(ServerConfig
+                .getDataLogDir()), DEFAULT_TICK_TIME, treeBuilder);
+    }
+
+    public static long getZxidFromName(String name, String prefix) {
+        long zxid = -1;
+        String nameParts[] = name.split("\\.");
+        if (nameParts.length == 2 && nameParts[0].equals(prefix)) {
+            try {
+                zxid = Long.parseLong(nameParts[1], 16);
+            } catch (NumberFormatException e) {
+            }
+        }
+        return zxid;
+    }
+
+    static public long isValidSnapshot(File f) throws IOException {
+        long zxid = getZxidFromName(f.getName(), "snapshot");
+        if (zxid == -1)
+            return -1;
+
+        // Check for a valid snapshot
+        RandomAccessFile raf = new RandomAccessFile(f, "r");
+        try {
+            raf.seek(raf.length() - 5);
+            byte bytes[] = new byte[5];
+            raf.read(bytes);
+            ByteBuffer bb = ByteBuffer.wrap(bytes);
+            int len = bb.getInt();
+            byte b = bb.get();
+            if (len != 1 || b != '/') {
+                ZooLog.logWarn("Invalid snapshot " + f + " len = " + len
+                        + " byte = " + (b & 0xff));
+                return -1;
+            }
+        } finally {
+            raf.close();
+        }
+
+        return zxid;
+    }
+
+    static File[] getLogFiles(File logDir, long snapshotZxid) {
+        List<File> files = Arrays.asList(logDir.listFiles());
+        Collections.sort(files, new Comparator<File>() {
+            public int compare(File o1, File o2) {
+                long z1 = getZxidFromName(o1.getName(), "log");
+                long z2 = getZxidFromName(o2.getName(), "log");
+                return z1 < z2 ? -1 : (z1 > z2 ? 1 : 0);
+            }
+        });
+        // Find the log file that starts before or at the same time as the
+        // zxid of the snapshot
+        long logZxid = 0;
+        for (File f : files) {
+            long fzxid = getZxidFromName(f.getName(), "log");
+            if (fzxid > snapshotZxid) {
+                continue;
+            }
+            if (fzxid > logZxid) {
+                logZxid = fzxid;
+            }
+        }
+        List<File> v = new ArrayList<File>(5);
+        // Apply the logs
+        for (File f : files) {
+            long fzxid = getZxidFromName(f.getName(), "log");
+            if (fzxid < logZxid) {
+                continue;
+            }
+            v.add(f);
+        }
+        return v.toArray(new File[0]);
+    }
+
+    public void loadData() throws IOException, FileNotFoundException,
+            SyncFailedException, InterruptedException {
+        long highestZxid = 0;
+        for (File f : dataDir.listFiles()) {
+            long zxid = isValidSnapshot(f);
+            if (zxid == -1) {
+                ZooLog.logWarn("Skipping " + f);
+                continue;
+            }
+            if (zxid > highestZxid) {
+                highestZxid = zxid;
+            }
+        }
+        // Restore sessions and data
+        // Find the latest snapshot
+        File snapshot = new File(dataDir, "snapshot."
+                + Long.toHexString(highestZxid));
+        if (snapshot.exists()) {
+            long snapShotZxid = highestZxid;
+            ZooLog.logWarn("Processing snapshot: " + snapshot);
+            InputStream snapIS =
+                new BufferedInputStream(new FileInputStream(snapshot));
+            loadData(BinaryInputArchive.getArchive(snapIS));
+            snapIS.close();            
+            dataTree.lastProcessedZxid = highestZxid;
+            File[] files = getLogFiles(dataLogDir, snapShotZxid);
+            // Apply the logs
+            for (File f : files) {
+                ZooLog.logWarn("Processing log file: " + f);
+                InputStream logIS =
+                    new BufferedInputStream(new FileInputStream(f));
+                highestZxid = playLog(BinaryInputArchive.getArchive(logIS));
+                logIS.close();                
+                FileInputStream logStream = new FileInputStream(f);
+                highestZxid = playLog(BinaryInputArchive.getArchive(logStream));
+                logStream.close();
+            }
+            hzxid = highestZxid;
+            ZooLog.logWarn("Snapshot/log data restored");
+        } else {
+            sessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();
+            dataTree = treeBuilder.build();
+        }
+        // Clean up dead sessions
+        LinkedList<Long> deadSessions = new LinkedList<Long>();
+        for (long session : dataTree.getSessions()) {
+            if (sessionsWithTimeouts.get(session) == null) {
+                deadSessions.add(session);
+            }
+        }
+        dataTree.initialized = true;
+        for (long session : deadSessions) {
+            killSession(session);
+        }
+        // Make a clean snapshot
+        snapshot();
+    }
+
+    public void loadData(InputArchive ia) throws IOException {
+        sessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();
+        dataTree = treeBuilder.build();
+
+        int count = ia.readInt("count");
+        while (count > 0) {
+            long id = ia.readLong("id");
+            int to = ia.readInt("timeout");
+            sessionsWithTimeouts.put(id, to);
+            ZooLog.logTextTraceMessage("loadData --- session in archive: " + id
+                    + " with timeout: " + to, ZooLog.SESSION_TRACE_MASK);
+            count--;
+        }
+        dataTree.deserialize(ia, "tree");
+    }
+
+    public long playLog(InputArchive logStream) throws IOException {
+        long highestZxid = 0;
+        try {
+            while (true) {
+                byte[] bytes = logStream.readBuffer("txnEntry");
+                if (bytes.length == 0) {
+                    // Since we preallocate, we define EOF to be an
+                    // empty transaction
+                    throw new EOFException();
+                }
+                InputArchive ia = BinaryInputArchive
+                        .getArchive(new ByteArrayInputStream(bytes));
+                TxnHeader hdr = new TxnHeader();
+                Record txn = deserializeTxn(ia, hdr);
+                if (logStream.readByte("EOR") != 'B') {
+                    ZooLog.logError("Last transaction was partial.");
+                    throw new EOFException();
+                }
+                if (hdr.getZxid() <= highestZxid && highestZxid != 0) {
+                    ZooLog.logError(highestZxid + "(higestZxid) >= "
+                            + hdr.getZxid() + "(next log) for type "
+                            + hdr.getType());
+                } else {
+                    highestZxid = hdr.getZxid();
+                }
+                switch (hdr.getType()) {
+                case OpCode.createSession:
+                    sessionsWithTimeouts.put(hdr.getClientId(),
+                            ((CreateSessionTxn) txn).getTimeOut());
+                    ZooLog.logTextTraceMessage(
+                            "playLog --- create session in log: "
+                                    + Long.toHexString(hdr.getClientId())
+                                    + " with timeout: "
+                                    + ((CreateSessionTxn) txn).getTimeOut(),
+                            ZooLog.SESSION_TRACE_MASK);
+                    // give dataTree a chance to sync its lastProcessedZxid
+                    dataTree.processTxn(hdr, txn);
+                    break;
+                case OpCode.closeSession:
+                    sessionsWithTimeouts.remove(hdr.getClientId());
+                    ZooLog.logTextTraceMessage(
+                            "playLog --- close session in log: "
+                                    + Long.toHexString(hdr.getClientId()),
+                            ZooLog.SESSION_TRACE_MASK);
+                    dataTree.processTxn(hdr, txn);
+                    break;
+                default:
+                    dataTree.processTxn(hdr, txn);
+                }
+                Request r = new Request(null, 0, hdr.getCxid(), hdr.getType(),
+                        null, null);
+                r.txn = txn;
+                r.hdr = hdr;
+                r.zxid = hdr.getZxid();
+                addCommittedProposal(r);
+            }
+        } catch (EOFException e) {
+        }
+        return highestZxid;
+    }
+
+    /**
+     * maintains a list of last 500 or so committed requests. This is used for
+     * fast follower synchronization.
+     * 
+     * @param r
+     *            committed request
+     */
+
+    public void addCommittedProposal(Request request) {
+        synchronized (committedLog) {
+            if (committedLog.size() > commitLogCount) {
+                committedLog.removeFirst();
+                minCommittedLog = committedLog.getFirst().packet.getZxid();
+            }
+            if (committedLog.size() == 0) {
+                minCommittedLog = request.zxid;
+                maxCommittedLog = request.zxid;
+            }
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
+            try {
+                request.hdr.serialize(boa, "hdr");
+                if (request.txn != null) {
+                    request.txn.serialize(boa, "txn");
+                }
+                baos.close();
+            } catch (IOException e) {
+                // This really should be impossible
+                ZooLog.logException(e);
+            }
+            QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid,
+                    baos.toByteArray(), null);
+            Proposal p = new Proposal();
+            p.packet = pp;
+            p.request = request;
+            committedLog.add(p);
+            maxCommittedLog = p.packet.getZxid();
+        }
+    }
+
+    static public Record deserializeTxn(InputArchive ia, TxnHeader hdr)
+            throws IOException {
+        hdr.deserialize(ia, "hdr");
+        Record txn = null;
+        switch (hdr.getType()) {
+        case OpCode.createSession:
+            // This isn't really an error txn; it just has the same
+            // format. The error represents the timeout
+            txn = new CreateSessionTxn();
+            break;
+        case OpCode.closeSession:
+            return null;
+        case OpCode.create:
+            txn = new CreateTxn();
+            break;
+        case OpCode.delete:
+            txn = new DeleteTxn();
+            break;
+        case OpCode.setData:
+            txn = new SetDataTxn();
+            break;
+        case OpCode.setACL:
+            txn = new SetACLTxn();
+            break;
+        case OpCode.error:
+            txn = new ErrorTxn();
+            break;
+        }
+        if (txn != null) {
+            txn.deserialize(ia, "txn");
+        }
+        return txn;
+    }
+
+    public void truncateLog(long finalZxid) throws IOException {
+        long highestZxid = 0;
+        for (File f : dataDir.listFiles()) {
+            long zxid = isValidSnapshot(f);
+            if (zxid == -1) {
+                ZooLog.logWarn("Skipping " + f);
+                continue;
+            }
+            if (zxid > highestZxid) {
+                highestZxid = zxid;
+            }
+        }
+        File[] files = getLogFiles(dataLogDir, highestZxid);
+        boolean truncated = false;
+        for (File f : files) {
+            FileInputStream fin = new FileInputStream(f);
+            InputArchive ia = BinaryInputArchive.getArchive(fin);
+            FileChannel fchan = fin.getChannel();
+            try {
+                while (true) {
+                    byte[] bytes = ia.readBuffer("txtEntry");
+                    if (bytes.length == 0) {
+                        throw new EOFException();
+                    }
+                    InputArchive iab = BinaryInputArchive
+                            .getArchive(new ByteArrayInputStream(bytes));
+                    TxnHeader hdr = new TxnHeader();
+                    deserializeTxn(iab, hdr);
+                    if (ia.readByte("EOF") != 'B') {
+                        throw new EOFException();
+                    }
+                    if (hdr.getZxid() == finalZxid) {
+                        // this is where we need to truncate
+
+                        long pos = fchan.position();
+                        fin.close();
+                        FileOutputStream fout = new FileOutputStream(f);
+                        FileChannel fchanOut = fout.getChannel();
+                        fchanOut.truncate(pos);
+                        truncated = true;
+                        break;
+                    }
+                }
+            } catch (EOFException eof) {
+            }
+            if (truncated == true) {
+                break;
+            }
+        }
+        if (truncated == false) {
+            // not able to truncate the log
+            ZooLog.logError("Not able to truncate the log "
+                    + Long.toHexString(finalZxid));
+            System.exit(13);
+        }
+
+    }
+
+    public void snapshot(BinaryOutputArchive oa) throws IOException,
+            InterruptedException {
+        HashMap<Long, Integer> sessSnap = new HashMap<Long, Integer>(
+                sessionsWithTimeouts);
+        oa.writeInt(sessSnap.size(), "count");
+        for (Entry<Long, Integer> entry : sessSnap.entrySet()) {
+            oa.writeLong(entry.getKey().longValue(), "id");
+            oa.writeInt(entry.getValue().intValue(), "timeout");
+        }
+        dataTree.serialize(oa, "tree");
+    }
+
+    public void snapshot() throws InterruptedException {
+        long lastZxid = dataTree.lastProcessedZxid;
+        ZooLog.logTextTraceMessage(
+                "Snapshotting: " + Long.toHexString(lastZxid),
+                ZooLog.textTraceMask);
+        try {
+            File f =new File(dataDir, "snapshot." + Long.toHexString(lastZxid));
+            OutputStream sessOS = new BufferedOutputStream(new FileOutputStream(f));
+            BinaryOutputArchive oa = BinaryOutputArchive.getArchive(sessOS);
+            snapshot(oa);
+            sessOS.flush();
+            sessOS.close();
+            ZooLog.logTextTraceMessage(
+                    "Snapshotting finished: " + Long.toHexString(lastZxid),
+                    ZooLog.textTraceMask);
+        } catch (IOException e) {
+            ZooLog.logException(e, "Severe error, exiting");
+            // This is a severe error that we cannot recover from,
+            // so we need to exit
+            System.exit(10);
+        }
+    }
+
+    /**
+     * This should be called from a synchronized block on this!
+     */
+    public long getZxid() {
+        return hzxid;
+    }
+
+    synchronized long getNextZxid() {
+        return ++hzxid;
+    }
+
+    long getTime() {
+        return System.currentTimeMillis();
+    }
+
+    static String getLogName(long zxid) {
+        return "log." + Long.toHexString(zxid);
+    }
+
+    public void closeSession(long sessionId) throws KeeperException,
+            InterruptedException {
+        ZooLog.logTextTraceMessage("ZooKeeperServer --- Session to be closed: "
+                + Long.toHexString(sessionId), ZooLog.SESSION_TRACE_MASK);
+        // we do not want to wait for a session close. send it as soon as we
+        // detect it!
+        submitRequest(null, sessionId, OpCode.closeSession, 0, null, null);
+    }
+
+    protected void killSession(long sessionId) {
+        dataTree.killSession(sessionId);
+        ZooLog.logTextTraceMessage("ZooKeeperServer --- killSession: "
+                + Long.toHexString(sessionId), ZooLog.SESSION_TRACE_MASK);
+        if (sessionTracker != null) {
+            sessionTracker.removeSession(sessionId);
+        }
+    }
+
+    public void expire(long sessionId) {
+        try {
+            ZooLog.logTextTraceMessage(
+                    "ZooKeeperServer --- Session to expire: " + Long.toHexString(sessionId),
+                    ZooLog.SESSION_TRACE_MASK);
+            closeSession(sessionId);
+        } catch (Exception e) {
+            ZooLog.logException(e);
+        }
+    }
+
+    void touch(ServerCnxn cnxn) throws IOException {
+        if (cnxn == null) {
+            return;
+        }
+        long id = cnxn.getSessionId();
+        int to = cnxn.getSessionTimeout();
+        if (!sessionTracker.touchSession(id, to)) {
+            throw new IOException("Missing session " + Long.toHexString(id));
+        }
+    }
+
+    public void startup() throws IOException, InterruptedException {
+        if (dataTree == null) {
+            loadData();
+        }
+        createSessionTracker();
+        setupRequestProcessors();
+        running = true;
+        synchronized (this) {
+            notifyAll();
+        }
+    }
+
+    protected void setupRequestProcessors() {
+        RequestProcessor finalProcessor = new FinalRequestProcessor(this);
+        RequestProcessor syncProcessor = new SyncRequestProcessor(this,
+                finalProcessor);
+        firstProcessor = new PrepRequestProcessor(this, syncProcessor);
+    }
+
+    protected void createSessionTracker() {
+        sessionTracker = new SessionTrackerImpl(this, sessionsWithTimeouts,
+                tickTime, 1);
+    }
+
+    public boolean isRunning() {
+        return running;
+    }
+
+    public void shutdown() {
+        // new RuntimeException("Calling shutdown").printStackTrace();
+        this.running = false;
+        // Since sessionTracker and syncThreads poll we just have to
+        // set running to false and they will detect it during the poll
+        // interval.
+        if (sessionTracker != null) {
+            sessionTracker.shutdown();
+        }
+        if (firstProcessor != null) {
+            firstProcessor.shutdown();
+        }
+        if (dataTree != null) {
+            dataTree.clear();
+        }
+    }
+
+    synchronized public void incInProcess() {
+        requestsInProcess++;
+    }
+
+    synchronized public void decInProcess() {
+        requestsInProcess--;
+    }
+
+    public int getInProcess() {
+        return requestsInProcess;
+    }
+
+    /**
+     * This structure is used to facilitate information sharing between PrepRP
+     * and FinalRP.
+     */
+    static class ChangeRecord {
+        ChangeRecord(long zxid, String path, Stat stat, int childCount,
+                ArrayList<ACL> acl) {
+            this.zxid = zxid;
+            this.path = path;
+            this.stat = stat;
+            this.childCount = childCount;
+            this.acl = acl;
+        }
+
+        long zxid;
+
+        String path;
+
+        Stat stat; /* Make sure to create a new object when changing */
+
+        int childCount;
+
+        ArrayList<ACL> acl; /* Make sure to create a new object when changing */
+
+        @SuppressWarnings("unchecked")
+        ChangeRecord duplicate(long zxid) {
+            Stat stat = new Stat();
+            if (this.stat != null) {
+                DataTree.copyStat(this.stat, stat);
+            }
+            return new ChangeRecord(zxid, path, stat, childCount,
+                    acl == null ? new ArrayList<ACL>() : (ArrayList<ACL>) acl
+                            .clone());
+        }
+    }
+
+    byte[] generatePasswd(long id) {
+        Random r = new Random(id ^ superSecret);
+        byte p[] = new byte[16];
+        r.nextBytes(p);
+        return p;
+    }
+
+    protected boolean checkPasswd(long sessionId, byte[] passwd) {
+        return sessionId != 0
+                && Arrays.equals(passwd, generatePasswd(sessionId));
+    }
+
+    long createSession(ServerCnxn cnxn, byte passwd[], int timeout)
+            throws InterruptedException {
+        long sessionId = sessionTracker.createSession(timeout);
+        Random r = new Random(sessionId ^ superSecret);
+        r.nextBytes(passwd);
+        ByteBuffer to = ByteBuffer.allocate(4);
+        to.putInt(timeout);
+        cnxn.setSessionId(sessionId);
+        submitRequest(cnxn, sessionId, OpCode.createSession, 0, to, null);
+        return sessionId;
+    }
+
+    protected void revalidateSession(ServerCnxn cnxn, long sessionId,
+            int sessionTimeout) throws IOException, InterruptedException {
+        boolean rc = sessionTracker.touchSession(sessionId, sessionTimeout);
+        ZooLog.logTextTraceMessage("Session " + Long.toHexString(sessionId) + 
+                " is valid: " + rc,ZooLog.SESSION_TRACE_MASK);
+        cnxn.finishSessionInit(rc);
+    }
+
+    public void reopenSession(ServerCnxn cnxn, long sessionId, byte[] passwd,
+            int sessionTimeout) throws IOException, InterruptedException {
+        if (!checkPasswd(sessionId, passwd)) {
+            cnxn.finishSessionInit(false);
+        } else {
+            revalidateSession(cnxn, sessionId, sessionTimeout);
+        }
+    }
+
+    public void closeSession(ServerCnxn cnxn, RequestHeader requestHeader)
+            throws KeeperException, InterruptedException {
+        closeSession(cnxn.getSessionId());
+    }
+
+    public long getServerId() {
+        return 0;
+    }
+
+    /**
+     * @param cnxn
+     * @param sessionId
+     * @param xid
+     * @param bb
+     */
+    public void submitRequest(ServerCnxn cnxn, long sessionId, int type,
+            int xid, ByteBuffer bb, ArrayList<Id> authInfo) {
+        if (firstProcessor == null) {
+            synchronized (this) {
+                try {
+                    while (!running) {
+                        wait(1000);
+                    }
+                } catch (InterruptedException e) {
+                    ZooLog.logException(e);
+                }
+                if (firstProcessor == null) {
+                    throw new RuntimeException("Not started");
+                }
+            }
+        }
+        try {
+            touch(cnxn);
+            Request si = new Request(cnxn, sessionId, xid, type, bb, authInfo);
+            boolean validpacket = Request.isValid(type);
+            if (validpacket) {
+                firstProcessor.processRequest(si);
+                if (cnxn != null) {
+                    incInProcess();
+                }
+            } else {
+                ZooLog.logWarn("Dropping packet at server of type " + type);
+                // if unvalid packet drop the packet.
+            }
+        } catch (IOException e) {
+            ZooLog.logException(e);
+        }
+    }
+
+    static public void byteBuffer2Record(ByteBuffer bb, Record record)
+            throws IOException {
+        BinaryInputArchive ia;
+        ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));
+        record.deserialize(ia, "request");
+    }
+
+    public static int getSnapCount() {
+        String sc = System.getProperty("zookeeper.snapCount");
+        try {
+            return Integer.parseInt(sc);
+        } catch (Exception e) {
+            return 10000;
+        }
+    }
+
+    public int getGlobalOutstandingLimit() {
+        String sc = System.getProperty("zookeeper.globalOutstandingLimit");
+        int limit;
+        try {
+            limit = Integer.parseInt(sc);
+        } catch (Exception e) {
+            limit = 1000;
+        }
+        return limit;
+    }
+
+    public void setServerCnxnFactory(NIOServerCnxn.Factory factory) {
+        serverCnxnFactory = factory;
+    }
+
+    public NIOServerCnxn.Factory getServerCnxnFactory() {
+        return serverCnxnFactory;
+    }
+
+    public long getLastProcessedZxid() {
+        return dataTree.lastProcessedZxid;
+    }
+
+    public long getOutstandingRequests() {
+        return getInProcess();
+    }
+}
<EOC>
<SOC>
-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package com.yahoo.zookeeper.server.quorum;
-
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.SocketException;
-import java.nio.ByteBuffer;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.Random;
-
-import com.yahoo.zookeeper.server.ZooLog;
-import com.yahoo.zookeeper.server.quorum.Election;
-import com.yahoo.zookeeper.server.quorum.Vote;
-import com.yahoo.zookeeper.server.quorum.QuorumCnxManager;
-import com.yahoo.zookeeper.server.quorum.QuorumCnxManager.Message;
-import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;
-import com.yahoo.zookeeper.server.quorum.QuorumPeer.ServerState;
-
-
-/**
- * Implementation of leader election using TCP. It uses an object of the class 
- * QuorumCnxManager to manage connections. Otherwise, the algorithm is push-based
- * as with the other UDP implementations. 
- * 
- * There are a few parameters that can be tuned to change its behavior. First, 
- * finalizeWait determines the amount of time to wait until deciding upon a leader.
- * This is part of the leader election algorithm.
- */
-
-
-public class FastLeaderElection implements Election {
-
-	/* Sequence numbers for messages */
-    static int sequencer = 0;
-
-    /*
-     * Determine how much time a process has to wait
-     * once it believes that it has reached the end of
-     * leader election.
-     */
-    static int finalizeWait = 100;
-
-    /*
-	 * Challenge counter to avoid replay attacks
-	 */
-	
-	static int challengeCounter = 0;
-	
-	/*
-	 * Flag to determine whether to authenticate or not
-	 */
-    
-	private boolean authEnabled = false;
-    
-	/*
-	 * Connection manager
-	 */
-	
-	QuorumCnxManager manager;
-
-    static public class Notification {
-        /*
-         * Proposed leader
-         */
-        long leader;
-
-        /*
-         * zxid of the proposed leader
-         */
-        long zxid;
-
-        /*
-         * Epoch
-         */
-        long epoch;
-
-        /*
-         * current state of sender
-         */
-        QuorumPeer.ServerState state;
-        
-        /*
-         * Address of sender
-         */
-        InetAddress addr;
-    }
-
-    /*
-     * Messages to send, both Notifications and Acks
-     */
-    static public class ToSend {
-    	static enum mType {crequest, challenge, notification, ack};
-        
-        ToSend(mType type, 
-        		long leader, 
-        		long zxid, 
-        		long epoch, 
-        		ServerState state,
-        		InetAddress addr) {
-        
-        	this.leader = leader;
-        	this.zxid = zxid;
-        	this.epoch = epoch;
-        	this.state = state;
-        	this.addr = addr;
-        }
-        
-        /*
-         * Proposed leader in the case of notification
-         */
-        long leader;
-
-        /*
-         * id contains the tag for acks, and zxid for notifications
-         */
-        long zxid;
-
-        /*
-         * Epoch
-         */
-        long epoch;
-
-        /*
-         * Current state;
-         */
-        QuorumPeer.ServerState state;
-        
-        /*
-         * Address of recipient
-         */
-        InetAddress addr;
-    }
-
-    LinkedBlockingQueue<ToSend> sendqueue;
-    LinkedBlockingQueue<Notification> recvqueue;
-
-    private class Messenger {
-    	
-        DatagramSocket mySocket;
-        long lastProposedLeader;
-        long lastProposedZxid;
-        long lastEpoch;
-        
-        class WorkerReceiver implements Runnable {
-
-        	QuorumCnxManager manager;
-            Messenger msg;
-
-            WorkerReceiver(QuorumCnxManager manager, Messenger msg) {
-                this.manager = manager;
-                this.msg = msg;
-            }
-
-            public void run() {
-                
-            	Message response;
-            	while (true) {
-                    // Sleeps on receive
-            		try{
-            			response = manager.recvQueue.take();
-            			
-            			// Receive new message
-            			if (response.buffer.capacity() < 28) {
-            				ZooLog.logError("Got a short response: "
-            						+ response.buffer.capacity());
-            				continue;
-            			}
-            			response.buffer.clear();
-               
-
-            			QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;
-            			switch (response.buffer.getInt()) {
-            			case 0:
-            				ackstate = QuorumPeer.ServerState.LOOKING;
-            				break;
-            			case 1:
-            				ackstate = QuorumPeer.ServerState.LEADING;
-            				break;
-            			case 2:
-            				ackstate = QuorumPeer.ServerState.FOLLOWING;
-            				break;
-            			}
-                    	
-            			Notification n = new Notification();
-            			n.leader = response.buffer.getLong();
-            			n.zxid = response.buffer.getLong();
-            			n.epoch = response.buffer.getLong();
-            			n.state = ackstate;
-            			n.addr = response.addr;
-
-            			if ((messenger.lastEpoch <= n.epoch)
-            					&& ((n.zxid > messenger.lastProposedZxid) 
-            					|| ((n.zxid == messenger.lastProposedZxid) 
-            					&& (n.leader > messenger.lastProposedLeader)))) {
-            				messenger.lastProposedZxid = n.zxid;
-            				messenger.lastProposedLeader = n.leader;
-            				messenger.lastEpoch = n.epoch;
-            			}
-
-            			//InetAddress addr = (InetAddress) responsePacket.getSocketAddress();
-            			if(self.state == QuorumPeer.ServerState.LOOKING){
-            				recvqueue.offer(n);
-            				if(recvqueue.size() == 0) ZooLog.logWarn("Message: " + n.addr);
-            				if((ackstate == QuorumPeer.ServerState.LOOKING)
-            						&& (n.epoch < logicalclock)){
-            					ToSend notmsg = new ToSend(ToSend.mType.notification, 
-                						proposedLeader, 
-                						proposedZxid,
-                						logicalclock,
-                						self.state,
-                						response.addr);
-                				sendqueue.offer(notmsg);
-            				}
-            			} else { 	           				
-            				if((ackstate == QuorumPeer.ServerState.LOOKING) &&
-            						(self.state != QuorumPeer.ServerState.LOOKING)){
-            					ToSend notmsg = new ToSend(ToSend.mType.notification, 
-            						self.currentVote.id, 
-            						self.currentVote.zxid,
-            						logicalclock,
-            						self.state,
-            						response.addr);
-            					sendqueue.offer(notmsg);
-            				}
-            			}
-            			
-            		} catch (InterruptedException e) {
-            			System.out.println("Interrupted Exception while waiting for new message" +
-            					e.toString());
-            		}
-            	}
-            }
-        }
-
-        class WorkerSender implements Runnable {
-        	
-            Random rand;
-            QuorumCnxManager manager;
-            boolean processing;
-            int ackWait = finalizeWait / 6;
-
-            
-            WorkerSender(QuorumCnxManager manager){ 
-                rand = new Random(java.lang.Thread.currentThread().getId() + System.currentTimeMillis());
-                this.manager = manager;
-            }
-            
-            public void run() {
-                while (true) {
-                    try {
-                        ToSend m = sendqueue.take();
-                        process(m);
-                    } catch (InterruptedException e) {
-                        break;
-                    }
-
-                }
-            }
-
-            private void process(ToSend m) {
-                int attempts = 0;
-                byte requestBytes[] = new byte[28];
-                ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);  
-                
-                /*
-                 * Building notification packet to send
-                 */
-                    
-                requestBuffer.clear();
-                requestBuffer.putInt(m.state.ordinal());
-                requestBuffer.putLong(m.leader);
-                requestBuffer.putLong(m.zxid);
-                requestBuffer.putLong(m.epoch);
-                
-                manager.toSend(m.addr, requestBuffer);
-                  
-            }
-        }
-
-        public boolean queueEmpty() {
-            return (sendqueue.isEmpty() || recvqueue.isEmpty());
-        }
-
-        Messenger(QuorumCnxManager manager) {
-            lastProposedLeader = 0;
-            lastProposedZxid = 0;
-            lastEpoch = 0;
-
-            Thread t = new Thread(new WorkerSender(manager),
-            		"WorkerSender Thread");
-            t.setDaemon(true);
-            t.start();
-
-            t = new Thread(new WorkerReceiver(manager, this),
-                    				"WorkerReceiver Thread");
-            t.setDaemon(true);
-            t.start();
-        }
-
-    }
-
-    QuorumPeer self;
-    int port;
-    long logicalclock; /* Election instance */
-    Messenger messenger;
-    DatagramSocket mySocket;
-    long proposedLeader;
-    long proposedZxid;
-
-        
-    public FastLeaderElection(QuorumPeer self, QuorumCnxManager manager){
-    	this.manager = manager;
-    	starter(self, manager);
-    }
-    
-    private void starter(QuorumPeer self, QuorumCnxManager manager) {
-        this.self = self;
-        proposedLeader = -1;
-        proposedZxid = -1;
-
-        sendqueue = new LinkedBlockingQueue<ToSend>();
-        recvqueue = new LinkedBlockingQueue<Notification>();
-        messenger = new Messenger(manager);
-    }
-
-    private void leaveInstance() {
-        recvqueue.clear();
-    }
-
-    public static class ElectionResult {
-        public Vote vote;
-
-        public int count;
-
-        public Vote winner;
-
-        public int winningCount;
-    }
-
-    private void sendNotifications() {
-        for (QuorumServer server : self.quorumPeers) {
-            InetAddress saddr = server.addr.getAddress();
-
-            ToSend notmsg = new ToSend(ToSend.mType.notification, 
-            		proposedLeader, 
-            		proposedZxid,
-                    logicalclock,
-                    QuorumPeer.ServerState.LOOKING,
-                    saddr);
-
-            sendqueue.offer(notmsg);
-        }
-    }
-
-    private boolean totalOrderPredicate(long id, long zxid) {
-        if ((zxid > proposedZxid)
-                || ((zxid == proposedZxid) && (id > proposedLeader)))
-            return true;
-        else
-            return false;
-
-    }
-
-    private boolean termPredicate(
-            HashMap<InetAddress, Vote> votes, long l,
-            long zxid) {
-
-        int count = 0;
-        Collection<Vote> votesCast = votes.values();
-        /*
-         * First make the views consistent. Sometimes peers will have
-         * different zxids for a server depending on timing.
-         */
-        for (Vote v : votesCast) {
-            if ((v.id == l) && (v.zxid == zxid))
-                count++;
-        }
-        
-        if (count > (self.quorumPeers.size() / 2))
-            return true;
-        else
-            return false;
-
-    }
-
-    public Vote lookForLeader() throws InterruptedException {
-        HashMap<InetAddress, Vote> recvset = new HashMap<InetAddress, Vote>();
-
-        HashMap<InetAddress, Vote> outofelection = new HashMap<InetAddress, Vote>();
-
-        logicalclock++;
-
-        proposedLeader = self.getId();
-        proposedZxid = self.getLastLoggedZxid();
-
-        ZooLog.logWarn("Election tally: " + proposedZxid);
-        sendNotifications();
-
-        /*
-         * Loop in which we exchange notifications until we find a leader
-         */
-
-        while (self.state == ServerState.LOOKING) {
-            /*
-             * Remove next notification from queue, times out after 2 times
-             * the termination time
-             */
-            Notification n = recvqueue.poll(2*finalizeWait, TimeUnit.MILLISECONDS);
-            
-            /*
-             * Sends more notifications if haven't received enough.
-             * Otherwise processes new notification.
-             */
-            if(n == null){
-            	if(manager.haveDelivered()){
-            		sendNotifications();
-            	}
-            }
-            else switch (n.state) {
-            case LOOKING:
-            	// If notification > current, replace and send messages out
-            	if (n.epoch > logicalclock) {
-                    logicalclock = n.epoch;
-                    recvset.clear();
-                    if(totalOrderPredicate(n.leader, n.zxid)){
-                    	proposedLeader = n.leader;
-                        proposedZxid = n.zxid;
-                    }
-                    sendNotifications();
-                } else if (n.epoch < logicalclock) {
-                	break;
-                } else if (totalOrderPredicate(n.leader, n.zxid)) {
-                	proposedLeader = n.leader;
-                    proposedZxid = n.zxid;
-
-                    sendNotifications();
-                }
-
-                recvset.put(n.addr, new Vote(n.leader,
-                        n.zxid));
-
-                //If have received from all nodes, then terminate
-                if (self.quorumPeers.size() == recvset.size()) {
-                    self.state = (proposedLeader == self.getId()) ? ServerState.LEADING
-                            : ServerState.FOLLOWING;
-                    leaveInstance();
-                    return new Vote(proposedLeader, proposedZxid);
-
-                } else if (termPredicate(recvset, proposedLeader, proposedZxid)) {
-                    //Otherwise, wait for a fixed amount of time
-                    ZooLog.logWarn("Passed predicate");
-                    Thread.sleep(finalizeWait);
-
-                    // Verify if there is any change in the proposed leader
-                    while ((!recvqueue.isEmpty())
-                            && !totalOrderPredicate(recvqueue.peek().leader,
-                                    recvqueue.peek().zxid)) {
-                        recvqueue.poll();
-                    }
-                    if (recvqueue.isEmpty()) {
-                        self.state = (proposedLeader == self.getId()) ? ServerState.LEADING
-                                : ServerState.FOLLOWING;
-                        leaveInstance();
-                        return new Vote(proposedLeader,
-                                proposedZxid);
-                    }
-                }
-                break;
-            case LEADING:
-                outofelection.put(n.addr, new Vote(n.leader, n.zxid));
-
-                if (termPredicate(outofelection, n.leader, n.zxid)) {
-                    
-                    self.state = (n.leader == self.getId()) ? ServerState.LEADING
-                            : ServerState.FOLLOWING;
-
-                    leaveInstance();
-                    return new Vote(n.leader, n.zxid);
-                }
-                break;
-            case FOLLOWING:
-                outofelection.put(n.addr, new Vote(n.leader, n.zxid));
-
-                if (termPredicate(outofelection, n.leader, n.zxid)) {
-                    
-                    self.state = (n.leader == self.getId()) ? ServerState.LEADING
-                            : ServerState.FOLLOWING;
-
-                    leaveInstance();
-                    return new Vote(n.leader, n.zxid);
-                }
-                break;
-            default:
-                break;
-            }
-        }
-
-        return null;
-    }
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package com.yahoo.zookeeper.server.quorum;
+
+import java.net.DatagramSocket;
+import java.net.InetAddress;
+import java.nio.ByteBuffer;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Random;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+import com.yahoo.zookeeper.server.ZooLog;
+import com.yahoo.zookeeper.server.quorum.QuorumCnxManager.Message;
+import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+import com.yahoo.zookeeper.server.quorum.QuorumPeer.ServerState;
+
+
+/**
+ * Implementation of leader election using TCP. It uses an object of the class 
+ * QuorumCnxManager to manage connections. Otherwise, the algorithm is push-based
+ * as with the other UDP implementations. 
+ * 
+ * There are a few parameters that can be tuned to change its behavior. First, 
+ * finalizeWait determines the amount of time to wait until deciding upon a leader.
+ * This is part of the leader election algorithm.
+ */
+
+
+public class FastLeaderElection implements Election {
+
+	/* Sequence numbers for messages */
+    static int sequencer = 0;
+
+    /*
+     * Determine how much time a process has to wait
+     * once it believes that it has reached the end of
+     * leader election.
+     */
+    static int finalizeWait = 100;
+
+    /*
+	 * Challenge counter to avoid replay attacks
+	 */
+	
+	static int challengeCounter = 0;
+	
+	/*
+	 * Flag to determine whether to authenticate or not
+	 */
+    
+	private boolean authEnabled = false;
+    
+	/*
+	 * Connection manager
+	 */
+	
+	QuorumCnxManager manager;
+
+    static public class Notification {
+        /*
+         * Proposed leader
+         */
+        long leader;
+
+        /*
+         * zxid of the proposed leader
+         */
+        long zxid;
+
+        /*
+         * Epoch
+         */
+        long epoch;
+
+        /*
+         * current state of sender
+         */
+        QuorumPeer.ServerState state;
+        
+        /*
+         * Address of sender
+         */
+        InetAddress addr;
+    }
+
+    /*
+     * Messages to send, both Notifications and Acks
+     */
+    static public class ToSend {
+    	static enum mType {crequest, challenge, notification, ack};
+        
+        ToSend(mType type, 
+        		long leader, 
+        		long zxid, 
+        		long epoch, 
+        		ServerState state,
+        		InetAddress addr) {
+        
+        	this.leader = leader;
+        	this.zxid = zxid;
+        	this.epoch = epoch;
+        	this.state = state;
+        	this.addr = addr;
+        }
+        
+        /*
+         * Proposed leader in the case of notification
+         */
+        long leader;
+
+        /*
+         * id contains the tag for acks, and zxid for notifications
+         */
+        long zxid;
+
+        /*
+         * Epoch
+         */
+        long epoch;
+
+        /*
+         * Current state;
+         */
+        QuorumPeer.ServerState state;
+        
+        /*
+         * Address of recipient
+         */
+        InetAddress addr;
+    }
+
+    LinkedBlockingQueue<ToSend> sendqueue;
+    LinkedBlockingQueue<Notification> recvqueue;
+
+    private class Messenger {
+    	
+        DatagramSocket mySocket;
+        long lastProposedLeader;
+        long lastProposedZxid;
+        long lastEpoch;
+        
+        class WorkerReceiver implements Runnable {
+
+        	QuorumCnxManager manager;
+            Messenger msg;
+
+            WorkerReceiver(QuorumCnxManager manager, Messenger msg) {
+                this.manager = manager;
+                this.msg = msg;
+            }
+
+            public void run() {
+                
+            	Message response;
+            	while (true) {
+                    // Sleeps on receive
+            		try{
+            			response = manager.recvQueue.take();
+            			
+            			// Receive new message
+            			if (response.buffer.capacity() < 28) {
+            				ZooLog.logError("Got a short response: "
+            						+ response.buffer.capacity());
+            				continue;
+            			}
+            			response.buffer.clear();
+               
+
+            			QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;
+            			switch (response.buffer.getInt()) {
+            			case 0:
+            				ackstate = QuorumPeer.ServerState.LOOKING;
+            				break;
+            			case 1:
+            				ackstate = QuorumPeer.ServerState.LEADING;
+            				break;
+            			case 2:
+            				ackstate = QuorumPeer.ServerState.FOLLOWING;
+            				break;
+            			}
+                    	
+            			Notification n = new Notification();
+            			n.leader = response.buffer.getLong();
+            			n.zxid = response.buffer.getLong();
+            			n.epoch = response.buffer.getLong();
+            			n.state = ackstate;
+            			n.addr = response.addr;
+
+            			if ((messenger.lastEpoch <= n.epoch)
+            					&& ((n.zxid > messenger.lastProposedZxid) 
+            					|| ((n.zxid == messenger.lastProposedZxid) 
+            					&& (n.leader > messenger.lastProposedLeader)))) {
+            				messenger.lastProposedZxid = n.zxid;
+            				messenger.lastProposedLeader = n.leader;
+            				messenger.lastEpoch = n.epoch;
+            			}
+
+            			//InetAddress addr = (InetAddress) responsePacket.getSocketAddress();
+            			if(self.getPeerState() == QuorumPeer.ServerState.LOOKING){
+            				recvqueue.offer(n);
+            				if(recvqueue.size() == 0) ZooLog.logWarn("Message: " + n.addr);
+            				if((ackstate == QuorumPeer.ServerState.LOOKING)
+            						&& (n.epoch < logicalclock)){
+            					ToSend notmsg = new ToSend(ToSend.mType.notification, 
+                						proposedLeader, 
+                						proposedZxid,
+                						logicalclock,
+                						self.getPeerState(),
+                						response.addr);
+                				sendqueue.offer(notmsg);
+            				}
+            			} else { 	           				
+            				if((ackstate == QuorumPeer.ServerState.LOOKING) &&
+            						(self.getPeerState() != QuorumPeer.ServerState.LOOKING)){
+            					ToSend notmsg = new ToSend(ToSend.mType.notification, 
+            						self.currentVote.id, 
+            						self.currentVote.zxid,
+            						logicalclock,
+            						self.getPeerState(),
+            						response.addr);
+            					sendqueue.offer(notmsg);
+            				}
+            			}
+            			
+            		} catch (InterruptedException e) {
+            			System.out.println("Interrupted Exception while waiting for new message" +
+            					e.toString());
+            		}
+            	}
+            }
+        }
+
+        class WorkerSender implements Runnable {
+        	
+            Random rand;
+            QuorumCnxManager manager;
+            boolean processing;
+            int ackWait = finalizeWait / 6;
+
+            
+            WorkerSender(QuorumCnxManager manager){ 
+                rand = new Random(java.lang.Thread.currentThread().getId() + System.currentTimeMillis());
+                this.manager = manager;
+            }
+            
+            public void run() {
+                while (true) {
+                    try {
+                        ToSend m = sendqueue.take();
+                        process(m);
+                    } catch (InterruptedException e) {
+                        break;
+                    }
+
+                }
+            }
+
+            private void process(ToSend m) {
+                int attempts = 0;
+                byte requestBytes[] = new byte[28];
+                ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);  
+                
+                /*
+                 * Building notification packet to send
+                 */
+                    
+                requestBuffer.clear();
+                requestBuffer.putInt(m.state.ordinal());
+                requestBuffer.putLong(m.leader);
+                requestBuffer.putLong(m.zxid);
+                requestBuffer.putLong(m.epoch);
+                
+                manager.toSend(m.addr, requestBuffer);
+                  
+            }
+        }
+
+        public boolean queueEmpty() {
+            return (sendqueue.isEmpty() || recvqueue.isEmpty());
+        }
+
+        Messenger(QuorumCnxManager manager) {
+            lastProposedLeader = 0;
+            lastProposedZxid = 0;
+            lastEpoch = 0;
+
+            Thread t = new Thread(new WorkerSender(manager),
+            		"WorkerSender Thread");
+            t.setDaemon(true);
+            t.start();
+
+            t = new Thread(new WorkerReceiver(manager, this),
+                    				"WorkerReceiver Thread");
+            t.setDaemon(true);
+            t.start();
+        }
+
+    }
+
+    QuorumPeer self;
+    int port;
+    long logicalclock; /* Election instance */
+    Messenger messenger;
+    DatagramSocket mySocket;
+    long proposedLeader;
+    long proposedZxid;
+
+        
+    public FastLeaderElection(QuorumPeer self, QuorumCnxManager manager){
+    	this.manager = manager;
+    	starter(self, manager);
+    }
+    
+    private void starter(QuorumPeer self, QuorumCnxManager manager) {
+        this.self = self;
+        proposedLeader = -1;
+        proposedZxid = -1;
+
+        sendqueue = new LinkedBlockingQueue<ToSend>();
+        recvqueue = new LinkedBlockingQueue<Notification>();
+        messenger = new Messenger(manager);
+    }
+
+    private void leaveInstance() {
+        recvqueue.clear();
+    }
+
+    public static class ElectionResult {
+        public Vote vote;
+
+        public int count;
+
+        public Vote winner;
+
+        public int winningCount;
+    }
+
+    private void sendNotifications() {
+        for (QuorumServer server : self.quorumPeers) {
+            InetAddress saddr = server.addr.getAddress();
+
+            ToSend notmsg = new ToSend(ToSend.mType.notification, 
+            		proposedLeader, 
+            		proposedZxid,
+                    logicalclock,
+                    QuorumPeer.ServerState.LOOKING,
+                    saddr);
+
+            sendqueue.offer(notmsg);
+        }
+    }
+
+    private boolean totalOrderPredicate(long id, long zxid) {
+        if ((zxid > proposedZxid)
+                || ((zxid == proposedZxid) && (id > proposedLeader)))
+            return true;
+        else
+            return false;
+
+    }
+
+    private boolean termPredicate(
+            HashMap<InetAddress, Vote> votes, long l,
+            long zxid) {
+
+        int count = 0;
+        Collection<Vote> votesCast = votes.values();
+        /*
+         * First make the views consistent. Sometimes peers will have
+         * different zxids for a server depending on timing.
+         */
+        for (Vote v : votesCast) {
+            if ((v.id == l) && (v.zxid == zxid))
+                count++;
+        }
+        
+        if (count > (self.quorumPeers.size() / 2))
+            return true;
+        else
+            return false;
+
+    }
+
+    public Vote lookForLeader() throws InterruptedException {
+        HashMap<InetAddress, Vote> recvset = new HashMap<InetAddress, Vote>();
+
+        HashMap<InetAddress, Vote> outofelection = new HashMap<InetAddress, Vote>();
+
+        logicalclock++;
+
+        proposedLeader = self.getId();
+        proposedZxid = self.getLastLoggedZxid();
+
+        ZooLog.logWarn("Election tally: " + proposedZxid);
+        sendNotifications();
+
+        /*
+         * Loop in which we exchange notifications until we find a leader
+         */
+
+        while (self.getPeerState() == ServerState.LOOKING) {
+            /*
+             * Remove next notification from queue, times out after 2 times
+             * the termination time
+             */
+            Notification n = recvqueue.poll(2*finalizeWait, TimeUnit.MILLISECONDS);
+            
+            /*
+             * Sends more notifications if haven't received enough.
+             * Otherwise processes new notification.
+             */
+            if(n == null){
+            	if(manager.haveDelivered()){
+            		sendNotifications();
+            	}
+            }
+            else switch (n.state) {
+            case LOOKING:
+            	// If notification > current, replace and send messages out
+            	if (n.epoch > logicalclock) {
+                    logicalclock = n.epoch;
+                    recvset.clear();
+                    if(totalOrderPredicate(n.leader, n.zxid)){
+                    	proposedLeader = n.leader;
+                        proposedZxid = n.zxid;
+                    }
+                    sendNotifications();
+                } else if (n.epoch < logicalclock) {
+                	break;
+                } else if (totalOrderPredicate(n.leader, n.zxid)) {
+                	proposedLeader = n.leader;
+                    proposedZxid = n.zxid;
+
+                    sendNotifications();
+                }
+
+                recvset.put(n.addr, new Vote(n.leader,
+                        n.zxid));
+
+                //If have received from all nodes, then terminate
+                if (self.quorumPeers.size() == recvset.size()) {
+                    self.setPeerState((proposedLeader == self.getId()) ? 
+                    		ServerState.LEADING: ServerState.FOLLOWING);
+                    leaveInstance();
+                    return new Vote(proposedLeader, proposedZxid);
+
+                } else if (termPredicate(recvset, proposedLeader, proposedZxid)) {
+                    //Otherwise, wait for a fixed amount of time
+                    ZooLog.logWarn("Passed predicate");
+                    Thread.sleep(finalizeWait);
+
+                    // Verify if there is any change in the proposed leader
+                    while ((!recvqueue.isEmpty())
+                            && !totalOrderPredicate(recvqueue.peek().leader,
+                                    recvqueue.peek().zxid)) {
+                        recvqueue.poll();
+                    }
+                    if (recvqueue.isEmpty()) {
+                        self.setPeerState((proposedLeader == self.getId()) ? 
+                        		ServerState.LEADING: ServerState.FOLLOWING);
+                        leaveInstance();
+                        return new Vote(proposedLeader,
+                                proposedZxid);
+                    }
+                }
+                break;
+            case LEADING:
+                outofelection.put(n.addr, new Vote(n.leader, n.zxid));
+
+                if (termPredicate(outofelection, n.leader, n.zxid)) {
+                    
+                    self.setPeerState((n.leader == self.getId()) ? 
+                    		ServerState.LEADING: ServerState.FOLLOWING);
+
+                    leaveInstance();
+                    return new Vote(n.leader, n.zxid);
+                }
+                break;
+            case FOLLOWING:
+                outofelection.put(n.addr, new Vote(n.leader, n.zxid));
+
+                if (termPredicate(outofelection, n.leader, n.zxid)) {
+                    
+                    self.setPeerState((n.leader == self.getId()) ? 
+                    		ServerState.LEADING: ServerState.FOLLOWING);
+
+                    leaveInstance();
+                    return new Vote(n.leader, n.zxid);
+                }
+                break;
+            default:
+                break;
+            }
+        }
+
+        return null;
+    }
+}
<EOC>
<SOC>
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketAddress;
-import java.util.HashSet;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.concurrent.ConcurrentLinkedQueue;
 

 import com.yahoo.zookeeper.server.Request;
 import com.yahoo.zookeeper.server.RequestProcessor;
 import com.yahoo.zookeeper.server.ZooLog;
-import com.yahoo.zookeeper.server.quorum.QuorumPeer.ServerState;
 
 /**
  * This class has the control logic for the Leader.

         }
     }
 
+    boolean isFollowerSynced(FollowerHandler follower){
+        synchronized (forwardingFollowers) {
+            return forwardingFollowers.contains(follower);
+        }        
+    }
+    
     ServerSocket ss;
 
     Leader(QuorumPeer self,LeaderZooKeeperServer zk) throws IOException {
         this.self = self;
         try {
-            ss = new ServerSocket(self.myQuorumAddr.getPort());
+            ss = new ServerSocket(self.getQuorumAddress().getPort());
         } catch (BindException e) {
             ZooLog.logError("Couldn't bind to port "
-                    + self.myQuorumAddr.getPort());
+                    + self.getQuorumAddress().getPort());
             throw e;
         }
         this.zk=zk;

                         + " followers, only synced with "
                         + newLeaderProposal.ackCount);
                 if (followers.size() >= self.quorumPeers.size() / 2) {
-                    ZooLog
-                            .logWarn("Enough followers present. Perhaps the initTicks need to be increased.");
+                    ZooLog.logWarn("Enough followers present. "+
+                            "Perhaps the initTicks need to be increased.");
                 }
-                self.state = ServerState.LOOKING;
                 return;
             }
             Thread.sleep(self.tickTime);

                         + (self.quorumPeers.size() / 2));
                 // make sure the order is the same!
                 // the leader goes to looking
-                self.state = ServerState.LOOKING;
-
                 return;
             }
             tickSkip = !tickSkip;

         sendPacket(qp);
                
         if(pendingSyncs.containsKey(zxid)){
-        	sendSync(syncHandler.get(pendingSyncs.get(zxid).sessionId), pendingSyncs.get(zxid));
-        	syncHandler.remove(pendingSyncs.get(zxid));
-        	pendingSyncs.remove(zxid);
+            sendSync(syncHandler.get(pendingSyncs.get(zxid).sessionId), pendingSyncs.get(zxid));
+            syncHandler.remove(pendingSyncs.get(zxid));
+            pendingSyncs.remove(zxid);
         }
     }
 

      * @return the proposal that is queued to send to all the members
      */
     public Proposal propose(Request request) {
-    	
-    	
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    	BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
-    	try {
-    		request.hdr.serialize(boa, "hdr");
-    		if (request.txn != null) {
-    			request.txn.serialize(boa, "txn");
-    		}
-    		baos.close();
-    	} catch (IOException e) {
-    		// This really should be impossible
-    		ZooLog.logException(e);
-    	}
-    	QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, baos
+        
+        
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
+        try {
+            request.hdr.serialize(boa, "hdr");
+            if (request.txn != null) {
+                request.txn.serialize(boa, "txn");
+            }
+            baos.close();
+        } catch (IOException e) {
+            // This really should be impossible
+            ZooLog.logException(e);
+        }
+        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, baos
                 .toByteArray(), null);
-    	
+        
         Proposal p = new Proposal();
         p.packet = pp;
         p.request = request;

      */
     
     public void processSync(Request r){
-    	if(outstandingProposals.isEmpty()){
-    		ZooLog.logWarn("No outstanding proposal");
-    		sendSync(syncHandler.get(r.sessionId), r);
-    			syncHandler.remove(r.sessionId);
-    	}
-    	else{
-    		pendingSyncs.put(lastProposed, r);
-    	}
+        if(outstandingProposals.isEmpty()){
+            ZooLog.logWarn("No outstanding proposal");
+            sendSync(syncHandler.get(r.sessionId), r);
+                syncHandler.remove(r.sessionId);
+        }
+        else{
+            pendingSyncs.put(lastProposed, r);
+        }
     }
         
     /**

      */
         
     synchronized public void setSyncHandler(FollowerHandler f, long s){
-    	syncHandler.put(s, f);
+        syncHandler.put(s, f);
     }
             
     /**

      */
             
     public void sendSync(FollowerHandler f, Request r){
-    	QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);
-    	f.queuePacket(qp);
+        QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);
+        f.queuePacket(qp);
     }
                 
     /**
<EOC>
<SOC>
-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetSocketAddress;
-import java.net.SocketException;
-import java.nio.ByteBuffer;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Random;
-import java.util.Map.Entry;
-
-import com.yahoo.zookeeper.server.ZooLog;
-import com.yahoo.zookeeper.server.quorum.Vote;
-import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;
-import com.yahoo.zookeeper.server.quorum.QuorumPeer.ServerState;
-
-public class LeaderElection {
-    //static public class Vote {
-    //    public Vote(long id, long zxid) {
-    //        this.id = id;
-    //        this.zxid = zxid;
-    //    }
-    //
-    //    public long id;
-    //
-    //    public long zxid;
-    //
-    //    @Override
-    //    public boolean equals(Object o) {
-    //        if (!(o instanceof Vote)) {
-    //            return false;
-    //        }
-    //        Vote other = (Vote) o;
-    //        return id == other.id && zxid == other.zxid;
-    //    }
-    //
-    //    @Override
-    //    public int hashCode() {
-    //        return (int) (id & zxid);
-    //    }
-    //
-   // }
-
-    QuorumPeer self;
-
-    public LeaderElection(QuorumPeer self) {
-        this.self = self;
-    }
-
-    public static class ElectionResult {
-        public Vote vote;
-
-        public int count;
-
-        public Vote winner;
-
-        public int winningCount;
-    }
-
-    private ElectionResult countVotes(HashMap<InetSocketAddress, Vote> votes) {
-        ElectionResult result = new ElectionResult();
-        // Initialize with null vote
-        result.vote = new Vote(Long.MIN_VALUE, Long.MIN_VALUE);
-        result.winner = new Vote(Long.MIN_VALUE, Long.MIN_VALUE);
-        Collection<Vote> votesCast = votes.values();
-        // First make the views consistent. Sometimes peers will have
-        // different zxids for a server depending on timing.
-        for (Vote v : votesCast) {
-            for (Vote w : votesCast) {
-                if (v.id == w.id) {
-                    if (v.zxid < w.zxid) {
-                        v.zxid = w.zxid;
-                    }
-                }
-            }
-        }
-        HashMap<Vote, Integer> countTable = new HashMap<Vote, Integer>();
-        // Now do the tally
-        for (Vote v : votesCast) {
-            Integer count = countTable.get(v);
-            if (count == null) {
-                count = new Integer(0);
-            }
-            countTable.put(v, count + 1);
-            if (v.id == result.vote.id) {
-                result.count++;
-            } else if (v.zxid > result.vote.zxid
-                    || (v.zxid == result.vote.zxid && v.id > result.vote.id)) {
-                result.vote = v;
-                result.count = 1;
-            }
-        }
-        result.winningCount = 0;
-        ZooLog.logWarn("Election tally: ");
-        for (Entry<Vote, Integer> entry : countTable.entrySet()) {
-            if (entry.getValue() > result.winningCount) {
-                result.winningCount = entry.getValue();
-                result.winner = entry.getKey();
-            }
-            ZooLog.logWarn(entry.getKey().id + "\t-> " + entry.getValue());
-        }
-        return result;
-    }
-
-    public Vote lookForLeader() throws InterruptedException {
-        self.currentVote = new Vote(self.getId(), self.getLastLoggedZxid());
-        // We are going to look for a leader by casting a vote for ourself
-        byte requestBytes[] = new byte[4];
-        ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);
-        byte responseBytes[] = new byte[28];
-        ByteBuffer responseBuffer = ByteBuffer.wrap(responseBytes);
-        /* The current vote for the leader. Initially me! */
-        DatagramSocket s = null;
-        try {
-            s = new DatagramSocket();
-            s.setSoTimeout(200);
-        } catch (SocketException e1) {
-            e1.printStackTrace();
-            System.exit(4);
-        }
-        DatagramPacket requestPacket = new DatagramPacket(requestBytes,
-                requestBytes.length);
-        DatagramPacket responsePacket = new DatagramPacket(responseBytes,
-                responseBytes.length);
-        HashMap<InetSocketAddress, Vote> votes = new HashMap<InetSocketAddress, Vote>(
-                self.quorumPeers.size());
-        int xid = new Random().nextInt();
-        while (self.running) {
-            votes.clear();
-            requestBuffer.clear();
-            requestBuffer.putInt(xid);
-            requestPacket.setLength(4);
-            for (QuorumServer server : self.quorumPeers) {
-                requestPacket.setSocketAddress(server.addr);
-                try {
-                    s.send(requestPacket);
-                    responsePacket.setLength(responseBytes.length);
-                    s.receive(responsePacket);
-                    if (responsePacket.getLength() != responseBytes.length) {
-                        ZooLog.logError("Got a short response: "
-                                + responsePacket.getLength());
-                        continue;
-                    }
-                    responseBuffer.clear();
-                    int recvedXid = responseBuffer.getInt();
-                    if (recvedXid != xid) {
-                        ZooLog.logError("Got bad xid: expected " + xid
-                                + " got " + recvedXid);
-                        continue;
-                    }
-                    long peerId = responseBuffer.getLong();
-                    //if(server.id != peerId){
-                        Vote vote = new Vote(responseBuffer.getLong(),
-                            responseBuffer.getLong());
-                        InetSocketAddress addr = (InetSocketAddress) responsePacket
-                            .getSocketAddress();
-                        votes.put(addr, vote);
-                    //}
-                } catch (IOException e) {
-                    // Errors are okay, since hosts may be
-                    // down
-                    // ZooKeeperServer.logException(e);
-                }
-            }
-            ElectionResult result = countVotes(votes);
-            if (result.winner.id >= 0) {
-                self.currentVote = result.vote;
-                if (result.winningCount > (self.quorumPeers.size() / 2)) {
-                    self.currentVote = result.winner;
-                    s.close();
-                    self.state = (self.currentVote.id == self.getId()) 
-							? ServerState.LEADING: ServerState.FOLLOWING;
-                    if (self.state == ServerState.FOLLOWING) {
-                        Thread.sleep(100);
-                    }
-                    return self.currentVote;
-                }
-            }
-            Thread.sleep(1000);
-        }
-        return null;
-    }
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetSocketAddress;
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Random;
+import java.util.Map.Entry;
+
+import com.yahoo.zookeeper.server.ZooLog;
+import com.yahoo.zookeeper.server.quorum.Vote;
+import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+import com.yahoo.zookeeper.server.quorum.QuorumPeer.ServerState;
+
+public class LeaderElection implements Election  {
+    QuorumPeer self;
+
+    public LeaderElection(QuorumPeer self) {
+        this.self = self;
+    }
+
+    public static class ElectionResult {
+        public Vote vote;
+
+        public int count;
+
+        public Vote winner;
+
+        public int winningCount;
+    }
+
+    private ElectionResult countVotes(HashMap<InetSocketAddress, Vote> votes) {
+        ElectionResult result = new ElectionResult();
+        // Initialize with null vote
+        result.vote = new Vote(Long.MIN_VALUE, Long.MIN_VALUE);
+        result.winner = new Vote(Long.MIN_VALUE, Long.MIN_VALUE);
+        Collection<Vote> votesCast = votes.values();
+        // First make the views consistent. Sometimes peers will have
+        // different zxids for a server depending on timing.
+        for (Vote v : votesCast) {
+            for (Vote w : votesCast) {
+                if (v.id == w.id) {
+                    if (v.zxid < w.zxid) {
+                        v.zxid = w.zxid;
+                    }
+                }
+            }
+        }
+        HashMap<Vote, Integer> countTable = new HashMap<Vote, Integer>();
+        // Now do the tally
+        for (Vote v : votesCast) {
+            Integer count = countTable.get(v);
+            if (count == null) {
+                count = new Integer(0);
+            }
+            countTable.put(v, count + 1);
+            if (v.id == result.vote.id) {
+                result.count++;
+            } else if (v.zxid > result.vote.zxid
+                    || (v.zxid == result.vote.zxid && v.id > result.vote.id)) {
+                result.vote = v;
+                result.count = 1;
+            }
+        }
+        result.winningCount = 0;
+        ZooLog.logWarn("Election tally: ");
+        for (Entry<Vote, Integer> entry : countTable.entrySet()) {
+            if (entry.getValue() > result.winningCount) {
+                result.winningCount = entry.getValue();
+                result.winner = entry.getKey();
+            }
+            ZooLog.logWarn(entry.getKey().id + "\t-> " + entry.getValue());
+        }
+        return result;
+    }
+
+    public Vote lookForLeader() throws InterruptedException {
+        self.currentVote = new Vote(self.getId(), self.getLastLoggedZxid());
+        // We are going to look for a leader by casting a vote for ourself
+        byte requestBytes[] = new byte[4];
+        ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);
+        byte responseBytes[] = new byte[28];
+        ByteBuffer responseBuffer = ByteBuffer.wrap(responseBytes);
+        /* The current vote for the leader. Initially me! */
+        DatagramSocket s = null;
+        try {
+            s = new DatagramSocket();
+            s.setSoTimeout(200);
+        } catch (SocketException e1) {
+            e1.printStackTrace();
+            System.exit(4);
+        }
+        DatagramPacket requestPacket = new DatagramPacket(requestBytes,
+                requestBytes.length);
+        DatagramPacket responsePacket = new DatagramPacket(responseBytes,
+                responseBytes.length);
+        HashMap<InetSocketAddress, Vote> votes = new HashMap<InetSocketAddress, Vote>(
+                self.quorumPeers.size());
+        int xid = new Random().nextInt();
+        while (self.running) {
+            votes.clear();
+            requestBuffer.clear();
+            requestBuffer.putInt(xid);
+            requestPacket.setLength(4);
+            for (QuorumServer server : self.quorumPeers) {
+                requestPacket.setSocketAddress(server.addr);
+                try {
+                    s.send(requestPacket);
+                    responsePacket.setLength(responseBytes.length);
+                    s.receive(responsePacket);
+                    if (responsePacket.getLength() != responseBytes.length) {
+                        ZooLog.logError("Got a short response: "
+                                + responsePacket.getLength());
+                        continue;
+                    }
+                    responseBuffer.clear();
+                    int recvedXid = responseBuffer.getInt();
+                    if (recvedXid != xid) {
+                        ZooLog.logError("Got bad xid: expected " + xid
+                                + " got " + recvedXid);
+                        continue;
+                    }
+                    responseBuffer.getLong();
+                    //if(server.id != peerId){
+                        Vote vote = new Vote(responseBuffer.getLong(),
+                            responseBuffer.getLong());
+                        InetSocketAddress addr = (InetSocketAddress) responsePacket
+                            .getSocketAddress();
+                        votes.put(addr, vote);
+                    //}
+                } catch (IOException e) {
+                    // Errors are okay, since hosts may be
+                    // down
+                    // ZooKeeperServer.logException(e);
+                }
+            }
+            ElectionResult result = countVotes(votes);
+            if (result.winner.id >= 0) {
+                self.currentVote = result.vote;
+                if (result.winningCount > (self.quorumPeers.size() / 2)) {
+                    self.currentVote = result.winner;
+                    s.close();
+                    self.setPeerState((self.currentVote.id == self.getId()) 
+                            ? ServerState.LEADING: ServerState.FOLLOWING);
+                    if (self.getPeerState() == ServerState.FOLLOWING) {
+                        Thread.sleep(100);
+                    }
+                    return self.currentVote;
+                }
+            }
+            Thread.sleep(1000);
+        }
+        return null;
+    }
+}
<EOC>
<SOC>
-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-import java.lang.InterruptedException;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Random;
-import java.util.concurrent.ArrayBlockingQueue;
-import java.net.SocketAddress;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
-import java.nio.ByteBuffer;
-import java.nio.channels.SocketChannel;
-import java.nio.channels.ServerSocketChannel;
-
-import com.yahoo.zookeeper.server.ZooLog;
-
-/**
- * This class implements a connection manager for leader election using TCP. It
- * maintains one coonection for every pair of servers. The tricky part is to
- * guarantee that there is exactly one connection for every pair of servers that
- * are operating correctly and that can communicate over the network.
- * 
- * If two servers try to start a connection concurrently, then the connection
- * manager uses a very simple tie-breaking mechanism to decide which connection
- * to drop based on the IP addressed of the two parties. 
- * 
- * For every peer, the manager maintains a queue of messages to send. If the
- * connection to any particular peer drops, then the sender thread puts the
- * message back on the list. As this implementation currently uses a queue
- * implementation to maintain messages to send to another peer, we add the
- * message to the tail of the queue, thus changing the order of messages.
- * Although this is not a problem for the leader election, it could be a problem
- * when consolidating peer communication. This is to be verified, though.
- * 
- */
-
-class QuorumCnxManager extends Thread {
-    /*
-     * Maximum capacity of thread queues
-     */
-
-    static final int CAPACITY = 100;
-
-    /*
-     * Maximum number of attempts to connect to a peer
-     */
-
-    static final int MAX_CONNECTION_ATTEMPTS = 2;
-
-    /*
-     * Packet size
-     */
-    int packetSize;
-
-    /*
-     * Port to listen on
-     */
-    int port;
-
-    /*
-     * Challenge to initiate connections
-     */
-    long challenge;
-
-    /*
-     * Local IP address
-     */
-    InetAddress localIP;
-
-    /*
-     * Mapping from Peer to Thread number
-     */
-    HashMap<InetAddress, SendWorker> senderWorkerMap;
-    HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>> queueSendMap;
-
-    /*
-     * Reception queue
-     */
-    ArrayBlockingQueue<Message> recvQueue;
-
-    /*
-     * Shutdown flag
-     */
-
-    boolean shutdown = false;
-
-    /*
-     * Listener thread
-     */
-    Listener listener;
-
-    class Message {
-        Message(ByteBuffer buffer, InetAddress addr) {
-            this.buffer = buffer;
-            this.addr = addr;
-        }
-
-        ByteBuffer buffer;
-        InetAddress addr;
-    }
-
-    QuorumCnxManager(int port) {
-        this.port = port;
-        this.recvQueue = new ArrayBlockingQueue<Message>(CAPACITY);
-        this.queueSendMap = new HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>>();
-        this.senderWorkerMap = new HashMap<InetAddress, SendWorker>();
-
-        try {
-            localIP = InetAddress.getLocalHost();
-        } catch (UnknownHostException e) {
-            ZooLog.logWarn("Couldn't get local address");
-        }
-
-        // Generates a challenge to guarantee one connection between pairs of
-        // servers
-        genChallenge();
-
-        // Starts listener thread that waits for connection requests 
-        listener = new Listener(this);
-        listener.start();
-    }
-
-    void genChallenge() {
-        Random rand = new Random(System.currentTimeMillis()
-                + localIP.hashCode());
-        long newValue = rand.nextLong();
-        challenge = newValue;
-    }
-
-    /**
-     * If this server has initiated the connection, then it gives up on the
-     * connection if it loses challenge. Otherwise, it keeps the connection.
-     */
-
-    boolean initiateConnection(SocketChannel s) {
-        boolean challenged = true;
-        boolean wins = false;
-        long newChallenge;
-
-        // Compare IP addresses based on their hash codes 
-        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
-        //if(hashCodeRemote >= localIP.hashCode()){
-        //    wins = false;
-        //} else {
-        //    wins = true;
-        //} 
-        //ZooLog.logWarn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
-        
-        try {
-            while (challenged && s.isConnected()) {
-                // Sending challenge
-                byte[] msgBytes = new byte[8];
-                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
-                msgBuffer.putLong(challenge);
-                msgBuffer.position(0);
-                s.write(msgBuffer);
-        
-                      // Reading challenge
-                    msgBuffer.position(0);
-                  int numBytes = s.read(msgBuffer);
-        
-                 msgBuffer.position(0);
-               newChallenge = msgBuffer.getLong();
-                if (challenge > newChallenge) {
-                   wins = true;
-                    challenged = false;
-                } else if (challenge == newChallenge) {
-                    genChallenge();
-                } else {
-                    challenged = false;
-                }
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn("Exception reading or writing challenge: "
-                    + e.toString());
-            return false;
-        }
-
-        // If lost the challenge, then drop the new connection
-        if (!wins) {
-            try {
-                //ZooLog.logWarn("lost cause (initiate");
-                s.socket().close();
-            } catch (IOException e) {
-                ZooLog
-                        .logWarn("Error when closing socket or trying to reopen connection: "
-                                + e.toString());
-
-            }
-        // Otherwise proceed with the connection
-        } else
-            synchronized (senderWorkerMap) {
-                /*
-                 * It may happen that a thread from a previous connection to the same
-                 * server is still active. In this case, we terminate the thread by
-                 * calling finish(). Note that senderWorkerMap is a map from IP 
-                 * addresses to worker thread.
-                 */
-                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
-                    senderWorkerMap.get(s.socket().getInetAddress()).finish();
-                }
-
-                /*
-                 * Start new worker thread with a clean state.
-                 */
-                SendWorker sw = new SendWorker(s);
-                if (s != null) {
-                    RecvWorker rw = new RecvWorker(s);
-                    sw.setRecv(rw);
-
-                    if (senderWorkerMap
-                            .containsKey(s.socket().getInetAddress())) {
-                        InetAddress addr = s.socket().getInetAddress();
-                        senderWorkerMap.get(addr).finish();
-                    }
-
-                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
-                    sw.start();
-                    rw.start();
-
-                    return true;
-                } else {
-                    ZooLog.logWarn("Channel null");
-                    return false;
-                }
-            }
-
-        return false;
-    }
-
-    /**
-     * If this server receives a connection request, then it gives up on the new
-     * connection if it wins. Notice that it checks whether it has a connection
-     * to this server already or not. If it does, then it sends the smallest
-     * possible long value to lose the challenge.
-     * 
-     */
-    boolean receiveConnection(SocketChannel s) {
-        boolean challenged = true;
-        boolean wins = false;
-        long newChallenge;
-       
-        
-        //Compare IP addresses based on their hash codes.
-        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
-        //if(hashCodeRemote >= localIP.hashCode()){
-        //    wins = false;
-        //} else {
-        //    wins = true;
-        //} 
-        
-        //ZooLog.logWarn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
-        
-        
-        try {
-            while (challenged && s.isConnected()) {
-               // Sending challenge
-                byte[] msgBytes = new byte[8];
-                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
-                long vsent;
-                if (senderWorkerMap.get(s.socket().getInetAddress()) == null)
-                    vsent = Long.MIN_VALUE;
-                else
-                    vsent = challenge;
-                msgBuffer.putLong(vsent);
-                msgBuffer.position(0);
-                s.write(msgBuffer);
-        
-                // Reading challenge
-                msgBuffer.position(0);
-                int numBytes = s.read(msgBuffer);
-        
-                msgBuffer.position(0);
-                newChallenge = msgBuffer.getLong();
-                if (vsent > newChallenge) {
-                    wins = true;
-                    challenged = false;
-                } else if (challenge == newChallenge) {
-                    genChallenge();
-                } else {
-                    challenged = false;
-                }
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn("Exception reading or writing challenge: "
-                    + e.toString());
-            return false;
-        }
-
-        //If wins the challenge, then close the new connection.
-        if (wins) {
-            try {
-                InetAddress addr = s.socket().getInetAddress();
-                SendWorker sw = senderWorkerMap.get(addr);
-
-                //ZooLog.logWarn("Keep connection (received)");
-                //sw.connect();
-                s.socket().close();
-                sw.finish();
-                SocketChannel channel = SocketChannel.open(new InetSocketAddress(addr, port));
-                if (channel.isConnected()) {
-                    initiateConnection(channel);
-                }
-                
-                
-            } catch (IOException e) {
-                ZooLog
-                        .logWarn("Error when closing socket or trying to reopen connection: "
-                                + e.toString());
-            }
-        //Otherwise start worker threads to receive data.
-        } else
-            synchronized (senderWorkerMap) {
-                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
-                    senderWorkerMap.get(s.socket().getInetAddress()).finish();       
-                }
-                
-                SendWorker sw = new SendWorker(s);
-                if (s != null) {
-                    RecvWorker rw = new RecvWorker(s);
-                    sw.setRecv(rw);
-
-                    if (senderWorkerMap
-                            .containsKey(s.socket().getInetAddress())) {
-                        InetAddress addr = s.socket().getInetAddress();
-                        senderWorkerMap.get(addr).finish();
-                    }
-
-                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
-                    sw.start();
-                    rw.start();
-
-                    return true;
-                } else {
-                    ZooLog.logWarn("Channel null");
-                    return false;
-                }
-            }
-
-        return false;
-    }
-
-    /**
-     * Processes invoke this message to send a message. Currently, only leader
-     * election uses it.
-     */
-    void toSend(InetAddress addr, ByteBuffer b) {
-        /*
-         * If sending message to myself, then simply enqueue it (loopback).
-         */
-        if (addr.equals(localIP)) {
-            try {
-                b.position(0);
-                recvQueue.put(new Message(b.duplicate(), addr));
-            } catch (InterruptedException e) {
-                ZooLog.logWarn("Exception when loopbacking");
-            }
-        /*
-         * Otherwise send to the corresponding thread to send. 
-         */
-        } else
-            try {
-                /*
-                 * Start a new connection if doesn't have one already.
-                 */
-                if (!queueSendMap.containsKey(addr)) {
-                    queueSendMap.put(addr, new ArrayBlockingQueue<ByteBuffer>(
-                            CAPACITY));
-                    queueSendMap.get(addr).put(b);
-
-                } else {
-                    if (queueSendMap.get(addr).remainingCapacity() == 0) {
-                        queueSendMap.get(addr).take();
-                    }
-                    queueSendMap.get(addr).put(b);
-                }
-                
-                synchronized (senderWorkerMap) {
-                    if (senderWorkerMap.get(addr) == null) {
-                        SocketChannel channel;
-                        try {
-                            channel = SocketChannel
-                                    .open(new InetSocketAddress(addr, port));
-                            channel.socket().setTcpNoDelay(true);
-                            initiateConnection(channel);
-                        } catch (IOException e) {
-                            ZooLog.logWarn("Cannot open channel to "
-                                    + addr.toString() + "( " + e.toString()
-                                    + ")");
-                        }
-                    }
-                }     
-            } catch (InterruptedException e) {
-                ZooLog
-                        .logWarn("Interrupted while waiting to put message in queue."
-                                + e.toString());
-            }
-    }
-
-    /**
-     * Check if all queues are empty, indicating that all messages have been delivered.
-     */
-    boolean haveDelivered() {
-        for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {
-            if (queue.size() == 0)
-                return true;
-        }
-
-        return false;
-    }
-
-    /**
-     * Flag that it is time to wrap up all activities and interrupt the listener.
-     */
-    public void shutdown() {
-        shutdown = true;
-        listener.interrupt();
-    }
-
-    /**
-     * Thread to listen on some port
-     */
-    class Listener extends Thread {
-        QuorumCnxManager manager;
-
-        Listener(QuorumCnxManager m) {
-            manager = m;
-        }
-
-        /**
-         * Sleeps on accept().
-         */
-        public void run() {
-            ServerSocketChannel ss = null;
-            try {
-                if (ss != null)
-                    ss.close();
-                ss = ServerSocketChannel.open();
-                ss.socket().bind(new InetSocketAddress(port));
-
-                while (!shutdown) {
-                    SocketChannel client = ss.accept();
-                    client.socket().setTcpNoDelay(true);
-                    /*
-                     * This synchronized block guarantees that if
-                     * both parties try to connect to each other
-                     * simultaneously, then only one will succeed.
-                     * If we don't have this block, then there 
-                     * are runs in which both parties act as if they
-                     * don't have any connection starting or started.
-                     * In receiveConnection(), a server sends the minimum
-                     * value for a challenge, if they believe they must
-                     * accept the connection because they don't have one.
-                     * 
-                     * This synchronized block prevents that the same server
-                     * invokes receiveConnection() and initiateConnection() 
-                     * simultaneously.
-                     */
-                    synchronized(senderWorkerMap){
-                        ZooLog.logWarn("Connection request");
-                        receiveConnection(client);
-                    }
-                }
-            } catch (IOException e) {
-                System.err.println("Listener.run: " + e.getMessage());
-            }
-        }
-    }
-
-    /**
-     * Thread to send messages. Instance waits on a queue, and send a message as
-     * soon as there is one available. If connection breaks, then opens a new
-     * one.
-     */
-
-    class SendWorker extends Thread {
-        // Send msgs to peer
-        InetAddress addr;
-        SocketChannel channel;
-        RecvWorker recvWorker;
-        boolean running = true;
-
-        SendWorker(SocketChannel channel) {
-            this.addr = channel.socket().getInetAddress();
-            this.channel = channel;
-            recvWorker = null;
-        }
-
-        void setRecv(RecvWorker recvWorker) {
-            this.recvWorker = recvWorker;
-        }
-
-        //boolean connect() throws IOException {
-        //    if (recvWorker != null)
-        //        recvWorker.finish();
-        //
-        //    channel = SocketChannel.open(new InetSocketAddress(addr, port));
-        //    if (channel.isConnected()) {
-        //        recvWorker = new RecvWorker(channel);
-        //        initiateConnection(channel);
-        //        ZooLog.logWarn("Opened new connection");
-        //    } else {
-        //        ZooLog.logWarn("Channel not connected.");
-        //    }
-        //
-        //    return channel.isConnected();
-        //}
-
-        boolean finish() {
-            running = false;
-
-            this.interrupt();
-            if (recvWorker != null)
-                recvWorker.finish();
-            senderWorkerMap.remove(channel.socket().getInetAddress());
-            return running;
-        }
-
-        public void run() {
-
-            long init, init1, end1, end;
-            while (running && !shutdown) {
-
-                ByteBuffer b = null;
-                try {
-                    init = System.currentTimeMillis();
-                    b = queueSendMap.get(addr).take();
-                } catch (InterruptedException e) {
-                    ZooLog
-                            .logWarn("Interrupted while waiting for message on queue ("
-                                    + e.toString() + ")");
-                    continue;
-                }
-
-                try {
-                    byte[] msgBytes = new byte[b.capacity()
-                            + (Integer.SIZE / 8)];
-                    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
-                    msgBuffer.putInt(b.capacity());
-                    int tmpSize = b.capacity() + (Integer.SIZE / 8);
-
-                    msgBuffer.put(b.array(), 0, b.capacity());
-                    msgBuffer.position(0);
-                    int numbytes = channel.write(msgBuffer);
-                    end = System.currentTimeMillis() - init;
-
-                } catch (IOException e) {
-                    /*
-                     * If reconnection doesn't work, then put the
-                     * message back to the beginning of the queue and leave.
-                     */
-                    ZooLog.logWarn("Exception when using channel: " + addr
-                            + ")" + e.toString());
-                    running = false;
-                    synchronized (senderWorkerMap) {
-                        recvWorker.finish();
-                        recvWorker = null;
-                    
-                        senderWorkerMap.remove(channel.socket().getInetAddress());
-                    
-                        if (b != null) {
-                            if (queueSendMap.get(channel.socket().getInetAddress())
-                                    .size() == 0)
-                                queueSendMap.get(channel.socket().getInetAddress())
-                                    .offer(b);
-                        }
-                    }
-                }
-            }
-            ZooLog.logWarn("Leaving thread");
-        }
-    }
-
-    /**
-     * Thread to receive messages. Instance waits on a socket read. If the
-     * channel breaks, then removes itself from the pool of receivers.
-     */
-
-    class RecvWorker extends Thread {
-        InetAddress addr;
-        SocketChannel channel;
-        boolean running = true;
-
-        RecvWorker(SocketChannel channel) {
-            this.addr = channel.socket().getInetAddress();
-            this.channel = channel;
-        }
-
-        boolean finish() {
-            running = false;
-            this.interrupt();
-            return running;
-        }
-
-        public void run() {
-            try {
-                byte[] size = new byte[4];
-                ByteBuffer msgLength = ByteBuffer.wrap(size);
-                while (running && !shutdown && channel.isConnected()) {
-                    /**
-                     * Reads the first int to determine the length of the
-                     * message
-                     */
-                    while (msgLength.hasRemaining()) {
-                        channel.read(msgLength);
-                    }
-                    msgLength.position(0);
-                    int length = msgLength.getInt();
-
-                    /**
-                     * Allocates a new ByteBuffer to receive the message
-                     */
-                    if (length > 0) {
-                        byte[] msgArray = new byte[length];
-                        ByteBuffer message = ByteBuffer.wrap(msgArray);
-                        int numbytes = 0;
-                        while (message.hasRemaining()) {
-                            numbytes += channel.read(message);
-                        }
-                        message.position(0);
-                        synchronized (recvQueue) {
-                            recvQueue
-                                    .put(new Message(message.duplicate(), addr));
-                        }
-                        msgLength.position(0);
-                    }
-                }
-
-            } catch (IOException e) {
-                ZooLog.logWarn("Connection broken: " + e.toString());
-
-            } catch (InterruptedException e) {
-                ZooLog.logWarn("Interrupted while trying to add new "
-                        + "message to the reception queue (" + e.toString()
-                        + ")");
-            }
-        }
-    }
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.nio.ByteBuffer;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SocketChannel;
+import java.util.HashMap;
+import java.util.Random;
+import java.util.concurrent.ArrayBlockingQueue;
+
+import com.yahoo.zookeeper.server.ZooLog;
+
+/**
+ * This class implements a connection manager for leader election using TCP. It
+ * maintains one coonection for every pair of servers. The tricky part is to
+ * guarantee that there is exactly one connection for every pair of servers that
+ * are operating correctly and that can communicate over the network.
+ * 
+ * If two servers try to start a connection concurrently, then the connection
+ * manager uses a very simple tie-breaking mechanism to decide which connection
+ * to drop based on the IP addressed of the two parties. 
+ * 
+ * For every peer, the manager maintains a queue of messages to send. If the
+ * connection to any particular peer drops, then the sender thread puts the
+ * message back on the list. As this implementation currently uses a queue
+ * implementation to maintain messages to send to another peer, we add the
+ * message to the tail of the queue, thus changing the order of messages.
+ * Although this is not a problem for the leader election, it could be a problem
+ * when consolidating peer communication. This is to be verified, though.
+ * 
+ */
+
+class QuorumCnxManager extends Thread {
+    /*
+     * Maximum capacity of thread queues
+     */
+
+    static final int CAPACITY = 100;
+
+    /*
+     * Maximum number of attempts to connect to a peer
+     */
+
+    static final int MAX_CONNECTION_ATTEMPTS = 2;
+
+    /*
+     * Packet size
+     */
+    int packetSize;
+
+    /*
+     * Port to listen on
+     */
+    int port;
+
+    /*
+     * Challenge to initiate connections
+     */
+    long challenge;
+
+    /*
+     * Local IP address
+     */
+    InetAddress localIP;
+
+    /*
+     * Mapping from Peer to Thread number
+     */
+    HashMap<InetAddress, SendWorker> senderWorkerMap;
+    HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>> queueSendMap;
+
+    /*
+     * Reception queue
+     */
+    ArrayBlockingQueue<Message> recvQueue;
+
+    /*
+     * Shutdown flag
+     */
+
+    boolean shutdown = false;
+
+    /*
+     * Listener thread
+     */
+    Listener listener;
+
+    class Message {
+        Message(ByteBuffer buffer, InetAddress addr) {
+            this.buffer = buffer;
+            this.addr = addr;
+        }
+
+        ByteBuffer buffer;
+        InetAddress addr;
+    }
+
+    QuorumCnxManager(int port) {
+        this.port = port;
+        this.recvQueue = new ArrayBlockingQueue<Message>(CAPACITY);
+        this.queueSendMap = new HashMap<InetAddress, ArrayBlockingQueue<ByteBuffer>>();
+        this.senderWorkerMap = new HashMap<InetAddress, SendWorker>();
+
+        try {
+            localIP = InetAddress.getLocalHost();
+        } catch (UnknownHostException e) {
+            ZooLog.logWarn("Couldn't get local address");
+        }
+
+        // Generates a challenge to guarantee one connection between pairs of
+        // servers
+        genChallenge();
+
+        // Starts listener thread that waits for connection requests 
+        listener = new Listener(this);
+        listener.start();
+    }
+
+    void genChallenge() {
+        Random rand = new Random(System.currentTimeMillis()
+                + localIP.hashCode());
+        long newValue = rand.nextLong();
+        challenge = newValue;
+    }
+
+    /**
+     * If this server has initiated the connection, then it gives up on the
+     * connection if it loses challenge. Otherwise, it keeps the connection.
+     */
+
+    boolean initiateConnection(SocketChannel s) {
+        boolean challenged = true;
+        boolean wins = false;
+        long newChallenge;
+
+        // Compare IP addresses based on their hash codes 
+        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
+        //if(hashCodeRemote >= localIP.hashCode()){
+        //    wins = false;
+        //} else {
+        //    wins = true;
+        //} 
+        //ZooLog.logWarn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
+        
+        try {
+            while (challenged && s.isConnected()) {
+                // Sending challenge
+                byte[] msgBytes = new byte[8];
+                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
+                msgBuffer.putLong(challenge);
+                msgBuffer.position(0);
+                s.write(msgBuffer);
+        
+                      // Reading challenge
+                    msgBuffer.position(0);
+                  int numBytes = s.read(msgBuffer);
+        
+                 msgBuffer.position(0);
+               newChallenge = msgBuffer.getLong();
+                if (challenge > newChallenge) {
+                   wins = true;
+                    challenged = false;
+                } else if (challenge == newChallenge) {
+                    genChallenge();
+                } else {
+                    challenged = false;
+                }
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn("Exception reading or writing challenge: "
+                    + e.toString());
+            return false;
+        }
+
+        // If lost the challenge, then drop the new connection
+        if (!wins) {
+            try {
+                //ZooLog.logWarn("lost cause (initiate");
+                s.socket().close();
+            } catch (IOException e) {
+                ZooLog
+                        .logWarn("Error when closing socket or trying to reopen connection: "
+                                + e.toString());
+
+            }
+        // Otherwise proceed with the connection
+        } else
+            synchronized (senderWorkerMap) {
+                /*
+                 * It may happen that a thread from a previous connection to the same
+                 * server is still active. In this case, we terminate the thread by
+                 * calling finish(). Note that senderWorkerMap is a map from IP 
+                 * addresses to worker thread.
+                 */
+                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
+                    senderWorkerMap.get(s.socket().getInetAddress()).finish();
+                }
+
+                /*
+                 * Start new worker thread with a clean state.
+                 */
+                SendWorker sw = new SendWorker(s);
+                if (s != null) {
+                    RecvWorker rw = new RecvWorker(s);
+                    sw.setRecv(rw);
+
+                    if (senderWorkerMap
+                            .containsKey(s.socket().getInetAddress())) {
+                        InetAddress addr = s.socket().getInetAddress();
+                        senderWorkerMap.get(addr).finish();
+                    }
+
+                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
+                    sw.start();
+                    rw.start();
+
+                    return true;
+                } else {
+                    ZooLog.logWarn("Channel null");
+                    return false;
+                }
+            }
+
+        return false;
+    }
+
+    /**
+     * If this server receives a connection request, then it gives up on the new
+     * connection if it wins. Notice that it checks whether it has a connection
+     * to this server already or not. If it does, then it sends the smallest
+     * possible long value to lose the challenge.
+     * 
+     */
+    boolean receiveConnection(SocketChannel s) {
+        boolean challenged = true;
+        boolean wins = false;
+        long newChallenge;
+       
+        
+        //Compare IP addresses based on their hash codes.
+        //int hashCodeRemote = s.socket().getInetAddress().hashCode();
+        //if(hashCodeRemote >= localIP.hashCode()){
+        //    wins = false;
+        //} else {
+        //    wins = true;
+        //} 
+        
+        //ZooLog.logWarn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
+        
+        
+        try {
+            while (challenged && s.isConnected()) {
+               // Sending challenge
+                byte[] msgBytes = new byte[8];
+                ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
+                long vsent;
+                if (senderWorkerMap.get(s.socket().getInetAddress()) == null)
+                    vsent = Long.MIN_VALUE;
+                else
+                    vsent = challenge;
+                msgBuffer.putLong(vsent);
+                msgBuffer.position(0);
+                s.write(msgBuffer);
+        
+                // Reading challenge
+                msgBuffer.position(0);
+                s.read(msgBuffer);
+        
+                msgBuffer.position(0);
+                newChallenge = msgBuffer.getLong();
+                if (vsent > newChallenge) {
+                    wins = true;
+                    challenged = false;
+                } else if (challenge == newChallenge) {
+                    genChallenge();
+                } else {
+                    challenged = false;
+                }
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn("Exception reading or writing challenge: "
+                    + e.toString());
+            return false;
+        }
+
+        //If wins the challenge, then close the new connection.
+        if (wins) {
+            try {
+                InetAddress addr = s.socket().getInetAddress();
+                SendWorker sw = senderWorkerMap.get(addr);
+
+                //ZooLog.logWarn("Keep connection (received)");
+                //sw.connect();
+                s.socket().close();
+                sw.finish();
+                SocketChannel channel = SocketChannel.open(new InetSocketAddress(addr, port));
+                if (channel.isConnected()) {
+                    initiateConnection(channel);
+                }
+                
+                
+            } catch (IOException e) {
+                ZooLog
+                        .logWarn("Error when closing socket or trying to reopen connection: "
+                                + e.toString());
+            }
+        //Otherwise start worker threads to receive data.
+        } else
+            synchronized (senderWorkerMap) {
+                if (senderWorkerMap.get(s.socket().getInetAddress()) != null) {
+                    senderWorkerMap.get(s.socket().getInetAddress()).finish();       
+                }
+                
+                SendWorker sw = new SendWorker(s);
+                if (s != null) {
+                    RecvWorker rw = new RecvWorker(s);
+                    sw.setRecv(rw);
+
+                    if (senderWorkerMap
+                            .containsKey(s.socket().getInetAddress())) {
+                        InetAddress addr = s.socket().getInetAddress();
+                        senderWorkerMap.get(addr).finish();
+                    }
+
+                    senderWorkerMap.put(s.socket().getInetAddress(), sw);
+                    sw.start();
+                    rw.start();
+
+                    return true;
+                } else {
+                    ZooLog.logWarn("Channel null");
+                    return false;
+                }
+            }
+
+        return false;
+    }
+
+    /**
+     * Processes invoke this message to send a message. Currently, only leader
+     * election uses it.
+     */
+    void toSend(InetAddress addr, ByteBuffer b) {
+        /*
+         * If sending message to myself, then simply enqueue it (loopback).
+         */
+        if (addr.equals(localIP)) {
+            try {
+                b.position(0);
+                recvQueue.put(new Message(b.duplicate(), addr));
+            } catch (InterruptedException e) {
+                ZooLog.logWarn("Exception when loopbacking");
+            }
+        /*
+         * Otherwise send to the corresponding thread to send. 
+         */
+        } else
+            try {
+                /*
+                 * Start a new connection if doesn't have one already.
+                 */
+                if (!queueSendMap.containsKey(addr)) {
+                    queueSendMap.put(addr, new ArrayBlockingQueue<ByteBuffer>(
+                            CAPACITY));
+                    queueSendMap.get(addr).put(b);
+
+                } else {
+                    if (queueSendMap.get(addr).remainingCapacity() == 0) {
+                        queueSendMap.get(addr).take();
+                    }
+                    queueSendMap.get(addr).put(b);
+                }
+                
+                synchronized (senderWorkerMap) {
+                    if (senderWorkerMap.get(addr) == null) {
+                        SocketChannel channel;
+                        try {
+                            channel = SocketChannel
+                                    .open(new InetSocketAddress(addr, port));
+                            channel.socket().setTcpNoDelay(true);
+                            initiateConnection(channel);
+                        } catch (IOException e) {
+                            ZooLog.logWarn("Cannot open channel to "
+                                    + addr.toString() + "( " + e.toString()
+                                    + ")");
+                        }
+                    }
+                }     
+            } catch (InterruptedException e) {
+                ZooLog
+                        .logWarn("Interrupted while waiting to put message in queue."
+                                + e.toString());
+            }
+    }
+
+    /**
+     * Check if all queues are empty, indicating that all messages have been delivered.
+     */
+    boolean haveDelivered() {
+        for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {
+            if (queue.size() == 0)
+                return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Flag that it is time to wrap up all activities and interrupt the listener.
+     */
+    public void shutdown() {
+        shutdown = true;
+        listener.interrupt();
+    }
+
+    /**
+     * Thread to listen on some port
+     */
+    class Listener extends Thread {
+        QuorumCnxManager manager;
+
+        Listener(QuorumCnxManager m) {
+            manager = m;
+        }
+
+        /**
+         * Sleeps on accept().
+         */
+        public void run() {
+            ServerSocketChannel ss = null;
+            try {
+                if (ss != null)
+                    ss.close();
+                ss = ServerSocketChannel.open();
+                ss.socket().bind(new InetSocketAddress(port));
+
+                while (!shutdown) {
+                    SocketChannel client = ss.accept();
+                    client.socket().setTcpNoDelay(true);
+                    /*
+                     * This synchronized block guarantees that if
+                     * both parties try to connect to each other
+                     * simultaneously, then only one will succeed.
+                     * If we don't have this block, then there 
+                     * are runs in which both parties act as if they
+                     * don't have any connection starting or started.
+                     * In receiveConnection(), a server sends the minimum
+                     * value for a challenge, if they believe they must
+                     * accept the connection because they don't have one.
+                     * 
+                     * This synchronized block prevents that the same server
+                     * invokes receiveConnection() and initiateConnection() 
+                     * simultaneously.
+                     */
+                    synchronized(senderWorkerMap){
+                        ZooLog.logWarn("Connection request");
+                        receiveConnection(client);
+                    }
+                }
+            } catch (IOException e) {
+                System.err.println("Listener.run: " + e.getMessage());
+            }
+        }
+    }
+
+    /**
+     * Thread to send messages. Instance waits on a queue, and send a message as
+     * soon as there is one available. If connection breaks, then opens a new
+     * one.
+     */
+
+    class SendWorker extends Thread {
+        // Send msgs to peer
+        InetAddress addr;
+        SocketChannel channel;
+        RecvWorker recvWorker;
+        boolean running = true;
+
+        SendWorker(SocketChannel channel) {
+            this.addr = channel.socket().getInetAddress();
+            this.channel = channel;
+            recvWorker = null;
+        }
+
+        void setRecv(RecvWorker recvWorker) {
+            this.recvWorker = recvWorker;
+        }
+
+        //boolean connect() throws IOException {
+        //    if (recvWorker != null)
+        //        recvWorker.finish();
+        //
+        //    channel = SocketChannel.open(new InetSocketAddress(addr, port));
+        //    if (channel.isConnected()) {
+        //        recvWorker = new RecvWorker(channel);
+        //        initiateConnection(channel);
+        //        ZooLog.logWarn("Opened new connection");
+        //    } else {
+        //        ZooLog.logWarn("Channel not connected.");
+        //    }
+        //
+        //    return channel.isConnected();
+        //}
+
+        boolean finish() {
+            running = false;
+
+            this.interrupt();
+            if (recvWorker != null)
+                recvWorker.finish();
+            senderWorkerMap.remove(channel.socket().getInetAddress());
+            return running;
+        }
+
+        public void run() {
+
+            long init, init1, end1, end;
+            while (running && !shutdown) {
+
+                ByteBuffer b = null;
+                try {
+                    init = System.currentTimeMillis();
+                    b = queueSendMap.get(addr).take();
+                } catch (InterruptedException e) {
+                    ZooLog
+                            .logWarn("Interrupted while waiting for message on queue ("
+                                    + e.toString() + ")");
+                    continue;
+                }
+
+                try {
+                    byte[] msgBytes = new byte[b.capacity()
+                            + (Integer.SIZE / 8)];
+                    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
+                    msgBuffer.putInt(b.capacity());
+                    int tmpSize = b.capacity() + (Integer.SIZE / 8);
+
+                    msgBuffer.put(b.array(), 0, b.capacity());
+                    msgBuffer.position(0);
+                    int numbytes = channel.write(msgBuffer);
+                    end = System.currentTimeMillis() - init;
+
+                } catch (IOException e) {
+                    /*
+                     * If reconnection doesn't work, then put the
+                     * message back to the beginning of the queue and leave.
+                     */
+                    ZooLog.logWarn("Exception when using channel: " + addr
+                            + ")" + e.toString());
+                    running = false;
+                    synchronized (senderWorkerMap) {
+                        recvWorker.finish();
+                        recvWorker = null;
+                    
+                        senderWorkerMap.remove(channel.socket().getInetAddress());
+                    
+                        if (b != null) {
+                            if (queueSendMap.get(channel.socket().getInetAddress())
+                                    .size() == 0)
+                                queueSendMap.get(channel.socket().getInetAddress())
+                                    .offer(b);
+                        }
+                    }
+                }
+            }
+            ZooLog.logWarn("Leaving thread");
+        }
+    }
+
+    /**
+     * Thread to receive messages. Instance waits on a socket read. If the
+     * channel breaks, then removes itself from the pool of receivers.
+     */
+
+    class RecvWorker extends Thread {
+        InetAddress addr;
+        SocketChannel channel;
+        boolean running = true;
+
+        RecvWorker(SocketChannel channel) {
+            this.addr = channel.socket().getInetAddress();
+            this.channel = channel;
+        }
+
+        boolean finish() {
+            running = false;
+            this.interrupt();
+            return running;
+        }
+
+        public void run() {
+            try {
+                byte[] size = new byte[4];
+                ByteBuffer msgLength = ByteBuffer.wrap(size);
+                while (running && !shutdown && channel.isConnected()) {
+                    /**
+                     * Reads the first int to determine the length of the
+                     * message
+                     */
+                    while (msgLength.hasRemaining()) {
+                        channel.read(msgLength);
+                    }
+                    msgLength.position(0);
+                    int length = msgLength.getInt();
+
+                    /**
+                     * Allocates a new ByteBuffer to receive the message
+                     */
+                    if (length > 0) {
+                        byte[] msgArray = new byte[length];
+                        ByteBuffer message = ByteBuffer.wrap(msgArray);
+                        int numbytes = 0;
+                        while (message.hasRemaining()) {
+                            numbytes += channel.read(message);
+                        }
+                        message.position(0);
+                        synchronized (recvQueue) {
+                            recvQueue
+                                    .put(new Message(message.duplicate(), addr));
+                        }
+                        msgLength.position(0);
+                    }
+                }
+
+            } catch (IOException e) {
+                ZooLog.logWarn("Connection broken: " + e.toString());
+
+            } catch (InterruptedException e) {
+                ZooLog.logWarn("Interrupted while trying to add new "
+                        + "message to the reception queue (" + e.toString()
+                        + ")");
+            }
+        }
+    }
 }
\ No newline at end of file
<EOC>
<SOC>
-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-
-import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.*;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetSocketAddress;
-import java.net.SocketException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.InputArchive;
-import com.yahoo.zookeeper.server.NIOServerCnxn;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooLog;
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+
+import static com.yahoo.zookeeper.server.ServerConfig.getClientPort;
+import static com.yahoo.zookeeper.server.ServerConfig.getDataDir;
+import static com.yahoo.zookeeper.server.ServerConfig.getDataLogDir;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getElectionAlg;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getElectionPort;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getInitLimit;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getServerId;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getServers;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getSyncLimit;
+import static com.yahoo.zookeeper.server.quorum.QuorumPeerConfig.getTickTime;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetSocketAddress;
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.InputArchive;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooLog;
 import com.yahoo.zookeeper.server.quorum.Vote;
 import com.yahoo.zookeeper.server.quorum.FastLeaderElection;
 import com.yahoo.zookeeper.server.quorum.QuorumCnxManager;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-/**
- * This class manages the quorum protocol. There are three states this server
- * can be in:
- * <ol>
- * <li>Leader election - each server will elect a leader (proposing itself as a
- * leader initially).</li>
- * <li>Follower - the server will synchronize with the leader and replicate any
- * transactions.</li>
- * <li>Leader - the server will process requests and forward them to followers.
- * A majority of followers must log the request before it can be accepted.
- * </ol>
- * 
- * This class will setup a datagram socket that will always respond with its
- * view of the current leader. The response will take the form of:
- * 
- * <pre>
- * int xid;
- * 
- * long myid;
- * 
- * long leader_id;
- * 
- * long leader_zxid;
- * </pre>
- * 
- * The request for the current leader will consist solely of an xid: int xid;
- * 
- * <h2>Configuration file</h2>
- * 
- * When the main() method of this class is used to start the program, the file
- * "zoo.cfg" in the current directory will be used to obtain configuration
- * information. zoo.cfg is a Properties file, so keys and values are separated
- * by equals (=) and the key/value pairs are separated by new lines. The
- * following keys are used in the configuration file:
- * <ol>
- * <li>dataDir - The directory where the zookeeper data is stored.</li>
- * <li>clientPort - The port used to communicate with clients.</li>
- * <li>tickTime - The duration of a tick in milliseconds. This is the basic
- * unit of time in zookeeper.</li>
- * <li>initLimit - The maximum number of ticks that a follower will wait to
- * initially synchronize with a leader.</li>
- * <li>syncLimit - The maximum number of ticks that a follower will wait for a
- * message (including heartbeats) from the leader.</li>
- * <li>server.<i>id</i> - This is the host:port that the server with the
- * given id will use for the quorum protocol.</li>
- * </ol>
- * In addition to the zoo.cfg file. There is a file in the data directory called
- * "myid" that contains the server id as an ASCII decimal value.
- */
-public class QuorumPeer extends Thread {
-	/**
-	 * Create an instance of a quorum peer 
-	 */
-	public interface Factory{
-		public QuorumPeer create() throws IOException;
-	}
-    public static class QuorumServer {
-        public QuorumServer(long id, InetSocketAddress addr) {
-            this.id = id;
-            this.addr = addr;
-        }
-
-        public InetSocketAddress addr;
-
-        public long id;
-    }
-
-    public enum ServerState {
-        LOOKING, FOLLOWING, LEADING;
-    }
-    /**
-     * The servers that make up the cluster
-     */
-    ArrayList<QuorumServer> quorumPeers;
-    public int getQuorumSize(){
-    	return quorumPeers.size();
-    }
-    /**
-     * My id
-     */
-    private long myid;
-
-
-    /**
-     * get the id of this quorum peer.
-     */
-    public long getId() {
-    	return myid;
-    }
-
-    /**
-     * This is who I think the leader currently is.
-     */
-    volatile Vote currentVote;
-
-    boolean running = true;
-
-    /**
-     * The number of milliseconds of each tick
-     */
-    int tickTime;
-
-    /**
-     * The number of ticks that the initial synchronization phase can take
-     */
-    int initLimit;
-
-    /**
-     * The number of ticks that can pass between sending a request and getting
-     * an acknowledgement
-     */
-    int syncLimit;
-
-    /**
-     * The current tick
-     */
-    int tick;
-
-    /**
-     * This class simply responds to requests for the current leader of this
-     * node.
-     * <p>
-     * The request contains just an xid generated by the requestor.
-     * <p>
-     * The response has the xid, the id of this server, the id of the leader,
-     * and the zxid of the leader.
-     * 
-     * @author breed
-     * 
-     */
-    class ResponderThread extends Thread {
-        ResponderThread() {
-            super("ResponderThread");
-        }
-
-        public void run() {
-            try {
-                byte b[] = new byte[36];
-                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
-                DatagramPacket packet = new DatagramPacket(b, b.length);
-                while (true) {
-                    udpSocket.receive(packet);
-                    if (packet.getLength() != 4) {
-                        ZooLog.logError("Got more than just an xid! Len = "
-                                + packet.getLength());
-                    } else {
-                        responseBuffer.clear();
-                        responseBuffer.getInt(); // Skip the xid
-                        responseBuffer.putLong(myid);
-                        switch (state) {
-                        case LOOKING:
-                            responseBuffer.putLong(currentVote.id);
-                            responseBuffer.putLong(currentVote.zxid);
-                            break;
-                        case LEADING:
-                            responseBuffer.putLong(myid);
-                            try {
-                                responseBuffer.putLong(leader.lastProposed);
-                            } catch (NullPointerException npe) {
-                                // This can happen in state transitions,
-                                // just ignore the request
-                            }
-                            break;
-                        case FOLLOWING:
-                            responseBuffer.putLong(currentVote.id);
-                            try {
-                                responseBuffer.putLong(follower.getZxid());
-                            } catch (NullPointerException npe) {
-                                // This can happen in state transitions,
-                                // just ignore the request
-                            }
-                        }
-                        packet.setData(b);
-                        udpSocket.send(packet);
-                    }
-                    packet.setLength(b.length);
-                }
-            } catch (Exception e) {
-                ZooLog.logException(e);
-            } finally {
-                ZooLog.logError("QuorumPeer responder thread exited");
-            }
-        }
-    }
-
-    public ServerState state = ServerState.LOOKING;
-
-    DatagramSocket udpSocket;
-
-    InetSocketAddress myQuorumAddr;
-
-    /**
-     * the directory where the snapshot is stored.
-     */
-    private File dataDir;
-
-    /**
-     * the directory where the logs are stored.
-     */
-    private File dataLogDir;
-
-    int clientPort;
-
-    int electionAlg;
-    
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+/**
+ * This class manages the quorum protocol. There are three states this server
+ * can be in:
+ * <ol>
+ * <li>Leader election - each server will elect a leader (proposing itself as a
+ * leader initially).</li>
+ * <li>Follower - the server will synchronize with the leader and replicate any
+ * transactions.</li>
+ * <li>Leader - the server will process requests and forward them to followers.
+ * A majority of followers must log the request before it can be accepted.
+ * </ol>
+ * 
+ * This class will setup a datagram socket that will always respond with its
+ * view of the current leader. The response will take the form of:
+ * 
+ * <pre>
+ * int xid;
+ * 
+ * long myid;
+ * 
+ * long leader_id;
+ * 
+ * long leader_zxid;
+ * </pre>
+ * 
+ * The request for the current leader will consist solely of an xid: int xid;
+ * 
+ * <h2>Configuration file</h2>
+ * 
+ * When the main() method of this class is used to start the program, the file
+ * "zoo.cfg" in the current directory will be used to obtain configuration
+ * information. zoo.cfg is a Properties file, so keys and values are separated
+ * by equals (=) and the key/value pairs are separated by new lines. The
+ * following keys are used in the configuration file:
+ * <ol>
+ * <li>dataDir - The directory where the zookeeper data is stored.</li>
+ * <li>clientPort - The port used to communicate with clients.</li>
+ * <li>tickTime - The duration of a tick in milliseconds. This is the basic
+ * unit of time in zookeeper.</li>
+ * <li>initLimit - The maximum number of ticks that a follower will wait to
+ * initially synchronize with a leader.</li>
+ * <li>syncLimit - The maximum number of ticks that a follower will wait for a
+ * message (including heartbeats) from the leader.</li>
+ * <li>server.<i>id</i> - This is the host:port that the server with the
+ * given id will use for the quorum protocol.</li>
+ * </ol>
+ * In addition to the zoo.cfg file. There is a file in the data directory called
+ * "myid" that contains the server id as an ASCII decimal value.
+ */
+public class QuorumPeer extends Thread implements QuorumStats.Provider {
+    /**
+     * Create an instance of a quorum peer 
+     */
+    public interface Factory{
+        public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) throws IOException;
+        public NIOServerCnxn.Factory createConnectionFactory() throws IOException;
+    }
+    
+    public static class QuorumServer {
+        public QuorumServer(long id, InetSocketAddress addr) {
+            this.id = id;
+            this.addr = addr;
+        }
+
+        public InetSocketAddress addr;
+
+        public long id;
+    }
+
+    public enum ServerState {
+        LOOKING, FOLLOWING, LEADING;
+    }
+    /**
+     * The servers that make up the cluster
+     */
+    ArrayList<QuorumServer> quorumPeers;
+    public int getQuorumSize(){
+        return quorumPeers.size();
+    }
+    /**
+     * My id
+     */
+    private long myid;
+
+
+    /**
+     * get the id of this quorum peer.
+     */
+    public long getId() {
+        return myid;
+    }
+
+    /**
+     * This is who I think the leader currently is.
+     */
+    volatile Vote currentVote;
+
+    volatile boolean running = true;
+
+    /**
+     * The number of milliseconds of each tick
+     */
+    int tickTime;
+
+    /**
+     * The number of ticks that the initial synchronization phase can take
+     */
+    int initLimit;
+
+    /**
+     * The number of ticks that can pass between sending a request and getting
+     * an acknowledgement
+     */
+    int syncLimit;
+
+    /**
+     * The current tick
+     */
+    int tick;
+
+    /**
+     * This class simply responds to requests for the current leader of this
+     * node.
+     * <p>
+     * The request contains just an xid generated by the requestor.
+     * <p>
+     * The response has the xid, the id of this server, the id of the leader,
+     * and the zxid of the leader.
+     * 
+     * @author breed
+     * 
+     */
+    class ResponderThread extends Thread {
+        ResponderThread() {
+            super("ResponderThread");
+        }
+
+        public void run() {
+            try {
+                byte b[] = new byte[36];
+                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
+                DatagramPacket packet = new DatagramPacket(b, b.length);
+                while (true) {
+                    udpSocket.receive(packet);
+                    if (packet.getLength() != 4) {
+                        ZooLog.logError("Got more than just an xid! Len = "
+                                + packet.getLength());
+                    } else {
+                        responseBuffer.clear();
+                        responseBuffer.getInt(); // Skip the xid
+                        responseBuffer.putLong(myid);
+                        switch (state) {
+                        case LOOKING:
+                            responseBuffer.putLong(currentVote.id);
+                            responseBuffer.putLong(currentVote.zxid);
+                            break;
+                        case LEADING:
+                            responseBuffer.putLong(myid);
+                            try {
+                                responseBuffer.putLong(leader.lastProposed);
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                            break;
+                        case FOLLOWING:
+                            responseBuffer.putLong(currentVote.id);
+                            try {
+                                responseBuffer.putLong(follower.getZxid());
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                        }
+                        packet.setData(b);
+                        udpSocket.send(packet);
+                    }
+                    packet.setLength(b.length);
+                }
+            } catch (Exception e) {
+                ZooLog.logException(e);
+            } finally {
+                ZooLog.logError("QuorumPeer responder thread exited");
+            }
+        }
+    }
+
+    private ServerState state = ServerState.LOOKING;
+    
+    public void setPeerState(ServerState newState){
+        state=newState;
+    }
+    
+    public ServerState getPeerState(){
+        return state;
+    }
+    
+    DatagramSocket udpSocket;
+
+    private InetSocketAddress myQuorumAddr;
+    
+    public InetSocketAddress getQuorumAddress(){
+        return myQuorumAddr;
+    }
+
+    /**
+     * the directory where the snapshot is stored.
+     */
+    private File dataDir;
+
+    /**
+     * the directory where the logs are stored.
+     */
+    private File dataLogDir;
+
+    Election electionAlg;
+
     int electionPort;
 
-    NIOServerCnxn.Factory cnxnFactory;
-
-    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
-            File dataLogDir, int clientPort, int electionAlg, int electionPort,
-            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
-        super("QuorumPeer");
-        this.clientPort = clientPort;
-        this.cnxnFactory = new NIOServerCnxn.Factory(clientPort, this);
-        this.quorumPeers = quorumPeers;
-        this.dataDir = dataDir;
-        this.electionAlg = electionAlg;
+    NIOServerCnxn.Factory cnxnFactory;
+
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int electionAlg, int electionPort,long myid, int tickTime, 
+            int initLimit, int syncLimit,NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        super("QuorumPeer");
+        this.cnxnFactory = cnxnFactory;
+        this.quorumPeers = quorumPeers;
+        this.dataDir = dataDir;
         this.electionPort = electionPort;
-        this.dataLogDir = dataLogDir;
-        this.myid = myid;
-        this.tickTime = tickTime;
-        this.initLimit = initLimit;
-        this.syncLimit = syncLimit;
-        currentVote = new Vote(myid, getLastLoggedZxid());
-        for (QuorumServer p : quorumPeers) {
-            if (p.id == myid) {
-                myQuorumAddr = p.addr;
-                break;
-            }
-        }
-        if (myQuorumAddr == null) {
-            throw new SocketException("My id " + myid + " not in the peer list");
-        }
-        if (electionAlg == 0) {
-            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
-            new ResponderThread().start();
-        }
-    }
-
-    public QuorumPeer() throws IOException {
-    	// use quorum peer config to instantiate the class 
-		this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
-				getClientPort(), getElectionAlg(), getElectionPort(),
-				getServerId(), getTickTime(), getInitLimit(), getSyncLimit());
-	}
-    public Follower follower;
-
-    public Leader leader;
-
-    protected Follower makeFollower() throws IOException {
-		return new Follower(this, new FollowerZooKeeperServer(dataDir,
-				dataLogDir, this));
-	}
-
-	protected Leader makeLeader() throws IOException {
-		return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
-				this));
-	}
-    
-    public void run() {
-
-        /*
-         * Main loop
-         */
-        Election le = null;
-        switch(electionAlg){
-        case 1:
-            le = new AuthFastLeaderElection(this, this.electionPort);
-            break;
-        case 2:
-            le = new AuthFastLeaderElection(this, this.electionPort, true);                break;
-        case 3:
-            le =
-                new FastLeaderElection(this,
-                        new QuorumCnxManager(this.electionPort));
-        }
-
-        while (running) {
-            switch (state) {
-            case LOOKING:
-                try {
-                    ZooLog.logWarn("LOOKING");
-                    long init, end, diff;
-                    switch (electionAlg) {
-                    // Legacy algorithm
-                    case 0:
-                       init = System.currentTimeMillis();
-                        currentVote = new LeaderElection(this).lookForLeader();
-                        end = System.currentTimeMillis();
-                        diff = end - init;
-                        ZooLog.logWarn("Leader election latency: " + diff + " " + currentVote.id);
-                        break;
-                    // All other algorithms
-                    default:
-                        init = System.currentTimeMillis();
-                        if(le != null) currentVote = le.lookForLeader();
-                        end = System.currentTimeMillis();
-                        diff = end - init;
-                        ZooLog.logWarn("Leader election latency: " + diff);
-                        break;
-                    } 
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                    state = ServerState.LOOKING;
-                }
-                break;            
-            case FOLLOWING:
-                try {
-                    ZooLog.logWarn("FOLLOWING");
-                    follower = makeFollower();
-                    follower.followLeader();
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                } finally {
-                    follower.shutdown();
-                    follower = null;
-                    state = ServerState.LOOKING;
-                }
-                break;
-            case LEADING:
-                ZooLog.logWarn("LEADING");
-                try {
-                    leader = makeLeader();
-                    leader.lead();
-                    leader = null;
-                } catch (Exception e) {
-                    ZooLog.logException(e);
-                } finally {
-                    if (leader != null) {
-                        leader.shutdown("Forcing shutdown");
-                    }
-                    state = ServerState.LOOKING;
-                }
-                break;
-            }
-        }
-        ZooLog.logError("QuorumPeer main thread exited");
-    }
-
-    public void shutdown() {
-        running = false;
-        if (leader != null) {
-            leader.shutdown("quorum Peer shutdown");
-        }
-        if (follower != null) {
-            follower.shutdown();
-        }
-        cnxnFactory.shutdown();
-        udpSocket.close();
-    }
-
-    long getLastLoggedZxid() {
-        File[] list = dataLogDir.listFiles();
-        if (list == null) {
-            return 0;
-        }
-        long maxLog = -1;
-        long maxSnapShot = 0;
-        for (File f : list) {
-            String name = f.getName();
-            if (name.startsWith("log.")) {
-                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), "log");
-                if (zxid > maxLog) {
-                    maxLog = zxid;
-                }
-            } else if (name.startsWith("snapshot.")) {
-                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
-                        "snapshot");
-                if (zxid > maxLog) {
-                    maxSnapShot = zxid;
-                }
-            }
-        }
-        if (maxSnapShot > maxLog) {
-            return maxSnapShot;
-        }
-        long zxid = maxLog;
-        FileInputStream logStream = null;
-        try {
-            logStream = new FileInputStream(new File(dataLogDir, "log."
-                    + Long.toHexString(maxLog)));
-            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
-            while (true) {
-                byte[] bytes = ia.readBuffer("txnEntry");
-                if (bytes.length == 0) {
-                    // Since we preallocate, we define EOF to be an
-                    // empty transaction
-                    break;
-                }
-                int B = ia.readByte("EOR");
-                if (B != 'B') {
-                    break;
-                }
-                InputArchive bia = BinaryInputArchive
-                        .getArchive(new ByteArrayInputStream(bytes));
-                TxnHeader hdr = new TxnHeader();
-                hdr.deserialize(bia, "hdr");
-                zxid = hdr.getZxid();
-            }
-        } catch (IOException e) {
-            ZooLog.logWarn(e.toString());
-        } finally {
-            try {
-                if (logStream != null) {
-                    logStream.close();
-                }
-            } catch (IOException e) {
-                ZooLog.logException(e);
-            }
-        }
-        return zxid;
-    }
-
-    public static void runPeer(QuorumPeer.Factory qpFactory) {
-		try {
-			QuorumPeer self = qpFactory.create();
-			self.start();
-			self.join();
-		} catch (Exception e) {
-			ZooLog.logException(e);
-		}
-		System.exit(2);
-	}
-    
-    public static void main(String args[]) {
-		if (args.length == 2) {
-			ZooKeeperServer.main(args);
-			return;
-		}
-		QuorumPeerConfig.parse(args);
-		if (!QuorumPeerConfig.isStandalone()) {
-			runPeer(new QuorumPeer.Factory() {
-				public QuorumPeer create() throws IOException {
-					return new QuorumPeer();
-				}
-			});
-		}else{
-			// there is only server in the quorum -- run as standalone
-			ZooKeeperServer.main(args);
-		}
-	}
-}
+        this.dataLogDir = dataLogDir;
+        this.myid = myid;
+        this.tickTime = tickTime;
+        this.initLimit = initLimit;
+        this.syncLimit = syncLimit;
+        currentVote = new Vote(myid, getLastLoggedZxid());
+        for (QuorumServer p : quorumPeers) {
+            if (p.id == myid) {
+                myQuorumAddr = p.addr;
+                break;
+            }
+        }
+        if (myQuorumAddr == null) {
+            throw new SocketException("My id " + myid + " not in the peer list");
+        }
+        if (electionAlg == 0) {
+            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
+            new ResponderThread().start();
+        }
+        this.electionAlg = createElectionAlgorithm(electionAlg);
+        QuorumStats.getInstance().setStatsProvider(this);
+    }
+
+    /**
+     * This constructor is only used by the existing unit test code.
+     */
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int clientPort, int electionAlg, int electionPort,
+            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
+        this(quorumPeers,dataDir,dataLogDir,electionAlg,electionPort,myid,tickTime,
+                initLimit,syncLimit,new NIOServerCnxn.Factory(clientPort));
+    }
+    /**
+     *  The constructor uses the quorum peer config to instantiate the class
+     */
+    public QuorumPeer(NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
+                getElectionAlg(), getElectionPort(),getServerId(),getTickTime(), 
+                getInitLimit(), getSyncLimit(),cnxnFactory);
+    }
+    
+    public Follower follower;
+    public Leader leader;
+
+    protected Follower makeFollower(File dataDir,File dataLogDir) throws IOException {
+        return new Follower(this, new FollowerZooKeeperServer(dataDir,
+                dataLogDir, this,new ZooKeeperServer.BasicDataTreeBuilder()));
+    }
+
+    protected Leader makeLeader(File dataDir,File dataLogDir) throws IOException {
+        return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
+                this,new ZooKeeperServer.BasicDataTreeBuilder()));
+    }
+    
+    private Election createElectionAlgorithm(int electionAlgorithm){
+        Election le=null;
+        //TODO: use a factory rather than a switch
+        switch (electionAlgorithm) {
+        case 0:
+            // will create a new instance for each run of the protocol
+            break;
+        case 1:
+            le = new AuthFastLeaderElection(this, this.electionPort);
+            break;
+        case 2:
+            le = new AuthFastLeaderElection(this, this.electionPort, true); 
+            break;
+        case 3:
+            le = new FastLeaderElection(this,
+                        new QuorumCnxManager(this.electionPort));
+        default:
+            assert false;
+        }
+        return le;       
+    }
+    
+    protected Election makeLEStrategy(){
+        if(electionAlg==null)
+            return new LeaderElection(this);
+        return electionAlg;
+    }
+    
+    synchronized protected void setLeader(Leader newLeader){
+        leader=newLeader;
+    }
+
+    synchronized protected void setFollower(Follower newFollower){
+        follower=newFollower;
+    }
+    
+    synchronized public ZooKeeperServer getActiveServer(){
+        if(leader!=null)
+            return leader.zk;
+        else if(follower!=null)
+            return follower.zk;
+        return null;
+    }
+    
+    public void run() {
+        /*
+         * Main loop
+         */
+        while (running) {
+            switch (state) {
+            case LOOKING:
+                try {
+                    ZooLog.logWarn("LOOKING");
+                    currentVote = makeLEStrategy().lookForLeader();
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                    state = ServerState.LOOKING;
+                }
+                break;
+            case FOLLOWING:
+                try {
+                    ZooLog.logWarn("FOLLOWING");
+                    setFollower(makeFollower(dataDir,dataLogDir));
+                    follower.followLeader();
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                } finally {
+                    follower.shutdown();
+                    setFollower(null);
+                    state = ServerState.LOOKING;
+                }
+                break;
+            case LEADING:
+                ZooLog.logWarn("LEADING");
+                try {
+                    setLeader(makeLeader(dataDir,dataLogDir));
+                    leader.lead();
+                    setLeader(null);
+                } catch (Exception e) {
+                    ZooLog.logException(e);
+                } finally {
+                    if (leader != null) {
+                        leader.shutdown("Forcing shutdown");
+                        setLeader(null);
+                    }
+                    state = ServerState.LOOKING;
+                }
+                break;
+            }
+        }
+        ZooLog.logError("QuorumPeer main thread exited");
+    }
+
+    public void shutdown() {
+        running = false;
+        if (leader != null) {
+            leader.shutdown("quorum Peer shutdown");
+        }
+        if (follower != null) {
+            follower.shutdown();
+        }
+        cnxnFactory.shutdown();
+        udpSocket.close();
+    }
+
+    long getLastLoggedZxid() {
+        File[] list = dataLogDir.listFiles();
+        if (list == null) {
+            return 0;
+        }
+        long maxLog = -1;
+        long maxSnapShot = 0;
+        for (File f : list) {
+            String name = f.getName();
+            if (name.startsWith("log.")) {
+                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), "log");
+                if (zxid > maxLog) {
+                    maxLog = zxid;
+                }
+            } else if (name.startsWith("snapshot.")) {
+                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
+                        "snapshot");
+                if (zxid > maxLog) {
+                    maxSnapShot = zxid;
+                }
+            }
+        }
+        if (maxSnapShot > maxLog) {
+            return maxSnapShot;
+        }
+        long zxid = maxLog;
+        FileInputStream logStream = null;
+        try {
+            logStream = new FileInputStream(new File(dataLogDir, "log."
+                    + Long.toHexString(maxLog)));
+            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
+            while (true) {
+                byte[] bytes = ia.readBuffer("txnEntry");
+                if (bytes.length == 0) {
+                    // Since we preallocate, we define EOF to be an
+                    // empty transaction
+                    break;
+                }
+                int B = ia.readByte("EOR");
+                if (B != 'B') {
+                    break;
+                }
+                InputArchive bia = BinaryInputArchive
+                        .getArchive(new ByteArrayInputStream(bytes));
+                TxnHeader hdr = new TxnHeader();
+                hdr.deserialize(bia, "hdr");
+                zxid = hdr.getZxid();
+            }
+        } catch (IOException e) {
+            ZooLog.logWarn(e.toString());
+        } finally {
+            try {
+                if (logStream != null) {
+                    logStream.close();
+                }
+            } catch (IOException e) {
+                ZooLog.logException(e);
+            }
+        }
+        return zxid;
+    }
+
+    public static void runPeer(QuorumPeer.Factory qpFactory) {
+        try {
+            QuorumStats.registerAsConcrete();
+            QuorumPeer self = qpFactory.create(qpFactory.createConnectionFactory());
+            self.start();
+            self.join();
+        } catch (Exception e) {
+            ZooLog.logException(e);
+        }
+        System.exit(2);
+    }
+    
+    public String[] getQuorumPeers() {
+        List<String> l = new ArrayList<String>();
+        synchronized (this) {
+            if (leader != null) {
+                synchronized (leader.followers) {
+                    for (FollowerHandler fh : leader.followers) {
+                        if (fh.s == null)
+                            continue;
+                        String s = fh.s.getRemoteSocketAddress().toString();
+                        if (leader.isFollowerSynced(fh))
+                            s += "*";
+                        l.add(s);
+                    }
+                }
+            } else if (follower != null) {
+                l.add(follower.sock.getRemoteSocketAddress().toString());
+            }
+        }
+        return l.toArray(new String[0]);
+    }
+
+    public String getServerState() {
+        switch (state) {
+        case LOOKING:
+            return QuorumStats.Provider.LOOKING_STATE;
+        case LEADING:
+            return QuorumStats.Provider.LEADING_STATE;
+        case FOLLOWING:
+            return QuorumStats.Provider.FOLLOWING_STATE;
+        }
+        return QuorumStats.Provider.UNKNOWN_STATE;
+    }
+
+    public static void main(String args[]) {
+        if (args.length == 2) {
+            ZooKeeperServer.main(args);
+            return;
+        }
+        QuorumPeerConfig.parse(args);
+        if (!QuorumPeerConfig.isStandalone()) {
+            runPeer(new QuorumPeer.Factory() {
+                public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) 
+                        throws IOException {
+                    return new QuorumPeer(cnxnFactory);
+                }
+                public NIOServerCnxn.Factory createConnectionFactory()
+                        throws IOException {
+                    return new NIOServerCnxn.Factory(getClientPort());
+                }
+            });
+        }else{
+            // there is only server in the quorum -- run as standalone
+            ZooKeeperServer.main(args);
+        }
+    }
+}
<EOC>
<SOC>
 import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
+
 import com.yahoo.jute.InputArchive;
 import com.yahoo.jute.OutputArchive;
 import com.yahoo.jute.Record;

                 try {
                     deleteNode(path);
                     ZooLog.logTextTraceMessage("Deleting ephemeral node "
-                            + path + " for session " + Long.toHexString(session),
+                            + path + " for session "
+                            + Long.toHexString(session),
                             ZooLog.SESSION_TRACE_MASK);
                 } catch (KeeperException e) {
                     ZooLog.logException(e);

         }
     }
 
-    void serializeNode(OutputArchive oa, String path) throws IOException,
-            InterruptedException {
-        DataNode node = getNode(path);
+    /** 
+     * this method uses a stringbuilder to create a new 
+     * path for children. This is faster than string
+     * appends ( str1 + str2). 
+     * @param oa OutputArchive to write to.
+     * @param path a string builder.
+     * @throws IOException
+     * @throws InterruptedException
+     */
+    void serializeNode(OutputArchive oa, StringBuilder path)
+            throws IOException, InterruptedException {
+        String pathString = path.toString();
+        DataNode node = getNode(pathString);
         if (node == null) {
             return;
         }
-        ArrayList<String> children = null;
+        String children[] = null;
         synchronized (node) {
             scount++;
-            oa.writeString(path, "path");
+            oa.writeString(pathString, "path");
             oa.writeRecord(node, "node");
-            children = new ArrayList<String>(node.children);
+            children = node.children.toArray(new String[node.children.size()]);
         }
+        path.append('/');
+        int off = path.length();
         if (children != null) {
-            Collections.sort(children);
-            for (String childName : children) {
-                String childPath = path + '/' + childName;
-                serializeNode(oa, childPath);
+            for (String child : children) {
+                //since this is single buffer being resused 
+                // we need
+                // to truncate the previous bytes of string.
+                path.delete(off, Integer.MAX_VALUE);
+                path.append(child);
+                serializeNode(oa, path);
             }
         }
     }

     public void serialize(OutputArchive oa, String tag) throws IOException,
             InterruptedException {
         scount = 0;
-        serializeNode(oa, "");
+        serializeNode(oa, new StringBuilder(""));
         // / marks end of stream
         // we need to check if clear had been called in between the snapshot.
         if (root != null) {

         // dataWatches = null;
         // childWatches = null;
     }
-
 }
<EOC>
<SOC>
 import java.util.Set;
 import java.util.concurrent.LinkedBlockingQueue;
 
+import org.apache.log4j.Logger;
+
 import com.yahoo.jute.BinaryInputArchive;
 import com.yahoo.jute.BinaryOutputArchive;
 import com.yahoo.jute.Record;

 import com.yahoo.zookeeper.proto.SetDataResponse;
 import com.yahoo.zookeeper.proto.WatcherEvent;
 import com.yahoo.zookeeper.server.ByteBufferInputStream;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
 import com.yahoo.zookeeper.server.ZooLog;
 
 /**

  * 
  */
 public class ClientCnxn {
+    private static final Logger LOG = Logger.getLogger(ZooKeeperServer.class);
+
     private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
 
     static class AuthData {

                     this.bb.putInt(this.bb.capacity() - 4);
                     this.bb.rewind();
                 } catch (IOException e) {
-                    ZooLog.logException(e, "this should be impossible!");
+                    LOG.error("this should be impossible!", e);
                 }
             }
         }

 
     final static UncaughtExceptionHandler uncaughtExceptionHandler = new UncaughtExceptionHandler() {
         public void uncaughtException(Thread t, Throwable e) {
-            ZooLog.logException(e, "from " + t.getName());
+            LOG.error("from " + t.getName(), e);
         }
     };
 

                             rc = p.replyHeader.getErr();
                         }
                         if (p.cb == null) {
-                            ZooLog
-                                    .logError("Somehow a null cb got to EventThread!");
+                            LOG.error("Somehow a null cb got to EventThread!");
                         } else if (p.response instanceof ExistsResponse
                                 || p.response instanceof SetDataResponse
                                 || p.response instanceof SetACLResponse) {

         }
 
         private void primeConnection(SelectionKey k) throws IOException {
-            ZooLog.logWarn("Priming connection to "
+            LOG.warn("Priming connection to "
                     + ((SocketChannel) sockKey.channel()));
             lastConnectIndex = currentConnectIndex;
             ConnectRequest conReq = new ConnectRequest(0, lastZxid,

             sock.configureBlocking(false);
             sock.socket().setSoLinger(false, -1);
             sock.socket().setTcpNoDelay(true);
-            ZooLog.logWarn("Trying to connect to " + addr);
+            LOG.warn("Trying to connect to " + addr);
             sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
             if (sock.connect(addr)) {
                 primeConnection(sockKey);

                     }
                     selected.clear();
                 } catch (Exception e) {
-                    ZooLog.logWarn("Closing: " + e.getMessage());
+                    LOG.warn("Closing: " + e.getMessage());
                     cleanup();
                     if (zooKeeper.state.isAlive()) {
                         waitingEvents.add(new WatcherEvent(Event.EventNone,
<EOC>
<SOC>
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 
+import org.apache.log4j.Logger;
+
 import com.yahoo.jute.Record;
 import com.yahoo.zookeeper.KeeperException;
 import com.yahoo.zookeeper.ZooDefs;

 import com.yahoo.zookeeper.proto.GetChildrenResponse;
 import com.yahoo.zookeeper.proto.GetDataRequest;
 import com.yahoo.zookeeper.proto.GetDataResponse;
-import com.yahoo.zookeeper.proto.SyncRequest;
-import com.yahoo.zookeeper.proto.SyncResponse;
 import com.yahoo.zookeeper.proto.ReplyHeader;
 import com.yahoo.zookeeper.proto.SetACLResponse;
 import com.yahoo.zookeeper.proto.SetDataResponse;
+import com.yahoo.zookeeper.proto.SyncRequest;
+import com.yahoo.zookeeper.proto.SyncResponse;
 import com.yahoo.zookeeper.server.DataTree.ProcessTxnResult;
 import com.yahoo.zookeeper.server.NIOServerCnxn.Factory;
 import com.yahoo.zookeeper.txn.CreateSessionTxn;

  * outstandingRequests member of ZooKeeperServer.
  */
 public class FinalRequestProcessor implements RequestProcessor {
+    private static final Logger LOG = Logger.getLogger(FinalRequestProcessor.class);
+
     ZooKeeperServer zks;
 
     public FinalRequestProcessor(ZooKeeperServer zks) {

     }
 
     public void processRequest(Request request) {
-        // ZooLog.logWarn("Zoo>>> cxid = " + request.cxid + " type = " +
+        // LOG.warn("Zoo>>> cxid = " + request.cxid + " type = " +
         // request.type + " id = " + request.sessionId + " cnxn " +
         // request.cnxn);
         // request.addRQRec(">final");

             while (!zks.outstandingChanges.isEmpty()
                     && zks.outstandingChanges.get(0).zxid <= request.zxid) {
                 if (zks.outstandingChanges.get(0).zxid < request.zxid) {
-                    ZooLog.logError("Zxid outstanding "
+                    LOG.error("Zxid outstanding "
                             + zks.outstandingChanges.get(0).zxid
                             + " is less than current " + request.zxid);
                 }

                         zks.sessionTracker.addSession(request.sessionId, cst
                                 .getTimeOut());
                     } else {
-                        ZooLog.logWarn("*****>>>>> Got "
+                        LOG.warn("*****>>>>> Got "
                                 + request.txn.getClass() + " "
                                 + request.txn.toString());
                     }

         } catch (KeeperException e) {
             err = e.getCode();
         } catch (Exception e) {
-            ZooLog.logWarn("****************************** " + request);
+            LOG.warn("****************************** " + request);
             StringBuffer sb = new StringBuffer();
             ByteBuffer bb = request.request;
             bb.rewind();
             while (bb.hasRemaining()) {
                 sb.append(Integer.toHexString(bb.get() & 0xff));
             }
-            ZooLog.logWarn(sb.toString());
-            ZooLog.logException(e);
+            LOG.warn(sb.toString());
+            LOG.error("FIXMSG",e);
             err = Code.MarshallingError;
         }
         ReplyHeader hdr = new ReplyHeader(request.cxid, request.zxid, err);

         try {
             request.cnxn.sendResponse(hdr, rsp, "response");
         } catch (IOException e) {
-            ZooLog.logException(e);
+            LOG.error("FIXMSG",e);
         }
     }
 
<EOC>
<SOC>
 import java.text.DateFormat;
 import java.util.Date;
 
+import org.apache.log4j.Logger;
+
 import com.yahoo.jute.BinaryInputArchive;
 import com.yahoo.jute.InputArchive;
 import com.yahoo.zookeeper.txn.TxnHeader;
 
 public class LogFormatter {
+    private static final Logger LOG = Logger.getLogger(LogFormatter.class);
 
     /**
      * @param args

                     + Long.toHexString(hdr.getZxid())
                     + " " + TraceFormatter.op2String(hdr.getType()));
             if (logStream.readByte("EOR") != 'B') {
-                ZooLog.logError("Last transaction was partial.");
+                LOG.error("Last transaction was partial.");
                 throw new EOFException();
             }
         }
<EOC>
<SOC>
 import java.util.Set;
 import java.util.concurrent.LinkedBlockingQueue;
 
+import org.apache.log4j.Logger;
+
 import com.yahoo.jute.BinaryInputArchive;
 import com.yahoo.jute.BinaryOutputArchive;
 import com.yahoo.jute.Record;

  * client, but only one thread doing the communication.
  */
 public class NIOServerCnxn implements Watcher, ServerCnxn {
+    private static final Logger LOG = Logger.getLogger(NIOServerCnxn.class);
+
     static public class Factory extends Thread {
         ZooKeeperServer zks;
 

                     }
                     selected.clear();
                 } catch (Exception e) {
-                    ZooLog.logException(e);
+                    LOG.error("FIXMSG",e);
                 }
             }
             ZooLog.logTextTraceMessage("NIOServerCnxn factory exitedloop.",
                     ZooLog.textTraceMask);
             clear();
-            ZooLog.logError("=====> Goodbye cruel world <======");
+            LOG.error("=====> Goodbye cruel world <======");
             // System.exit(0);
         }
 

                 this.join();
             } catch (InterruptedException e) {
             } catch (Exception e) {
-                ZooLog.logException(e);
+                LOG.error("FIXMSG",e);
             }
             if (zks != null) {
                 zks.shutdown();

                     sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);
                 }
             } catch (RuntimeException e) {
-                ZooLog.logException(e);
+                LOG.error("FIXMSG",e);
                 throw e;
             }
         }

         } catch (CancelledKeyException e) {
             close();
         } catch (IOException e) {
-            // ZooLog.logException(e);
+            // LOG.error("FIXMSG",e);
             close();
         }
     }

             if (ap == null
                     || ap.handleAuthentication(this, authPacket.getAuth()) != KeeperException.Code.Ok) {
                 if (ap == null)
-                    ZooLog.logError("No authentication provider for scheme: "
+                    LOG.error("No authentication provider for scheme: "
                             + scheme);
                 else
-                    ZooLog.logError("Authentication failed for scheme: "
+                    LOG.error("Authentication failed for scheme: "
                             + scheme);
                 // send a response...
                 ReplyHeader rh = new ReplyHeader(h.getXid(), 0,

                 sendBuffer(NIOServerCnxn.closeConn);
                 disableRecv();
             } else {
-                ZooLog.logError("Authentication succeeded for scheme: "
+                LOG.error("Authentication succeeded for scheme: "
                         + scheme);
                 ReplyHeader rh = new ReplyHeader(h.getXid(), 0,
                         KeeperException.Code.Ok);

                 .getArchive(new ByteBufferInputStream(incomingBuffer));
         ConnectRequest connReq = new ConnectRequest();
         connReq.deserialize(bia, "connect");
-        ZooLog.logWarn("Connected to " + sock.socket().getRemoteSocketAddress()
+        LOG.warn("Connected to " + sock.socket().getRemoteSocketAddress()
                 + " lastZxid " + connReq.getLastZxidSeen());
         if (zk == null) {
             throw new IOException("ZooKeeperServer not running");
         }
         if (connReq.getLastZxidSeen() > zk.dataTree.lastProcessedZxid) {
-            ZooLog.logError("Client has seen "
+            LOG.error("Client has seen "
                     + Long.toHexString(connReq.getLastZxidSeen())
                     + " our last zxid is "
                     + Long.toHexString(zk.dataTree.lastProcessedZxid));

         if (connReq.getSessionId() != 0) {
             setSessionId(connReq.getSessionId());
             zk.reopenSession(this, sessionId, passwd, sessionTimeout);
-            ZooLog.logWarn("Renewing session " + Long.toHexString(sessionId));
+            LOG.warn("Renewing session " + Long.toHexString(sessionId));
         } else {
             zk.createSession(this, passwd, sessionTimeout);
-            ZooLog.logWarn("Creating new session "
+            LOG.warn("Creating new session "
                     + Long.toHexString(sessionId));
         }
         initialized = true;

         try {
             sock.socket().close();
         } catch (IOException e) {
-            ZooLog.logException(e);
+            LOG.error("FIXMSG",e);
         }
         try {
             sock.close();

             // this section arise.
             // factory.selector.wakeup();
         } catch (IOException e) {
-            ZooLog.logException(e);
+            LOG.error("FIXMSG",e);
         }
         sock = null;
         if (sk != null) {

             }
             baos.close();
         } catch (IOException e) {
-            ZooLog.logError("Error serializing response");
+            LOG.error("Error serializing response");
         }
         byte b[] = baos.toByteArray();
         ByteBuffer bb = ByteBuffer.wrap(b);

             ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
             bb.putInt(bb.remaining() - 4).rewind();
             sendBuffer(bb);
-            ZooLog.logWarn("Finished init of " + Long.toHexString(sessionId)
+            LOG.warn("Finished init of " + Long.toHexString(sessionId)
                     + ": " + valid);
             if (!valid) {
                 sendBuffer(closeConn);

                 enableRecv();
             }
         } catch (Exception e) {
-            ZooLog.logException(e);
+            LOG.error("FIXMSG",e);
             close();
         }
     }
<EOC>
<SOC>
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.LinkedBlockingQueue;
 
+import org.apache.log4j.Logger;
+
 import com.yahoo.jute.BinaryInputArchive;
 import com.yahoo.jute.BinaryOutputArchive;
 import com.yahoo.jute.InputArchive;

  * PrepRequestProcessor -> SyncRequestProcessor -> FinalRequestProcessor
  */
 public class ZooKeeperServer implements SessionExpirer, ServerStats.Provider {
+    private static final Logger LOG = Logger.getLogger(ZooKeeperServer.class);
+
     /**
      * Create an instance of Zookeeper server
      */

             if (zk.isRunning())
                 zk.shutdown();
         } catch (Exception e) {
-            ZooLog.logException(e);
+            LOG.error("FIXMSG",e);
         }
         System.exit(0);
     }

             int len = bb.getInt();
             byte b = bb.get();
             if (len != 1 || b != '/') {
-                ZooLog.logWarn("Invalid snapshot " + f + " len = " + len
+                LOG.warn("Invalid snapshot " + f + " len = " + len
                         + " byte = " + (b & 0xff));
                 return -1;
             }

         for (File f : files) {
             zxid = isValidSnapshot(f);
             if (zxid == -1) {
-                ZooLog.logWarn("Skipping " + f);
+                LOG.warn("Skipping " + f);
                 continue;
             }
 
-            ZooLog.logWarn("Processing snapshot: " + f);
+            LOG.warn("Processing snapshot: " + f);
             
             InputStream snapIS =
                 new BufferedInputStream(new FileInputStream(f));

             // Apply the logs on/after the selected snapshot
             File[] logfiles = getLogFiles(dataLogDir.listFiles(), zxid);
             for (File logfile : logfiles) {
-                ZooLog.logWarn("Processing log file: " + logfile);
+                LOG.warn("Processing log file: " + logfile);
                 
                 InputStream logIS =
                     new BufferedInputStream(new FileInputStream(logfile));

                 TxnHeader hdr = new TxnHeader();
                 Record txn = deserializeTxn(ia, hdr);
                 if (logStream.readByte("EOR") != 'B') {
-                    ZooLog.logError("Last transaction was partial.");
+                    LOG.error("Last transaction was partial.");
                     throw new EOFException();
                 }
                 if (hdr.getZxid() <= highestZxid && highestZxid != 0) {
-                    ZooLog.logError(highestZxid + "(higestZxid) >= "
+                    LOG.error(highestZxid + "(higestZxid) >= "
                             + hdr.getZxid() + "(next log) for type "
                             + hdr.getType());
                 } else {

                 baos.close();
             } catch (IOException e) {
                 // This really should be impossible
-                ZooLog.logException(e);
+                LOG.error("FIXMSG",e);
             }
             QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid,
                     baos.toByteArray(), null);

         for (File f : dataDir.listFiles()) {
             long zxid = isValidSnapshot(f);
             if (zxid == -1) {
-                ZooLog.logWarn("Skipping " + f);
+                LOG.warn("Skipping " + f);
                 continue;
             }
             if (zxid > highestZxid) {

         }
         if (truncated == false) {
             // not able to truncate the log
-            ZooLog.logError("Not able to truncate the log "
+            LOG.error("Not able to truncate the log "
                     + Long.toHexString(finalZxid));
             System.exit(13);
         }

                     "Snapshotting finished: " + Long.toHexString(lastZxid),
                     ZooLog.textTraceMask);
         } catch (IOException e) {
-            ZooLog.logException(e, "Severe error, exiting");
+            LOG.error("Severe error, exiting",e);
             // This is a severe error that we cannot recover from,
             // so we need to exit
             System.exit(10);

                     ZooLog.SESSION_TRACE_MASK);
             closeSession(sessionId);
         } catch (Exception e) {
-            ZooLog.logException(e);
+            LOG.error("FIXMSG",e);
         }
     }
 

                         wait(1000);
                     }
                 } catch (InterruptedException e) {
-                    ZooLog.logException(e);
+                    LOG.error("FIXMSG",e);
                 }
                 if (firstProcessor == null) {
                     throw new RuntimeException("Not started");

                     incInProcess();
                 }
             } else {
-                ZooLog.logWarn("Dropping packet at server of type " + type);
+                LOG.warn("Dropping packet at server of type " + type);
                 // if unvalid packet drop the packet.
             }
         } catch (IOException e) {
-            ZooLog.logException(e);
+            LOG.error("FIXMSG",e);
         }
     }
 
<EOC>
<SOC>
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
+import org.apache.log4j.Logger;
+
 import com.yahoo.zookeeper.KeeperException;
 import com.yahoo.zookeeper.data.Id;
 import com.yahoo.zookeeper.server.ServerCnxn;
-import com.yahoo.zookeeper.server.ZooLog;
 
 public class DigestAuthenticationProvider implements AuthenticationProvider {
+    private static final Logger LOG = Logger.getLogger(DigestAuthenticationProvider.class);
+
     public static String superDigest = "super:1wZ8qIvQBMTq0KPxMc6RQ/PCXKM=";
 
     public String getScheme() {

             cnxn.getAuthInfo().add(new Id(getScheme(), digest));
             return KeeperException.Code.Ok;
         } catch (NoSuchAlgorithmException e) {
-            ZooLog.logException(e);
+            LOG.error("FIXMSG",e);
         }
         return KeeperException.Code.AuthFailed;
     }
<EOC>
<SOC>
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 
+import org.apache.log4j.Logger;
+
 import com.yahoo.zookeeper.server.ZooLog;
 import com.yahoo.zookeeper.server.quorum.QuorumCnxManager.Message;
 import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;

 
 
 public class FastLeaderElection implements Election {
+    private static final Logger LOG = Logger.getLogger(FastLeaderElection.class);
 
 	/* Sequence numbers for messages */
     static int sequencer = 0;

             			
             			// Receive new message
             			if (response.buffer.capacity() < 28) {
-            				ZooLog.logError("Got a short response: "
+            				LOG.error("Got a short response: "
             						+ response.buffer.capacity());
             				continue;
             			}

             			//InetAddress addr = (InetAddress) responsePacket.getSocketAddress();
             			if(self.getPeerState() == QuorumPeer.ServerState.LOOKING){
             				recvqueue.offer(n);
-            				if(recvqueue.size() == 0) ZooLog.logWarn("Message: " + n.addr);
+            				if(recvqueue.size() == 0) LOG.warn("Message: " + n.addr);
             				if((ackstate == QuorumPeer.ServerState.LOOKING)
             						&& (n.epoch < logicalclock)){
             					ToSend notmsg = new ToSend(ToSend.mType.notification, 

         proposedLeader = self.getId();
         proposedZxid = self.getLastLoggedZxid();
 
-        ZooLog.logWarn("Election tally: " + proposedZxid);
+        LOG.warn("Election tally: " + proposedZxid);
         sendNotifications();
 
         /*

 
                 } else if (termPredicate(recvset, proposedLeader, proposedZxid)) {
                     //Otherwise, wait for a fixed amount of time
-                    ZooLog.logWarn("Passed predicate");
+                    LOG.warn("Passed predicate");
                     Thread.sleep(finalizeWait);
 
                     // Verify if there is any change in the proposed leader
<EOC>
<SOC>
 import java.util.Iterator;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
+import org.apache.log4j.Logger;
+
 import com.yahoo.jute.BinaryOutputArchive;
 import com.yahoo.zookeeper.server.FinalRequestProcessor;
 import com.yahoo.zookeeper.server.Request;

  * This class has the control logic for the Leader.
  */
 public class Leader {
+    private static final Logger LOG = Logger.getLogger(Leader.class);
+
     static public class Proposal {
         public QuorumPacket packet;
 

         try {
             ss = new ServerSocket(self.getQuorumAddress().getPort());
         } catch (BindException e) {
-            ZooLog.logError("Couldn't bind to port "
+            LOG.error("Couldn't bind to port "
                     + self.getQuorumAddress().getPort());
             throw e;
         }

         newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),
                 null, null);
         if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {
-            ZooLog.logError("NEWLEADER proposal has Zxid of "
+            LOG.error("NEWLEADER proposal has Zxid of "
                     + newLeaderProposal.packet.getZxid());
         }
         outstandingProposals.add(newLeaderProposal);

                         + " followers, only synced with "
                         + newLeaderProposal.ackCount);
                 if (followers.size() >= self.quorumPeers.size() / 2) {
-                    ZooLog.logWarn("Enough followers present. "+
+                    LOG.warn("Enough followers present. "+
                             "Perhaps the initTicks need to be increased.");
                 }
                 return;

             return;
         }
 
-        ZooLog.logException(new Exception("shutdown Leader! reason: "
+        LOG.error("FIXMSG",new Exception("shutdown Leader! reason: "
                         + reason));
         // NIO should not accept conenctions
         self.cnxnFactory.setZooKeeperServer(null);

         try {
             ss.close();
         } catch (IOException e) {
-            ZooLog.logException(e);
+            LOG.error("FIXMSG",e);
         }
         synchronized (followers) {
             for (Iterator<FollowerHandler> it = followers.iterator(); it

     synchronized public void processAck(long zxid, SocketAddress followerAddr) {
         boolean first = true;
         /*
-         * ZooLog.logError("Ack zxid: " + Long.toHexString(zxid)); for (Proposal
+         * LOG.error("Ack zxid: " + Long.toHexString(zxid)); for (Proposal
          * p : outstandingProposals) { long packetZxid = p.packet.getZxid();
-         * ZooLog.logError("outstanding proposal: " +
-         * Long.toHexString(packetZxid)); } ZooLog.logError("outstanding
+         * LOG.error("outstanding proposal: " +
+         * Long.toHexString(packetZxid)); } LOG.error("outstanding
          * proposals all");
          */
         if (outstandingProposals.size() == 0) {

             long packetZxid = p.packet.getZxid();
             if (packetZxid == zxid) {
                 p.ackCount++;
-                // ZooLog.logException(new RuntimeException(), "Count for " +
+                // LOG.error("FIXMSG",new RuntimeException(), "Count for " +
                 // Long.toHexString(zxid) + " is " + p.ackCount);
                 if (p.ackCount > self.quorumPeers.size() / 2){
                     if (!first) {
-                        ZooLog.logError("Commiting " + Long.toHexString(zxid)
+                        LOG.error("Commiting " + Long.toHexString(zxid)
                                 + " from " + followerAddr + " not first!");
-                        ZooLog.logError("First is "
+                        LOG.error("First is "
                                 + outstandingProposals.element().packet);
                         System.exit(13);
                     }

                     // We don't commit the new leader proposal
                     if ((zxid & 0xffffffffL) != 0) {
                         if (p.request == null) {
-                            ZooLog.logError("Going to commmit null: " + p);
+                            LOG.error("Going to commmit null: " + p);
                         }
                         commit(zxid);
                         zk.commitProcessor.commit(p.request);

                 first = false;
             }
         }
-        ZooLog.logError("Trying to commit future proposal: "
+        LOG.error("Trying to commit future proposal: "
                 + Long.toHexString(zxid) + " from " + followerAddr);
     }
 

             baos.close();
         } catch (IOException e) {
             // This really should be impossible
-            ZooLog.logException(e);
+            LOG.error("FIXMSG",e);
         }
         QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, baos
                 .toByteArray(), null);

     
     public void processSync(Request r){
         if(outstandingProposals.isEmpty()){
-            ZooLog.logWarn("No outstanding proposal");
+            LOG.warn("No outstanding proposal");
             sendSync(syncHandler.get(r.sessionId), r);
                 syncHandler.remove(r.sessionId);
         }
<EOC>
<SOC>
 import java.util.Random;
 import java.util.concurrent.ArrayBlockingQueue;
 
+import org.apache.log4j.Logger;
+
 import com.yahoo.zookeeper.server.ZooLog;
 
 /**

  */
 
 class QuorumCnxManager extends Thread {
+    private static final Logger LOG = Logger.getLogger(QuorumCnxManager.class);
+
     /*
      * Maximum capacity of thread queues
      */

         try {
             localIP = InetAddress.getLocalHost();
         } catch (UnknownHostException e) {
-            ZooLog.logWarn("Couldn't get local address");
+            LOG.warn("Couldn't get local address");
         }
 
         // Generates a challenge to guarantee one connection between pairs of

         //} else {
         //    wins = true;
         //} 
-        //ZooLog.logWarn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
+        //LOG.warn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
         
         try {
             while (challenged && s.isConnected()) {

                 }
             }
         } catch (IOException e) {
-            ZooLog.logWarn("Exception reading or writing challenge: "
+            LOG.warn("Exception reading or writing challenge: "
                     + e.toString());
             return false;
         }

         // If lost the challenge, then drop the new connection
         if (!wins) {
             try {
-                //ZooLog.logWarn("lost cause (initiate");
+                //LOG.warn("lost cause (initiate");
                 s.socket().close();
             } catch (IOException e) {
-                ZooLog
-                        .logWarn("Error when closing socket or trying to reopen connection: "
+                LOG.warn("Error when closing socket or trying to reopen connection: "
                                 + e.toString());
 
             }

 
                     return true;
                 } else {
-                    ZooLog.logWarn("Channel null");
+                    LOG.warn("Channel null");
                     return false;
                 }
             }

         //    wins = true;
         //} 
         
-        //ZooLog.logWarn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
+        //LOG.warn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
         
         
         try {

                 }
             }
         } catch (IOException e) {
-            ZooLog.logWarn("Exception reading or writing challenge: "
+            LOG.warn("Exception reading or writing challenge: "
                     + e.toString());
             return false;
         }

                 InetAddress addr = s.socket().getInetAddress();
                 SendWorker sw = senderWorkerMap.get(addr);
 
-                //ZooLog.logWarn("Keep connection (received)");
+                //LOG.warn("Keep connection (received)");
                 //sw.connect();
                 s.socket().close();
                 sw.finish();

                 
                 
             } catch (IOException e) {
-                ZooLog
-                        .logWarn("Error when closing socket or trying to reopen connection: "
+                LOG.warn("Error when closing socket or trying to reopen connection: "
                                 + e.toString());
             }
         //Otherwise start worker threads to receive data.

 
                     return true;
                 } else {
-                    ZooLog.logWarn("Channel null");
+                    LOG.warn("Channel null");
                     return false;
                 }
             }

                 b.position(0);
                 recvQueue.put(new Message(b.duplicate(), addr));
             } catch (InterruptedException e) {
-                ZooLog.logWarn("Exception when loopbacking");
+                LOG.warn("Exception when loopbacking");
             }
         /*
          * Otherwise send to the corresponding thread to send. 

                             channel.socket().setTcpNoDelay(true);
                             initiateConnection(channel);
                         } catch (IOException e) {
-                            ZooLog.logWarn("Cannot open channel to "
+                            LOG.warn("Cannot open channel to "
                                     + addr.toString() + "( " + e.toString()
                                     + ")");
                         }
                     }
                 }     
             } catch (InterruptedException e) {
-                ZooLog
-                        .logWarn("Interrupted while waiting to put message in queue."
+                LOG.warn("Interrupted while waiting to put message in queue."
                                 + e.toString());
             }
     }

                      * simultaneously.
                      */
                     synchronized(senderWorkerMap){
-                        ZooLog.logWarn("Connection request");
+                        LOG.warn("Connection request");
                         receiveConnection(client);
                     }
                 }

         //    if (channel.isConnected()) {
         //        recvWorker = new RecvWorker(channel);
         //        initiateConnection(channel);
-        //        ZooLog.logWarn("Opened new connection");
+        //        LOG.warn("Opened new connection");
         //    } else {
-        //        ZooLog.logWarn("Channel not connected.");
+        //        LOG.warn("Channel not connected.");
         //    }
         //
         //    return channel.isConnected();

                     init = System.currentTimeMillis();
                     b = queueSendMap.get(addr).take();
                 } catch (InterruptedException e) {
-                    ZooLog
-                            .logWarn("Interrupted while waiting for message on queue ("
+                    LOG.warn("Interrupted while waiting for message on queue ("
                                     + e.toString() + ")");
                     continue;
                 }

                      * If reconnection doesn't work, then put the
                      * message back to the beginning of the queue and leave.
                      */
-                    ZooLog.logWarn("Exception when using channel: " + addr
+                    LOG.warn("Exception when using channel: " + addr
                             + ")" + e.toString());
                     running = false;
                     synchronized (senderWorkerMap) {

                     }
                 }
             }
-            ZooLog.logWarn("Leaving thread");
+            LOG.warn("Leaving thread");
         }
     }
 

                 }
 
             } catch (IOException e) {
-                ZooLog.logWarn("Connection broken: " + e.toString());
+                LOG.warn("Connection broken: " + e.toString());
 
             } catch (InterruptedException e) {
-                ZooLog.logWarn("Interrupted while trying to add new "
+                LOG.warn("Interrupted while trying to add new "
                         + "message to the reception queue (" + e.toString()
                         + ")");
             }
<EOC>
<SOC>
  * connected to as needed.
  * 
  */
-public class ClientCnxn {
+class ClientCnxn {
     private static final Logger LOG = Logger.getLogger(ZooKeeperServer.class);
 
     private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();

 
     private int sessionTimeout;
 
-    private int timeout;
-
     private ZooKeeper zooKeeper;
 
     private long sessionId;

         }
     }
 
+    @SuppressWarnings("unchecked")
+    private void finishPacket(Packet p) {
+        p.finished = true;
+        if (p.cb == null) {
+            synchronized (p) {
+                p.notifyAll();
+            }
+        } else {
+            waitingEvents.add(p);
+        }
+    }
+
+    private void conLossPacket(Packet p) {
+        if (p.replyHeader == null) {
+            return;
+        }
+        switch(zooKeeper.state) {
+        case AUTH_FAILED:
+            p.replyHeader.setErr(KeeperException.Code.AuthFailed);
+            break;
+        case CLOSED:
+            p.replyHeader.setErr(KeeperException.Code.SessionExpired);
+            break;
+        default:
+            p.replyHeader.setErr(KeeperException.Code.ConnectionLoss);
+        }
+        finishPacket(p);
+    }
+
     long lastZxid;
 
     /**

                 zooKeeper.state = States.CLOSED;
                 waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
                         Watcher.Event.KeeperStateExpired, null));
-                throw new IOException("Connect failed");
+                throw new IOException("Session Expired");
             }
             readTimeout = sessionTimeout * 2 / 3;
             connectTimeout = sessionTimeout / serverAddrs.size();
-            timeout = readTimeout / 2;
             sessionId = conRsp.getSessionId();
             sessionPasswd = conRsp.getPasswd();
             waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,

 
         @SuppressWarnings("unchecked")
         void readResponse() throws IOException {
-            timeout = readTimeout / 2;
             ByteBufferInputStream bbis = new ByteBufferInputStream(
                     incomingBuffer);
             BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);

             finishPacket(p);
         }
 
-        @SuppressWarnings("unchecked")
-        private void finishPacket(Packet p) {
-            p.finished = true;
-            if (p.cb == null) {
-                synchronized (p) {
-                    p.notifyAll();
-                }
-            } else {
-                waitingEvents.add(p);
-            }
-        }
-
         /**
          * @return true if a packet was received
          * @param k

             }
         }
 
-        private void conLossPacket(Packet p) {
-            if (p.replyHeader == null) {
-                return;
-            }
-            p.replyHeader.setErr(KeeperException.Code.ConnectionLoss);
-            finishPacket(p);
-        }
-
         private void sendPing() {
             RequestHeader h = new RequestHeader(-2, OpCode.ping);
             queuePacket(h, null, null, null, null, null, null);

 
         @Override
         public void run() {
-            timeout = connectTimeout;
             long now = System.currentTimeMillis();
             long lastHeard = now;
-            int idle = 0;
+            long lastSend = now;
             while (zooKeeper.state.isAlive()) {
                 try {
                     if (sockKey == null) {
                         startConnect();
+                        lastSend = now;
                         lastHeard = now;
                     }
-                    int to = (int) (timeout - idle);
+                    int idleRecv = (int) (now - lastHeard);
+                    int idleSend = (int) (now - lastSend);
+                    int to = readTimeout - idleRecv;
+                    if (zooKeeper.state != States.CONNECTED) {
+                        to = connectTimeout - idleRecv;
+                    }
                     if (to <= 0) {
                         throw new IOException("TIMED OUT");
                     }
+                    if (zooKeeper.state == States.CONNECTED) {
+                        int timeToNextPing = readTimeout/2 - idleSend;
+                        if (timeToNextPing <= 0) {
+                            sendPing();
+                            lastSend = now;
+                            enableWrite();
+                        } else {
+                            if (timeToNextPing < to) {
+                                to = timeToNextPing;
+                            }
+                        }
+                    }
+                    
                     selector.select(to);
                     Set<SelectionKey> selected;
                     synchronized (this) {
                         selected = selector.selectedKeys();
                     }
+                    // Everything below and until we get back to the select is
+                    // non blocking, so time is effectively a constant. That is
+                    // Why we just have to do this once, here
                     now = System.currentTimeMillis();
-                    idle = (int) (now - lastHeard);
                     for (SelectionKey k : selected) {
                         SocketChannel sc = ((SocketChannel) k.channel());
                         if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {
                             if (sc.finishConnect()) {
                                 zooKeeper.state = States.CONNECTED;
-                                timeout = readTimeout / 2;
                                 lastHeard = now;
+                                lastSend = now;
                                 primeConnection(k);
                             }
                         } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
+                            if (outgoingQueue.size() > 0) {
+                                // We have something to send so it's the same
+                                // as if we do the send now.
+                                lastSend = now;
+                            }
                             if (doIO()) {
                                 lastHeard = now;
                             }
                         }
                     }
-                    // ZooLog.logWarn("interest = " +
-                    // Integer.toHexString(sockKey.interestOps()) + " ready = "
-                    // + Integer.toHexString(sockKey.readyOps()) + " PQq = " +
-                    // pendingQueue.size() + " timout = " + timeout + "
-                    // outgoingQueue = " + outgoingQueue.size());
                     if (zooKeeper.state == States.CONNECTED) {
-                        if (pendingQueue.size() == 0) {
-                            if (idle >= timeout && timeout == readTimeout / 2) {
-                                sendPing();
-                                timeout = readTimeout;
-                            }
-                        } else {
-                            timeout = readTimeout;
-                        }
                         if (outgoingQueue.size() > 0) {
                             enableWrite();
                         } else {
                             disableWrite();
                         }
-                    } else {
-                        timeout = connectTimeout;
                     }
                     selected.clear();
                 } catch (Exception e) {
-                    LOG.warn("Closing: " + e.getMessage());
+                    LOG.warn("Closing: ", e);
                     cleanup();
                     if (zooKeeper.state.isAlive()) {
                         waitingEvents.add(new WatcherEvent(Event.EventNone,
                                 Event.KeeperStateDisconnected, null));
                     }
 
-                    timeout = connectTimeout;
                     now = System.currentTimeMillis();
                     lastHeard = now;
-                    idle = 0;
+                    lastSend = now;
                 }
             }
             cleanup();

             packet.cb = cb;
             packet.ctx = ctx;
             packet.path = path;
-            outgoingQueue.add(packet);
+            if (!zooKeeper.state.isAlive()) {
+                conLossPacket(packet);
+            } else {
+                outgoingQueue.add(packet);
+            }
         }
         synchronized (sendThread) {
             selector.wakeup();
<EOC>
<SOC>
 import java.nio.ByteBuffer;
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.Random;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 
 import org.apache.log4j.Logger;
 
-import com.yahoo.zookeeper.server.ZooLog;
 import com.yahoo.zookeeper.server.quorum.QuorumCnxManager.Message;
 import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;
 import com.yahoo.zookeeper.server.quorum.QuorumPeer.ServerState;

 	
 	static int challengeCounter = 0;
 	
-	/*
-	 * Flag to determine whether to authenticate or not
-	 */
-    
-	private boolean authEnabled = false;
     
 	/*
 	 * Connection manager

 
     private class Messenger {
     	
-        DatagramSocket mySocket;
         long lastProposedLeader;
         long lastProposedZxid;
         long lastEpoch;

         class WorkerReceiver implements Runnable {
 
         	QuorumCnxManager manager;
-            Messenger msg;
 
-            WorkerReceiver(QuorumCnxManager manager, Messenger msg) {
+            WorkerReceiver(QuorumCnxManager manager) {
                 this.manager = manager;
-                this.msg = msg;
             }
 
             public void run() {

 
         class WorkerSender implements Runnable {
         	
-            Random rand;
             QuorumCnxManager manager;
-            boolean processing;
-            int ackWait = finalizeWait / 6;
 
-            
             WorkerSender(QuorumCnxManager manager){ 
-                rand = new Random(java.lang.Thread.currentThread().getId() + System.currentTimeMillis());
                 this.manager = manager;
             }
             

             }
 
             private void process(ToSend m) {
-                int attempts = 0;
                 byte requestBytes[] = new byte[28];
                 ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);  
                 

             t.setDaemon(true);
             t.start();
 
-            t = new Thread(new WorkerReceiver(manager, this),
+            t = new Thread(new WorkerReceiver(manager),
                     				"WorkerReceiver Thread");
             t.setDaemon(true);
             t.start();

     int port;
     long logicalclock; /* Election instance */
     Messenger messenger;
-    DatagramSocket mySocket;
     long proposedLeader;
     long proposedZxid;
 
<EOC>
<SOC>
                 this.outstandingLimit = 1;
             }
         }
-        
+
         public InetSocketAddress getLocalAddress(){
             return (InetSocketAddress)ss.socket().getLocalSocketAddress();
         }

                 SelectionKey sk) throws IOException {
             return new NIOServerCnxn(zks, sock, sk, this);
         }
-        
+
         public void run() {
             while (!ss.socket().isClosed()) {
                 try {

                     LOG.error("FIXMSG",e);
                 }
             }
-            ZooLog.logTextTraceMessage("NIOServerCnxn factory exitedloop.",
-                    ZooLog.textTraceMask);
+            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                     "NIOServerCnxn factory exitedloop.");
             clear();
             LOG.error("=====> Goodbye cruel world <======");
             // System.exit(0);

 
         /**
          * clear all the connections in the selector
-         * 
+         *
          */
         synchronized public void clear() {
             selector.wakeup();

         synchronized (factory) {
             try {
                 sk.selector().wakeup();
-                // ZooLog.logTextTraceMessage("Add a buffer to outgoingBuffers",
-                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK);
-                // ZooLog.logTextTraceMessage("sk " + sk + " is valid: " +
-                // sk.isValid(), ZooLog.CLIENT_DATA_PACKET_TRACE_MASK);
+                // ZooLog.logTraceMessage(LOG,
+                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
+                // "Add a buffer to outgoingBuffers");
+                // ZooLog.logTraceMessage(LOG,
+                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
+                //"sk " + sk + " is valid: " +
+                // sk.isValid(), );
                 outgoingBuffers.add(bb);
                 if (sk.isValid()) {
                     sk.interestOps(sk.interestOps() | SelectionKey.OP_WRITE);

                 }
             }
             if (k.isWritable()) {
-                // ZooLog.logTextTraceMessage("outgoingBuffers.size() = " +
-                // outgoingBuffers.size(),
-                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK);
+                // ZooLog.logTraceMessage(LOG,
+                // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK
+                // "outgoingBuffers.size() = " +
+                // outgoingBuffers.size());
                 if (outgoingBuffers.size() > 0) {
-                    // ZooLog.logTextTraceMessage("sk " + k + " is valid: " +
-                    // k.isValid(), ZooLog.CLIENT_DATA_PACKET_TRACE_MASK);
+                    // ZooLog.logTraceMessage(LOG,
+                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK,
+                    // "sk " + k + " is valid: " +
+                    // k.isValid());
 
                     /*
                      * This is going to reset the buffer position to 0 and the

                         ServerStats.getInstance().incrementPacketsSent();
                         outgoingBuffers.remove();
                     }
-                    // ZooLog.logTextTraceMessage("after send,
-                    // outgoingBuffers.size() = " + outgoingBuffers.size(),
-                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK);
+                    // ZooLog.logTraceMessage(LOG,
+                    // ZooLog.CLIENT_DATA_PACKET_TRACE_MASK, "after send,
+                    // outgoingBuffers.size() = " + outgoingBuffers.size());
                 }
                 synchronized (this) {
                     if (outgoingBuffers.size() == 0) {

             } else if (len == killCmd) {
                 System.exit(0);
             } else if (len == getTraceMaskCmd) {
-                long traceMask = ZooLog.getTextTraceLevel();
+                long traceMask = ZooTrace.getTextTraceLevel();
                 ByteBuffer resp = ByteBuffer.allocate(8);
                 resp.putLong(traceMask);
                 resp.flip();

                 System.out.println("rc=" + rc);
                 incomingBuffer.flip();
                 long traceMask = incomingBuffer.getLong();
-                ZooLog.setTextTraceLevel(traceMask);
+                ZooTrace.setTextTraceLevel(traceMask);
                 ByteBuffer resp = ByteBuffer.allocate(8);
                 resp.putLong(traceMask);
                 resp.flip();

 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see com.yahoo.zookeeper.server.ServerCnxnIface#getSessionTimeout()
      */
     public int getSessionTimeout() {

 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see com.yahoo.zookeeper.server.ServerCnxnIface#close()
      */
     public void close() {

             zk.removeCnxn(this);
         }
 
-        ZooLog.logTextTraceMessage("close  NIOServerCnxn: " + sock,
-                ZooLog.SESSION_TRACE_MASK);
+        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
+                                 "close  NIOServerCnxn: " + sock);
         try {
             /*
              * The following sequence of code is stupid! You would think that

 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see com.yahoo.zookeeper.server.ServerCnxnIface#sendResponse(com.yahoo.zookeeper.proto.ReplyHeader,
      *      com.yahoo.jute.Record, java.lang.String)
      */

 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see com.yahoo.zookeeper.server.ServerCnxnIface#process(com.yahoo.zookeeper.proto.WatcherEvent)
      */
     synchronized public void process(WatcherEvent event) {
         ReplyHeader h = new ReplyHeader(-1, -1L, 0);
-        ZooLog.logTextTraceMessage("Deliver event " + event + " to "
-                + this.sessionId + " through " + this,
-                ZooLog.EVENT_DELIVERY_TRACE_MASK);
+        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,
+                                 "Deliver event " + event + " to "
+                                 + this.sessionId + " through " + this);
         sendResponse(h, event, "notification");
     }
 

 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see com.yahoo.zookeeper.server.ServerCnxnIface#getSessionId()
      */
     public long getSessionId() {

     private class CnxnStats implements ServerCnxn.Stats{
         long packetsReceived;
         long packetsSent;
-        
+
         /**
          * The number of requests that have been submitted but not yet responded to.
          */
<EOC>
<SOC>
     public int getNodeCount(){
         return nodes.size();
     }
-    
+
     public int getWatchCount(){
         return dataWatches.size()+childWatches.size();
     }

             }
             node.parent = null;
         }
-        ZooLog.logTextTraceMessage("dataWatches.triggerWatch " + path,
-                ZooLog.EVENT_DELIVERY_TRACE_MASK);
-        ZooLog.logTextTraceMessage("childWatches.triggerWatch " + parentName,
-                ZooLog.EVENT_DELIVERY_TRACE_MASK);
+        ZooTrace.logTraceMessage(LOG,
+                                 ZooTrace.EVENT_DELIVERY_TRACE_MASK,
+                                 "dataWatches.triggerWatch " + path);
+        ZooTrace.logTraceMessage(LOG,
+                                 ZooTrace.EVENT_DELIVERY_TRACE_MASK,
+                                 "childWatches.triggerWatch " + parentName);
         dataWatches.triggerWatch(path, Event.EventNodeDeleted);
         childWatches.triggerWatch(parentName.equals("")?"/":parentName, Event.EventNodeChildrenChanged);
     }

         /**
          * Equality is defined as the clientId and the cxid being the same. This
          * allows us to use hash tables to track completion of transactions.
-         * 
+         *
          * @see java.lang.Object#equals(java.lang.Object)
          */
         @Override

 
         /**
          * See equals() to find the rational for how this hashcode is generated.
-         * 
+         *
          * @see ProcessTxnResult#equals(Object)
          * @see java.lang.Object#hashCode()
          */

             for (String path : list) {
                 try {
                     deleteNode(path);
-                    ZooLog.logTextTraceMessage("Deleting ephemeral node "
-                            + path + " for session "
-                            + Long.toHexString(session),
-                            ZooLog.SESSION_TRACE_MASK);
+                    ZooTrace.logTraceMessage(LOG,
+                                             ZooTrace.SESSION_TRACE_MASK,
+                                             "Deleting ephemeral node "
+                                             + path + " for session "
+                                             + Long.toHexString(session));
                 } catch (KeeperException e) {
                     LOG.error("FIXMSG",e);
                 }

         }
     }
 
-    /** 
-     * this method uses a stringbuilder to create a new 
+    /**
+     * this method uses a stringbuilder to create a new
      * path for children. This is faster than string
-     * appends ( str1 + str2). 
+     * appends ( str1 + str2).
      * @param oa OutputArchive to write to.
      * @param path a string builder.
      * @throws IOException

         int off = path.length();
         if (children != null) {
             for (String child : children) {
-                //since this is single buffer being resused 
+                //since this is single buffer being resused
                 // we need
                 // to truncate the previous bytes of string.
                 path.delete(off, Integer.MAX_VALUE);
<EOC>
<SOC>
-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.auth;
-
-import java.io.IOException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.zookeeper.KeeperException;
-import com.yahoo.zookeeper.data.Id;
-import com.yahoo.zookeeper.server.ServerCnxn;
-
-public class DigestAuthenticationProvider implements AuthenticationProvider {
-    private static final Logger LOG = Logger.getLogger(DigestAuthenticationProvider.class);
-
-    public static String superDigest = "super:1wZ8qIvQBMTq0KPxMc6RQ/PCXKM=";
-
-    public String getScheme() {
-        return "digest";
-    }
-
-    static final private String base64Encode(byte b[]) {
-        StringBuffer sb = new StringBuffer();
-        for (int i = 0; i < b.length;) {
-            int pad = 0;
-            int v = (b[i++] & 0xff) << 16;
-            if (i < b.length) {
-                v |= (b[i++] & 0xff) << 8;
-            } else {
-                pad++;
-            }
-            if (i < b.length) {
-                v |= (b[i++] & 0xff);
-            } else {
-                pad++;
-            }
-            sb.append(encode(v >> 18));
-            sb.append(encode(v >> 12));
-            if (pad < 2) {
-                sb.append(encode(v >> 6));
-            } else {
-                sb.append('=');
-            }
-            if (pad < 1) {
-                sb.append(encode(v));
-            } else {
-                sb.append('=');
-            }
-        }
-        return sb.toString();
-    }
-
-    static final private char encode(int i) {
-        i &= 0x3f;
-        if (i < 26) {
-            return (char) ('A' + i);
-        }
-        if (i < 52) {
-            return (char) ('a' + i - 26);
-        }
-        if (i < 62) {
-            return (char) ('0' + i - 52);
-        }
-        return i == 62 ? '+' : '/';
-    }
-
-    static public String generateDigest(String idPassword)
-            throws NoSuchAlgorithmException {
-        String parts[] = idPassword.split(":", 2);
-        byte digest[] = MessageDigest.getInstance("SHA1").digest(
-                idPassword.getBytes());
-        return parts[0] + ":" + base64Encode(digest);
-    }
-
-    public int handleAuthentication(ServerCnxn cnxn, byte[] authData) {
-        String id = new String(authData);
-        try {
-            String digest = generateDigest(id);
-            if (digest.equals(superDigest)) {
-                cnxn.getAuthInfo().add(new Id("super", ""));
-            }
-            cnxn.getAuthInfo().add(new Id(getScheme(), digest));
-            return KeeperException.Code.Ok;
-        } catch (NoSuchAlgorithmException e) {
-            LOG.error("FIXMSG",e);
-        }
-        return KeeperException.Code.AuthFailed;
-    }
-
-    public boolean isAuthenticated() {
-        return true;
-    }
-
-    public boolean isValid(String id) {
-        String parts[] = id.split(":");
-        return parts.length == 2;
-    }
-
-    public boolean matches(String id, String aclExpr) {
-        return id.equals(aclExpr);
-    }
-
-    public static void main(String args[]) throws IOException,
-            NoSuchAlgorithmException {
-        for (int i = 0; i < args.length; i++) {
-            System.out.println(args[i] + "->" + generateDigest(args[i]));
-        }
-    }
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.auth;
+
+import java.io.IOException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.data.Id;
+import com.yahoo.zookeeper.server.ServerCnxn;
+
+public class DigestAuthenticationProvider implements AuthenticationProvider {
+    private static final Logger LOG = Logger.getLogger(DigestAuthenticationProvider.class);
+
+    public final static String superDigest = "super:1wZ8qIvQBMTq0KPxMc6RQ/PCXKM=";
+
+    public String getScheme() {
+        return "digest";
+    }
+
+    static final private String base64Encode(byte b[]) {
+        StringBuffer sb = new StringBuffer();
+        for (int i = 0; i < b.length;) {
+            int pad = 0;
+            int v = (b[i++] & 0xff) << 16;
+            if (i < b.length) {
+                v |= (b[i++] & 0xff) << 8;
+            } else {
+                pad++;
+            }
+            if (i < b.length) {
+                v |= (b[i++] & 0xff);
+            } else {
+                pad++;
+            }
+            sb.append(encode(v >> 18));
+            sb.append(encode(v >> 12));
+            if (pad < 2) {
+                sb.append(encode(v >> 6));
+            } else {
+                sb.append('=');
+            }
+            if (pad < 1) {
+                sb.append(encode(v));
+            } else {
+                sb.append('=');
+            }
+        }
+        return sb.toString();
+    }
+
+    static final private char encode(int i) {
+        i &= 0x3f;
+        if (i < 26) {
+            return (char) ('A' + i);
+        }
+        if (i < 52) {
+            return (char) ('a' + i - 26);
+        }
+        if (i < 62) {
+            return (char) ('0' + i - 52);
+        }
+        return i == 62 ? '+' : '/';
+    }
+
+    static public String generateDigest(String idPassword)
+            throws NoSuchAlgorithmException {
+        String parts[] = idPassword.split(":", 2);
+        byte digest[] = MessageDigest.getInstance("SHA1").digest(
+                idPassword.getBytes());
+        return parts[0] + ":" + base64Encode(digest);
+    }
+
+    public int handleAuthentication(ServerCnxn cnxn, byte[] authData) {
+        String id = new String(authData);
+        try {
+            String digest = generateDigest(id);
+            if (digest.equals(superDigest)) {
+                cnxn.getAuthInfo().add(new Id("super", ""));
+            }
+            cnxn.getAuthInfo().add(new Id(getScheme(), digest));
+            return KeeperException.Code.Ok;
+        } catch (NoSuchAlgorithmException e) {
+            LOG.error("Missing algorithm",e);
+        }
+        return KeeperException.Code.AuthFailed;
+    }
+
+    public boolean isAuthenticated() {
+        return true;
+    }
+
+    public boolean isValid(String id) {
+        String parts[] = id.split(":");
+        return parts.length == 2;
+    }
+
+    public boolean matches(String id, String aclExpr) {
+        return id.equals(aclExpr);
+    }
+
+    public static void main(String args[]) throws IOException,
+            NoSuchAlgorithmException {
+        for (int i = 0; i < args.length; i++) {
+            System.out.println(args[i] + "->" + generateDigest(args[i]));
+        }
+    }
+}
<EOC>
<SOC>
-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/**
- * This class has the control logic for the Follower.
- */
-package com.yahoo.zookeeper.server.quorum;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.util.HashMap;
-import java.util.Map.Entry;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.BinaryOutputArchive;
-import com.yahoo.jute.InputArchive;
-import com.yahoo.jute.OutputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.server.Request;
-import com.yahoo.zookeeper.server.ServerCnxn;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooTrace;
-import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-public class Follower {
-    private static final Logger LOG = Logger.getLogger(Follower.class);
-
-    QuorumPeer self;
-
-    FollowerZooKeeperServer zk;
-
-    Follower(QuorumPeer self,FollowerZooKeeperServer zk) {
-        this.self = self;
-        this.zk=zk;
-    }
-
-    private InputArchive leaderIs;
-
-    private OutputArchive leaderOs;
-
-    private BufferedOutputStream bufferedOutput;
-
-    public Socket sock;
-
-    /**
-     * write a packet to the leader
-     *
-     * @param pp
-     *                the proposal packet to be sent to the leader
-     * @throws IOException
-     */
-    void writePacket(QuorumPacket pp) throws IOException {
-        long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;
-        if (pp.getType() == Leader.PING) {
-            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;
-        }
-        ZooTrace.logQuorumPacket(LOG, traceMask, 'o', pp);
-        synchronized (leaderOs) {
-            leaderOs.writeRecord(pp, "packet");
-            bufferedOutput.flush();
-        }
-    }
-
-    /**
-     * read a packet from the leader
-     *
-     * @param pp
-     *                the packet to be instantiated
-     * @throws IOException
-     */
-    void readPacket(QuorumPacket pp) throws IOException {
-        synchronized (leaderIs) {
-            leaderIs.readRecord(pp, "packet");
-        }
-        long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;
-        if (pp.getType() == Leader.PING) {
-            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;
-        }
-        ZooTrace.logQuorumPacket(LOG, traceMask, 'i', pp);
-    }
-
-    /**
-     * the main method called by the follower to follow the leader
-     *
-     * @throws InterruptedException
-     */
-    void followLeader() throws InterruptedException {
-        InetSocketAddress addr = null;
-        // Find the leader by id
-        for (QuorumServer s : self.quorumPeers) {
-            if (s.id == self.currentVote.id) {
-                addr = s.addr;
-                break;
-            }
-        }
-        if (addr == null) {
-            LOG.error("Couldn't find the leader with id = "
-                    + self.currentVote.id);
-        }
-        LOG.warn("Following " + addr);
-        sock = new Socket();
-        try {
-            QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);
-            sock.setSoTimeout(self.tickTime * self.initLimit);
-            for (int tries = 0; tries < 5; tries++) {
-                try {
-                    //sock = new Socket();
-                    //sock.setSoTimeout(self.tickTime * self.initLimit);
-                    sock.connect(addr, self.tickTime * self.syncLimit);
-                    sock.setTcpNoDelay(true);
-                    break;
-                } catch (ConnectException e) {
-                    LOG.error("FIXMSG",e);
-                    if (tries == 4) {
-                        throw e;
-                    }
-                    else{
-                        sock = new Socket();
-                        sock.setSoTimeout(self.tickTime * self.initLimit);
-                    }
-                }
-                Thread.sleep(1000);
-            }
-            leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(
-                    sock.getInputStream()));
-            bufferedOutput = new BufferedOutputStream(sock.getOutputStream());
-            leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);
-            QuorumPacket qp = new QuorumPacket();
-            qp.setType(Leader.LASTZXID);
-            long sentLastZxid = self.getLastLoggedZxid();
-            qp.setZxid(sentLastZxid);
-            writePacket(qp);
-            readPacket(qp);
-            long newLeaderZxid = qp.getZxid();
-
-            if (qp.getType() != Leader.NEWLEADER) {
-                LOG.error("First packet should have been NEWLEADER");
-                throw new IOException("First packet should have been NEWLEADER");
-            }
-            readPacket(qp);
-            synchronized (zk) {
-                if (qp.getType() == Leader.DIFF) {
-                    LOG.warn("Getting a diff from the leader!");
-                    zk.loadData();
-                }
-                else if (qp.getType() == Leader.SNAP) {
-                    LOG.warn("Getting a snapshot from leader");
-                    // The leader is going to dump the database
-                    zk.loadData(leaderIs);
-                    String signature = leaderIs.readString("signature");
-                    if (!signature.equals("BenWasHere")) {
-                        LOG.error("Missing signature. Got " + signature);
-                        throw new IOException("Missing signature");
-                    }
-                } else if (qp.getType() == Leader.TRUNC) {
-                    //we need to truncate the log to the lastzxid of the leader
-                    LOG.warn("Truncating log to get in sync with the leader "
-                            + Long.toHexString(qp.getZxid()));
-                    zk.truncateLog(qp.getZxid());
-                    zk.loadData();
-                }
-                else {
-                    LOG.error("Got unexpected packet from leader "
-                            + qp.getType() + " exiting ... " );
-                    System.exit(13);
-                }
-                zk.dataTree.lastProcessedZxid = newLeaderZxid;
-            }
-            ack.setZxid(newLeaderZxid & ~0xffffffffL);
-            writePacket(ack);
-            sock.setSoTimeout(self.tickTime * self.syncLimit);
-            zk.startup();
-            while (self.running) {
-                readPacket(qp);
-                switch (qp.getType()) {
-                case Leader.PING:
-                    // Send back the ping with our session data
-                    ByteArrayOutputStream bos = new ByteArrayOutputStream();
-                    DataOutputStream dos = new DataOutputStream(bos);
-                    HashMap<Long, Integer> touchTable = ((FollowerZooKeeperServer) zk)
-                            .getTouchSnapshot();
-                    for (Entry<Long, Integer> entry : touchTable.entrySet()) {
-                        dos.writeLong(entry.getKey());
-                        dos.writeInt(entry.getValue());
-                    }
-                    qp.setData(bos.toByteArray());
-                    writePacket(qp);
-                    break;
-                case Leader.PROPOSAL:
-                    TxnHeader hdr = new TxnHeader();
-                    BinaryInputArchive ia = BinaryInputArchive
-                            .getArchive(new ByteArrayInputStream(qp.getData()));
-                    Record txn = ZooKeeperServer.deserializeTxn(ia, hdr);
-                    if (hdr.getZxid() != lastQueued + 1) {
-                        LOG.warn("Got zxid "
-                                + Long.toHexString(hdr.getZxid())
-                                + " expected "
-                                + Long.toHexString(lastQueued + 1));
-                    }
-                    lastQueued = hdr.getZxid();
-                    zk.logRequest(hdr, txn);
-                    break;
-                case Leader.COMMIT:
-                    zk.commit(qp.getZxid());
-                    break;
-                case Leader.UPTODATE:
-                    zk.snapshot();
-                    self.cnxnFactory.setZooKeeperServer(zk);
-                    break;
-                case Leader.REVALIDATE:
-                    ByteArrayInputStream bis = new ByteArrayInputStream(qp
-                            .getData());
-                    DataInputStream dis = new DataInputStream(bis);
-                    long sessionId = dis.readLong();
-                    boolean valid = dis.readBoolean();
-                    synchronized (pendingRevalidations) {
-                        ServerCnxn cnxn = pendingRevalidations
-                                .remove(sessionId);
-                        if (cnxn == null) {
-                            LOG.warn("Missing "
-                                    + Long.toHexString(sessionId)
-                                    + " for validation");
-                        } else {
-                            cnxn.finishSessionInit(valid);
-                        }
-                    }
-                    ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
-                                             "Session " + sessionId
-                                             + " is valid: " + valid);
-                    break;
-                case Leader.SYNC:
-                    zk.sync();
-                    break;
-                }
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-            try {
-                sock.close();
-            } catch (IOException e1) {
-                e1.printStackTrace();
-            }
-
-            synchronized (pendingRevalidations) {
-                // clear pending revalitions
-                pendingRevalidations.clear();
-                pendingRevalidations.notifyAll();
-            }
-        }
-    }
-
-    private long lastQueued;
-
-    ConcurrentHashMap<Long, ServerCnxn> pendingRevalidations = new ConcurrentHashMap<Long, ServerCnxn>();
-
-    /**
-     * validate a seesion for a client
-     *
-     * @param clientId
-     *                the client to be revailidated
-     * @param timeout
-     *                the timeout for which the session is valid
-     * @return
-     * @throws IOException
-     * @throws InterruptedException
-     */
-    void validateSession(ServerCnxn cnxn, long clientId, int timeout)
-            throws IOException, InterruptedException {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        DataOutputStream dos = new DataOutputStream(baos);
-        dos.writeLong(clientId);
-        dos.writeInt(timeout);
-        dos.close();
-        QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos
-                .toByteArray(), null);
-        pendingRevalidations.put(clientId, cnxn);
-        ZooTrace.logTraceMessage(LOG,
-                                 ZooTrace.SESSION_TRACE_MASK,
-                                 "To validate session "
-                                 + Long.toHexString(clientId));
-        writePacket(qp);
-    }
-
-    /**
-     * send a request packet to the leader
-     *
-     * @param request
-     *                the request from the client
-     * @throws IOException
-     */
-    void request(Request request) throws IOException {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        DataOutputStream oa = new DataOutputStream(baos);
-        oa.writeLong(request.sessionId);
-        oa.writeInt(request.cxid);
-        oa.writeInt(request.type);
-        if (request.request != null) {
-            request.request.rewind();
-            int len = request.request.remaining();
-            byte b[] = new byte[len];
-            request.request.get(b);
-            request.request.rewind();
-            oa.write(b);
-        }
-        oa.close();
-        QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos
-                .toByteArray(), request.authInfo);
-//        QuorumPacket qp;
-//        if(request.type == OpCode.sync){
-//            qp = new QuorumPacket(Leader.SYNC, -1, baos
-//                    .toByteArray(), request.authInfo);
-//        }
-//        else{
-//        qp = new QuorumPacket(Leader.REQUEST, -1, baos
-//                .toByteArray(), request.authInfo);
-//        }
-        writePacket(qp);
-    }
-
-    public long getZxid() {
-        try {
-            synchronized (zk) {
-                return zk.getZxid();
-            }
-        } catch (NullPointerException e) {
-        }
-        return -1;
-    }
-
-    public void shutdown() {
-        // set the zookeeper server to null
-        self.cnxnFactory.setZooKeeperServer(null);
-        // clear all the connections
-        self.cnxnFactory.clear();
-        // shutdown previous zookeeper
-        if (zk != null) {
-            zk.shutdown();
-
-        }
-        LOG.error("FIXMSG",new Exception("shutdown Follower"));
-    }
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * This class has the control logic for the Follower.
+ */
+package com.yahoo.zookeeper.server.quorum;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.util.HashMap;
+import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.BinaryOutputArchive;
+import com.yahoo.jute.InputArchive;
+import com.yahoo.jute.OutputArchive;
+import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.server.Request;
+import com.yahoo.zookeeper.server.ServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooTrace;
+import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+public class Follower {
+    private static final Logger LOG = Logger.getLogger(Follower.class);
+
+    QuorumPeer self;
+
+    FollowerZooKeeperServer zk;
+
+    Follower(QuorumPeer self,FollowerZooKeeperServer zk) {
+        this.self = self;
+        this.zk=zk;
+    }
+
+    private InputArchive leaderIs;
+
+    private OutputArchive leaderOs;
+
+    private BufferedOutputStream bufferedOutput;
+
+    public Socket sock;
+
+    /**
+     * write a packet to the leader
+     *
+     * @param pp
+     *                the proposal packet to be sent to the leader
+     * @throws IOException
+     */
+    void writePacket(QuorumPacket pp) throws IOException {
+        long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;
+        if (pp.getType() == Leader.PING) {
+            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;
+        }
+        ZooTrace.logQuorumPacket(LOG, traceMask, 'o', pp);
+        synchronized (leaderOs) {
+            leaderOs.writeRecord(pp, "packet");
+            bufferedOutput.flush();
+        }
+    }
+
+    /**
+     * read a packet from the leader
+     *
+     * @param pp
+     *                the packet to be instantiated
+     * @throws IOException
+     */
+    void readPacket(QuorumPacket pp) throws IOException {
+        synchronized (leaderIs) {
+            leaderIs.readRecord(pp, "packet");
+        }
+        long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;
+        if (pp.getType() == Leader.PING) {
+            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;
+        }
+        ZooTrace.logQuorumPacket(LOG, traceMask, 'i', pp);
+    }
+
+    /**
+     * the main method called by the follower to follow the leader
+     *
+     * @throws InterruptedException
+     */
+    void followLeader() throws InterruptedException {
+        InetSocketAddress addr = null;
+        // Find the leader by id
+        for (QuorumServer s : self.quorumPeers) {
+            if (s.id == self.currentVote.id) {
+                addr = s.addr;
+                break;
+            }
+        }
+        if (addr == null) {
+            LOG.warn("Couldn't find the leader with id = "
+                    + self.currentVote.id);
+        }
+        LOG.info("Following " + addr);
+        sock = new Socket();
+        try {
+            QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);
+            sock.setSoTimeout(self.tickTime * self.initLimit);
+            for (int tries = 0; tries < 5; tries++) {
+                try {
+                    //sock = new Socket();
+                    //sock.setSoTimeout(self.tickTime * self.initLimit);
+                    sock.connect(addr, self.tickTime * self.syncLimit);
+                    sock.setTcpNoDelay(true);
+                    break;
+                } catch (ConnectException e) {
+                    if (tries == 4) {
+                        LOG.error("Unexpected exception",e);
+                        throw e;
+                    } else {
+                        LOG.warn("Unexpected exception",e);
+                        sock = new Socket();
+                        sock.setSoTimeout(self.tickTime * self.initLimit);
+                    }
+                }
+                Thread.sleep(1000);
+            }
+            leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(
+                    sock.getInputStream()));
+            bufferedOutput = new BufferedOutputStream(sock.getOutputStream());
+            leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);
+            QuorumPacket qp = new QuorumPacket();
+            qp.setType(Leader.LASTZXID);
+            long sentLastZxid = self.getLastLoggedZxid();
+            qp.setZxid(sentLastZxid);
+            writePacket(qp);
+            readPacket(qp);
+            long newLeaderZxid = qp.getZxid();
+
+            if (qp.getType() != Leader.NEWLEADER) {
+                LOG.error("First packet should have been NEWLEADER");
+                throw new IOException("First packet should have been NEWLEADER");
+            }
+            readPacket(qp);
+            synchronized (zk) {
+                if (qp.getType() == Leader.DIFF) {
+                    LOG.info("Getting a diff from the leader!");
+                    zk.loadData();
+                }
+                else if (qp.getType() == Leader.SNAP) {
+                    LOG.info("Getting a snapshot from leader");
+                    // The leader is going to dump the database
+                    zk.loadData(leaderIs);
+                    String signature = leaderIs.readString("signature");
+                    if (!signature.equals("BenWasHere")) {
+                        LOG.error("Missing signature. Got " + signature);
+                        throw new IOException("Missing signature");
+                    }
+                } else if (qp.getType() == Leader.TRUNC) {
+                    //we need to truncate the log to the lastzxid of the leader
+                    LOG.warn("Truncating log to get in sync with the leader "
+                            + Long.toHexString(qp.getZxid()));
+                    zk.truncateLog(qp.getZxid());
+                    zk.loadData();
+                }
+                else {
+                    LOG.error("Got unexpected packet from leader "
+                            + qp.getType() + " exiting ... " );
+                    System.exit(13);
+                }
+                zk.dataTree.lastProcessedZxid = newLeaderZxid;
+            }
+            ack.setZxid(newLeaderZxid & ~0xffffffffL);
+            writePacket(ack);
+            sock.setSoTimeout(self.tickTime * self.syncLimit);
+            zk.startup();
+            while (self.running) {
+                readPacket(qp);
+                switch (qp.getType()) {
+                case Leader.PING:
+                    // Send back the ping with our session data
+                    ByteArrayOutputStream bos = new ByteArrayOutputStream();
+                    DataOutputStream dos = new DataOutputStream(bos);
+                    HashMap<Long, Integer> touchTable = ((FollowerZooKeeperServer) zk)
+                            .getTouchSnapshot();
+                    for (Entry<Long, Integer> entry : touchTable.entrySet()) {
+                        dos.writeLong(entry.getKey());
+                        dos.writeInt(entry.getValue());
+                    }
+                    qp.setData(bos.toByteArray());
+                    writePacket(qp);
+                    break;
+                case Leader.PROPOSAL:
+                    TxnHeader hdr = new TxnHeader();
+                    BinaryInputArchive ia = BinaryInputArchive
+                            .getArchive(new ByteArrayInputStream(qp.getData()));
+                    Record txn = ZooKeeperServer.deserializeTxn(ia, hdr);
+                    if (hdr.getZxid() != lastQueued + 1) {
+                        LOG.warn("Got zxid "
+                                + Long.toHexString(hdr.getZxid())
+                                + " expected "
+                                + Long.toHexString(lastQueued + 1));
+                    }
+                    lastQueued = hdr.getZxid();
+                    zk.logRequest(hdr, txn);
+                    break;
+                case Leader.COMMIT:
+                    zk.commit(qp.getZxid());
+                    break;
+                case Leader.UPTODATE:
+                    zk.snapshot();
+                    self.cnxnFactory.setZooKeeperServer(zk);
+                    break;
+                case Leader.REVALIDATE:
+                    ByteArrayInputStream bis = new ByteArrayInputStream(qp
+                            .getData());
+                    DataInputStream dis = new DataInputStream(bis);
+                    long sessionId = dis.readLong();
+                    boolean valid = dis.readBoolean();
+                    synchronized (pendingRevalidations) {
+                        ServerCnxn cnxn = pendingRevalidations
+                                .remove(sessionId);
+                        if (cnxn == null) {
+                            LOG.warn("Missing "
+                                    + Long.toHexString(sessionId)
+                                    + " for validation");
+                        } else {
+                            cnxn.finishSessionInit(valid);
+                        }
+                    }
+                    ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
+                                             "Session " + sessionId
+                                             + " is valid: " + valid);
+                    break;
+                case Leader.SYNC:
+                    zk.sync();
+                    break;
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            try {
+                sock.close();
+            } catch (IOException e1) {
+                e1.printStackTrace();
+            }
+
+            synchronized (pendingRevalidations) {
+                // clear pending revalitions
+                pendingRevalidations.clear();
+                pendingRevalidations.notifyAll();
+            }
+        }
+    }
+
+    private long lastQueued;
+
+    ConcurrentHashMap<Long, ServerCnxn> pendingRevalidations = new ConcurrentHashMap<Long, ServerCnxn>();
+
+    /**
+     * validate a seesion for a client
+     *
+     * @param clientId
+     *                the client to be revailidated
+     * @param timeout
+     *                the timeout for which the session is valid
+     * @return
+     * @throws IOException
+     * @throws InterruptedException
+     */
+    void validateSession(ServerCnxn cnxn, long clientId, int timeout)
+            throws IOException, InterruptedException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        DataOutputStream dos = new DataOutputStream(baos);
+        dos.writeLong(clientId);
+        dos.writeInt(timeout);
+        dos.close();
+        QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos
+                .toByteArray(), null);
+        pendingRevalidations.put(clientId, cnxn);
+        ZooTrace.logTraceMessage(LOG,
+                                 ZooTrace.SESSION_TRACE_MASK,
+                                 "To validate session "
+                                 + Long.toHexString(clientId));
+        writePacket(qp);
+    }
+
+    /**
+     * send a request packet to the leader
+     *
+     * @param request
+     *                the request from the client
+     * @throws IOException
+     */
+    void request(Request request) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        DataOutputStream oa = new DataOutputStream(baos);
+        oa.writeLong(request.sessionId);
+        oa.writeInt(request.cxid);
+        oa.writeInt(request.type);
+        if (request.request != null) {
+            request.request.rewind();
+            int len = request.request.remaining();
+            byte b[] = new byte[len];
+            request.request.get(b);
+            request.request.rewind();
+            oa.write(b);
+        }
+        oa.close();
+        QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos
+                .toByteArray(), request.authInfo);
+//        QuorumPacket qp;
+//        if(request.type == OpCode.sync){
+//            qp = new QuorumPacket(Leader.SYNC, -1, baos
+//                    .toByteArray(), request.authInfo);
+//        }
+//        else{
+//        qp = new QuorumPacket(Leader.REQUEST, -1, baos
+//                .toByteArray(), request.authInfo);
+//        }
+        writePacket(qp);
+    }
+
+    public long getZxid() {
+        try {
+            synchronized (zk) {
+                return zk.getZxid();
+            }
+        } catch (NullPointerException e) {
+        }
+        return -1;
+    }
+
+    public void shutdown() {
+        // set the zookeeper server to null
+        self.cnxnFactory.setZooKeeperServer(null);
+        // clear all the connections
+        self.cnxnFactory.clear();
+        // shutdown previous zookeeper
+        if (zk != null) {
+            zk.shutdown();
+
+        }
+        LOG.error("FIXMSG",new Exception("shutdown Follower"));
+    }
+}
<EOC>
<SOC>
-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server.quorum;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.net.Socket;
-import java.nio.ByteBuffer;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.BinaryOutputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooTrace;
-import com.yahoo.zookeeper.server.quorum.Leader.Proposal;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-/**
- * There will be an instance of this class created by the Leader for each
- * follower.All communication for a given Follower will be handled by this
- * class.
- */
-public class FollowerHandler extends Thread {
-    private static final Logger LOG = Logger.getLogger(FollowerHandler.class);
-
-    public Socket s;
-
-    Leader leader;
-
-    long tickOfLastAck;
-
-    /**
-     * The packets to be sent to the follower
-     */
-    LinkedBlockingQueue<QuorumPacket> queuedPackets = new LinkedBlockingQueue<QuorumPacket>();
-
-    private BinaryInputArchive ia;
-
-    private BinaryOutputArchive oa;
-
-    private BufferedOutputStream bufferedOutput;
-
-    FollowerHandler(Socket s, Leader leader) throws IOException {
-        super("FollowerHandler-" + s.getRemoteSocketAddress());
-        this.s = s;
-        this.leader = leader;
-        leader.addFollowerHandler(this);
-        start();
-    }
-
-    /**
-     * If this packet is queued, the sender thread will exit
-     */
-    QuorumPacket proposalOfDeath = new QuorumPacket();
-
-    /**
-     * This method will use the thread to send packets added to the
-     * queuedPackets list
-     *
-     * @throws InterruptedException
-     */
-    private void sendPackets() throws InterruptedException {
-        long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;
-        while (true) {
-            QuorumPacket p;
-            p = queuedPackets.take();
-
-            if (p == proposalOfDeath) {
-                // Packet of death!
-                break;
-            }
-            if (p.getType() == Leader.PING) {
-                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;
-            }
-            ZooTrace.logQuorumPacket(LOG, traceMask, 'o', p);
-            try {
-                oa.writeRecord(p, "packet");
-                bufferedOutput.flush();
-            } catch (IOException e) {
-                if (!s.isClosed()) {
-                    LOG.error("FIXMSG",e);
-                }
-                break;
-            }
-        }
-    }
-
-    static public String packetToString(QuorumPacket p) {
-        if (true)
-            return null;
-        String type = null;
-        String mess = null;
-        Record txn = null;
-        switch (p.getType()) {
-        case Leader.ACK:
-            type = "ACK";
-            break;
-        case Leader.COMMIT:
-            type = "COMMIT";
-            break;
-        case Leader.LASTZXID:
-            type = "LASTZXID";
-            break;
-        case Leader.NEWLEADER:
-            type = "NEWLEADER";
-            break;
-        case Leader.PING:
-            type = "PING";
-            break;
-        case Leader.PROPOSAL:
-            type = "PROPOSAL";
-            BinaryInputArchive ia = BinaryInputArchive
-                    .getArchive(new ByteArrayInputStream(p.getData()));
-            TxnHeader hdr = new TxnHeader();
-            try {
-                txn = ZooKeeperServer.deserializeTxn(ia, hdr);
-                // mess = "transaction: " + txn.toString();
-            } catch (IOException e) {
-                LOG.error("FIXMSG",e);
-            }
-            break;
-        case Leader.REQUEST:
-            type = "REQUEST";
-            break;
-        case Leader.REVALIDATE:
-            type = "REVALIDATE";
-            ByteArrayInputStream bis = new ByteArrayInputStream(p.getData());
-            DataInputStream dis = new DataInputStream(bis);
-            try {
-                long id = dis.readLong();
-                mess = " sessionid = " + id;
-            } catch (IOException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
-
-            break;
-        case Leader.UPTODATE:
-            type = "UPTODATE";
-            break;
-        default:
-            type = "UNKNOWN" + p.getType();
-        }
-        String entry = null;
-        if (type != null) {
-            entry = type + " " + Long.toHexString(p.getZxid()) + " " + mess;
-        }
-        return entry;
-    }
-
-    /**
-     * This thread will receive packets from the follower and process them and
-     * also listen to new connections from new followers.
-     */
-    public void run() {
-        try {
-
-            ia = BinaryInputArchive.getArchive(new BufferedInputStream(s
-                    .getInputStream()));
-            bufferedOutput = new BufferedOutputStream(s.getOutputStream());
-            oa = BinaryOutputArchive.getArchive(bufferedOutput);
-
-            QuorumPacket qp = new QuorumPacket();
-            ia.readRecord(qp, "packet");
-            if (qp.getType() != Leader.LASTZXID) {
-                LOG.error("First packet " + qp.toString()
-                        + " is not LASTZXID!");
-                return;
-            }
-            long peerLastZxid = qp.getZxid();
-            int packetToSend = Leader.SNAP;
-            boolean logTxns = true;
-
-            long zxidToSend = 0;
-            // we are sending the diff
-            synchronized(leader.zk.committedLog) {
-                if (leader.zk.committedLog.size() != 0) {
-                    if ((leader.zk.maxCommittedLog >= peerLastZxid)
-                            && (leader.zk.minCommittedLog <= peerLastZxid)) {
-                        packetToSend = Leader.DIFF;
-                        zxidToSend = leader.zk.maxCommittedLog;
-                        for (Proposal propose: leader.zk.committedLog) {
-                            if (propose.packet.getZxid() > peerLastZxid) {
-                                queuePacket(propose.packet);
-                                QuorumPacket qcommit = new QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),
-                                        null, null);
-                                queuePacket(qcommit);
-
-                            }
-                        }
-                    }
-                }
-                else {
-                    logTxns = false;
-                }            }
-            long leaderLastZxid = leader.startForwarding(this, peerLastZxid);
-            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,
-                    leaderLastZxid, null, null);
-            oa.writeRecord(newLeaderQP, "packet");
-            bufferedOutput.flush();
-            // a special case when both the ids are the same
-            if (peerLastZxid == leaderLastZxid) {
-                packetToSend = Leader.DIFF;
-                zxidToSend = leaderLastZxid;
-            }
-            //check if we decided to send a diff or we need to send a truncate
-            // we avoid using epochs for truncating because epochs make things
-            // complicated. Two epochs might have the last 32 bits as same.
-            // only if we know that there is a committed zxid in the queue that
-            // is less than the one the peer has we send a trunc else to make
-            // things simple we just send sanpshot.
-            if (logTxns && (peerLastZxid > leader.zk.maxCommittedLog)) {
-                // this is the only case that we are sure that
-                // we can ask the follower to truncate the log
-                packetToSend = Leader.TRUNC;
-                zxidToSend = leader.zk.maxCommittedLog;
-
-            }
-            oa.writeRecord(new QuorumPacket(packetToSend, zxidToSend, null, null), "packet");
-            bufferedOutput.flush();
-            // only if we are not truncating or fast sycning
-            if (packetToSend == Leader.SNAP) {
-                LOG.warn("Sending snapshot last zxid of peer is "
-                        + Long.toHexString(peerLastZxid) + " " + " zxid of leader is "
-                        + Long.toHexString(leaderLastZxid));
-                // Dump data to follower
-                leader.zk.snapshot(oa);
-                oa.writeString("BenWasHere", "signature");
-            }
-            bufferedOutput.flush();
-            //
-            // Mutation packets will be queued during the serialize,
-            // so we need to mark when the follower can actually start
-            // using the data
-            //
-            queuedPackets
-                    .add(new QuorumPacket(Leader.UPTODATE, -1, null, null));
-
-            // Start sending packets
-            new Thread() {
-                public void run() {
-                    Thread.currentThread().setName(
-                            "Sender-" + s.getRemoteSocketAddress());
-                    try {
-                        sendPackets();
-                    } catch (InterruptedException e) {
-                        LOG.error("FIXMSG",e);
-                    }
-                }
-            }.start();
-
-            while (true) {
-                qp = new QuorumPacket();
-                ia.readRecord(qp, "packet");
-
-                long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;
-                if (qp.getType() == Leader.PING) {
-                    traceMask = ZooTrace.SERVER_PING_TRACE_MASK;
-                }
-                ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);
-                tickOfLastAck = leader.self.tick;
-
-
-                ByteBuffer bb;
-                long sessionId;
-                int cxid;
-                int type;
-
-                switch (qp.getType()) {
-                case Leader.ACK:
-                    leader.processAck(qp.getZxid(), s.getLocalSocketAddress());
-                    break;
-                case Leader.PING:
-                    // Process the touches
-                    ByteArrayInputStream bis = new ByteArrayInputStream(qp
-                            .getData());
-                    DataInputStream dis = new DataInputStream(bis);
-                    while (dis.available() > 0) {
-                        long sess = dis.readLong();
-                        int to = dis.readInt();
-                        leader.zk.touch(sess, to);
-                    }
-                    break;
-                case Leader.REVALIDATE:
-                    bis = new ByteArrayInputStream(qp.getData());
-                    dis = new DataInputStream(bis);
-                    long id = dis.readLong();
-                    int to = dis.readInt();
-                    ByteArrayOutputStream bos = new ByteArrayOutputStream();
-                    DataOutputStream dos = new DataOutputStream(bos);
-                    dos.writeLong(id);
-                    boolean valid = leader.zk.touch(id, to);
-                    ZooTrace.logTraceMessage(LOG,
-                                             ZooTrace.SESSION_TRACE_MASK,
-                                             "Session " + Long.toHexString(id)
-                                             + " is valid: "+ valid);
-                    dos.writeBoolean(valid);
-                    qp.setData(bos.toByteArray());
-                    queuedPackets.add(qp);
-                    break;
-                case Leader.REQUEST:
-                    bb = ByteBuffer.wrap(qp.getData());
-                    sessionId = bb.getLong();
-                    cxid = bb.getInt();
-                    type = bb.getInt();
-                    bb = bb.slice();
-                    if(type == OpCode.sync){
-                        leader.setSyncHandler(this, sessionId);
-                    }
-                    leader.zk.submitRequest(null, sessionId, type, cxid, bb,
-                            qp.getAuthinfo());
-                    break;
-                default:
-                }
-            }
-        } catch (IOException e) {
-            if (s != null && !s.isClosed()) {
-                LOG.error("FIXMSG",e);
-            }
-        } catch (InterruptedException e) {
-            LOG.error("FIXMSG",e);
-        } finally {
-            LOG.warn("******* GOODBYE " + s.getRemoteSocketAddress()
-                    + " ********");
-            // Send the packet of death
-            try {
-                queuedPackets.put(proposalOfDeath);
-            } catch (InterruptedException e) {
-                LOG.error("FIXMSG",e);
-            }
-            shutdown();
-        }
-    }
-
-    public void shutdown() {
-        try {
-            if (s != null && !s.isClosed()) {
-                s.close();
-            }
-        } catch (IOException e) {
-            LOG.error("FIXMSG",e);
-        }
-        leader.removeFollowerHandler(this);
-    }
-
-    public long tickOfLastAck() {
-        return tickOfLastAck;
-    }
-
-    /**
-     * ping calls from the leader to the followers
-     */
-    public void ping() {
-        QuorumPacket ping = new QuorumPacket(Leader.PING, leader.lastProposed,
-                null, null);
-        queuePacket(ping);
-    }
-
-    void queuePacket(QuorumPacket p) {
-        queuedPackets.add(p);
-    }
-
-    public boolean synced() {
-        return isAlive()
-                && tickOfLastAck >= leader.self.tick - leader.self.syncLimit;
-    }
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server.quorum;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.net.Socket;
+import java.nio.ByteBuffer;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.BinaryOutputArchive;
+import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.ZooDefs.OpCode;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooTrace;
+import com.yahoo.zookeeper.server.quorum.Leader.Proposal;
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+/**
+ * There will be an instance of this class created by the Leader for each
+ * follower.All communication for a given Follower will be handled by this
+ * class.
+ */
+public class FollowerHandler extends Thread {
+    private static final Logger LOG = Logger.getLogger(FollowerHandler.class);
+
+    public Socket s;
+
+    Leader leader;
+
+    long tickOfLastAck;
+
+    /**
+     * The packets to be sent to the follower
+     */
+    LinkedBlockingQueue<QuorumPacket> queuedPackets = new LinkedBlockingQueue<QuorumPacket>();
+
+    private BinaryInputArchive ia;
+
+    private BinaryOutputArchive oa;
+
+    private BufferedOutputStream bufferedOutput;
+
+    FollowerHandler(Socket s, Leader leader) throws IOException {
+        super("FollowerHandler-" + s.getRemoteSocketAddress());
+        this.s = s;
+        this.leader = leader;
+        leader.addFollowerHandler(this);
+        start();
+    }
+
+    /**
+     * If this packet is queued, the sender thread will exit
+     */
+    QuorumPacket proposalOfDeath = new QuorumPacket();
+
+    /**
+     * This method will use the thread to send packets added to the
+     * queuedPackets list
+     *
+     * @throws InterruptedException
+     */
+    private void sendPackets() throws InterruptedException {
+        long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;
+        while (true) {
+            QuorumPacket p;
+            p = queuedPackets.take();
+
+            if (p == proposalOfDeath) {
+                // Packet of death!
+                break;
+            }
+            if (p.getType() == Leader.PING) {
+                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;
+            }
+            ZooTrace.logQuorumPacket(LOG, traceMask, 'o', p);
+            try {
+                oa.writeRecord(p, "packet");
+                bufferedOutput.flush();
+            } catch (IOException e) {
+                if (!s.isClosed()) {
+                    LOG.warn("Unexpected exception",e);
+                }
+                break;
+            }
+        }
+    }
+
+    static public String packetToString(QuorumPacket p) {
+        if (true)
+            return null;
+        String type = null;
+        String mess = null;
+        Record txn = null;
+        switch (p.getType()) {
+        case Leader.ACK:
+            type = "ACK";
+            break;
+        case Leader.COMMIT:
+            type = "COMMIT";
+            break;
+        case Leader.LASTZXID:
+            type = "LASTZXID";
+            break;
+        case Leader.NEWLEADER:
+            type = "NEWLEADER";
+            break;
+        case Leader.PING:
+            type = "PING";
+            break;
+        case Leader.PROPOSAL:
+            type = "PROPOSAL";
+            BinaryInputArchive ia = BinaryInputArchive
+                    .getArchive(new ByteArrayInputStream(p.getData()));
+            TxnHeader hdr = new TxnHeader();
+            try {
+                txn = ZooKeeperServer.deserializeTxn(ia, hdr);
+                // mess = "transaction: " + txn.toString();
+            } catch (IOException e) {
+                LOG.warn("Unexpected exception",e);
+            }
+            break;
+        case Leader.REQUEST:
+            type = "REQUEST";
+            break;
+        case Leader.REVALIDATE:
+            type = "REVALIDATE";
+            ByteArrayInputStream bis = new ByteArrayInputStream(p.getData());
+            DataInputStream dis = new DataInputStream(bis);
+            try {
+                long id = dis.readLong();
+                mess = " sessionid = " + id;
+            } catch (IOException e) {
+                LOG.warn("Unexpected exception", e);
+            }
+
+            break;
+        case Leader.UPTODATE:
+            type = "UPTODATE";
+            break;
+        default:
+            type = "UNKNOWN" + p.getType();
+        }
+        String entry = null;
+        if (type != null) {
+            entry = type + " " + Long.toHexString(p.getZxid()) + " " + mess;
+        }
+        return entry;
+    }
+
+    /**
+     * This thread will receive packets from the follower and process them and
+     * also listen to new connections from new followers.
+     */
+    public void run() {
+        try {
+
+            ia = BinaryInputArchive.getArchive(new BufferedInputStream(s
+                    .getInputStream()));
+            bufferedOutput = new BufferedOutputStream(s.getOutputStream());
+            oa = BinaryOutputArchive.getArchive(bufferedOutput);
+
+            QuorumPacket qp = new QuorumPacket();
+            ia.readRecord(qp, "packet");
+            if (qp.getType() != Leader.LASTZXID) {
+                LOG.error("First packet " + qp.toString()
+                        + " is not LASTZXID!");
+                return;
+            }
+            long peerLastZxid = qp.getZxid();
+            int packetToSend = Leader.SNAP;
+            boolean logTxns = true;
+
+            long zxidToSend = 0;
+            // we are sending the diff
+            synchronized(leader.zk.committedLog) {
+                if (leader.zk.committedLog.size() != 0) {
+                    if ((leader.zk.maxCommittedLog >= peerLastZxid)
+                            && (leader.zk.minCommittedLog <= peerLastZxid)) {
+                        packetToSend = Leader.DIFF;
+                        zxidToSend = leader.zk.maxCommittedLog;
+                        for (Proposal propose: leader.zk.committedLog) {
+                            if (propose.packet.getZxid() > peerLastZxid) {
+                                queuePacket(propose.packet);
+                                QuorumPacket qcommit = new QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),
+                                        null, null);
+                                queuePacket(qcommit);
+
+                            }
+                        }
+                    }
+                }
+                else {
+                    logTxns = false;
+                }            }
+            long leaderLastZxid = leader.startForwarding(this, peerLastZxid);
+            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,
+                    leaderLastZxid, null, null);
+            oa.writeRecord(newLeaderQP, "packet");
+            bufferedOutput.flush();
+            // a special case when both the ids are the same
+            if (peerLastZxid == leaderLastZxid) {
+                packetToSend = Leader.DIFF;
+                zxidToSend = leaderLastZxid;
+            }
+            //check if we decided to send a diff or we need to send a truncate
+            // we avoid using epochs for truncating because epochs make things
+            // complicated. Two epochs might have the last 32 bits as same.
+            // only if we know that there is a committed zxid in the queue that
+            // is less than the one the peer has we send a trunc else to make
+            // things simple we just send sanpshot.
+            if (logTxns && (peerLastZxid > leader.zk.maxCommittedLog)) {
+                // this is the only case that we are sure that
+                // we can ask the follower to truncate the log
+                packetToSend = Leader.TRUNC;
+                zxidToSend = leader.zk.maxCommittedLog;
+
+            }
+            oa.writeRecord(new QuorumPacket(packetToSend, zxidToSend, null, null), "packet");
+            bufferedOutput.flush();
+            // only if we are not truncating or fast sycning
+            if (packetToSend == Leader.SNAP) {
+                LOG.warn("Sending snapshot last zxid of peer is "
+                        + Long.toHexString(peerLastZxid) + " " + " zxid of leader is "
+                        + Long.toHexString(leaderLastZxid));
+                // Dump data to follower
+                leader.zk.snapshot(oa);
+                oa.writeString("BenWasHere", "signature");
+            }
+            bufferedOutput.flush();
+            //
+            // Mutation packets will be queued during the serialize,
+            // so we need to mark when the follower can actually start
+            // using the data
+            //
+            queuedPackets
+                    .add(new QuorumPacket(Leader.UPTODATE, -1, null, null));
+
+            // Start sending packets
+            new Thread() {
+                public void run() {
+                    Thread.currentThread().setName(
+                            "Sender-" + s.getRemoteSocketAddress());
+                    try {
+                        sendPackets();
+                    } catch (InterruptedException e) {
+                        LOG.warn("Interrupted",e);
+                    }
+                }
+            }.start();
+
+            while (true) {
+                qp = new QuorumPacket();
+                ia.readRecord(qp, "packet");
+
+                long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;
+                if (qp.getType() == Leader.PING) {
+                    traceMask = ZooTrace.SERVER_PING_TRACE_MASK;
+                }
+                ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);
+                tickOfLastAck = leader.self.tick;
+
+
+                ByteBuffer bb;
+                long sessionId;
+                int cxid;
+                int type;
+
+                switch (qp.getType()) {
+                case Leader.ACK:
+                    leader.processAck(qp.getZxid(), s.getLocalSocketAddress());
+                    break;
+                case Leader.PING:
+                    // Process the touches
+                    ByteArrayInputStream bis = new ByteArrayInputStream(qp
+                            .getData());
+                    DataInputStream dis = new DataInputStream(bis);
+                    while (dis.available() > 0) {
+                        long sess = dis.readLong();
+                        int to = dis.readInt();
+                        leader.zk.touch(sess, to);
+                    }
+                    break;
+                case Leader.REVALIDATE:
+                    bis = new ByteArrayInputStream(qp.getData());
+                    dis = new DataInputStream(bis);
+                    long id = dis.readLong();
+                    int to = dis.readInt();
+                    ByteArrayOutputStream bos = new ByteArrayOutputStream();
+                    DataOutputStream dos = new DataOutputStream(bos);
+                    dos.writeLong(id);
+                    boolean valid = leader.zk.touch(id, to);
+                    ZooTrace.logTraceMessage(LOG,
+                                             ZooTrace.SESSION_TRACE_MASK,
+                                             "Session " + Long.toHexString(id)
+                                             + " is valid: "+ valid);
+                    dos.writeBoolean(valid);
+                    qp.setData(bos.toByteArray());
+                    queuedPackets.add(qp);
+                    break;
+                case Leader.REQUEST:
+                    bb = ByteBuffer.wrap(qp.getData());
+                    sessionId = bb.getLong();
+                    cxid = bb.getInt();
+                    type = bb.getInt();
+                    bb = bb.slice();
+                    if(type == OpCode.sync){
+                        leader.setSyncHandler(this, sessionId);
+                    }
+                    leader.zk.submitRequest(null, sessionId, type, cxid, bb,
+                            qp.getAuthinfo());
+                    break;
+                default:
+                }
+            }
+        } catch (IOException e) {
+            if (s != null && !s.isClosed()) {
+                LOG.error("FIXMSG",e);
+            }
+        } catch (InterruptedException e) {
+            LOG.error("FIXMSG",e);
+        } finally {
+            LOG.warn("******* GOODBYE " + s.getRemoteSocketAddress()
+                    + " ********");
+            // Send the packet of death
+            try {
+                queuedPackets.put(proposalOfDeath);
+            } catch (InterruptedException e) {
+                LOG.error("FIXMSG",e);
+            }
+            shutdown();
+        }
+    }
+
+    public void shutdown() {
+        try {
+            if (s != null && !s.isClosed()) {
+                s.close();
+            }
+        } catch (IOException e) {
+            LOG.error("FIXMSG",e);
+        }
+        leader.removeFollowerHandler(this);
+    }
+
+    public long tickOfLastAck() {
+        return tickOfLastAck;
+    }
+
+    /**
+     * ping calls from the leader to the followers
+     */
+    public void ping() {
+        QuorumPacket ping = new QuorumPacket(Leader.PING, leader.lastProposed,
+                null, null);
+        queuePacket(ping);
+    }
+
+    void queuePacket(QuorumPacket p) {
+        queuedPackets.add(p);
+    }
+
+    public boolean synced() {
+        return isAlive()
+                && tickOfLastAck >= leader.self.tick - leader.self.syncLimit;
+    }
+}
<EOC>
<SOC>
 import java.util.Random;
 import java.util.concurrent.ArrayBlockingQueue;
 
-import com.yahoo.zookeeper.server.ZooLog;
+import org.apache.log4j.Logger;
 
 /**
  * This class implements a connection manager for leader election using TCP. It

  */
 
 class QuorumCnxManager extends Thread {
+    private static final Logger LOG = Logger.getLogger(QuorumCnxManager.class);
+
     /*
      * Maximum capacity of thread queues
      */

         try {
             localIP = InetAddress.getLocalHost();
         } catch (UnknownHostException e) {
-            ZooLog.logWarn("Couldn't get local address");
+            LOG.warn("Couldn't get local address");
         }
 
         // Generates a challenge to guarantee one connection between pairs of

         genChallenge();
 
         // Starts listener thread that waits for connection requests 
-        listener = new Listener(this);
+        listener = new Listener();
         listener.start();
     }
 

         //} else {
         //    wins = true;
         //} 
-        //ZooLog.logWarn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
+        //LOG.warn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
         
         try {
             while (challenged && s.isConnected()) {

                 msgBuffer.position(0);
                 s.write(msgBuffer);
         
-                      // Reading challenge
-                    msgBuffer.position(0);
-                  int numBytes = s.read(msgBuffer);
+                // Reading challenge
+                msgBuffer.position(0);
+                s.read(msgBuffer);
         
-                 msgBuffer.position(0);
-               newChallenge = msgBuffer.getLong();
+                msgBuffer.position(0);
+                newChallenge = msgBuffer.getLong();
                 if (challenge > newChallenge) {
                    wins = true;
                     challenged = false;

                 }
             }
         } catch (IOException e) {
-            ZooLog.logWarn("Exception reading or writing challenge: "
+            LOG.warn("Exception reading or writing challenge: "
                     + e.toString());
             return false;
         }

         // If lost the challenge, then drop the new connection
         if (!wins) {
             try {
-                //ZooLog.logWarn("lost cause (initiate");
+                //LOG.warn("lost cause (initiate");
                 s.socket().close();
             } catch (IOException e) {
-                ZooLog
-                        .logWarn("Error when closing socket or trying to reopen connection: "
+                LOG.warn("Error when closing socket or trying to reopen connection: "
                                 + e.toString());
 
             }

                 /*
                  * Start new worker thread with a clean state.
                  */
-                SendWorker sw = new SendWorker(s);
                 if (s != null) {
+                    SendWorker sw = new SendWorker(s);
                     RecvWorker rw = new RecvWorker(s);
                     sw.setRecv(rw);
 

 
                     return true;
                 } else {
-                    ZooLog.logWarn("Channel null");
+                    LOG.warn("Channel null");
                     return false;
                 }
             }

         //    wins = true;
         //} 
         
-        //ZooLog.logWarn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
+        //LOG.warn("Hash codes: " + hashCodeRemote + ", " + localIP.hashCode());
         
         
         try {

                 }
             }
         } catch (IOException e) {
-            ZooLog.logWarn("Exception reading or writing challenge: "
+            LOG.warn("Exception reading or writing challenge: "
                     + e.toString());
             return false;
         }

                 InetAddress addr = s.socket().getInetAddress();
                 SendWorker sw = senderWorkerMap.get(addr);
 
-                //ZooLog.logWarn("Keep connection (received)");
+                //LOG.warn("Keep connection (received)");
                 //sw.connect();
                 s.socket().close();
                 sw.finish();

                 
                 
             } catch (IOException e) {
-                ZooLog
-                        .logWarn("Error when closing socket or trying to reopen connection: "
+                LOG.warn("Error when closing socket or trying to reopen connection: "
                                 + e.toString());
             }
         //Otherwise start worker threads to receive data.

                     senderWorkerMap.get(s.socket().getInetAddress()).finish();       
                 }
                 
-                SendWorker sw = new SendWorker(s);
                 if (s != null) {
+                    SendWorker sw = new SendWorker(s);
                     RecvWorker rw = new RecvWorker(s);
                     sw.setRecv(rw);
 

 
                     return true;
                 } else {
-                    ZooLog.logWarn("Channel null");
+                    LOG.warn("Channel null");
                     return false;
                 }
             }

                 b.position(0);
                 recvQueue.put(new Message(b.duplicate(), addr));
             } catch (InterruptedException e) {
-                ZooLog.logWarn("Exception when loopbacking");
+                LOG.warn("Exception when loopbacking");
             }
         /*
          * Otherwise send to the corresponding thread to send. 

                             channel.socket().setTcpNoDelay(true);
                             initiateConnection(channel);
                         } catch (IOException e) {
-                            ZooLog.logWarn("Cannot open channel to "
+                            LOG.warn("Cannot open channel to "
                                     + addr.toString() + "( " + e.toString()
                                     + ")");
                         }
                     }
                 }     
             } catch (InterruptedException e) {
-                ZooLog
-                        .logWarn("Interrupted while waiting to put message in queue."
+                LOG.warn("Interrupted while waiting to put message in queue."
                                 + e.toString());
             }
     }

      * Thread to listen on some port
      */
     class Listener extends Thread {
-        QuorumCnxManager manager;
-
-        Listener(QuorumCnxManager m) {
-            manager = m;
-        }
 
         /**
          * Sleeps on accept().

         public void run() {
             ServerSocketChannel ss = null;
             try {
-                if (ss != null)
-                    ss.close();
                 ss = ServerSocketChannel.open();
                 ss.socket().bind(new InetSocketAddress(port));
 

                      * simultaneously.
                      */
                     synchronized(senderWorkerMap){
-                        ZooLog.logWarn("Connection request");
+                        LOG.warn("Connection request");
                         receiveConnection(client);
                     }
                 }

             this.recvWorker = recvWorker;
         }
 
-        //boolean connect() throws IOException {
-        //    if (recvWorker != null)
-        //        recvWorker.finish();
-        //
-        //    channel = SocketChannel.open(new InetSocketAddress(addr, port));
-        //    if (channel.isConnected()) {
-        //        recvWorker = new RecvWorker(channel);
-        //        initiateConnection(channel);
-        //        ZooLog.logWarn("Opened new connection");
-        //    } else {
-        //        ZooLog.logWarn("Channel not connected.");
-        //    }
-        //
-        //    return channel.isConnected();
-        //}
-
         boolean finish() {
             running = false;
 

 
         public void run() {
 
-            long init, init1, end1, end;
             while (running && !shutdown) {
 
                 ByteBuffer b = null;
                 try {
-                    init = System.currentTimeMillis();
                     b = queueSendMap.get(addr).take();
                 } catch (InterruptedException e) {
-                    ZooLog
-                            .logWarn("Interrupted while waiting for message on queue ("
+                    LOG.warn("Interrupted while waiting for message on queue ("
                                     + e.toString() + ")");
                     continue;
                 }

                             + (Integer.SIZE / 8)];
                     ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
                     msgBuffer.putInt(b.capacity());
-                    int tmpSize = b.capacity() + (Integer.SIZE / 8);
 
                     msgBuffer.put(b.array(), 0, b.capacity());
                     msgBuffer.position(0);
-                    int numbytes = channel.write(msgBuffer);
-                    end = System.currentTimeMillis() - init;
+                    channel.write(msgBuffer);
 
                 } catch (IOException e) {
                     /*
                      * If reconnection doesn't work, then put the
                      * message back to the beginning of the queue and leave.
                      */
-                    ZooLog.logWarn("Exception when using channel: " + addr
+                    LOG.warn("Exception when using channel: " + addr
                             + ")" + e.toString());
                     running = false;
                     synchronized (senderWorkerMap) {

                     
                         senderWorkerMap.remove(channel.socket().getInetAddress());
                     
-                        if (b != null) {
-                            if (queueSendMap.get(channel.socket().getInetAddress())
+                        if (queueSendMap.get(channel.socket().getInetAddress())
                                     .size() == 0)
-                                queueSendMap.get(channel.socket().getInetAddress())
+                            queueSendMap.get(channel.socket().getInetAddress())
                                     .offer(b);
-                        }
                     }
                 }
             }
-            ZooLog.logWarn("Leaving thread");
+            LOG.warn("Leaving thread");
         }
     }
 

                 }
 
             } catch (IOException e) {
-                ZooLog.logWarn("Connection broken: " + e.toString());
+                LOG.warn("Connection broken: " + e.toString());
 
             } catch (InterruptedException e) {
-                ZooLog.logWarn("Interrupted while trying to add new "
+                LOG.warn("Interrupted while trying to add new "
                         + "message to the reception queue (" + e.toString()
                         + ")");
             }
         }
     }
-}
\ No newline at end of file
+}
<EOC>
<SOC>
         genChallenge();
 
         // Starts listener thread that waits for connection requests 
-        listener = new Listener(this);
+        listener = new Listener();
         listener.start();
     }
 

                 msgBuffer.position(0);
                 s.write(msgBuffer);
         
-                      // Reading challenge
-                    msgBuffer.position(0);
-                  int numBytes = s.read(msgBuffer);
+                // Reading challenge
+                msgBuffer.position(0);
+                s.read(msgBuffer);
         
-                 msgBuffer.position(0);
-               newChallenge = msgBuffer.getLong();
+                msgBuffer.position(0);
+                newChallenge = msgBuffer.getLong();
                 if (challenge > newChallenge) {
                    wins = true;
                     challenged = false;

                 /*
                  * Start new worker thread with a clean state.
                  */
-                SendWorker sw = new SendWorker(s);
                 if (s != null) {
+                    SendWorker sw = new SendWorker(s);
                     RecvWorker rw = new RecvWorker(s);
                     sw.setRecv(rw);
 

                     senderWorkerMap.get(s.socket().getInetAddress()).finish();       
                 }
                 
-                SendWorker sw = new SendWorker(s);
                 if (s != null) {
+                    SendWorker sw = new SendWorker(s);
                     RecvWorker rw = new RecvWorker(s);
                     sw.setRecv(rw);
 

      * Thread to listen on some port
      */
     class Listener extends Thread {
-        QuorumCnxManager manager;
-
-        Listener(QuorumCnxManager m) {
-            manager = m;
-        }
 
         /**
          * Sleeps on accept().

         public void run() {
             ServerSocketChannel ss = null;
             try {
-                if (ss != null)
-                    ss.close();
                 ss = ServerSocketChannel.open();
                 ss.socket().bind(new InetSocketAddress(port));
 

             this.recvWorker = recvWorker;
         }
 
-        //boolean connect() throws IOException {
-        //    if (recvWorker != null)
-        //        recvWorker.finish();
-        //
-        //    channel = SocketChannel.open(new InetSocketAddress(addr, port));
-        //    if (channel.isConnected()) {
-        //        recvWorker = new RecvWorker(channel);
-        //        initiateConnection(channel);
-        //        LOG.warn("Opened new connection");
-        //    } else {
-        //        LOG.warn("Channel not connected.");
-        //    }
-        //
-        //    return channel.isConnected();
-        //}
-
         boolean finish() {
             running = false;
 

 
         public void run() {
 
-            long init, init1, end1, end;
             while (running && !shutdown) {
 
                 ByteBuffer b = null;
                 try {
-                    init = System.currentTimeMillis();
                     b = queueSendMap.get(addr).take();
                 } catch (InterruptedException e) {
                     LOG.warn("Interrupted while waiting for message on queue ("

                             + (Integer.SIZE / 8)];
                     ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);
                     msgBuffer.putInt(b.capacity());
-                    int tmpSize = b.capacity() + (Integer.SIZE / 8);
 
                     msgBuffer.put(b.array(), 0, b.capacity());
                     msgBuffer.position(0);
-                    int numbytes = channel.write(msgBuffer);
-                    end = System.currentTimeMillis() - init;
+                    channel.write(msgBuffer);
 
                 } catch (IOException e) {
                     /*

                     
                         senderWorkerMap.remove(channel.socket().getInetAddress());
                     
-                        if (b != null) {
-                            if (queueSendMap.get(channel.socket().getInetAddress())
+                        if (queueSendMap.get(channel.socket().getInetAddress())
                                     .size() == 0)
-                                queueSendMap.get(channel.socket().getInetAddress())
+                            queueSendMap.get(channel.socket().getInetAddress())
                                     .offer(b);
-                        }
                     }
                 }
             }
<EOC>
<SOC>
-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.lang.Thread.UncaughtExceptionHandler;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.nio.channels.SocketChannel;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.Random;
-import java.util.Set;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.BinaryOutputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.AsyncCallback.ACLCallback;
-import com.yahoo.zookeeper.AsyncCallback.ChildrenCallback;
-import com.yahoo.zookeeper.AsyncCallback.DataCallback;
-import com.yahoo.zookeeper.AsyncCallback.StatCallback;
-import com.yahoo.zookeeper.AsyncCallback.StringCallback;
-import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
-import com.yahoo.zookeeper.Watcher.Event;
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.ZooKeeper.States;
-import com.yahoo.zookeeper.proto.AuthPacket;
-import com.yahoo.zookeeper.proto.ConnectRequest;
-import com.yahoo.zookeeper.proto.ConnectResponse;
-import com.yahoo.zookeeper.proto.CreateResponse;
-import com.yahoo.zookeeper.proto.ExistsResponse;
-import com.yahoo.zookeeper.proto.GetACLResponse;
-import com.yahoo.zookeeper.proto.GetChildrenResponse;
-import com.yahoo.zookeeper.proto.GetDataResponse;
-import com.yahoo.zookeeper.proto.ReplyHeader;
-import com.yahoo.zookeeper.proto.RequestHeader;
-import com.yahoo.zookeeper.proto.SetACLResponse;
-import com.yahoo.zookeeper.proto.SetDataResponse;
-import com.yahoo.zookeeper.proto.WatcherEvent;
-import com.yahoo.zookeeper.server.ByteBufferInputStream;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooTrace;
-
-/**
- * This class manages the socket i/o for the client. ClientCnxn maintains a list
- * of available servers to connect to and "transparently" switches servers it is
- * connected to as needed.
- *
- */
-class ClientCnxn {
-    private static final Logger LOG = Logger.getLogger(ZooKeeperServer.class);
-
-    private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
-
-    static class AuthData {
-        AuthData(String scheme, byte data[]) {
-            this.scheme = scheme;
-            this.data = data;
-        }
-
-        String scheme;
-
-        byte data[];
-    }
-
-    private ArrayList<AuthData> authInfo = new ArrayList<AuthData>();
-
-    /**
-     * These are the packets that have been sent and are waiting for a response.
-     */
-    private LinkedList<Packet> pendingQueue = new LinkedList<Packet>();
-
-    private LinkedBlockingQueue waitingEvents = new LinkedBlockingQueue();
-
-    /**
-     * These are the packets that need to be sent.
-     */
-    private LinkedList<Packet> outgoingQueue = new LinkedList<Packet>();
-
-    private int nextAddrToTry = 0;
-
-    private int connectTimeout;
-
-    private int readTimeout;
-
-    private final int sessionTimeout;
-
-    private final ZooKeeper zooKeeper;
-
-    private long sessionId;
-
-    private byte sessionPasswd[] = new byte[16];
-
-    final SendThread sendThread;
-
-    final EventThread eventThread;
-
-    final Selector selector = Selector.open();
-
-    public long getSessionId() {
-        return sessionId;
-    }
-
-    public byte[] getSessionPasswd() {
-        return sessionPasswd;
-    }
-
-    public String toString() {
-        StringBuffer sb = new StringBuffer();
-        sb.append("sessionId: ").append(sessionId).append("\n");
-        sb.append("lastZxid: ").append(lastZxid).append("\n");
-        sb.append("xid: ").append(xid).append("\n");
-        sb.append("nextAddrToTry: ").append(nextAddrToTry).append("\n");
-        sb.append("serverAddrs: ").append(serverAddrs.get(nextAddrToTry))
-                .append("\n");
-        return sb.toString();
-    }
-
-    /**
-     * This class allows us to pass the headers and the relevant records around.
-     */
-    static class Packet {
-        RequestHeader header;
-
-        ByteBuffer bb;
-
-        String path;
-
-        ReplyHeader replyHeader;
-
-        Record request;
-
-        Record response;
-
-        boolean finished;
-
-        AsyncCallback cb;
-
-        Object ctx;
-
-        Packet(RequestHeader header, ReplyHeader replyHeader, Record record,
-                Record response, ByteBuffer bb) {
-            this.header = header;
-            this.replyHeader = replyHeader;
-            this.request = record;
-            this.response = response;
-            if (bb != null) {
-                this.bb = bb;
-            } else {
-                try {
-                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-                    BinaryOutputArchive boa = BinaryOutputArchive
-                            .getArchive(baos);
-                    boa.writeInt(-1, "len"); // We'll fill this in later
-                    header.serialize(boa, "header");
-                    if (record != null) {
-                        record.serialize(boa, "request");
-                    }
-                    baos.close();
-                    this.bb = ByteBuffer.wrap(baos.toByteArray());
-                    this.bb.putInt(this.bb.capacity() - 4);
-                    this.bb.rewind();
-                } catch (IOException e) {
-                    LOG.warn("Unexpected exception",e);
-                }
-            }
-        }
-    }
-
-    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper)
-            throws KeeperException, IOException {
-        this(hosts, sessionTimeout, zooKeeper, 0, new byte[16]);
-    }
-
-    /**
-     * Creates a connection object. The actual network connect doesn't get
-     * established until needed.
-     *
-     * @param hosts
-     *                a comma separated list of hosts that can be connected to.
-     * @param connectTimeout
-     *                the timeout for connections.
-     * @param readTimeout
-     *                the read timeout.
-     * @param zooKeeper
-     *                the zookeeper object that this connection is related to.
-     * @throws KeeperException
-     * @throws IOException
-     */
-    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
-            long sessionId, byte[] sessionPasswd) throws KeeperException,
-            IOException {
-        this.zooKeeper = zooKeeper;
-        this.sessionId = sessionId;
-        this.sessionPasswd = sessionPasswd;
-        String hostsList[] = hosts.split(",");
-        for (String host : hostsList) {
-            int port = 2181;
-            String parts[] = host.split(":");
-            if (parts.length > 1) {
-                port = Integer.parseInt(parts[1]);
-                host = parts[0];
-            }
-            InetAddress addrs[] = InetAddress.getAllByName(host);
-            for (InetAddress addr : addrs) {
-                serverAddrs.add(new InetSocketAddress(addr, port));
-            }
-        }
-        this.sessionTimeout = sessionTimeout;
-        connectTimeout = sessionTimeout / hostsList.length;
-        readTimeout = sessionTimeout * 2 / 3;
-        Collections.shuffle(serverAddrs);
-        sendThread = new SendThread();
-        sendThread.start();
-        eventThread = new EventThread();
-        eventThread.start();
-    }
-
-    WatcherEvent eventOfDeath = new WatcherEvent();
-
-    final static UncaughtExceptionHandler uncaughtExceptionHandler = new UncaughtExceptionHandler() {
-        public void uncaughtException(Thread t, Throwable e) {
-            LOG.error("from " + t.getName(), e);
-        }
-    };
-
-    class EventThread extends Thread {
-        EventThread() {
-            super("EventThread");
-            setUncaughtExceptionHandler(uncaughtExceptionHandler);
-            setDaemon(true);
-        }
-
-        public void run() {
-            try {
-                while (true) {
-                    Object event = waitingEvents.take();
-                    if (event == eventOfDeath) {
-                        break;
-                    }
-                    if (event instanceof WatcherEvent) {
-                        zooKeeper.watcher.process((WatcherEvent) event);
-                    } else {
-                        Packet p = (Packet) event;
-                        int rc = 0;
-                        String path = p.path;
-                        if (p.replyHeader.getErr() != 0) {
-                            rc = p.replyHeader.getErr();
-                        }
-                        if (p.cb == null) {
-                            LOG.warn("Somehow a null cb got to EventThread!");
-                        } else if (p.response instanceof ExistsResponse
-                                || p.response instanceof SetDataResponse
-                                || p.response instanceof SetACLResponse) {
-                            StatCallback cb = (StatCallback) p.cb;
-                            if (rc == 0) {
-                                if (p.response instanceof ExistsResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((ExistsResponse) p.response)
-                                                    .getStat());
-                                } else if (p.response instanceof SetDataResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((SetDataResponse) p.response)
-                                                    .getStat());
-                                } else if (p.response instanceof SetACLResponse) {
-                                    cb.processResult(rc, path, p.ctx,
-                                            ((SetACLResponse) p.response)
-                                                    .getStat());
-                                }
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.response instanceof GetDataResponse) {
-                            DataCallback cb = (DataCallback) p.cb;
-                            GetDataResponse rsp = (GetDataResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx,
-                                        rsp.getData(), rsp.getStat());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null, null);
-                            }
-                        } else if (p.response instanceof GetACLResponse) {
-                            ACLCallback cb = (ACLCallback) p.cb;
-                            GetACLResponse rsp = (GetACLResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx, rsp.getAcl(),
-                                        rsp.getStat());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null, null);
-                            }
-                        } else if (p.response instanceof GetChildrenResponse) {
-                            ChildrenCallback cb = (ChildrenCallback) p.cb;
-                            GetChildrenResponse rsp = (GetChildrenResponse) p.response;
-                            if (rc == 0) {
-                                cb.processResult(rc, path, p.ctx, rsp
-                                        .getChildren());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.response instanceof CreateResponse) {
-                            StringCallback cb = (StringCallback) p.cb;
-                            CreateResponse rsp = (CreateResponse) p.response;
-                            if (rc == 0) {
-                                cb
-                                        .processResult(rc, path, p.ctx, rsp
-                                                .getPath());
-                            } else {
-                                cb.processResult(rc, path, p.ctx, null);
-                            }
-                        } else if (p.cb instanceof VoidCallback) {
-                            VoidCallback cb = (VoidCallback) p.cb;
-                            cb.processResult(rc, path, p.ctx);
-                        }
-                    }
-                }
-            } catch (InterruptedException e) {
-            }
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private void finishPacket(Packet p) {
-        p.finished = true;
-        if (p.cb == null) {
-            synchronized (p) {
-                p.notifyAll();
-            }
-        } else {
-            waitingEvents.add(p);
-        }
-    }
-
-    private void conLossPacket(Packet p) {
-        if (p.replyHeader == null) {
-            return;
-        }
-        switch(zooKeeper.state) {
-        case AUTH_FAILED:
-            p.replyHeader.setErr(KeeperException.Code.AuthFailed);
-            break;
-        case CLOSED:
-            p.replyHeader.setErr(KeeperException.Code.SessionExpired);
-            break;
-        default:
-            p.replyHeader.setErr(KeeperException.Code.ConnectionLoss);
-        }
-        finishPacket(p);
-    }
-
-    long lastZxid;
-
-    /**
-     * This class services the outgoing request queue and generates the heart
-     * beats. It also spawns the ReadThread.
-     */
-    class SendThread extends Thread {
-        SelectionKey sockKey;
-
-        ByteBuffer lenBuffer = ByteBuffer.allocateDirect(4);
-
-        ByteBuffer incomingBuffer = lenBuffer;
-
-        boolean initialized;
-
-        void readLength() throws IOException {
-            int len = incomingBuffer.getInt();
-            if (len < 0 || len >= 4096 * 1024) {
-                throw new IOException("Packet len" + len + " is out of range!");
-            }
-            incomingBuffer = ByteBuffer.allocate(len);
-        }
-
-        void readConnectResult() throws IOException {
-            ByteBufferInputStream bbis = new ByteBufferInputStream(
-                    incomingBuffer);
-            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
-            ConnectResponse conRsp = new ConnectResponse();
-            conRsp.deserialize(bbia, "connect");
-            int sessionTimeout = conRsp.getTimeOut();
-            if (sessionTimeout <= 0) {
-                zooKeeper.state = States.CLOSED;
-                waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
-                        Watcher.Event.KeeperStateExpired, null));
-                throw new IOException("Session Expired");
-            }
-            readTimeout = sessionTimeout * 2 / 3;
-            connectTimeout = sessionTimeout / serverAddrs.size();
-            sessionId = conRsp.getSessionId();
-            sessionPasswd = conRsp.getPasswd();
-            waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
-                    Watcher.Event.KeeperStateSyncConnected, null));
-        }
-
-        @SuppressWarnings("unchecked")
-        void readResponse() throws IOException {
-            ByteBufferInputStream bbis = new ByteBufferInputStream(
-                    incomingBuffer);
-            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
-            ReplyHeader r = new ReplyHeader();
-
-            r.deserialize(bbia, "header");
-            if (r.getXid() == -2) {
-                // -2 is the xid for pings
-                return;
-            }
-            if (r.getXid() == -4) {
-                // -2 is the xid for AuthPacket
-                // TODO: process AuthPacket here
-                return;
-            }
-            if (r.getXid() == -1) {
-                // -1 means notification
-                WatcherEvent event = new WatcherEvent();
-                event.deserialize(bbia, "response");
-                // System.out.println("Got an event: " + event + " for " +
-                // sessionId + " through" + _cnxn);
-                waitingEvents.add(event);
-                return;
-            }
-            if (pendingQueue.size() == 0) {
-                throw new IOException("Nothing in the queue, but got "
-                        + r.getXid());
-            }
-            Packet p = null;
-            synchronized (pendingQueue) {
-                p = pendingQueue.remove();
-            }
-            /*
-             * Since requests are processed in order, we better get a response
-             * to the first request!
-             */
-            if (p.header.getXid() != r.getXid()) {
-                throw new IOException("Xid out of order. Got " + r.getXid()
-                        + " expected " + p.header.getXid());
-            }
-            p.replyHeader.setXid(r.getXid());
-            p.replyHeader.setErr(r.getErr());
-            p.replyHeader.setZxid(r.getZxid());
-            lastZxid = r.getZxid();
-            if (p.response != null && r.getErr() == 0) {
-                p.response.deserialize(bbia, "response");
-            }
-            p.finished = true;
-            finishPacket(p);
-        }
-
-        /**
-         * @return true if a packet was received
-         * @param k
-         * @throws InterruptedException
-         * @throws IOException
-         */
-        boolean doIO() throws InterruptedException, IOException {
-            boolean packetReceived = false;
-            SocketChannel sock = (SocketChannel) sockKey.channel();
-            if (sock == null) {
-                throw new IOException("Socket is null!");
-            }
-            if (sockKey.isReadable()) {
-                int rc = sock.read(incomingBuffer);
-                if (rc < 0) {
-                    throw new IOException("Read error rc = " + rc + " "
-                            + incomingBuffer);
-                }
-                if (incomingBuffer.remaining() == 0) {
-                    incomingBuffer.flip();
-                    if (incomingBuffer == lenBuffer) {
-                        readLength();
-                    } else if (!initialized) {
-                        readConnectResult();
-                        enableRead();
-                        if (outgoingQueue.size() > 0) {
-                            enableWrite();
-                        }
-                        lenBuffer.clear();
-                        incomingBuffer = lenBuffer;
-                        packetReceived = true;
-                        initialized = true;
-                    } else {
-                        readResponse();
-                        lenBuffer.clear();
-                        incomingBuffer = lenBuffer;
-                        packetReceived = true;
-                    }
-                }
-            }
-            if (sockKey.isWritable()) {
-                synchronized (outgoingQueue) {
-                    if (outgoingQueue.size() > 0) {
-                        int rc = sock.write(outgoingQueue.getFirst().bb);
-                        if (outgoingQueue.getFirst().bb.remaining() == 0) {
-                            Packet p = outgoingQueue.removeFirst();
-                            if (p.header != null
-                                    && p.header.getType() != OpCode.ping
-                                    && p.header.getType() != OpCode.auth) {
-                                pendingQueue.add(p);
-                            }
-                        }
-                    }
-                }
-            }
-            if (outgoingQueue.size() == 0) {
-                disableWrite();
-            } else {
-                enableWrite();
-            }
-            return packetReceived;
-        }
-
-        synchronized private void enableWrite() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_WRITE) == 0) {
-                sockKey.interestOps(i | SelectionKey.OP_WRITE);
-            }
-        }
-
-        synchronized private void disableWrite() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_WRITE) != 0) {
-                sockKey.interestOps(i & (~SelectionKey.OP_WRITE));
-            }
-        }
-
-        synchronized private void enableRead() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_READ) == 0) {
-                sockKey.interestOps(i | SelectionKey.OP_READ);
-            }
-        }
-
-        synchronized private void disableRead() {
-            int i = sockKey.interestOps();
-            if ((i & SelectionKey.OP_READ) != 0) {
-                sockKey.interestOps(i & (~SelectionKey.OP_READ));
-            }
-        }
-
-        SendThread() {
-            super("SendThread");
-            zooKeeper.state = States.CONNECTING;
-            setUncaughtExceptionHandler(uncaughtExceptionHandler);
-            setDaemon(true);
-        }
-
-        private void primeConnection(SelectionKey k) throws IOException {
-            LOG.info("Priming connection to "
-                    + ((SocketChannel) sockKey.channel()));
-            lastConnectIndex = currentConnectIndex;
-            ConnectRequest conReq = new ConnectRequest(0, lastZxid,
-                    sessionTimeout, sessionId, sessionPasswd);
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
-            boa.writeInt(-1, "len");
-            conReq.serialize(boa, "connect");
-            baos.close();
-            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
-            bb.putInt(bb.capacity() - 4);
-            bb.rewind();
-            synchronized (outgoingQueue) {
-                for (AuthData id : authInfo) {
-                    outgoingQueue.addFirst(new Packet(new RequestHeader(-4,
-                            OpCode.auth), null, new AuthPacket(0, id.scheme,
-                            id.data), null, null));
-                }
-                outgoingQueue
-                        .addFirst((new Packet(null, null, null, null, bb)));
-            }
-            synchronized (this) {
-                k.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
-            }
-        }
-
-        private void sendPing() {
-            RequestHeader h = new RequestHeader(-2, OpCode.ping);
-            queuePacket(h, null, null, null, null, null, null);
-        }
-
-        int lastConnectIndex = -1;
-
-        int currentConnectIndex;
-
-        Random r = new Random(System.nanoTime());
-
-        private void startConnect() throws IOException {
-            if (lastConnectIndex == -1) {
-                // We don't want to delay the first try at a connect, so we
-                // start with -1 the first time around
-                lastConnectIndex = 0;
-            } else {
-                try {
-                    Thread.sleep(r.nextInt(1000));
-                } catch (InterruptedException e1) {
-                    LOG.warn("Unexpected exception", e1);
-                }
-                if (nextAddrToTry == lastConnectIndex) {
-                    try {
-                        // Try not to spin too fast!
-                        Thread.sleep(1000);
-                    } catch (InterruptedException e) {
-                        LOG.warn("Unexpected exception", e);
-                    }
-                }
-            }
-            zooKeeper.state = States.CONNECTING;
-            currentConnectIndex = nextAddrToTry;
-            InetSocketAddress addr = serverAddrs.get(nextAddrToTry);
-            nextAddrToTry++;
-            if (nextAddrToTry == serverAddrs.size()) {
-                nextAddrToTry = 0;
-            }
-            SocketChannel sock;
-            sock = SocketChannel.open();
-            sock.configureBlocking(false);
-            sock.socket().setSoLinger(false, -1);
-            sock.socket().setTcpNoDelay(true);
-            LOG.info("Attempting connection to server " + addr);
-            sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
-            if (sock.connect(addr)) {
-                primeConnection(sockKey);
-            }
-            initialized = false;
-        }
-
-        @Override
-        public void run() {
-            long now = System.currentTimeMillis();
-            long lastHeard = now;
-            long lastSend = now;
-            while (zooKeeper.state.isAlive()) {
-                try {
-                    if (sockKey == null) {
-                        startConnect();
-                        lastSend = now;
-                        lastHeard = now;
-                    }
-                    int idleRecv = (int) (now - lastHeard);
-                    int idleSend = (int) (now - lastSend);
-                    int to = readTimeout - idleRecv;
-                    if (zooKeeper.state != States.CONNECTED) {
-                        to = connectTimeout - idleRecv;
-                    }
-                    if (to <= 0) {
-                        throw new IOException("TIMED OUT");
-                    }
-                    if (zooKeeper.state == States.CONNECTED) {
-                        int timeToNextPing = readTimeout/2 - idleSend;
-                        if (timeToNextPing <= 0) {
-                            sendPing();
-                            lastSend = now;
-                            enableWrite();
-                        } else {
-                            if (timeToNextPing < to) {
-                                to = timeToNextPing;
-                            }
-                        }
-                    }
-
-                    selector.select(to);
-                    Set<SelectionKey> selected;
-                    synchronized (this) {
-                        selected = selector.selectedKeys();
-                    }
-                    // Everything below and until we get back to the select is
-                    // non blocking, so time is effectively a constant. That is
-                    // Why we just have to do this once, here
-                    now = System.currentTimeMillis();
-                    for (SelectionKey k : selected) {
-                        SocketChannel sc = ((SocketChannel) k.channel());
-                        if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {
-                            if (sc.finishConnect()) {
-                                zooKeeper.state = States.CONNECTED;
-                                lastHeard = now;
-                                lastSend = now;
-                                primeConnection(k);
-                                LOG.info("Server connection successful");
-                            }
-                        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
-                            if (outgoingQueue.size() > 0) {
-                                // We have something to send so it's the same
-                                // as if we do the send now.
-                                lastSend = now;
-                            }
-                            if (doIO()) {
-                                lastHeard = now;
-                            }
-                        }
-                    }
-                    if (zooKeeper.state == States.CONNECTED) {
-                        if (outgoingQueue.size() > 0) {
-                            enableWrite();
-                        } else {
-                            disableWrite();
-                        }
-                    }
-                    selected.clear();
-                } catch (Exception e) {
-                    LOG.warn("Closing: ", e);
-                    cleanup();
-                    if (zooKeeper.state.isAlive()) {
-                        waitingEvents.add(new WatcherEvent(Event.EventNone,
-                                Event.KeeperStateDisconnected, null));
-                    }
-
-                    now = System.currentTimeMillis();
-                    lastHeard = now;
-                    lastSend = now;
-                }
-            }
-            cleanup();
-            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                                     "SendThread exitedloop.");
-        }
-
-        private void cleanup() {
-            if (sockKey != null) {
-                SocketChannel sock = (SocketChannel) sockKey.channel();
-                sockKey.cancel();
-                try {
-                    sock.socket().shutdownInput();
-                } catch (IOException e2) {
-                }
-                try {
-                    sock.socket().shutdownOutput();
-                } catch (IOException e2) {
-                }
-                try {
-                    sock.socket().close();
-                } catch (IOException e1) {
-                }
-                try {
-                    sock.close();
-                } catch (IOException e1) {
-                }
-            }
-            try {
-                Thread.sleep(100);
-            } catch (InterruptedException e1) {
-                e1.printStackTrace();
-            }
-            sockKey = null;
-            synchronized (pendingQueue) {
-                for (Packet p : pendingQueue) {
-                    conLossPacket(p);
-                }
-                pendingQueue.clear();
-            }
-            synchronized (outgoingQueue) {
-                for (Packet p : outgoingQueue) {
-                    conLossPacket(p);
-                }
-                outgoingQueue.clear();
-            }
-        }
-
-        public void close() {
-            zooKeeper.state = States.CLOSED;
-            synchronized (this) {
-                selector.wakeup();
-            }
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    public void close() throws IOException {
-        long traceMask = ZooTrace.SESSION_TRACE_MASK;
-        if (ZooTrace.isTraceEnabled(LOG, traceMask)) {
-            ZooTrace.logTraceMessage(LOG, traceMask,
-                    "Close ClientCnxn for session: " + sessionId + "!");
-        }
-        sendThread.close();
-        waitingEvents.add(eventOfDeath);
-    }
-
-    private int xid = 1;
-
-    synchronized private int getXid() {
-        return xid++;
-    }
-
-    public ReplyHeader submitRequest(RequestHeader h, Record request,
-            Record response) throws InterruptedException {
-        ReplyHeader r = new ReplyHeader();
-        Packet packet = queuePacket(h, r, request, response, null, null, null);
-        synchronized (packet) {
-            while (!packet.finished) {
-                packet.wait();
-            }
-        }
-        return r;
-    }
-
-    Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
-            Record response, AsyncCallback cb, String path, Object ctx) {
-        Packet packet = null;
-        synchronized (outgoingQueue) {
-            if (h.getType() != OpCode.ping && h.getType() != OpCode.auth) {
-                h.setXid(getXid());
-            }
-            packet = new Packet(h, r, request, response, null);
-            packet.cb = cb;
-            packet.ctx = ctx;
-            packet.path = path;
-            if (!zooKeeper.state.isAlive()) {
-                conLossPacket(packet);
-            } else {
-                outgoingQueue.add(packet);
-            }
-        }
-        synchronized (sendThread) {
-            selector.wakeup();
-        }
-        return packet;
-    }
-
-    public void addAuthInfo(String scheme, byte auth[]) {
-        authInfo.add(new AuthData(scheme, auth));
-        if (zooKeeper.state == States.CONNECTED) {
-            queuePacket(new RequestHeader(-4, OpCode.auth), null,
-                    new AuthPacket(0, scheme, auth), null, null, null, null);
-        }
-    }
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.lang.Thread.UncaughtExceptionHandler;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.jute.BinaryInputArchive;
+import com.yahoo.jute.BinaryOutputArchive;
+import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.AsyncCallback.ACLCallback;
+import com.yahoo.zookeeper.AsyncCallback.ChildrenCallback;
+import com.yahoo.zookeeper.AsyncCallback.DataCallback;
+import com.yahoo.zookeeper.AsyncCallback.StatCallback;
+import com.yahoo.zookeeper.AsyncCallback.StringCallback;
+import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
+import com.yahoo.zookeeper.Watcher.Event;
+import com.yahoo.zookeeper.ZooDefs.OpCode;
+import com.yahoo.zookeeper.ZooKeeper.States;
+import com.yahoo.zookeeper.proto.AuthPacket;
+import com.yahoo.zookeeper.proto.ConnectRequest;
+import com.yahoo.zookeeper.proto.ConnectResponse;
+import com.yahoo.zookeeper.proto.CreateResponse;
+import com.yahoo.zookeeper.proto.ExistsResponse;
+import com.yahoo.zookeeper.proto.GetACLResponse;
+import com.yahoo.zookeeper.proto.GetChildrenResponse;
+import com.yahoo.zookeeper.proto.GetDataResponse;
+import com.yahoo.zookeeper.proto.ReplyHeader;
+import com.yahoo.zookeeper.proto.RequestHeader;
+import com.yahoo.zookeeper.proto.SetACLResponse;
+import com.yahoo.zookeeper.proto.SetDataResponse;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.ByteBufferInputStream;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooTrace;
+
+/**
+ * This class manages the socket i/o for the client. ClientCnxn maintains a list
+ * of available servers to connect to and "transparently" switches servers it is
+ * connected to as needed.
+ *
+ */
+class ClientCnxn {
+    private static final Logger LOG = Logger.getLogger(ZooKeeperServer.class);
+
+    private ArrayList<InetSocketAddress> serverAddrs = new ArrayList<InetSocketAddress>();
+
+    static class AuthData {
+        AuthData(String scheme, byte data[]) {
+            this.scheme = scheme;
+            this.data = data;
+        }
+
+        String scheme;
+
+        byte data[];
+    }
+
+    private ArrayList<AuthData> authInfo = new ArrayList<AuthData>();
+
+    /**
+     * These are the packets that have been sent and are waiting for a response.
+     */
+    private LinkedList<Packet> pendingQueue = new LinkedList<Packet>();
+
+    private LinkedBlockingQueue waitingEvents = new LinkedBlockingQueue();
+
+    /**
+     * These are the packets that need to be sent.
+     */
+    private LinkedList<Packet> outgoingQueue = new LinkedList<Packet>();
+
+    private int nextAddrToTry = 0;
+
+    private int connectTimeout;
+
+    private int readTimeout;
+
+    private final int sessionTimeout;
+
+    private final ZooKeeper zooKeeper;
+
+    private long sessionId;
+
+    private byte sessionPasswd[] = new byte[16];
+
+    final SendThread sendThread;
+
+    final EventThread eventThread;
+
+    final Selector selector = Selector.open();
+
+    public long getSessionId() {
+        return sessionId;
+    }
+
+    public byte[] getSessionPasswd() {
+        return sessionPasswd;
+    }
+
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append("sessionId: ").append(sessionId).append("\n");
+        sb.append("lastZxid: ").append(lastZxid).append("\n");
+        sb.append("xid: ").append(xid).append("\n");
+        sb.append("nextAddrToTry: ").append(nextAddrToTry).append("\n");
+        sb.append("serverAddrs: ").append(serverAddrs.get(nextAddrToTry))
+                .append("\n");
+        return sb.toString();
+    }
+
+    /**
+     * This class allows us to pass the headers and the relevant records around.
+     */
+    static class Packet {
+        RequestHeader header;
+
+        ByteBuffer bb;
+
+        String path;
+
+        ReplyHeader replyHeader;
+
+        Record request;
+
+        Record response;
+
+        boolean finished;
+
+        AsyncCallback cb;
+
+        Object ctx;
+
+        Packet(RequestHeader header, ReplyHeader replyHeader, Record record,
+                Record response, ByteBuffer bb) {
+            this.header = header;
+            this.replyHeader = replyHeader;
+            this.request = record;
+            this.response = response;
+            if (bb != null) {
+                this.bb = bb;
+            } else {
+                try {
+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                    BinaryOutputArchive boa = BinaryOutputArchive
+                            .getArchive(baos);
+                    boa.writeInt(-1, "len"); // We'll fill this in later
+                    header.serialize(boa, "header");
+                    if (record != null) {
+                        record.serialize(boa, "request");
+                    }
+                    baos.close();
+                    this.bb = ByteBuffer.wrap(baos.toByteArray());
+                    this.bb.putInt(this.bb.capacity() - 4);
+                    this.bb.rewind();
+                } catch (IOException e) {
+                    LOG.warn("Unexpected exception",e);
+                }
+            }
+        }
+    }
+
+    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper)
+            throws IOException {
+        this(hosts, sessionTimeout, zooKeeper, 0, new byte[16]);
+    }
+
+    /**
+     * Creates a connection object. The actual network connect doesn't get
+     * established until needed.
+     *
+     * @param hosts
+     *                a comma separated list of hosts that can be connected to.
+     * @param sessionTimeout
+     *                the timeout for connections.
+     * @param zooKeeper
+     *                the zookeeper object that this connection is related to.
+     * @throws KeeperException
+     * @throws IOException
+     */
+    public ClientCnxn(String hosts, int sessionTimeout, ZooKeeper zooKeeper,
+            long sessionId, byte[] sessionPasswd) throws IOException {
+        this.zooKeeper = zooKeeper;
+        this.sessionId = sessionId;
+        this.sessionPasswd = sessionPasswd;
+        String hostsList[] = hosts.split(",");
+        for (String host : hostsList) {
+            int port = 2181;
+            String parts[] = host.split(":");
+            if (parts.length > 1) {
+                port = Integer.parseInt(parts[1]);
+                host = parts[0];
+            }
+            InetAddress addrs[] = InetAddress.getAllByName(host);
+            for (InetAddress addr : addrs) {
+                serverAddrs.add(new InetSocketAddress(addr, port));
+            }
+        }
+        this.sessionTimeout = sessionTimeout;
+        connectTimeout = sessionTimeout / hostsList.length;
+        readTimeout = sessionTimeout * 2 / 3;
+        Collections.shuffle(serverAddrs);
+        sendThread = new SendThread();
+        sendThread.start();
+        eventThread = new EventThread();
+        eventThread.start();
+    }
+
+    WatcherEvent eventOfDeath = new WatcherEvent();
+
+    final static UncaughtExceptionHandler uncaughtExceptionHandler = new UncaughtExceptionHandler() {
+        public void uncaughtException(Thread t, Throwable e) {
+            LOG.error("from " + t.getName(), e);
+        }
+    };
+
+    class EventThread extends Thread {
+        EventThread() {
+            super("EventThread");
+            setUncaughtExceptionHandler(uncaughtExceptionHandler);
+            setDaemon(true);
+        }
+
+        public void run() {
+            try {
+                while (true) {
+                    Object event = waitingEvents.take();
+                    if (event == eventOfDeath) {
+                        break;
+                    }
+                    if (event instanceof WatcherEvent) {
+                        zooKeeper.watcher.process((WatcherEvent) event);
+                    } else {
+                        Packet p = (Packet) event;
+                        int rc = 0;
+                        String path = p.path;
+                        if (p.replyHeader.getErr() != 0) {
+                            rc = p.replyHeader.getErr();
+                        }
+                        if (p.cb == null) {
+                            LOG.warn("Somehow a null cb got to EventThread!");
+                        } else if (p.response instanceof ExistsResponse
+                                || p.response instanceof SetDataResponse
+                                || p.response instanceof SetACLResponse) {
+                            StatCallback cb = (StatCallback) p.cb;
+                            if (rc == 0) {
+                                if (p.response instanceof ExistsResponse) {
+                                    cb.processResult(rc, path, p.ctx,
+                                            ((ExistsResponse) p.response)
+                                                    .getStat());
+                                } else if (p.response instanceof SetDataResponse) {
+                                    cb.processResult(rc, path, p.ctx,
+                                            ((SetDataResponse) p.response)
+                                                    .getStat());
+                                } else if (p.response instanceof SetACLResponse) {
+                                    cb.processResult(rc, path, p.ctx,
+                                            ((SetACLResponse) p.response)
+                                                    .getStat());
+                                }
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null);
+                            }
+                        } else if (p.response instanceof GetDataResponse) {
+                            DataCallback cb = (DataCallback) p.cb;
+                            GetDataResponse rsp = (GetDataResponse) p.response;
+                            if (rc == 0) {
+                                cb.processResult(rc, path, p.ctx,
+                                        rsp.getData(), rsp.getStat());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null, null);
+                            }
+                        } else if (p.response instanceof GetACLResponse) {
+                            ACLCallback cb = (ACLCallback) p.cb;
+                            GetACLResponse rsp = (GetACLResponse) p.response;
+                            if (rc == 0) {
+                                cb.processResult(rc, path, p.ctx, rsp.getAcl(),
+                                        rsp.getStat());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null, null);
+                            }
+                        } else if (p.response instanceof GetChildrenResponse) {
+                            ChildrenCallback cb = (ChildrenCallback) p.cb;
+                            GetChildrenResponse rsp = (GetChildrenResponse) p.response;
+                            if (rc == 0) {
+                                cb.processResult(rc, path, p.ctx, rsp
+                                        .getChildren());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null);
+                            }
+                        } else if (p.response instanceof CreateResponse) {
+                            StringCallback cb = (StringCallback) p.cb;
+                            CreateResponse rsp = (CreateResponse) p.response;
+                            if (rc == 0) {
+                                cb
+                                        .processResult(rc, path, p.ctx, rsp
+                                                .getPath());
+                            } else {
+                                cb.processResult(rc, path, p.ctx, null);
+                            }
+                        } else if (p.cb instanceof VoidCallback) {
+                            VoidCallback cb = (VoidCallback) p.cb;
+                            cb.processResult(rc, path, p.ctx);
+                        }
+                    }
+                }
+            } catch (InterruptedException e) {
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private void finishPacket(Packet p) {
+        p.finished = true;
+        if (p.cb == null) {
+            synchronized (p) {
+                p.notifyAll();
+            }
+        } else {
+            waitingEvents.add(p);
+        }
+    }
+
+    private void conLossPacket(Packet p) {
+        if (p.replyHeader == null) {
+            return;
+        }
+        switch(zooKeeper.state) {
+        case AUTH_FAILED:
+            p.replyHeader.setErr(KeeperException.Code.AuthFailed);
+            break;
+        case CLOSED:
+            p.replyHeader.setErr(KeeperException.Code.SessionExpired);
+            break;
+        default:
+            p.replyHeader.setErr(KeeperException.Code.ConnectionLoss);
+        }
+        finishPacket(p);
+    }
+
+    long lastZxid;
+
+    /**
+     * This class services the outgoing request queue and generates the heart
+     * beats. It also spawns the ReadThread.
+     */
+    class SendThread extends Thread {
+        SelectionKey sockKey;
+
+        ByteBuffer lenBuffer = ByteBuffer.allocateDirect(4);
+
+        ByteBuffer incomingBuffer = lenBuffer;
+
+        boolean initialized;
+
+        void readLength() throws IOException {
+            int len = incomingBuffer.getInt();
+            if (len < 0 || len >= 4096 * 1024) {
+                throw new IOException("Packet len" + len + " is out of range!");
+            }
+            incomingBuffer = ByteBuffer.allocate(len);
+        }
+
+        void readConnectResult() throws IOException {
+            ByteBufferInputStream bbis = new ByteBufferInputStream(
+                    incomingBuffer);
+            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
+            ConnectResponse conRsp = new ConnectResponse();
+            conRsp.deserialize(bbia, "connect");
+            int sessionTimeout = conRsp.getTimeOut();
+            if (sessionTimeout <= 0) {
+                zooKeeper.state = States.CLOSED;
+                waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
+                        Watcher.Event.KeeperStateExpired, null));
+                throw new IOException("Session Expired");
+            }
+            readTimeout = sessionTimeout * 2 / 3;
+            connectTimeout = sessionTimeout / serverAddrs.size();
+            sessionId = conRsp.getSessionId();
+            sessionPasswd = conRsp.getPasswd();
+            waitingEvents.add(new WatcherEvent(Watcher.Event.EventNone,
+                    Watcher.Event.KeeperStateSyncConnected, null));
+        }
+
+        @SuppressWarnings("unchecked")
+        void readResponse() throws IOException {
+            ByteBufferInputStream bbis = new ByteBufferInputStream(
+                    incomingBuffer);
+            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
+            ReplyHeader r = new ReplyHeader();
+
+            r.deserialize(bbia, "header");
+            if (r.getXid() == -2) {
+                // -2 is the xid for pings
+                return;
+            }
+            if (r.getXid() == -4) {
+                // -2 is the xid for AuthPacket
+                // TODO: process AuthPacket here
+                return;
+            }
+            if (r.getXid() == -1) {
+                // -1 means notification
+                WatcherEvent event = new WatcherEvent();
+                event.deserialize(bbia, "response");
+                // System.out.println("Got an event: " + event + " for " +
+                // sessionId + " through" + _cnxn);
+                waitingEvents.add(event);
+                return;
+            }
+            if (pendingQueue.size() == 0) {
+                throw new IOException("Nothing in the queue, but got "
+                        + r.getXid());
+            }
+            Packet p = null;
+            synchronized (pendingQueue) {
+                p = pendingQueue.remove();
+            }
+            /*
+             * Since requests are processed in order, we better get a response
+             * to the first request!
+             */
+            if (p.header.getXid() != r.getXid()) {
+                throw new IOException("Xid out of order. Got " + r.getXid()
+                        + " expected " + p.header.getXid());
+            }
+            p.replyHeader.setXid(r.getXid());
+            p.replyHeader.setErr(r.getErr());
+            p.replyHeader.setZxid(r.getZxid());
+            lastZxid = r.getZxid();
+            if (p.response != null && r.getErr() == 0) {
+                p.response.deserialize(bbia, "response");
+            }
+            p.finished = true;
+            finishPacket(p);
+        }
+
+        /**
+         * @return true if a packet was received
+         * @throws InterruptedException
+         * @throws IOException
+         */
+        boolean doIO() throws InterruptedException, IOException {
+            boolean packetReceived = false;
+            SocketChannel sock = (SocketChannel) sockKey.channel();
+            if (sock == null) {
+                throw new IOException("Socket is null!");
+            }
+            if (sockKey.isReadable()) {
+                int rc = sock.read(incomingBuffer);
+                if (rc < 0) {
+                    throw new IOException("Read error rc = " + rc + " "
+                            + incomingBuffer);
+                }
+                if (incomingBuffer.remaining() == 0) {
+                    incomingBuffer.flip();
+                    if (incomingBuffer == lenBuffer) {
+                        readLength();
+                    } else if (!initialized) {
+                        readConnectResult();
+                        enableRead();
+                        if (outgoingQueue.size() > 0) {
+                            enableWrite();
+                        }
+                        lenBuffer.clear();
+                        incomingBuffer = lenBuffer;
+                        packetReceived = true;
+                        initialized = true;
+                    } else {
+                        readResponse();
+                        lenBuffer.clear();
+                        incomingBuffer = lenBuffer;
+                        packetReceived = true;
+                    }
+                }
+            }
+            if (sockKey.isWritable()) {
+                synchronized (outgoingQueue) {
+                    if (outgoingQueue.size() > 0) {
+                        int rc = sock.write(outgoingQueue.getFirst().bb);
+                        if (outgoingQueue.getFirst().bb.remaining() == 0) {
+                            Packet p = outgoingQueue.removeFirst();
+                            if (p.header != null
+                                    && p.header.getType() != OpCode.ping
+                                    && p.header.getType() != OpCode.auth) {
+                                pendingQueue.add(p);
+                            }
+                        }
+                    }
+                }
+            }
+            if (outgoingQueue.size() == 0) {
+                disableWrite();
+            } else {
+                enableWrite();
+            }
+            return packetReceived;
+        }
+
+        synchronized private void enableWrite() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_WRITE) == 0) {
+                sockKey.interestOps(i | SelectionKey.OP_WRITE);
+            }
+        }
+
+        synchronized private void disableWrite() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_WRITE) != 0) {
+                sockKey.interestOps(i & (~SelectionKey.OP_WRITE));
+            }
+        }
+
+        synchronized private void enableRead() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_READ) == 0) {
+                sockKey.interestOps(i | SelectionKey.OP_READ);
+            }
+        }
+
+        synchronized private void disableRead() {
+            int i = sockKey.interestOps();
+            if ((i & SelectionKey.OP_READ) != 0) {
+                sockKey.interestOps(i & (~SelectionKey.OP_READ));
+            }
+        }
+
+        SendThread() {
+            super("SendThread");
+            zooKeeper.state = States.CONNECTING;
+            setUncaughtExceptionHandler(uncaughtExceptionHandler);
+            setDaemon(true);
+        }
+
+        private void primeConnection(SelectionKey k) throws IOException {
+            LOG.info("Priming connection to "
+                    + ((SocketChannel) sockKey.channel()));
+            lastConnectIndex = currentConnectIndex;
+            ConnectRequest conReq = new ConnectRequest(0, lastZxid,
+                    sessionTimeout, sessionId, sessionPasswd);
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);
+            boa.writeInt(-1, "len");
+            conReq.serialize(boa, "connect");
+            baos.close();
+            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
+            bb.putInt(bb.capacity() - 4);
+            bb.rewind();
+            synchronized (outgoingQueue) {
+                for (AuthData id : authInfo) {
+                    outgoingQueue.addFirst(new Packet(new RequestHeader(-4,
+                            OpCode.auth), null, new AuthPacket(0, id.scheme,
+                            id.data), null, null));
+                }
+                outgoingQueue
+                        .addFirst((new Packet(null, null, null, null, bb)));
+            }
+            synchronized (this) {
+                k.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
+            }
+        }
+
+        private void sendPing() {
+            RequestHeader h = new RequestHeader(-2, OpCode.ping);
+            queuePacket(h, null, null, null, null, null, null);
+        }
+
+        int lastConnectIndex = -1;
+
+        int currentConnectIndex;
+
+        Random r = new Random(System.nanoTime());
+
+        private void startConnect() throws IOException {
+            if (lastConnectIndex == -1) {
+                // We don't want to delay the first try at a connect, so we
+                // start with -1 the first time around
+                lastConnectIndex = 0;
+            } else {
+                try {
+                    Thread.sleep(r.nextInt(1000));
+                } catch (InterruptedException e1) {
+                    LOG.warn("Unexpected exception", e1);
+                }
+                if (nextAddrToTry == lastConnectIndex) {
+                    try {
+                        // Try not to spin too fast!
+                        Thread.sleep(1000);
+                    } catch (InterruptedException e) {
+                        LOG.warn("Unexpected exception", e);
+                    }
+                }
+            }
+            zooKeeper.state = States.CONNECTING;
+            currentConnectIndex = nextAddrToTry;
+            InetSocketAddress addr = serverAddrs.get(nextAddrToTry);
+            nextAddrToTry++;
+            if (nextAddrToTry == serverAddrs.size()) {
+                nextAddrToTry = 0;
+            }
+            SocketChannel sock;
+            sock = SocketChannel.open();
+            sock.configureBlocking(false);
+            sock.socket().setSoLinger(false, -1);
+            sock.socket().setTcpNoDelay(true);
+            LOG.info("Attempting connection to server " + addr);
+            sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
+            if (sock.connect(addr)) {
+                primeConnection(sockKey);
+            }
+            initialized = false;
+        }
+
+        @Override
+        public void run() {
+            long now = System.currentTimeMillis();
+            long lastHeard = now;
+            long lastSend = now;
+            while (zooKeeper.state.isAlive()) {
+                try {
+                    if (sockKey == null) {
+                        startConnect();
+                        lastSend = now;
+                        lastHeard = now;
+                    }
+                    int idleRecv = (int) (now - lastHeard);
+                    int idleSend = (int) (now - lastSend);
+                    int to = readTimeout - idleRecv;
+                    if (zooKeeper.state != States.CONNECTED) {
+                        to = connectTimeout - idleRecv;
+                    }
+                    if (to <= 0) {
+                        throw new IOException("TIMED OUT");
+                    }
+                    if (zooKeeper.state == States.CONNECTED) {
+                        int timeToNextPing = readTimeout/2 - idleSend;
+                        if (timeToNextPing <= 0) {
+                            sendPing();
+                            lastSend = now;
+                            enableWrite();
+                        } else {
+                            if (timeToNextPing < to) {
+                                to = timeToNextPing;
+                            }
+                        }
+                    }
+
+                    selector.select(to);
+                    Set<SelectionKey> selected;
+                    synchronized (this) {
+                        selected = selector.selectedKeys();
+                    }
+                    // Everything below and until we get back to the select is
+                    // non blocking, so time is effectively a constant. That is
+                    // Why we just have to do this once, here
+                    now = System.currentTimeMillis();
+                    for (SelectionKey k : selected) {
+                        SocketChannel sc = ((SocketChannel) k.channel());
+                        if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {
+                            if (sc.finishConnect()) {
+                                zooKeeper.state = States.CONNECTED;
+                                lastHeard = now;
+                                lastSend = now;
+                                primeConnection(k);
+                                LOG.info("Server connection successful");
+                            }
+                        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
+                            if (outgoingQueue.size() > 0) {
+                                // We have something to send so it's the same
+                                // as if we do the send now.
+                                lastSend = now;
+                            }
+                            if (doIO()) {
+                                lastHeard = now;
+                            }
+                        }
+                    }
+                    if (zooKeeper.state == States.CONNECTED) {
+                        if (outgoingQueue.size() > 0) {
+                            enableWrite();
+                        } else {
+                            disableWrite();
+                        }
+                    }
+                    selected.clear();
+                } catch (Exception e) {
+                    LOG.warn("Closing: ", e);
+                    cleanup();
+                    if (zooKeeper.state.isAlive()) {
+                        waitingEvents.add(new WatcherEvent(Event.EventNone,
+                                Event.KeeperStateDisconnected, null));
+                    }
+
+                    now = System.currentTimeMillis();
+                    lastHeard = now;
+                    lastSend = now;
+                }
+            }
+            cleanup();
+            ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                                     "SendThread exitedloop.");
+        }
+
+        private void cleanup() {
+            if (sockKey != null) {
+                SocketChannel sock = (SocketChannel) sockKey.channel();
+                sockKey.cancel();
+                try {
+                    sock.socket().shutdownInput();
+                } catch (IOException e2) {
+                }
+                try {
+                    sock.socket().shutdownOutput();
+                } catch (IOException e2) {
+                }
+                try {
+                    sock.socket().close();
+                } catch (IOException e1) {
+                }
+                try {
+                    sock.close();
+                } catch (IOException e1) {
+                }
+            }
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e1) {
+                e1.printStackTrace();
+            }
+            sockKey = null;
+            synchronized (pendingQueue) {
+                for (Packet p : pendingQueue) {
+                    conLossPacket(p);
+                }
+                pendingQueue.clear();
+            }
+            synchronized (outgoingQueue) {
+                for (Packet p : outgoingQueue) {
+                    conLossPacket(p);
+                }
+                outgoingQueue.clear();
+            }
+        }
+
+        public void close() {
+            zooKeeper.state = States.CLOSED;
+            synchronized (this) {
+                selector.wakeup();
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public void close() throws IOException {
+        long traceMask = ZooTrace.SESSION_TRACE_MASK;
+        if (ZooTrace.isTraceEnabled(LOG, traceMask)) {
+            ZooTrace.logTraceMessage(LOG, traceMask,
+                    "Close ClientCnxn for session: " + sessionId + "!");
+        }
+        sendThread.close();
+        waitingEvents.add(eventOfDeath);
+    }
+
+    private int xid = 1;
+
+    synchronized private int getXid() {
+        return xid++;
+    }
+
+    public ReplyHeader submitRequest(RequestHeader h, Record request,
+            Record response) throws InterruptedException {
+        ReplyHeader r = new ReplyHeader();
+        Packet packet = queuePacket(h, r, request, response, null, null, null);
+        synchronized (packet) {
+            while (!packet.finished) {
+                packet.wait();
+            }
+        }
+        return r;
+    }
+
+    Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
+            Record response, AsyncCallback cb, String path, Object ctx) {
+        Packet packet = null;
+        synchronized (outgoingQueue) {
+            if (h.getType() != OpCode.ping && h.getType() != OpCode.auth) {
+                h.setXid(getXid());
+            }
+            packet = new Packet(h, r, request, response, null);
+            packet.cb = cb;
+            packet.ctx = ctx;
+            packet.path = path;
+            if (!zooKeeper.state.isAlive()) {
+                conLossPacket(packet);
+            } else {
+                outgoingQueue.add(packet);
+            }
+        }
+        synchronized (sendThread) {
+            selector.wakeup();
+        }
+        return packet;
+    }
+
+    public void addAuthInfo(String scheme, byte auth[]) {
+        authInfo.add(new AuthData(scheme, auth));
+        if (zooKeeper.state == States.CONNECTED) {
+            queuePacket(new RequestHeader(-4, OpCode.auth), null,
+                    new AuthPacket(0, scheme, auth), null, null, null, null);
+        }
+    }
+}
<EOC>
<SOC>
-/**
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.Date;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.zookeeper.AsyncCallback.ACLCallback;
-import com.yahoo.zookeeper.AsyncCallback.ChildrenCallback;
-import com.yahoo.zookeeper.AsyncCallback.DataCallback;
-import com.yahoo.zookeeper.AsyncCallback.StatCallback;
-import com.yahoo.zookeeper.AsyncCallback.StringCallback;
-import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
-import com.yahoo.zookeeper.KeeperException.Code;
-import com.yahoo.zookeeper.ZooDefs.Ids;
-import com.yahoo.zookeeper.data.ACL;
-import com.yahoo.zookeeper.data.Id;
-import com.yahoo.zookeeper.data.Stat;
-import com.yahoo.zookeeper.proto.CreateRequest;
-import com.yahoo.zookeeper.proto.CreateResponse;
-import com.yahoo.zookeeper.proto.DeleteRequest;
-import com.yahoo.zookeeper.proto.ExistsRequest;
-import com.yahoo.zookeeper.proto.GetACLRequest;
-import com.yahoo.zookeeper.proto.GetACLResponse;
-import com.yahoo.zookeeper.proto.GetChildrenRequest;
-import com.yahoo.zookeeper.proto.GetChildrenResponse;
-import com.yahoo.zookeeper.proto.GetDataRequest;
-import com.yahoo.zookeeper.proto.GetDataResponse;
-import com.yahoo.zookeeper.proto.ReplyHeader;
-import com.yahoo.zookeeper.proto.RequestHeader;
-import com.yahoo.zookeeper.proto.SetACLRequest;
-import com.yahoo.zookeeper.proto.SetACLResponse;
-import com.yahoo.zookeeper.proto.SetDataRequest;
-import com.yahoo.zookeeper.proto.SetDataResponse;
-import com.yahoo.zookeeper.proto.SyncRequest;
-import com.yahoo.zookeeper.proto.SyncResponse;
-import com.yahoo.zookeeper.proto.WatcherEvent;
-import com.yahoo.zookeeper.server.DataTree;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-
-/**
- * This is the main class of ZooKeeper client library. To use a ZooKeeper
- * service, an application must first instantiate an object of ZooKeeper class.
- * All the iterations will be done by calling the methods of ZooKeeper class.
- * <p>
- * To create a client(ZooKeeper) object, the application needs to pass a string
- * containing a list of host:port pairs, each corresponding to a ZooKeeper
- * server; a sessionTimeout; and an object of Watcher type.
- * <p>
- * The client object will pick an arbitrary server and try to connect to it. If
- * failed, it will try the next one in the list, until a connection is
- * established, or all the servers have been tried.
- * <p>
- * Once a connection to a server is established, a session ID is assigned to the
- * client. The client will send heart beats to the server periodically to keep
- * the session valid.
- * <p>
- * The application can call ZooKeeper APIs through a client as long as the
- * session ID of the client remains valid.
- * <p>
- * If for some reason, the client fails to send heart beats to the server for a
- * prolonged period of time (exceeding the sessionTimeout value, for instance),
- * the server will expire the session, and the session ID will become invalid.
- * The client object will no longer be usable. To make ZooKeeper API calls, the
- * application must create a new client object.
- * <p>
- * If the ZooKeeper server the client currently connects to fails or otherwise
- * does not respond, the client will automatically try to connect to another
- * server before its session ID expires. If successful, the application can
- * continue to use the client.
- * <p>
- * Some successful ZooKeeper API calls can leave watches on the "data nodes" in
- * the ZooKeeper server. Other successful ZooKeeper API calls can trigger those
- * watches. Once a watch is triggered, an event will be delivered to the client
- * which left the watch at the first place. Each watch can be triggered only
- * once. Thus, up to one event will be delivered to a client for every watch it
- * leaves.
- * <p>
- * A client needs an object of a class implementing Watcher interface for
- * processing the events delivered to the client.
- * 
- * When a client drops current connection and re-connects to a server, all the
- * existing watches are considered as being triggered but the undelivered events
- * are lost. To emulate this, the client will generate a special event to tell
- * the event handler a connection has been dropped. This special event has type
- * EventNone and state sKeeperStateDisconnected.
- * 
- */
-public class ZooKeeper {
-    private static final Logger LOG = Logger.getLogger(ZooKeeper.class);
-    
-    volatile Watcher watcher;
-
-    public enum States {
-        CONNECTING, ASSOCIATING, CONNECTED, CLOSED, AUTH_FAILED;
-
-        public boolean isAlive() {
-            return this != CLOSED && this != AUTH_FAILED;
-        }
-    }
-
-    volatile States state;
-
-    ClientCnxn cnxn;
-
-    public ZooKeeper(String host, int sessionTimeout, Watcher watcher)
-            throws KeeperException, IOException {
-        this.watcher = watcher;
-        cnxn = new ClientCnxn(host, sessionTimeout, this);
-    }
-
-    public ZooKeeper(String host, int sessionTimeout, Watcher watcher,
-            long sessionId, byte[] sessionPasswd) throws KeeperException,
-            IOException {
-        this.watcher = watcher;
-        cnxn = new ClientCnxn(host, sessionTimeout, this, sessionId,
-                sessionPasswd);
-    }
-
-    public long getSessionId() {
-        return cnxn.getSessionId();
-    }
-
-    public byte[] getSessionPasswd() {
-        return cnxn.getSessionPasswd();
-    }
-
-    public void addAuthInfo(String scheme, byte auth[]) {
-        cnxn.addAuthInfo(scheme, auth);
-    }
-
-    public String describeCNXN() {
-        return cnxn.toString();
-    }
-
-    public synchronized void register(Watcher watcher) {
-        this.watcher = watcher;
-    }
-
-    /**
-     * Close this client object. Once the client is closed, its session becomes
-     * invalid. All the ephemeral nodes in the ZooKeeper server associated with
-     * the session will be removed. The watches left on those nodes (and on
-     * their parents) will be triggered.
-     *
-     * @throws InterruptedException
-     *
-     * @throws IOException
-     * @throws InterruptedException
-     * @throws KeeperException
-     */
-    public synchronized void close() throws InterruptedException {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.closeSession);
-        cnxn.submitRequest(h, null, null);
-        try {
-            cnxn.close();
-        } catch (IOException e) {
-            LOG.warn("Unexpected exception", e);
-        }
-    }
-
-    /**
-     * Create a node with the given path. The node data will be the given data,
-     * and node acl will be the given acl.
-     * <p>
-     * The flags argument specifies whether the created node will be ephemeral
-     * or not.
-     * <p>
-     * An ephemeral node will be removed by the ZooKeeper automatically when the
-     * session associated with the creation of the node expires.
-     * <p>
-     * The flags argument can also specify to create a sequential node. The
-     * actual path name of a sequential node will be the given path plus a
-     * suffix "_i" where i is the current sequential number of the node. Once
-     * such a node is created, the sequential number will be incremented by one.
-     * <p>
-     * If a node with the same actual path already exists in the ZooKeeper, a
-     * KeeperException with error code KeeperException.NodeExists will be
-     * thrown. Note that since a different actual path is used for each
-     * invocation of creating sequential node with the same path argument, the
-     * call will never throw "file exists" KeeperException.
-     * <p>
-     * If the parent node does not exist in the ZooKeeper, a KeeperException
-     * with error code KeeperException.NoNode will be thrown.
-     * <p>
-     * An ephemeral node cannot have children. If the parent node of the given
-     * path is ephemeral, a KeeperException with error code
-     * KeeperException.NoChildrenForEphemerals will be thrown.
-     * <p>
-     * This operation, if successful, will trigger all the watches left on the
-     * node of the given path by exists and getData API calls, and the watches
-     * left on the parent node by getChildren API calls.
-     * <p>
-     * If a node is created successfully, the ZooKeeper server will trigger the
-     * watches on the path left by exists calls, and the watches on the parent
-     * of the node by getChildren calls.
-     *
-     * @param path
-     *                the path for the node
-     * @param data
-     *                the initial data for the node
-     * @param acl
-     *                the acl for the node
-     * @param flags
-     *                specifying whether the node to be created is ephemeral
-     *                and/or sequential
-     * @return the actual path of the created node
-     * @throws KeeperException
-     *                 an exception with appropriate error code defined in
-     *                 KeeperException class..
-     * @throws IOException
-     * @throws InterruptedException
-     */
-    public String create(String path, byte data[], ArrayList<ACL> acl, int flags)
-            throws KeeperException, InterruptedException {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.create);
-        CreateRequest request = new CreateRequest();
-        CreateResponse response = new CreateResponse();
-        request.setData(data);
-        request.setFlags(flags);
-        request.setPath(path);
-        if (acl != null && acl.size() == 0) {
-            throw new KeeperException(Code.InvalidACL);
-        }
-        request.setAcl(acl);
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
-        if (r.getErr() != 0) {
-            throw new KeeperException(r.getErr(), path);
-        }
-        return response.getPath();
-    }
-
-    /**
-     * The Asynchronous version of create. The request doesn't actually until
-     * the asynchronous callback is called.
-     *
-     * @see #create(String, byte[], ArrayList, int)
-     */
-
-    public void create(String path, byte data[], ArrayList<ACL> acl, int flags,
-            StringCallback cb, Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.create);
-        CreateRequest request = new CreateRequest();
-        CreateResponse response = new CreateResponse();
-        ReplyHeader r = new ReplyHeader();
-        request.setData(data);
-        request.setFlags(flags);
-        request.setPath(path);
-        request.setAcl(acl);
-        cnxn.queuePacket(h, r, request, response, cb, path, ctx);
-    }
-
-    /**
-     * Delete the node with the given path. The call will succeed if such a node
-     * exists, and the given version matches the node's version (if the given
-     * version is -1, it matches any node's versions).
-     * <p>
-     * A KeeperException with error code KeeperException.NoNode will be thrown
-     * if the nodes does not exist.
-     * <p>
-     * A KeeperException with error code KeeperException.BadVersion will be
-     * thrown if the given version does not match the node's version.
-     * <p>
-     * A KeeperException with error code KeeperException.NotEmpty will be thrown
-     * if the node has children.
-     * <p>
-     * This operation, if successful, will trigger all the watches on the node
-     * of the given path left by exists API calls, and the watches on the parent
-     * node left by getChildren API calls.
-     *
-     * @param path
-     *                the path of the node to be deleted.
-     * @param version
-     *                the expected node version.
-     * @throws KeeperException
-     *                 an KeeperException with appropriate error code.
-     * @throws IOException
-     * @throws InterruptedException
-     */
-    public void delete(String path, int version) throws KeeperException,
-            InterruptedException {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.delete);
-        DeleteRequest request = new DeleteRequest();
-        request.setPath(path);
-        request.setVersion(version);
-        ReplyHeader r = cnxn.submitRequest(h, request, null);
-        if (r.getErr() != 0) {
-            throw new KeeperException(r.getErr());
-        }
-    }
-
-    /**
-     * The Asynchronous version of delete. The request doesn't actually until
-     * the asynchronous callback is called.
-     *
-     * @see #delete(String, int)
-     */
-    public void delete(String path, int version, VoidCallback cb, Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.delete);
-        DeleteRequest request = new DeleteRequest();
-        request.setPath(path);
-        request.setVersion(version);
-        cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, path, ctx);
-    }
-
-    /**
-     * Return the stat of the node of the given path. Return null if no such a
-     * node exists.
-     * <p>
-     * If the watch is true and the call is successful (no exception is thrown),
-     * a watch will be left on the node with the given path. The watch will be
-     * triggered by a successful operation that creates/delete the node or sets
-     * the data on the node.
-     *
-     * @param path
-     *                the node path
-     * @param watch
-     *                whether need to watch this node
-     * @return the stat of the node of the given path; return null if no such a
-     *         node exists.
-     * @throws KeeperException
-     * @throws IOException
-     * @throws InterruptedException
-     */
-    public Stat exists(String path, boolean watch) throws KeeperException,
-            InterruptedException {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.exists);
-        ExistsRequest request = new ExistsRequest();
-        request.setPath(path);
-        request.setWatch(watch);
-        SetDataResponse response = new SetDataResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
-        if (r.getErr() != 0) {
-            if (r.getErr() == KeeperException.Code.NoNode) {
-                return null;
-            }
-            throw new KeeperException(r.getErr());
-        }
-        return response.getStat().getCzxid() == -1 ? null : response.getStat();
-    }
-
-    /**
-     * The Asynchronous version of exists. The request doesn't actually until
-     * the asynchronous callback is called.
-     *
-     * @see #exists(String, boolean)
-     */
-    public void exists(String path, boolean watch, StatCallback cb, Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.exists);
-        ExistsRequest request = new ExistsRequest();
-        request.setPath(path);
-        request.setWatch(watch);
-        SetDataResponse response = new SetDataResponse();
-        cnxn
-                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
-    }
-
-    /**
-     * Return the data and the stat of the node of the given path.
-     * <p>
-     * If the watch is true and the call is successfull (no exception is
-     * thrown), a watch will be left on the node with the given path. The watch
-     * will be triggered by a sucessful operation that sets data on the node, or
-     * deletes the node.
-     * <p>
-     * A KeeperException with error code KeeperException.NoNode will be thrown
-     * if no node with the given path exists.
-     *
-     * @param path
-     *                the given path
-     * @param watch
-     *                whether need to watch this node
-     * @param stat
-     *                teh stat of the node
-     * @return the data of the node
-     * @throws IOException
-     * @throws KeeperException
-     * @throws InterruptedException
-     */
-    public byte[] getData(String path, boolean watch, Stat stat)
-            throws KeeperException, InterruptedException {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.getData);
-        GetDataRequest request = new GetDataRequest();
-        request.setPath(path);
-        request.setWatch(watch);
-        GetDataResponse response = new GetDataResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
-        if (r.getErr() != 0) {
-            throw new KeeperException(r.getErr());
-        }
-        if (stat != null) {
-            DataTree.copyStat(response.getStat(), stat);
-        }
-        return response.getData();
-    }
-
-    /**
-     * The Asynchronous version of getData. The request doesn't actually until
-     * the asynchronous callback is called.
-     *
-     * @see #getData(String, boolean, Stat)
-     */
-
-    public void getData(String path, boolean watch, DataCallback cb, Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.getData);
-        GetDataRequest request = new GetDataRequest();
-        request.setPath(path);
-        request.setWatch(watch);
-        GetDataResponse response = new GetDataResponse();
-        cnxn
-                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
-    }
-
-    /**
-     * Set the data for the node of the given path if such a node exists and the
-     * given version matches the version of the node (if the given version is
-     * -1, it matches any node's versions). Return the stat of the node.
-     * <p>
-     * This operation, if successful, will trigger all the watches on the node
-     * of the given path left by getData calls.
-     * <p>
-     * A KeeperException with error code KeeperException.NoNode will be thrown
-     * if no node with the given path exists.
-     *
-     * A KeeperException with error code KeeperException.BadVersion will be
-     * thrown if the given version does not match the node's version.
-     *
-     * @param path
-     *                the path of the node
-     * @param data
-     *                the data to set
-     * @param version
-     *                the expected matching version
-     * @return the state of the node
-     * @throws KeeperException
-     * @throws IOException
-     * @throws InterruptedException
-     */
-    public Stat setData(String path, byte data[], int version)
-            throws KeeperException, InterruptedException {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.setData);
-        SetDataRequest request = new SetDataRequest();
-        request.setPath(path);
-        request.setData(data);
-        request.setVersion(version);
-        SetDataResponse response = new SetDataResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
-        if (r.getErr() != 0) {
-            throw new KeeperException(r.getErr());
-        }
-        return response.getStat();
-    }
-
-    /**
-     * The Asynchronous version of setData. The request doesn't actually until
-     * the asynchronous callback is called.
-     *
-     * @see #setData(String, byte[], int)
-     */
-    public void setData(String path, byte data[], int version, StatCallback cb,
-            Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.setData);
-        SetDataRequest request = new SetDataRequest();
-        request.setPath(path);
-        request.setData(data);
-        request.setVersion(version);
-        SetDataResponse response = new SetDataResponse();
-        cnxn
-                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
-    }
-
-    /**
-     *
-     * Return the ACL and stat of the node of the given path.
-     * <p>
-     * A KeeperException with error code KeeperException.NoNode will be thrown
-     * if no node with the given path exists.
-     *
-     * @param path
-     *                the given path for the node
-     * @param stat
-     *                the stat of the node will be copied to this parameter.
-     * @return the ACL array of the given node.
-     * @throws KeeperException
-     * @throws IOException
-     * @throws InterruptedException
-     */
-    public ArrayList<ACL> getACL(String path, Stat stat)
-            throws KeeperException, InterruptedException {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.getACL);
-        GetACLRequest request = new GetACLRequest();
-        request.setPath(path);
-        GetACLResponse response = new GetACLResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
-        if (r.getErr() != 0) {
-            throw new KeeperException(r.getErr());
-        }
-        DataTree.copyStat(response.getStat(), stat);
-        return response.getAcl();
-    }
-
-    /**
-     * The Asynchronous version of getACL. The request doesn't actually until
-     * the asynchronous callback is called.
-     *
-     * @see #getACL(String, Stat)
-     */
-    public void getACL(String path, Stat stat, ACLCallback cb, Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.getACL);
-        GetACLRequest request = new GetACLRequest();
-        request.setPath(path);
-        GetACLResponse response = new GetACLResponse();
-        cnxn
-                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
-    }
-
-    /**
-     * Set the ACL for the node of the given path if such a node exists and the
-     * given version matches the version of the node. Return the stat of the
-     * node.
-     * <p>
-     * A KeeperException with error code KeeperException.NoNode will be thrown
-     * if no node with the given path exists.
-     * <p>
-     * A KeeperException with error code KeeperException.BadVersion will be
-     * thrown if the given version does not match the node's version.
-     *
-     * @param path
-     * @param acl
-     * @param version
-     * @return the stat of the node.
-     * @throws KeeperException
-     * @throws IOException
-     * @throws InterruptedException
-     */
-    public Stat setACL(String path, ArrayList<ACL> acl, int version)
-            throws KeeperException, InterruptedException {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.setACL);
-        SetACLRequest request = new SetACLRequest();
-        request.setPath(path);
-        if (acl != null && acl.size() == 0) {
-            throw new KeeperException(Code.InvalidACL);
-        }
-        request.setAcl(acl);
-        request.setVersion(version);
-        SetACLResponse response = new SetACLResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
-        if (r.getErr() != 0) {
-            throw new KeeperException(r.getErr());
-        }
-        return response.getStat();
-    }
-
-    /**
-     * The Asynchronous version of setACL. The request doesn't actually until
-     * the asynchronous callback is called.
-     *
-     * @see #setACL(String, ArrayList, int)
-     */
-    public void setACL(String path, ArrayList<ACL> acl, int version,
-            StatCallback cb, Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.setACL);
-        SetACLRequest request = new SetACLRequest();
-        request.setPath(path);
-        request.setAcl(acl);
-        request.setVersion(version);
-        SetACLResponse response = new SetACLResponse();
-        cnxn
-                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
-    }
-
-    /**
-     * Return the list of the children of the node of the given path.
-     * <p>
-     * If the watch is true and the call is successful (no exception is thrown),
-     * a watch will be left on the node with the given path. The watch willbe
-     * triggered by a sucessful operation that deletes the node of the given
-     * path or creates/delete a child under the node.
-     * <p>
-     * A KeeperException with error code KeeperException.NoNode will be thrown
-     * if no node with the given path exists.
-     *
-     * @param path
-     * @param watch
-     * @return an array of children of the node with the given path
-     * @throws IOException
-     * @throws KeeperException
-     * @throws InterruptedException
-     */
-    public ArrayList<String> getChildren(String path, boolean watch)
-            throws KeeperException, InterruptedException {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.getChildren);
-        GetChildrenRequest request = new GetChildrenRequest();
-        request.setPath(path);
-        request.setWatch(watch);
-        GetChildrenResponse response = new GetChildrenResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
-        if (r.getErr() != 0) {
-            throw new KeeperException(r.getErr());
-        }
-        return response.getChildren();
-    }
-
-    /**
-     * The Asynchronous version of getChildren. The request doesn't actually
-     * until the asynchronous callback is called.
-     *
-     * @see #getChildren(String, boolean)
-     */
-    public void getChildren(String path, boolean watch, ChildrenCallback cb,
-            Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.getChildren);
-        GetChildrenRequest request = new GetChildrenRequest();
-        request.setPath(path);
-        request.setWatch(watch);
-        GetChildrenResponse response = new GetChildrenResponse();
-        cnxn
-                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
-    }
-
-    /**
-     * Asynchronous sync. Flushes channel between process and leader.
-     *
-     * @see #sync(String)
-     */
-    public void sync(String path, VoidCallback cb, Object ctx){
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.sync);
-        SyncRequest request = new SyncRequest();
-        SyncResponse response = new SyncResponse();
-        request.setPath(path);
-        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path, ctx);
-    }
-
-    public States getState() {
-        return state;
-    }
-
-    // Everything below this line is for testing!
-
-    static void usage() {
-        System.err.println("ZooKeeper host:port cmd args");
-        System.err.println("\tcreate path data acl");
-        System.err.println("\tdelete path [version]");
-        System.err.println("\tset path data [version]");
-        System.err.println("\tget path [watch]");
-        System.err.println("\tls path [watch]");
-        System.err.println("\tgetAcl path");
-        System.err.println("\tsetAcl path acl");
-        System.err.println("\tstat path [watch]");
-        System.err.println("\tsync path");
-    }
-
-    static private class MyWatcher implements Watcher {
-        public void process(WatcherEvent event) {
-            System.err.println(event.getPath() + ": " + event.getState() + "-"
-                    + event.getType());
-        }
-    }
-
-    static private int getPermFromString(String permString) {
-        int perm = 0;
-        for (int i = 0; i < permString.length(); i++) {
-            switch (permString.charAt(i)) {
-            case 'r':
-                perm |= ZooDefs.Perms.READ;
-                break;
-            case 'w':
-                perm |= ZooDefs.Perms.WRITE;
-                break;
-            case 'c':
-                perm |= ZooDefs.Perms.CREATE;
-                break;
-            case 'd':
-                perm |= ZooDefs.Perms.DELETE;
-                break;
-            case 'a':
-                perm |= ZooDefs.Perms.ADMIN;
-                break;
-            default:
-                System.err
-                        .println("Unknown perm type: " + permString.charAt(i));
-            }
-        }
-        return perm;
-    }
-
-    private static void printStat(Stat stat) {
-        System.err.println("ctime = " + new Date(stat.getCtime()).toString());
-        System.err.println("ctime = " + new Date(stat.getMtime()).toString());
-        System.err.println("cversion = " + stat.getCversion());
-        System.err.println("cZxid = " + stat.getCzxid());
-        System.err.println("mZxid = " + stat.getMzxid());
-        System.err.println("dataVersion = " + stat.getVersion());
-        System.err.println("aclVersion = " + stat.getAversion());
-    }
-
-    public static void main(String args[]) throws NumberFormatException,
-            KeeperException, IOException, InterruptedException {
-        if (args.length == 1) {
-            ZooKeeper zooKeeper = new ZooKeeper(args[0], 5000, new MyWatcher());
-            BufferedReader br = new BufferedReader(new InputStreamReader(
-                    System.in));
-            String line;
-            while ((line = br.readLine()) != null) {
-                line = "ignore " + line;
-                args = line.split(" ");
-                processCmd(args, zooKeeper);
-            }
-        } else if (args.length < 3) {
-            usage();
-        }
-
-        ZooKeeper zooKeeper = new ZooKeeper(args[0], 5000, new MyWatcher());
-        boolean watch = processCmd(args, zooKeeper);
-        if (!watch) {
-            System.exit(0);
-        }
-    }
-
-    private static DataCallback dataCallback = new DataCallback() {
-
-        public void processResult(int rc, String path, Object ctx, byte[] data,
-                Stat stat) {
-            System.out.println("rc = " + rc + " path = " + path + " data = "
-                    + (data == null ? "null" : new String(data)) + " stat = ");
-            printStat(stat);
-        }
-
-    };
-
-    private static boolean processCmd(String[] args, ZooKeeper zooKeeper)
-            throws KeeperException, IOException, InterruptedException {
-        Stat stat = new Stat();
-        if (args.length < 2) {
-            return false;
-        }
-        if (args.length < 3) {
-            usage();
-            return false;
-        }
-        String cmd = args[1];
-        boolean watch = args.length > 3;
-        String path = args[2];
-        ArrayList<ACL> acl = Ids.OPEN_ACL_UNSAFE;
-        System.out.println("Processing " + cmd);
-        if (cmd.equals("create") && args.length >= 4) {
-            if (args.length == 5) {
-                acl = parseACLs(args[4]);
-            }
-            String newPath = zooKeeper.create(path, args[3].getBytes(), acl, 0);
-            System.err.println("Created " + newPath);
-        } else if (cmd.equals("delete") && args.length >= 3) {
-            zooKeeper.delete(path, watch ? Integer.parseInt(args[3]) : -1);
-        } else if (cmd.equals("set") && args.length >= 4) {
-            stat = zooKeeper.setData(path, args[3].getBytes(),
-                    args.length > 4 ? Integer.parseInt(args[4]) : -1);
-            printStat(stat);
-        } else if (cmd.equals("aget") && args.length >= 3) {
-            zooKeeper.getData(path, watch, dataCallback, path);
-        } else if (cmd.equals("get") && args.length >= 3) {
-            byte data[] = zooKeeper.getData(path, watch, stat);
-            System.out.println(new String(data));
-            printStat(stat);
-        } else if (cmd.equals("ls") && args.length >= 3) {
-            ArrayList<String> children = zooKeeper.getChildren(path, watch);
-            System.out.println(children);
-        } else if (cmd.equals("getAcl") && args.length >= 2) {
-            acl = zooKeeper.getACL(path, stat);
-            for (ACL a : acl) {
-                System.out.println(a.getId() + ": "
-                        + getPermString(a.getPerms()));
-            }
-        } else if (cmd.equals("setAcl") && args.length >= 4) {
-
-            stat = zooKeeper.setACL(path, parseACLs(args[3]),
-                    args.length > 4 ? Integer.parseInt(args[4]) : -1);
-            printStat(stat);
-        } else if (cmd.equals("stat") && args.length >= 3) {
-            stat = zooKeeper.exists(path, watch);
-            printStat(stat);
-        } else {
-            usage();
-        }
-        return watch;
-    }
-
-    private static String getPermString(int perms) {
-        StringBuffer p = new StringBuffer();
-        if ((perms & ZooDefs.Perms.CREATE) != 0) {
-            p.append('c');
-        }
-        if ((perms & ZooDefs.Perms.DELETE) != 0) {
-            p.append('d');
-        }
-        if ((perms & ZooDefs.Perms.READ) != 0) {
-            p.append('r');
-        }
-        if ((perms & ZooDefs.Perms.WRITE) != 0) {
-            p.append('w');
-        }
-        if ((perms & ZooDefs.Perms.ADMIN) != 0) {
-            p.append('a');
-        }
-        return p.toString();
-    }
-
-    private static ArrayList<ACL> parseACLs(String aclString) {
-        ArrayList<ACL> acl;
-        String acls[] = aclString.split(",");
-        acl = new ArrayList<ACL>();
-        for (String a : acls) {
-            int firstColon = a.indexOf(':');
-            int lastColon = a.indexOf(':');
-            if (firstColon == -1 || lastColon == -1 || firstColon == lastColon) {
-                System.err
-                        .println(a + " does not have the form scheme:id:perm");
-                continue;
-            }
-            ACL newAcl = new ACL();
-            newAcl.setId(new Id(a.substring(0, firstColon), a.substring(
-                    firstColon + 1, lastColon)));
-            newAcl.setPerms(getPermFromString(a.substring(lastColon + 1)));
-            acl.add(newAcl);
-        }
-        return acl;
-    }
-
-    public void disconnect() throws IOException {
-        cnxn.close();
-    }
-}
+/**
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Date;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.zookeeper.AsyncCallback.ACLCallback;
+import com.yahoo.zookeeper.AsyncCallback.ChildrenCallback;
+import com.yahoo.zookeeper.AsyncCallback.DataCallback;
+import com.yahoo.zookeeper.AsyncCallback.StatCallback;
+import com.yahoo.zookeeper.AsyncCallback.StringCallback;
+import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
+import com.yahoo.zookeeper.ZooDefs.Ids;
+import com.yahoo.zookeeper.data.ACL;
+import com.yahoo.zookeeper.data.Id;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.CreateRequest;
+import com.yahoo.zookeeper.proto.CreateResponse;
+import com.yahoo.zookeeper.proto.DeleteRequest;
+import com.yahoo.zookeeper.proto.ExistsRequest;
+import com.yahoo.zookeeper.proto.GetACLRequest;
+import com.yahoo.zookeeper.proto.GetACLResponse;
+import com.yahoo.zookeeper.proto.GetChildrenRequest;
+import com.yahoo.zookeeper.proto.GetChildrenResponse;
+import com.yahoo.zookeeper.proto.GetDataRequest;
+import com.yahoo.zookeeper.proto.GetDataResponse;
+import com.yahoo.zookeeper.proto.ReplyHeader;
+import com.yahoo.zookeeper.proto.RequestHeader;
+import com.yahoo.zookeeper.proto.SetACLRequest;
+import com.yahoo.zookeeper.proto.SetACLResponse;
+import com.yahoo.zookeeper.proto.SetDataRequest;
+import com.yahoo.zookeeper.proto.SetDataResponse;
+import com.yahoo.zookeeper.proto.SyncRequest;
+import com.yahoo.zookeeper.proto.SyncResponse;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.DataTree;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+
+/**
+ * This is the main class of ZooKeeper client library. To use a ZooKeeper
+ * service, an application must first instantiate an object of ZooKeeper class.
+ * All the iterations will be done by calling the methods of ZooKeeper class.
+ * <p>
+ * To create a client(ZooKeeper) object, the application needs to pass a string
+ * containing a list of host:port pairs, each corresponding to a ZooKeeper
+ * server; a sessionTimeout; and an object of Watcher type.
+ * <p>
+ * The client object will pick an arbitrary server and try to connect to it. If
+ * failed, it will try the next one in the list, until a connection is
+ * established, or all the servers have been tried.
+ * <p>
+ * Once a connection to a server is established, a session ID is assigned to the
+ * client. The client will send heart beats to the server periodically to keep
+ * the session valid.
+ * <p>
+ * The application can call ZooKeeper APIs through a client as long as the
+ * session ID of the client remains valid.
+ * <p>
+ * If for some reason, the client fails to send heart beats to the server for a
+ * prolonged period of time (exceeding the sessionTimeout value, for instance),
+ * the server will expire the session, and the session ID will become invalid.
+ * The client object will no longer be usable. To make ZooKeeper API calls, the
+ * application must create a new client object.
+ * <p>
+ * If the ZooKeeper server the client currently connects to fails or otherwise
+ * does not respond, the client will automatically try to connect to another
+ * server before its session ID expires. If successful, the application can
+ * continue to use the client.
+ * <p>
+ * Some successful ZooKeeper API calls can leave watches on the "data nodes" in
+ * the ZooKeeper server. Other successful ZooKeeper API calls can trigger those
+ * watches. Once a watch is triggered, an event will be delivered to the client
+ * which left the watch at the first place. Each watch can be triggered only
+ * once. Thus, up to one event will be delivered to a client for every watch it
+ * leaves.
+ * <p>
+ * A client needs an object of a class implementing Watcher interface for
+ * processing the events delivered to the client.
+ *
+ * When a client drops current connection and re-connects to a server, all the
+ * existing watches are considered as being triggered but the undelivered events
+ * are lost. To emulate this, the client will generate a special event to tell
+ * the event handler a connection has been dropped. This special event has type
+ * EventNone and state sKeeperStateDisconnected.
+ *
+ */
+public class ZooKeeper {
+    private static final Logger LOG = Logger.getLogger(ZooKeeper.class);
+
+    volatile Watcher watcher;
+
+    public enum States {
+        CONNECTING, ASSOCIATING, CONNECTED, CLOSED, AUTH_FAILED;
+
+        public boolean isAlive() {
+            return this != CLOSED && this != AUTH_FAILED;
+        }
+    }
+
+    volatile States state;
+
+    ClientCnxn cnxn;
+
+    public ZooKeeper(String host, int sessionTimeout, Watcher watcher)
+            throws IOException {
+        this.watcher = watcher;
+        cnxn = new ClientCnxn(host, sessionTimeout, this);
+    }
+
+    public ZooKeeper(String host, int sessionTimeout, Watcher watcher,
+            long sessionId, byte[] sessionPasswd) throws IOException {
+        this.watcher = watcher;
+        cnxn = new ClientCnxn(host, sessionTimeout, this, sessionId,
+                sessionPasswd);
+    }
+
+    public long getSessionId() {
+        return cnxn.getSessionId();
+    }
+
+    public byte[] getSessionPasswd() {
+        return cnxn.getSessionPasswd();
+    }
+
+    public void addAuthInfo(String scheme, byte auth[]) {
+        cnxn.addAuthInfo(scheme, auth);
+    }
+
+    public String describeCNXN() {
+        return cnxn.toString();
+    }
+
+    public synchronized void register(Watcher watcher) {
+        this.watcher = watcher;
+    }
+
+    /**
+     * Close this client object. Once the client is closed, its session becomes
+     * invalid. All the ephemeral nodes in the ZooKeeper server associated with
+     * the session will be removed. The watches left on those nodes (and on
+     * their parents) will be triggered.
+     *
+     * @throws InterruptedException
+     *
+     * @throws IOException
+     * @throws InterruptedException
+     */
+    public synchronized void close() throws InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.closeSession);
+        cnxn.submitRequest(h, null, null);
+        try {
+            cnxn.close();
+        } catch (IOException e) {
+            LOG.warn("Unexpected exception", e);
+        }
+    }
+
+    /**
+     * Create a node with the given path. The node data will be the given data,
+     * and node acl will be the given acl.
+     * <p>
+     * The flags argument specifies whether the created node will be ephemeral
+     * or not.
+     * <p>
+     * An ephemeral node will be removed by the ZooKeeper automatically when the
+     * session associated with the creation of the node expires.
+     * <p>
+     * The flags argument can also specify to create a sequential node. The
+     * actual path name of a sequential node will be the given path plus a
+     * suffix "_i" where i is the current sequential number of the node. Once
+     * such a node is created, the sequential number will be incremented by one.
+     * <p>
+     * If a node with the same actual path already exists in the ZooKeeper, a
+     * KeeperException with error code KeeperException.NodeExists will be
+     * thrown. Note that since a different actual path is used for each
+     * invocation of creating sequential node with the same path argument, the
+     * call will never throw "file exists" KeeperException.
+     * <p>
+     * If the parent node does not exist in the ZooKeeper, a KeeperException
+     * with error code KeeperException.NoNode will be thrown.
+     * <p>
+     * An ephemeral node cannot have children. If the parent node of the given
+     * path is ephemeral, a KeeperException with error code
+     * KeeperException.NoChildrenForEphemerals will be thrown.
+     * <p>
+     * This operation, if successful, will trigger all the watches left on the
+     * node of the given path by exists and getData API calls, and the watches
+     * left on the parent node by getChildren API calls.
+     * <p>
+     * If a node is created successfully, the ZooKeeper server will trigger the
+     * watches on the path left by exists calls, and the watches on the parent
+     * of the node by getChildren calls.
+     *
+     * @param path
+     *                the path for the node
+     * @param data
+     *                the initial data for the node
+     * @param acl
+     *                the acl for the node
+     * @param flags
+     *                specifying whether the node to be created is ephemeral
+     *                and/or sequential
+     * @return the actual path of the created node
+     * @throws KeeperException if the server returns a non-zero error code
+     * @throws com.yahoo.zookeeper.KeeperException.InvalidACLException if the ACL is invalid
+     * @throws InterruptedException if the transaction is interrrupted
+     */
+    public String create(String path, byte data[], ArrayList<ACL> acl, int flags)
+            throws KeeperException, InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.create);
+        CreateRequest request = new CreateRequest();
+        CreateResponse response = new CreateResponse();
+        request.setData(data);
+        request.setFlags(flags);
+        request.setPath(path);
+        if (acl != null && acl.size() == 0) {
+            throw new KeeperException.InvalidACLException();
+        }
+        request.setAcl(acl);
+        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        if (r.getErr() != 0) {
+            throw KeeperException.create(r.getErr(), path);
+        }
+        return response.getPath();
+    }
+
+    /**
+     * The Asynchronous version of create. The request doesn't actually until
+     * the asynchronous callback is called.
+     *
+     * @see #create(String, byte[], ArrayList, int)
+     */
+
+    public void create(String path, byte data[], ArrayList<ACL> acl, int flags,
+            StringCallback cb, Object ctx) {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.create);
+        CreateRequest request = new CreateRequest();
+        CreateResponse response = new CreateResponse();
+        ReplyHeader r = new ReplyHeader();
+        request.setData(data);
+        request.setFlags(flags);
+        request.setPath(path);
+        request.setAcl(acl);
+        cnxn.queuePacket(h, r, request, response, cb, path, ctx);
+    }
+
+    /**
+     * Delete the node with the given path. The call will succeed if such a node
+     * exists, and the given version matches the node's version (if the given
+     * version is -1, it matches any node's versions).
+     * <p>
+     * A KeeperException with error code KeeperException.NoNode will be thrown
+     * if the nodes does not exist.
+     * <p>
+     * A KeeperException with error code KeeperException.BadVersion will be
+     * thrown if the given version does not match the node's version.
+     * <p>
+     * A KeeperException with error code KeeperException.NotEmpty will be thrown
+     * if the node has children.
+     * <p>
+     * This operation, if successful, will trigger all the watches on the node
+     * of the given path left by exists API calls, and the watches on the parent
+     * node left by getChildren API calls.
+     *
+     * @param path
+     *                the path of the node to be deleted.
+     * @param version
+     *                the expected node version.
+     * @throws InterruptedException IF the server transaction is interrupted
+     * @throws KeeperException If the server signals an error with a non-zero return code.
+     */
+    public void delete(String path, int version) throws
+            InterruptedException, KeeperException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.delete);
+        DeleteRequest request = new DeleteRequest();
+        request.setPath(path);
+        request.setVersion(version);
+        ReplyHeader r = cnxn.submitRequest(h, request, null);
+        if (r.getErr() != 0) {
+            throw KeeperException.create(r.getErr());
+        }
+    }
+
+    /**
+     * The Asynchronous version of delete. The request doesn't actually until
+     * the asynchronous callback is called.
+     *
+     * @see #delete(String, int)
+     */
+    public void delete(String path, int version, VoidCallback cb, Object ctx) {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.delete);
+        DeleteRequest request = new DeleteRequest();
+        request.setPath(path);
+        request.setVersion(version);
+        cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, path, ctx);
+    }
+
+    /**
+     * Return the stat of the node of the given path. Return null if no such a
+     * node exists.
+     * <p>
+     * If the watch is true and the call is successful (no exception is thrown),
+     * a watch will be left on the node with the given path. The watch will be
+     * triggered by a successful operation that creates/delete the node or sets
+     * the data on the node.
+     *
+     * @param path
+     *                the node path
+     * @param watch
+     *                whether need to watch this node
+     * @return the stat of the node of the given path; return null if no such a
+     *         node exists.
+     * @throws KeeperException If the server signals an error
+     * @throws InterruptedException If the server transaction is interrupted.
+     */
+    public Stat exists(String path, boolean watch) throws KeeperException,
+            InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.exists);
+        ExistsRequest request = new ExistsRequest();
+        request.setPath(path);
+        request.setWatch(watch);
+        SetDataResponse response = new SetDataResponse();
+        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        if (r.getErr() != 0) {
+            if (r.getErr() == KeeperException.Code.NoNode) {
+                return null;
+            }
+            throw KeeperException.create(r.getErr());
+        }
+        return response.getStat().getCzxid() == -1 ? null : response.getStat();
+    }
+
+    /**
+     * The Asynchronous version of exists. The request doesn't actually until
+     * the asynchronous callback is called.
+     *
+     * @see #exists(String, boolean)
+     */
+    public void exists(String path, boolean watch, StatCallback cb, Object ctx) {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.exists);
+        ExistsRequest request = new ExistsRequest();
+        request.setPath(path);
+        request.setWatch(watch);
+        SetDataResponse response = new SetDataResponse();
+        cnxn
+                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
+                        ctx);
+    }
+
+    /**
+     * Return the data and the stat of the node of the given path.
+     * <p>
+     * If the watch is true and the call is successfull (no exception is
+     * thrown), a watch will be left on the node with the given path. The watch
+     * will be triggered by a sucessful operation that sets data on the node, or
+     * deletes the node.
+     * <p>
+     * A KeeperException with error code KeeperException.NoNode will be thrown
+     * if no node with the given path exists.
+     *
+     * @param path
+     *                the given path
+     * @param watch
+     *                whether need to watch this node
+     * @param stat
+     *                teh stat of the node
+     * @return the data of the node
+     * @throws KeeperException If the server signals an error with a non-zero error code
+     * @throws InterruptedException If the server transaction is interrupted.
+     */
+    public byte[] getData(String path, boolean watch, Stat stat)
+            throws KeeperException, InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.getData);
+        GetDataRequest request = new GetDataRequest();
+        request.setPath(path);
+        request.setWatch(watch);
+        GetDataResponse response = new GetDataResponse();
+        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        if (r.getErr() != 0) {
+            throw KeeperException.create(r.getErr());
+        }
+        if (stat != null) {
+            DataTree.copyStat(response.getStat(), stat);
+        }
+        return response.getData();
+    }
+
+    /**
+     * The Asynchronous version of getData. The request doesn't actually until
+     * the asynchronous callback is called.
+     *
+     * @see #getData(String, boolean, Stat)
+     */
+
+    public void getData(String path, boolean watch, DataCallback cb, Object ctx) {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.getData);
+        GetDataRequest request = new GetDataRequest();
+        request.setPath(path);
+        request.setWatch(watch);
+        GetDataResponse response = new GetDataResponse();
+        cnxn
+                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
+                        ctx);
+    }
+
+    /**
+     * Set the data for the node of the given path if such a node exists and the
+     * given version matches the version of the node (if the given version is
+     * -1, it matches any node's versions). Return the stat of the node.
+     * <p>
+     * This operation, if successful, will trigger all the watches on the node
+     * of the given path left by getData calls.
+     * <p>
+     * A KeeperException with error code KeeperException.NoNode will be thrown
+     * if no node with the given path exists.
+     *
+     * A KeeperException with error code KeeperException.BadVersion will be
+     * thrown if the given version does not match the node's version.
+     *
+     * @param path
+     *                the path of the node
+     * @param data
+     *                the data to set
+     * @param version
+     *                the expected matching version
+     * @return the state of the node
+     * @throws InterruptedException If the server transaction is interrupted.
+     * @throws KeeperException If the server signals an error with a non-zero error code.
+     */
+    public Stat setData(String path, byte data[], int version)
+            throws KeeperException, InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.setData);
+        SetDataRequest request = new SetDataRequest();
+        request.setPath(path);
+        request.setData(data);
+        request.setVersion(version);
+        SetDataResponse response = new SetDataResponse();
+        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        if (r.getErr() != 0) {
+            throw KeeperException.create(r.getErr());
+        }
+        return response.getStat();
+    }
+
+    /**
+     * The Asynchronous version of setData. The request doesn't actually until
+     * the asynchronous callback is called.
+     *
+     * @see #setData(String, byte[], int)
+     */
+    public void setData(String path, byte data[], int version, StatCallback cb,
+            Object ctx) {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.setData);
+        SetDataRequest request = new SetDataRequest();
+        request.setPath(path);
+        request.setData(data);
+        request.setVersion(version);
+        SetDataResponse response = new SetDataResponse();
+        cnxn
+                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
+                        ctx);
+    }
+
+    /**
+     *
+     * Return the ACL and stat of the node of the given path.
+     * <p>
+     * A KeeperException with error code KeeperException.NoNode will be thrown
+     * if no node with the given path exists.
+     *
+     * @param path
+     *                the given path for the node
+     * @param stat
+     *                the stat of the node will be copied to this parameter.
+     * @return the ACL array of the given node.
+     * @throws InterruptedException If the server transaction is interrupted.
+     * @throws KeeperException If the server signals an error with a non-zero error code.
+     */
+    public ArrayList<ACL> getACL(String path, Stat stat)
+            throws KeeperException, InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.getACL);
+        GetACLRequest request = new GetACLRequest();
+        request.setPath(path);
+        GetACLResponse response = new GetACLResponse();
+        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        if (r.getErr() != 0) {
+            throw KeeperException.create(r.getErr());
+        }
+        DataTree.copyStat(response.getStat(), stat);
+        return response.getAcl();
+    }
+
+    /**
+     * The Asynchronous version of getACL. The request doesn't actually until
+     * the asynchronous callback is called.
+     *
+     * @see #getACL(String, Stat)
+     */
+    public void getACL(String path, Stat stat, ACLCallback cb, Object ctx) {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.getACL);
+        GetACLRequest request = new GetACLRequest();
+        request.setPath(path);
+        GetACLResponse response = new GetACLResponse();
+        cnxn
+                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
+                        ctx);
+    }
+
+    /**
+     * Set the ACL for the node of the given path if such a node exists and the
+     * given version matches the version of the node. Return the stat of the
+     * node.
+     * <p>
+     * A KeeperException with error code KeeperException.NoNode will be thrown
+     * if no node with the given path exists.
+     * <p>
+     * A KeeperException with error code KeeperException.BadVersion will be
+     * thrown if the given version does not match the node's version.
+     *
+     * @param path
+     * @param acl
+     * @param version
+     * @return the stat of the node.
+     * @throws InterruptedException If the server transaction is interrupted.
+     * @throws KeeperException If the server signals an error with a non-zero error code.
+     * @throws com.yahoo.zookeeper.KeeperException.InvalidACLException If the acl is invalide.
+     */
+    public Stat setACL(String path, ArrayList<ACL> acl, int version)
+            throws KeeperException, InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.setACL);
+        SetACLRequest request = new SetACLRequest();
+        request.setPath(path);
+        if (acl != null && acl.size() == 0) {
+            throw new KeeperException.InvalidACLException();
+        }
+        request.setAcl(acl);
+        request.setVersion(version);
+        SetACLResponse response = new SetACLResponse();
+        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        if (r.getErr() != 0) {
+            throw KeeperException.create(r.getErr());
+        }
+        return response.getStat();
+    }
+
+    /**
+     * The Asynchronous version of setACL. The request doesn't actually until
+     * the asynchronous callback is called.
+     *
+     * @see #setACL(String, ArrayList, int)
+     */
+    public void setACL(String path, ArrayList<ACL> acl, int version,
+            StatCallback cb, Object ctx) {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.setACL);
+        SetACLRequest request = new SetACLRequest();
+        request.setPath(path);
+        request.setAcl(acl);
+        request.setVersion(version);
+        SetACLResponse response = new SetACLResponse();
+        cnxn
+                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
+                        ctx);
+    }
+
+    /**
+     * Return the list of the children of the node of the given path.
+     * <p>
+     * If the watch is true and the call is successful (no exception is thrown),
+     * a watch will be left on the node with the given path. The watch willbe
+     * triggered by a sucessful operation that deletes the node of the given
+     * path or creates/delete a child under the node.
+     * <p>
+     * A KeeperException with error code KeeperException.NoNode will be thrown
+     * if no node with the given path exists.
+     *
+     * @param path
+     * @param watch
+     * @return an array of children of the node with the given path
+     * @throws InterruptedException If the server transaction is interrupted.
+     * @throws KeeperException If the server signals an error with a non-zero error code.
+     */
+    public ArrayList<String> getChildren(String path, boolean watch)
+            throws KeeperException, InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.getChildren);
+        GetChildrenRequest request = new GetChildrenRequest();
+        request.setPath(path);
+        request.setWatch(watch);
+        GetChildrenResponse response = new GetChildrenResponse();
+        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        if (r.getErr() != 0) {
+            throw KeeperException.create(r.getErr());
+        }
+        return response.getChildren();
+    }
+
+    /**
+     * The Asynchronous version of getChildren. The request doesn't actually
+     * until the asynchronous callback is called.
+     *
+     * @see #getChildren(String, boolean)
+     */
+    public void getChildren(String path, boolean watch, ChildrenCallback cb,
+            Object ctx) {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.getChildren);
+        GetChildrenRequest request = new GetChildrenRequest();
+        request.setPath(path);
+        request.setWatch(watch);
+        GetChildrenResponse response = new GetChildrenResponse();
+        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path,
+                        ctx);
+    }
+
+    /**
+     * Asynchronous sync. Flushes channel between process and leader.
+     */
+    public void sync(String path, VoidCallback cb, Object ctx){
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.sync);
+        SyncRequest request = new SyncRequest();
+        SyncResponse response = new SyncResponse();
+        request.setPath(path);
+        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path, ctx);
+    }
+
+    public States getState() {
+        return state;
+    }
+
+    // Everything below this line is for testing!
+
+    static void usage() {
+        System.err.println("ZooKeeper host:port cmd args");
+        System.err.println("\tcreate path data acl");
+        System.err.println("\tdelete path [version]");
+        System.err.println("\tset path data [version]");
+        System.err.println("\tget path [watch]");
+        System.err.println("\tls path [watch]");
+        System.err.println("\tgetAcl path");
+        System.err.println("\tsetAcl path acl");
+        System.err.println("\tstat path [watch]");
+        System.err.println("\tsync path");
+    }
+
+    static private class MyWatcher implements Watcher {
+        public void process(WatcherEvent event) {
+            System.err.println(event.getPath() + ": " + event.getState() + "-"
+                    + event.getType());
+        }
+    }
+
+    static private int getPermFromString(String permString) {
+        int perm = 0;
+        for (int i = 0; i < permString.length(); i++) {
+            switch (permString.charAt(i)) {
+            case 'r':
+                perm |= ZooDefs.Perms.READ;
+                break;
+            case 'w':
+                perm |= ZooDefs.Perms.WRITE;
+                break;
+            case 'c':
+                perm |= ZooDefs.Perms.CREATE;
+                break;
+            case 'd':
+                perm |= ZooDefs.Perms.DELETE;
+                break;
+            case 'a':
+                perm |= ZooDefs.Perms.ADMIN;
+                break;
+            default:
+                System.err
+                        .println("Unknown perm type: " + permString.charAt(i));
+            }
+        }
+        return perm;
+    }
+
+    private static void printStat(Stat stat) {
+        System.err.println("ctime = " + new Date(stat.getCtime()).toString());
+        System.err.println("ctime = " + new Date(stat.getMtime()).toString());
+        System.err.println("cversion = " + stat.getCversion());
+        System.err.println("cZxid = " + stat.getCzxid());
+        System.err.println("mZxid = " + stat.getMzxid());
+        System.err.println("dataVersion = " + stat.getVersion());
+        System.err.println("aclVersion = " + stat.getAversion());
+    }
+
+    public static void main(String args[]) throws NumberFormatException,
+            KeeperException, IOException, InterruptedException {
+        if (args.length == 1) {
+            ZooKeeper zooKeeper = new ZooKeeper(args[0], 5000, new MyWatcher());
+            BufferedReader br = new BufferedReader(new InputStreamReader(
+                    System.in));
+            String line;
+            while ((line = br.readLine()) != null) {
+                line = "ignore " + line;
+                args = line.split(" ");
+                processCmd(args, zooKeeper);
+            }
+        } else if (args.length < 3) {
+            usage();
+        }
+
+        ZooKeeper zooKeeper = new ZooKeeper(args[0], 5000, new MyWatcher());
+        boolean watch = processCmd(args, zooKeeper);
+        if (!watch) {
+            System.exit(0);
+        }
+    }
+
+    private static DataCallback dataCallback = new DataCallback() {
+
+        public void processResult(int rc, String path, Object ctx, byte[] data,
+                Stat stat) {
+            System.out.println("rc = " + rc + " path = " + path + " data = "
+                    + (data == null ? "null" : new String(data)) + " stat = ");
+            printStat(stat);
+        }
+
+    };
+
+    private static boolean processCmd(String[] args, ZooKeeper zooKeeper)
+            throws KeeperException, IOException, InterruptedException {
+        Stat stat = new Stat();
+        if (args.length < 2) {
+            return false;
+        }
+        if (args.length < 3) {
+            usage();
+            return false;
+        }
+        String cmd = args[1];
+        boolean watch = args.length > 3;
+        String path = args[2];
+        ArrayList<ACL> acl = Ids.OPEN_ACL_UNSAFE;
+        System.out.println("Processing " + cmd);
+        if (cmd.equals("create") && args.length >= 4) {
+            if (args.length == 5) {
+                acl = parseACLs(args[4]);
+            }
+            String newPath = zooKeeper.create(path, args[3].getBytes(), acl, 0);
+            System.err.println("Created " + newPath);
+        } else if (cmd.equals("delete") && args.length >= 3) {
+            zooKeeper.delete(path, watch ? Integer.parseInt(args[3]) : -1);
+        } else if (cmd.equals("set") && args.length >= 4) {
+            stat = zooKeeper.setData(path, args[3].getBytes(),
+                    args.length > 4 ? Integer.parseInt(args[4]) : -1);
+            printStat(stat);
+        } else if (cmd.equals("aget") && args.length >= 3) {
+            zooKeeper.getData(path, watch, dataCallback, path);
+        } else if (cmd.equals("get") && args.length >= 3) {
+            byte data[] = zooKeeper.getData(path, watch, stat);
+            System.out.println(new String(data));
+            printStat(stat);
+        } else if (cmd.equals("ls") && args.length >= 3) {
+            ArrayList<String> children = zooKeeper.getChildren(path, watch);
+            System.out.println(children);
+        } else if (cmd.equals("getAcl") && args.length >= 2) {
+            acl = zooKeeper.getACL(path, stat);
+            for (ACL a : acl) {
+                System.out.println(a.getId() + ": "
+                        + getPermString(a.getPerms()));
+            }
+        } else if (cmd.equals("setAcl") && args.length >= 4) {
+
+            stat = zooKeeper.setACL(path, parseACLs(args[3]),
+                    args.length > 4 ? Integer.parseInt(args[4]) : -1);
+            printStat(stat);
+        } else if (cmd.equals("stat") && args.length >= 3) {
+            stat = zooKeeper.exists(path, watch);
+            printStat(stat);
+        } else {
+            usage();
+        }
+        return watch;
+    }
+
+    private static String getPermString(int perms) {
+        StringBuffer p = new StringBuffer();
+        if ((perms & ZooDefs.Perms.CREATE) != 0) {
+            p.append('c');
+        }
+        if ((perms & ZooDefs.Perms.DELETE) != 0) {
+            p.append('d');
+        }
+        if ((perms & ZooDefs.Perms.READ) != 0) {
+            p.append('r');
+        }
+        if ((perms & ZooDefs.Perms.WRITE) != 0) {
+            p.append('w');
+        }
+        if ((perms & ZooDefs.Perms.ADMIN) != 0) {
+            p.append('a');
+        }
+        return p.toString();
+    }
+
+    private static ArrayList<ACL> parseACLs(String aclString) {
+        ArrayList<ACL> acl;
+        String acls[] = aclString.split(",");
+        acl = new ArrayList<ACL>();
+        for (String a : acls) {
+            int firstColon = a.indexOf(':');
+            int lastColon = a.indexOf(':');
+            if (firstColon == -1 || lastColon == -1 || firstColon == lastColon) {
+                System.err
+                        .println(a + " does not have the form scheme:id:perm");
+                continue;
+            }
+            ACL newAcl = new ACL();
+            newAcl.setId(new Id(a.substring(0, firstColon), a.substring(
+                    firstColon + 1, lastColon)));
+            newAcl.setPerms(getPermFromString(a.substring(lastColon + 1)));
+            acl.add(newAcl);
+        }
+        return acl;
+    }
+
+    public void disconnect() throws IOException {
+        cnxn.close();
+    }
+}
<EOC>
<SOC>
      * @throws KeeperException
      */
     public String createNode(String path, byte data[], ArrayList<ACL> acl,
-            long ephemeralOwner, long zxid, long time) throws KeeperException {
+            long ephemeralOwner, long zxid, long time) throws KeeperException.NoNodeException, KeeperException.NodeExistsException {
         int lastSlash = path.lastIndexOf('/');
         String parentName = path.substring(0, lastSlash);
         String childName = path.substring(lastSlash + 1);

         stat.setEphemeralOwner(ephemeralOwner);
         DataNode parent = nodes.get(parentName);
         if (parent == null) {
-            throw new KeeperException(KeeperException.Code.NoNode);
+            throw new KeeperException.NoNodeException();
         }
         synchronized (parent) {
             if (parent.children.contains(childName)) {
-                throw new KeeperException(KeeperException.Code.NodeExists);
+                throw new KeeperException.NodeExistsException();
             }
             int cver = parent.stat.getCversion();
             cver++;

         return path;
     }
 
-    public void deleteNode(String path) throws KeeperException {
+    public void deleteNode(String path) throws KeeperException.NoNodeException {
         int lastSlash = path.lastIndexOf('/');
         String parentName = path.substring(0, lastSlash);
         String childName = path.substring(lastSlash + 1);
         DataNode node = nodes.get(path);
         if (node == null) {
-            throw new KeeperException(KeeperException.Code.NoNode);
+            throw new KeeperException.NoNodeException();
         }
         nodes.remove(path);
         DataNode parent = nodes.get(parentName);
         if (parent == null) {
-            throw new KeeperException(KeeperException.Code.NoNode);
+            throw new KeeperException.NoNodeException();
         }
         synchronized (parent) {
             parent.children.remove(childName);

     }
 
     public Stat setData(String path, byte data[], int version, long zxid,
-            long time) throws KeeperException {
+            long time) throws KeeperException.NoNodeException {
         Stat s = new Stat();
         DataNode n = nodes.get(path);
         if (n == null) {
-            throw new KeeperException(KeeperException.Code.NoNode);
+            throw new KeeperException.NoNodeException();
         }
         synchronized (n) {
             n.data = data;

         return s;
     }
 
-    public byte[] getData(String path, Stat stat, Watcher watcher)
-            throws KeeperException {
+    public byte[] getData(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException {
         DataNode n = nodes.get(path);
         if (n == null) {
-            throw new KeeperException(KeeperException.Code.NoNode);
+            throw new KeeperException.NoNodeException();
         }
         synchronized (n) {
             copyStat(n.stat, stat);

         }
     }
 
-    public Stat statNode(String path, Watcher watcher) throws KeeperException {
+    public Stat statNode(String path, Watcher watcher) throws KeeperException.NoNodeException {
         Stat stat = new Stat();
         DataNode n = nodes.get(path);
         if (watcher != null) {
             dataWatches.addWatch(path, watcher);
         }
         if (n == null) {
-            throw new KeeperException(KeeperException.Code.NoNode);
+            throw new KeeperException.NoNodeException();
         }
         synchronized (n) {
             copyStat(n.stat, stat);

         }
     }
 
-    public ArrayList<String> getChildren(String path, Stat stat, Watcher watcher)
-            throws KeeperException {
+    public ArrayList<String> getChildren(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException {
         DataNode n = nodes.get(path);
         if (n == null) {
-            throw new KeeperException(KeeperException.Code.NoNode);
+            throw new KeeperException.NoNodeException();
         }
         synchronized (n) {
             ArrayList<String> children = new ArrayList<String>();

         }
     }
 
-    public Stat setACL(String path, ArrayList<ACL> acl, int version)
-            throws KeeperException {
+    public Stat setACL(String path, ArrayList<ACL> acl, int version) throws KeeperException.NoNodeException {
         Stat stat = new Stat();
         DataNode n = nodes.get(path);
         if (n == null) {
-            throw new KeeperException(KeeperException.Code.NoNode);
+            throw new KeeperException.NoNodeException();
         }
         synchronized (n) {
             n.stat.setAversion(version);

     }
 
     @SuppressWarnings("unchecked")
-    public ArrayList<ACL> getACL(String path, Stat stat) throws KeeperException {
+    public ArrayList<ACL> getACL(String path, Stat stat) throws KeeperException.NoNodeException {
         DataNode n = nodes.get(path);
         if (n == null) {
-            throw new KeeperException(KeeperException.Code.NoNode);
+            throw new KeeperException.NoNodeException();
         }
         synchronized (n) {
             copyStat(n.stat, stat);
<EOC>
<SOC>
-/*
- * Copyright 2008, Yahoo! Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.yahoo.zookeeper.server;
-
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import org.apache.log4j.Logger;
-
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.KeeperException;
-import com.yahoo.zookeeper.ZooDefs;
-import com.yahoo.zookeeper.KeeperException.Code;
-import com.yahoo.zookeeper.ZooDefs.CreateFlags;
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.data.ACL;
-import com.yahoo.zookeeper.data.Id;
-import com.yahoo.zookeeper.data.Stat;
-import com.yahoo.zookeeper.proto.CreateRequest;
-import com.yahoo.zookeeper.proto.DeleteRequest;
-import com.yahoo.zookeeper.proto.SetACLRequest;
-import com.yahoo.zookeeper.proto.SetDataRequest;
-import com.yahoo.zookeeper.server.ZooKeeperServer.ChangeRecord;
-import com.yahoo.zookeeper.server.auth.AuthenticationProvider;
-import com.yahoo.zookeeper.server.auth.ProviderRegistry;
-import com.yahoo.zookeeper.txn.CreateSessionTxn;
-import com.yahoo.zookeeper.txn.CreateTxn;
-import com.yahoo.zookeeper.txn.DeleteTxn;
-import com.yahoo.zookeeper.txn.ErrorTxn;
-import com.yahoo.zookeeper.txn.SetACLTxn;
-import com.yahoo.zookeeper.txn.SetDataTxn;
-import com.yahoo.zookeeper.txn.TxnHeader;
-
-/**
- * This request processor is generally at the start of a RequestProcessor
- * change. It sets up any transactions associated with requests that change the
- * state of the system. It counts on ZooKeeperServer to update
- * outstandingRequests, so that it can take into account transactions that are
- * in the queue to be applied when generating a transaction.
- */
-public class PrepRequestProcessor extends Thread implements RequestProcessor {
-    private static final Logger LOG = Logger.getLogger(PrepRequestProcessor.class);
-
-    static boolean skipACL;
-    static {
-        skipACL = System.getProperty("zookeeper.skipACL", "no").equals("yes");
-    }
-
-    LinkedBlockingQueue<Request> submittedRequests = new LinkedBlockingQueue<Request>();
-
-    RequestProcessor nextProcessor;
-
-    ZooKeeperServer zks;
-
-    public PrepRequestProcessor(ZooKeeperServer zks,
-            RequestProcessor nextProcessor) {
-        super("ProcessThread");
-        this.nextProcessor = nextProcessor;
-        this.zks = zks;
-
-        start();
-    }
-
-    public void run() {
-        try {
-            while (true) {
-                Request request = submittedRequests.take();
-                long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;
-                if (request.type == OpCode.ping) {
-                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;
-                }
-                ZooTrace.logRequest(LOG, traceMask, 'P', request, "");
-                if (Request.requestOfDeath == request) {
-                    break;
-                }
-                pRequest(request);
-            }
-        } catch (InterruptedException e) {
-            LOG.error("FIXMSG",e);
-        }
-        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                "PrepRequestProcessor exited loop!");
-    }
-
-    ChangeRecord getRecordForPath(String path) throws KeeperException {
-        ChangeRecord lastChange = null;
-        synchronized (zks.outstandingChanges) {
-            for (int i = 0; i < zks.outstandingChanges.size(); i++) {
-                ChangeRecord c = zks.outstandingChanges.get(i);
-                if (c.path.equals(path)) {
-                    lastChange = c;
-                }
-            }
-            if (lastChange == null) {
-                DataNode n = zks.dataTree.getNode(path);
-                if (n != null) {
-                    lastChange = new ChangeRecord(-1, path, n.stat, n.children
-                            .size(), n.acl);
-                }
-            }
-        }
-        if (lastChange == null || lastChange.stat == null) {
-            throw new KeeperException(KeeperException.Code.NoNode);
-        }
-        return lastChange;
-    }
-
-    void addChangeRecord(ChangeRecord c) {
-        synchronized (zks.outstandingChanges) {
-            zks.outstandingChanges.add(c);
-        }
-    }
-
-    static void checkACL(ZooKeeperServer zks, ArrayList<ACL> acl, int perm,
-            ArrayList<Id> ids) throws KeeperException {
-        if (skipACL) {
-            return;
-        }
-        if (acl == null || acl.size() == 0) {
-            return;
-        }
-        for (ACL a : acl) {
-            Id id = a.getId();
-            if ((a.getPerms() & perm) != 0) {
-                if (id.getScheme().equals("world")
-                        && id.getId().equals("anyone")) {
-                    return;
-                }
-                AuthenticationProvider ap = ProviderRegistry.getProvider(id
-                        .getScheme());
-                if (ap != null) {
-                    for (Id authId : ids) {
-                        if (authId.getScheme().equals("super")) {
-                            return;
-                        }
-                        if (authId.getScheme().equals(id.getScheme())
-                                && ap.matches(authId.getId(), id.getId())) {
-                            return;
-                        }
-                    }
-                }
-            }
-        }
-        throw new KeeperException(KeeperException.Code.NoAuth);
-    }
-
-    /**
-     * This method will be called inside the ProcessRequestThread, which is a
-     * singleton, so there will be a single thread calling this code.
-     *
-     * @param request
-     */
-    @SuppressWarnings("unchecked")
-    protected void pRequest(Request request) {
-        // LOG.info("Prep>>> cxid = " + request.cxid + " type = " +
-        // request.type + " id = " + request.sessionId);
-        TxnHeader txnHeader = null;
-        Record txn = null;
-        try {
-            switch (request.type) {
-            case OpCode.create:
-                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
-                        .getNextZxid(), zks.getTime(), OpCode.create);
-                zks.sessionTracker.checkSession(request.sessionId);
-                CreateRequest createRequest = new CreateRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request,
-                        createRequest);
-                String path = createRequest.getPath();
-                int lastSlash = path.lastIndexOf('/');
-                if (lastSlash == -1 || path.indexOf('\0') != -1) {
-                    throw new KeeperException(Code.BadArguments);
-                }
-                if (!fixupACL(request.authInfo, createRequest.getAcl())) {
-                    throw new KeeperException(Code.InvalidACL);
-                }
-                String parentPath = path.substring(0, lastSlash);
-                ChangeRecord parentRecord = getRecordForPath(parentPath);
-
-                checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE,
-                        request.authInfo);
-                int parentCVersion = parentRecord.stat.getCversion();
-                if ((createRequest.getFlags() & CreateFlags.SEQUENCE) != 0) {
-                    path = path + parentCVersion;
-                }
-                try {
-                    if (getRecordForPath(path) != null) {
-                        throw new KeeperException(Code.NodeExists);
-                    }
-                } catch (KeeperException e) {
-                    if (e.getCode() != Code.NoNode) {
-                        throw e;
-                    }
-                }
-                boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;
-                if (ephemeralParent) {
-                    throw new KeeperException(Code.NoChildrenForEphemerals);
-                }
-                txn = new CreateTxn(path, createRequest.getData(),
-                        createRequest.getAcl(),
-                        (createRequest.getFlags() & CreateFlags.EPHEMERAL) != 0);
-                Stat s = new Stat();
-                if ((createRequest.getFlags() & CreateFlags.EPHEMERAL) != 0) {
-                    s.setEphemeralOwner(request.sessionId);
-                }
-                parentRecord = parentRecord.duplicate(txnHeader.getZxid());
-                parentRecord.childCount++;
-                parentRecord.stat
-                        .setCversion(parentRecord.stat.getCversion() + 1);
-                addChangeRecord(parentRecord);
-                addChangeRecord(new ChangeRecord(txnHeader.getZxid(), path, s,
-                        0, createRequest.getAcl()));
-
-                break;
-            case OpCode.delete:
-                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
-                        .getNextZxid(), zks.getTime(), OpCode.delete);
-                zks.sessionTracker.checkSession(request.sessionId);
-                DeleteRequest deleteRequest = new DeleteRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request,
-                        deleteRequest);
-                path = deleteRequest.getPath();
-                lastSlash = path.lastIndexOf('/');
-                if (lastSlash == -1 || path.indexOf('\0') != -1
-                        || path.equals("/")) {
-                    throw new KeeperException(Code.BadArguments);
-                }
-                parentPath = path.substring(0, lastSlash);
-                parentRecord = getRecordForPath(parentPath);
-                ChangeRecord nodeRecord = getRecordForPath(path);
-                checkACL(zks, parentRecord.acl, ZooDefs.Perms.DELETE,
-                        request.authInfo);
-                int version = deleteRequest.getVersion();
-                if (version != -1 && nodeRecord.stat.getVersion() != version) {
-                    throw new KeeperException(Code.BadVersion);
-                }
-                if (nodeRecord.childCount > 0) {
-                    throw new KeeperException(Code.NotEmpty);
-                }
-                txn = new DeleteTxn(path);
-                parentRecord = parentRecord.duplicate(txnHeader.getZxid());
-                parentRecord.childCount--;
-                parentRecord.stat
-                        .setCversion(parentRecord.stat.getCversion() + 1);
-                addChangeRecord(parentRecord);
-                addChangeRecord(new ChangeRecord(txnHeader.getZxid(), path,
-                        null, -1, null));
-                break;
-            case OpCode.setData:
-                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
-                        .getNextZxid(), zks.getTime(), OpCode.setData);
-                zks.sessionTracker.checkSession(request.sessionId);
-                SetDataRequest setDataRequest = new SetDataRequest();
-                ZooKeeperServer.byteBuffer2Record(request.request,
-                        setDataRequest);
-                path = setDataRequest.getPath();
-                nodeRecord = getRecordForPath(path);
-                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE,
-                        request.authInfo);
-                version = setDataRequest.getVersion();
-                int currentVersion = nodeRecord.stat.getVersion();
-                if (version != -1 && version != currentVersion) {
-                    throw new KeeperException(Code.BadVersion);
-                }
-                version = currentVersion + 1;
-                txn = new SetDataTxn(path, setDataRequest.getData(), version);
-                nodeRecord = nodeRecord.duplicate(txnHeader.getZxid());
-                nodeRecord.stat.setVersion(version);
-                addChangeRecord(nodeRecord);
-                break;
-            case OpCode.setACL:
-                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
-                        .getNextZxid(), zks.getTime(), OpCode.setACL);
-                zks.sessionTracker.checkSession(request.sessionId);
-                SetACLRequest setAclRequest = new SetACLRequest();
-                if (!fixupACL(request.authInfo, setAclRequest.getAcl())) {
-                    throw new KeeperException(Code.InvalidACL);
-                }
-                ZooKeeperServer.byteBuffer2Record(request.request,
-                        setAclRequest);
-                path = setAclRequest.getPath();
-                nodeRecord = getRecordForPath(path);
-                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN,
-                        request.authInfo);
-                version = setAclRequest.getVersion();
-                currentVersion = nodeRecord.stat.getAversion();
-                if (version != -1 && version != currentVersion) {
-                    throw new KeeperException(Code.BadVersion);
-                }
-                version = currentVersion + 1;
-                txn = new SetACLTxn(path, setAclRequest.getAcl(), version);
-                nodeRecord = nodeRecord.duplicate(txnHeader.getZxid());
-                nodeRecord.stat.setAversion(version);
-                addChangeRecord(nodeRecord);
-                break;
-            case OpCode.createSession:
-                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
-                        .getNextZxid(), zks.getTime(), OpCode.createSession);
-                request.request.rewind();
-                int to = request.request.getInt();
-                txn = new CreateSessionTxn(to);
-                request.request.rewind();
-                zks.sessionTracker.addSession(request.sessionId, to);
-                break;
-            case OpCode.closeSession:
-                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
-                        .getNextZxid(), zks.getTime(), OpCode.closeSession);
-                HashSet<String> es = zks.dataTree
-                        .getEphemerals(request.sessionId);
-                synchronized (zks.outstandingChanges) {
-                    for (ChangeRecord c : zks.outstandingChanges) {
-                        if (c.stat == null) {
-                            // Doing a delete
-                            es.remove(c.path);
-                        } else if (c.stat.getEphemeralOwner() == request.sessionId) {
-                            es.add(c.path);
-                        }
-                    }
-                    for (String path2Delete : es) {
-                        addChangeRecord(new ChangeRecord(txnHeader.getZxid(),
-                                path2Delete, null, 0, null));
-                    }
-                }
-                LOG.info("Processed session termination request for id: "
-                        + Long.toHexString(request.sessionId));
-                break;
-            case OpCode.sync:
-            case OpCode.exists:
-            case OpCode.getData:
-            case OpCode.getACL:
-            case OpCode.getChildren:
-            case OpCode.ping:
-                break;
-            }
-        } catch (KeeperException e) {
-            if (txnHeader != null) {
-                txnHeader.setType(OpCode.error);
-                txn = new ErrorTxn(e.getCode());
-            }
-        } catch (Exception e) {
-            LOG.error("*********************************" + request);
-            StringBuffer sb = new StringBuffer();
-            ByteBuffer bb = request.request;
-            if(bb!=null){
-                bb.rewind();
-                while (bb.hasRemaining()) {
-                    sb.append(Integer.toHexString(bb.get() & 0xff));
-                }
-            }else
-                sb.append("request buffer is null");
-            LOG.error(sb.toString());
-            LOG.error("Unexpected exception", e);
-            if (txnHeader != null) {
-                txnHeader.setType(OpCode.error);
-                txn = new ErrorTxn(Code.MarshallingError);
-            }
-        }
-        request.hdr = txnHeader;
-        request.txn = txn;
-        if (request.hdr != null) {
-            request.zxid = request.hdr.getZxid();
-        }
-        nextProcessor.processRequest(request);
-    }
-
-    /**
-     *
-     * @param authInfo list of ACL IDs associated with the client connection
-     * @param acl list of ACLs being assigned to the node (create or setACL operation)
-     * @return
-     */
-    private boolean fixupACL(ArrayList<Id> authInfo, ArrayList<ACL> acl) {
-        if (skipACL) {
-            return true;
-        }
-        if (acl == null || acl.size() == 0) {
-            return false;
-        }
-        Iterator<ACL> it = acl.iterator();
-        LinkedList<ACL> toAdd = null;
-        while (it.hasNext()) {
-            ACL a = it.next();
-            Id id = a.getId();
-            if (id.getScheme().equals("world") && id.getId().equals("anyone")) {
-            } else if (id.getScheme().equals("auth")) {
-                it.remove();
-                if (toAdd == null) {
-                    toAdd = new LinkedList<ACL>();
-                }
-                for (Id cid : authInfo) {
-                    AuthenticationProvider ap = ProviderRegistry.getProvider(cid.getScheme());
-                    if (ap == null) {
-                        LOG.error("Missing AuthenticationProvider for "
-                                + cid.getScheme());
-                    } else if (ap.isAuthenticated()) {
-                        toAdd.add(new ACL(a.getPerms(), cid));
-                    }
-                }
-            } else {
-                AuthenticationProvider ap = ProviderRegistry.getProvider(id
-                        .getScheme());
-                if (ap == null) {
-                    return false;
-                }
-                if (!ap.isValid(id.getId())) {
-                    return false;
-                }
-            }
-        }
-        if (toAdd != null) {
-            for (ACL a : toAdd) {
-                acl.add(a);
-            }
-        }
-        return true;
-    }
-
-    public void processRequest(Request request) {
-        // request.addRQRec(">prep="+zks.outstandingChanges.size());
-        submittedRequests.add(request);
-    }
-
-    public void shutdown() {
-        submittedRequests.clear();
-        submittedRequests.add(Request.requestOfDeath);
-        nextProcessor.shutdown();
-    }
-}
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.yahoo.zookeeper.server;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import org.apache.log4j.Logger;
+
+import com.yahoo.jute.Record;
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.ZooDefs;
+import com.yahoo.zookeeper.KeeperException.Code;
+import com.yahoo.zookeeper.ZooDefs.CreateFlags;
+import com.yahoo.zookeeper.ZooDefs.OpCode;
+import com.yahoo.zookeeper.data.ACL;
+import com.yahoo.zookeeper.data.Id;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.CreateRequest;
+import com.yahoo.zookeeper.proto.DeleteRequest;
+import com.yahoo.zookeeper.proto.SetACLRequest;
+import com.yahoo.zookeeper.proto.SetDataRequest;
+import com.yahoo.zookeeper.server.ZooKeeperServer.ChangeRecord;
+import com.yahoo.zookeeper.server.auth.AuthenticationProvider;
+import com.yahoo.zookeeper.server.auth.ProviderRegistry;
+import com.yahoo.zookeeper.txn.CreateSessionTxn;
+import com.yahoo.zookeeper.txn.CreateTxn;
+import com.yahoo.zookeeper.txn.DeleteTxn;
+import com.yahoo.zookeeper.txn.ErrorTxn;
+import com.yahoo.zookeeper.txn.SetACLTxn;
+import com.yahoo.zookeeper.txn.SetDataTxn;
+import com.yahoo.zookeeper.txn.TxnHeader;
+
+/**
+ * This request processor is generally at the start of a RequestProcessor
+ * change. It sets up any transactions associated with requests that change the
+ * state of the system. It counts on ZooKeeperServer to update
+ * outstandingRequests, so that it can take into account transactions that are
+ * in the queue to be applied when generating a transaction.
+ */
+public class PrepRequestProcessor extends Thread implements RequestProcessor {
+    private static final Logger LOG = Logger.getLogger(PrepRequestProcessor.class);
+
+    static boolean skipACL;
+    static {
+        skipACL = System.getProperty("zookeeper.skipACL", "no").equals("yes");
+    }
+
+    LinkedBlockingQueue<Request> submittedRequests = new LinkedBlockingQueue<Request>();
+
+    RequestProcessor nextProcessor;
+
+    ZooKeeperServer zks;
+
+    public PrepRequestProcessor(ZooKeeperServer zks,
+            RequestProcessor nextProcessor) {
+        super("ProcessThread");
+        this.nextProcessor = nextProcessor;
+        this.zks = zks;
+
+        start();
+    }
+
+    public void run() {
+        try {
+            while (true) {
+                Request request = submittedRequests.take();
+                long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;
+                if (request.type == OpCode.ping) {
+                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;
+                }
+                ZooTrace.logRequest(LOG, traceMask, 'P', request, "");
+                if (Request.requestOfDeath == request) {
+                    break;
+                }
+                pRequest(request);
+            }
+        } catch (InterruptedException e) {
+            LOG.error("FIXMSG",e);
+        }
+        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
+                "PrepRequestProcessor exited loop!");
+    }
+
+    ChangeRecord getRecordForPath(String path) throws KeeperException.NoNodeException {
+        ChangeRecord lastChange = null;
+        synchronized (zks.outstandingChanges) {
+            for (int i = 0; i < zks.outstandingChanges.size(); i++) {
+                ChangeRecord c = zks.outstandingChanges.get(i);
+                if (c.path.equals(path)) {
+                    lastChange = c;
+                }
+            }
+            if (lastChange == null) {
+                DataNode n = zks.dataTree.getNode(path);
+                if (n != null) {
+                    lastChange = new ChangeRecord(-1, path, n.stat, n.children
+                            .size(), n.acl);
+                }
+            }
+        }
+        if (lastChange == null || lastChange.stat == null) {
+            throw new KeeperException.NoNodeException();
+        }
+        return lastChange;
+    }
+
+    void addChangeRecord(ChangeRecord c) {
+        synchronized (zks.outstandingChanges) {
+            zks.outstandingChanges.add(c);
+        }
+    }
+
+    static void checkACL(ZooKeeperServer zks, ArrayList<ACL> acl, int perm,
+            ArrayList<Id> ids) throws KeeperException.NoAuthException {
+        if (skipACL) {
+            return;
+        }
+        if (acl == null || acl.size() == 0) {
+            return;
+        }
+        for (ACL a : acl) {
+            Id id = a.getId();
+            if ((a.getPerms() & perm) != 0) {
+                if (id.getScheme().equals("world")
+                        && id.getId().equals("anyone")) {
+                    return;
+                }
+                AuthenticationProvider ap = ProviderRegistry.getProvider(id
+                        .getScheme());
+                if (ap != null) {
+                    for (Id authId : ids) {
+                        if (authId.getScheme().equals("super")) {
+                            return;
+                        }
+                        if (authId.getScheme().equals(id.getScheme())
+                                && ap.matches(authId.getId(), id.getId())) {
+                            return;
+                        }
+                    }
+                }
+            }
+        }
+        throw new KeeperException.NoAuthException();
+    }
+
+    /**
+     * This method will be called inside the ProcessRequestThread, which is a
+     * singleton, so there will be a single thread calling this code.
+     *
+     * @param request
+     */
+    @SuppressWarnings("unchecked")
+    protected void pRequest(Request request) {
+        // LOG.info("Prep>>> cxid = " + request.cxid + " type = " +
+        // request.type + " id = " + request.sessionId);
+        TxnHeader txnHeader = null;
+        Record txn = null;
+        try {
+            switch (request.type) {
+            case OpCode.create:
+                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
+                        .getNextZxid(), zks.getTime(), OpCode.create);
+                zks.sessionTracker.checkSession(request.sessionId);
+                CreateRequest createRequest = new CreateRequest();
+                ZooKeeperServer.byteBuffer2Record(request.request,
+                        createRequest);
+                String path = createRequest.getPath();
+                int lastSlash = path.lastIndexOf('/');
+                if (lastSlash == -1 || path.indexOf('\0') != -1) {
+                    throw new KeeperException.BadArgumentsException();
+                }
+                if (!fixupACL(request.authInfo, createRequest.getAcl())) {
+                    throw new KeeperException.InvalidACLException();
+                }
+                String parentPath = path.substring(0, lastSlash);
+                ChangeRecord parentRecord = getRecordForPath(parentPath);
+
+                checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE,
+                        request.authInfo);
+                int parentCVersion = parentRecord.stat.getCversion();
+                if ((createRequest.getFlags() & CreateFlags.SEQUENCE) != 0) {
+                    path = path + parentCVersion;
+                }
+                try {
+                    if (getRecordForPath(path) != null) {
+                        throw new KeeperException.NodeExistsException();
+                    }
+                } catch (KeeperException.NoNodeException e) {
+                    // ignore this one
+                }
+                boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;
+                if (ephemeralParent) {
+                    throw new KeeperException.NoChildrenForEphemeralsException();
+                }
+                txn = new CreateTxn(path, createRequest.getData(),
+                        createRequest.getAcl(),
+                        (createRequest.getFlags() & CreateFlags.EPHEMERAL) != 0);
+                Stat s = new Stat();
+                if ((createRequest.getFlags() & CreateFlags.EPHEMERAL) != 0) {
+                    s.setEphemeralOwner(request.sessionId);
+                }
+                parentRecord = parentRecord.duplicate(txnHeader.getZxid());
+                parentRecord.childCount++;
+                parentRecord.stat
+                        .setCversion(parentRecord.stat.getCversion() + 1);
+                addChangeRecord(parentRecord);
+                addChangeRecord(new ChangeRecord(txnHeader.getZxid(), path, s,
+                        0, createRequest.getAcl()));
+
+                break;
+            case OpCode.delete:
+                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
+                        .getNextZxid(), zks.getTime(), OpCode.delete);
+                zks.sessionTracker.checkSession(request.sessionId);
+                DeleteRequest deleteRequest = new DeleteRequest();
+                ZooKeeperServer.byteBuffer2Record(request.request,
+                        deleteRequest);
+                path = deleteRequest.getPath();
+                lastSlash = path.lastIndexOf('/');
+                if (lastSlash == -1 || path.indexOf('\0') != -1
+                        || path.equals("/")) {
+                    throw new KeeperException.BadArgumentsException();
+                }
+                parentPath = path.substring(0, lastSlash);
+                parentRecord = getRecordForPath(parentPath);
+                ChangeRecord nodeRecord = getRecordForPath(path);
+                checkACL(zks, parentRecord.acl, ZooDefs.Perms.DELETE,
+                        request.authInfo);
+                int version = deleteRequest.getVersion();
+                if (version != -1 && nodeRecord.stat.getVersion() != version) {
+                    throw new KeeperException.BadVersionException();
+                }
+                if (nodeRecord.childCount > 0) {
+                    throw new KeeperException.NotEmptyException();
+                }
+                txn = new DeleteTxn(path);
+                parentRecord = parentRecord.duplicate(txnHeader.getZxid());
+                parentRecord.childCount--;
+                parentRecord.stat
+                        .setCversion(parentRecord.stat.getCversion() + 1);
+                addChangeRecord(parentRecord);
+                addChangeRecord(new ChangeRecord(txnHeader.getZxid(), path,
+                        null, -1, null));
+                break;
+            case OpCode.setData:
+                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
+                        .getNextZxid(), zks.getTime(), OpCode.setData);
+                zks.sessionTracker.checkSession(request.sessionId);
+                SetDataRequest setDataRequest = new SetDataRequest();
+                ZooKeeperServer.byteBuffer2Record(request.request,
+                        setDataRequest);
+                path = setDataRequest.getPath();
+                nodeRecord = getRecordForPath(path);
+                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE,
+                        request.authInfo);
+                version = setDataRequest.getVersion();
+                int currentVersion = nodeRecord.stat.getVersion();
+                if (version != -1 && version != currentVersion) {
+                    throw new KeeperException.BadVersionException();
+                }
+                version = currentVersion + 1;
+                txn = new SetDataTxn(path, setDataRequest.getData(), version);
+                nodeRecord = nodeRecord.duplicate(txnHeader.getZxid());
+                nodeRecord.stat.setVersion(version);
+                addChangeRecord(nodeRecord);
+                break;
+            case OpCode.setACL:
+                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
+                        .getNextZxid(), zks.getTime(), OpCode.setACL);
+                zks.sessionTracker.checkSession(request.sessionId);
+                SetACLRequest setAclRequest = new SetACLRequest();
+                if (!fixupACL(request.authInfo, setAclRequest.getAcl())) {
+                    throw new KeeperException.InvalidACLException();
+                }
+                ZooKeeperServer.byteBuffer2Record(request.request,
+                        setAclRequest);
+                path = setAclRequest.getPath();
+                nodeRecord = getRecordForPath(path);
+                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN,
+                        request.authInfo);
+                version = setAclRequest.getVersion();
+                currentVersion = nodeRecord.stat.getAversion();
+                if (version != -1 && version != currentVersion) {
+                    throw new KeeperException.BadVersionException();
+                }
+                version = currentVersion + 1;
+                txn = new SetACLTxn(path, setAclRequest.getAcl(), version);
+                nodeRecord = nodeRecord.duplicate(txnHeader.getZxid());
+                nodeRecord.stat.setAversion(version);
+                addChangeRecord(nodeRecord);
+                break;
+            case OpCode.createSession:
+                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
+                        .getNextZxid(), zks.getTime(), OpCode.createSession);
+                request.request.rewind();
+                int to = request.request.getInt();
+                txn = new CreateSessionTxn(to);
+                request.request.rewind();
+                zks.sessionTracker.addSession(request.sessionId, to);
+                break;
+            case OpCode.closeSession:
+                txnHeader = new TxnHeader(request.sessionId, request.cxid, zks
+                        .getNextZxid(), zks.getTime(), OpCode.closeSession);
+                HashSet<String> es = zks.dataTree
+                        .getEphemerals(request.sessionId);
+                synchronized (zks.outstandingChanges) {
+                    for (ChangeRecord c : zks.outstandingChanges) {
+                        if (c.stat == null) {
+                            // Doing a delete
+                            es.remove(c.path);
+                        } else if (c.stat.getEphemeralOwner() == request.sessionId) {
+                            es.add(c.path);
+                        }
+                    }
+                    for (String path2Delete : es) {
+                        addChangeRecord(new ChangeRecord(txnHeader.getZxid(),
+                                path2Delete, null, 0, null));
+                    }
+                }
+                LOG.info("Processed session termination request for id: "
+                        + Long.toHexString(request.sessionId));
+                break;
+            case OpCode.sync:
+            case OpCode.exists:
+            case OpCode.getData:
+            case OpCode.getACL:
+            case OpCode.getChildren:
+            case OpCode.ping:
+                break;
+            }
+        } catch (KeeperException e) {
+            if (txnHeader != null) {
+                txnHeader.setType(OpCode.error);
+                txn = new ErrorTxn(e.getCode());
+            }
+        } catch (Exception e) {
+            LOG.error("*********************************" + request);
+            StringBuffer sb = new StringBuffer();
+            ByteBuffer bb = request.request;
+            if(bb!=null){
+                bb.rewind();
+                while (bb.hasRemaining()) {
+                    sb.append(Integer.toHexString(bb.get() & 0xff));
+                }
+            }else
+                sb.append("request buffer is null");
+            LOG.error(sb.toString());
+            LOG.error("Unexpected exception", e);
+            if (txnHeader != null) {
+                txnHeader.setType(OpCode.error);
+                txn = new ErrorTxn(Code.MarshallingError);
+            }
+        }
+        request.hdr = txnHeader;
+        request.txn = txn;
+        if (request.hdr != null) {
+            request.zxid = request.hdr.getZxid();
+        }
+        nextProcessor.processRequest(request);
+    }
+
+    /**
+     *
+     * @param authInfo list of ACL IDs associated with the client connection
+     * @param acl list of ACLs being assigned to the node (create or setACL operation)
+     * @return
+     */
+    private boolean fixupACL(ArrayList<Id> authInfo, ArrayList<ACL> acl) {
+        if (skipACL) {
+            return true;
+        }
+        if (acl == null || acl.size() == 0) {
+            return false;
+        }
+        Iterator<ACL> it = acl.iterator();
+        LinkedList<ACL> toAdd = null;
+        while (it.hasNext()) {
+            ACL a = it.next();
+            Id id = a.getId();
+            if (id.getScheme().equals("world") && id.getId().equals("anyone")) {
+            } else if (id.getScheme().equals("auth")) {
+                it.remove();
+                if (toAdd == null) {
+                    toAdd = new LinkedList<ACL>();
+                }
+                for (Id cid : authInfo) {
+                    AuthenticationProvider ap = ProviderRegistry.getProvider(cid.getScheme());
+                    if (ap == null) {
+                        LOG.error("Missing AuthenticationProvider for "
+                                + cid.getScheme());
+                    } else if (ap.isAuthenticated()) {
+                        toAdd.add(new ACL(a.getPerms(), cid));
+                    }
+                }
+            } else {
+                AuthenticationProvider ap = ProviderRegistry.getProvider(id
+                        .getScheme());
+                if (ap == null) {
+                    return false;
+                }
+                if (!ap.isValid(id.getId())) {
+                    return false;
+                }
+            }
+        }
+        if (toAdd != null) {
+            for (ACL a : toAdd) {
+                acl.add(a);
+            }
+        }
+        return true;
+    }
+
+    public void processRequest(Request request) {
+        // request.addRQRec(">prep="+zks.outstandingChanges.size());
+        submittedRequests.add(request);
+    }
+
+    public void shutdown() {
+        submittedRequests.clear();
+        submittedRequests.add(Request.requestOfDeath);
+        nextProcessor.shutdown();
+    }
+}
<EOC>
<SOC>
      */
     void removeSession(long sessionId);
 
-    void checkSession(long sessionId) throws KeeperException;
+    void checkSession(long sessionId) throws KeeperException.SessionExpiredException;
 }
<EOC>
<SOC>
                                  "Shutdown SessionTrackerImpl!");
     }
 
-
+   
     synchronized public long createSession(int sessionTimeout) {
         addSession(nextSessionId, sessionTimeout);
         return nextSessionId++;

         touchSession(id, sessionTimeout);
     }
 
-    public void checkSession(long sessionId) throws KeeperException {
+    public void checkSession(long sessionId) throws KeeperException.SessionExpiredException {
         if (sessionsById.get(sessionId) == null) {
-            throw new KeeperException(KeeperException.Code.SessionExpired);
+            throw new KeeperException.SessionExpiredException();
         }
     }
 }
<EOC>
<SOC>
 import java.util.HashMap;
 import java.util.concurrent.ConcurrentHashMap;
 
-import com.yahoo.zookeeper.KeeperException;
 import com.yahoo.zookeeper.server.SessionTracker;
 import com.yahoo.zookeeper.server.SessionTrackerImpl;
 

         return (nextSessionId++);
     }
 
-    public void checkSession(long sessionId) throws KeeperException {
+    public void checkSession(long sessionId)  {
         // Nothing to do here. Sessions are checked at the Leader
     }
 }
<EOC>
<SOC>
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.List;
+
 import com.yahoo.jute.Index;
 import com.yahoo.jute.InputArchive;
 import com.yahoo.jute.OutputArchive;

     DataNode() {
     }
 
-    DataNode(DataNode parent, byte data[], ArrayList<ACL> acl, Stat stat) {
+    DataNode(DataNode parent, byte data[], List<ACL> acl, Stat stat) {
         this.parent = parent;
         this.data = data;
         this.acl = acl;

 
     byte data[];
 
-    ArrayList<ACL> acl;
+    List<ACL> acl;
 
     public Stat stat;
 
<EOC>
<SOC>
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.List;
 
 import org.apache.log4j.Logger;
 

                 ZooKeeperServer.byteBuffer2Record(request.request,
                         getACLRequest);
                 stat = new Stat();
-                ArrayList<ACL> acl = zks.dataTree.getACL(getACLRequest
-                        .getPath(), stat);
+                List<ACL> acl = 
+                    zks.dataTree.getACL(getACLRequest.getPath(), stat);
                 rsp = new GetACLResponse(acl, stat);
                 break;
             case OpCode.getChildren:
<EOC>
<SOC>
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.concurrent.LinkedBlockingQueue;
 
 import org.apache.log4j.Logger;

         }
     }
 
-    static void checkACL(ZooKeeperServer zks, ArrayList<ACL> acl, int perm,
-            ArrayList<Id> ids) throws KeeperException.NoAuthException {
+    static void checkACL(ZooKeeperServer zks, List<ACL> acl, int perm,
+            List<Id> ids) throws KeeperException.NoAuthException {
         if (skipACL) {
             return;
         }

      * @param acl list of ACLs being assigned to the node (create or setACL operation)
      * @return
      */
-    private boolean fixupACL(ArrayList<Id> authInfo, ArrayList<ACL> acl) {
+    private boolean fixupACL(List<Id> authInfo, List<ACL> acl) {
         if (skipACL) {
             return true;
         }
<EOC>
<SOC>
 
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.List;
 
 import com.yahoo.jute.Record;
 import com.yahoo.zookeeper.ZooDefs.OpCode;

      * @param bb
      */
     public Request(ServerCnxn cnxn, long sessionId, int xid, int type,
-            ByteBuffer bb, ArrayList<Id> authInfo) {
+            ByteBuffer bb, List<Id> authInfo) {
         this.cnxn = cnxn;
         this.sessionId = sessionId;
         this.cxid = xid;

 
     public long zxid = -1;
 
-    public ArrayList<Id> authInfo;
+    public List<Id> authInfo;
 
     public long createTime = System.currentTimeMillis();
 
<EOC>
<SOC>
         if (retv == null) {
             return new HashSet<String>();
         }
-        return (HashSet<String>) retv.clone();
+        HashSet<String> cloned = null;
+        synchronized(retv) {
+            cloned =  (HashSet<String>) retv.clone();
+        }
+        return cloned;
     }
 
     public Collection<Long> getSessions() {

                     list = new HashSet<String>();
                     ephemerals.put(ephemeralOwner, list);
                 }
-                list.add(path);
+                synchronized(list) {
+                    list.add(path);
+                }
             }
         }
         dataWatches.triggerWatch(path, Event.EventNodeCreated);

             if (eowner != 0) {
                 HashSet<String> nodes = ephemerals.get(eowner);
                 if (nodes != null) {
-                    nodes.remove(path);
+                    synchronized(nodes) {
+                        nodes.remove(path);
+                    }
                 }
             }
             node.parent = null;

     }
 
     void killSession(long session) {
+        // the list is already removed from the ephemerals 
+        // so we do not have to worry about synchronyzing on
+        // the list. This is only called from FinalRequestProcessor
+        // so there is no need for synchornization. The list is not 
+        // changed here. Only create and delete change the list which
+        // are again called from FinalRequestProcessor in sequence.
         HashSet<String> list = ephemerals.remove(session);
         if (list != null) {
             for (String path : list) {

         for (long k : keys) {
             sb.append(Long.toHexString(k));
             sb.append(":\n");
-            for (String path : ephemerals.get(k)) {
-                sb.append("\t" + path + "\n");
+            HashSet<String> tmp = ephemerals.get(k);
+            synchronized(tmp) {
+                for (String path : tmp) {
+                    sb.append("\t" + path + "\n");
+                }
             }
         }
         return sb.toString();
<EOC>
<SOC>
 import com.yahoo.zookeeper.Watcher.Event;
 import com.yahoo.zookeeper.ZooDefs.OpCode;
 import com.yahoo.zookeeper.ZooKeeper.States;
+import com.yahoo.zookeeper.ZooKeeper.WatchRegistration;
 import com.yahoo.zookeeper.proto.AuthPacket;
 import com.yahoo.zookeeper.proto.ConnectRequest;
 import com.yahoo.zookeeper.proto.ConnectResponse;

 
         Object ctx;
 
+        WatchRegistration watchRegistration;
+
         Packet(RequestHeader header, ReplyHeader replyHeader, Record record,
-                Record response, ByteBuffer bb) {
+                Record response, ByteBuffer bb,
+                WatchRegistration watchRegistration) {
             this.header = header;
             this.replyHeader = replyHeader;
             this.request = record;

                     LOG.warn("Unexpected exception",e);
                 }
             }
+            this.watchRegistration = watchRegistration;
         }
     }
 

                         break;
                     }
                     if (event instanceof WatcherEvent) {
-                        zooKeeper.watcher.process((WatcherEvent) event);
+                        zooKeeper.processWatchEvent((WatcherEvent) event);
                     } else {
                         Packet p = (Packet) event;
                         int rc = 0;

 
     @SuppressWarnings("unchecked")
     private void finishPacket(Packet p) {
+        if (p.watchRegistration != null) {
+            p.watchRegistration.register(p.replyHeader.getErr());
+        }
+        
         p.finished = true;
         if (p.cb == null) {
             synchronized (p) {

                 for (AuthData id : authInfo) {
                     outgoingQueue.addFirst(new Packet(new RequestHeader(-4,
                             OpCode.auth), null, new AuthPacket(0, id.scheme,
-                            id.data), null, null));
+                            id.data), null, null, null));
                 }
-                outgoingQueue
-                        .addFirst((new Packet(null, null, null, null, bb)));
+                outgoingQueue.addFirst((new Packet(null, null, null, null, bb,
+                        null)));
             }
             synchronized (this) {
                 k.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);

 
         private void sendPing() {
             RequestHeader h = new RequestHeader(-2, OpCode.ping);
-            queuePacket(h, null, null, null, null, null, null);
+            queuePacket(h, null, null, null, null, null, null, null);
         }
 
         int lastConnectIndex = -1;

     }
 
     public ReplyHeader submitRequest(RequestHeader h, Record request,
-            Record response) throws InterruptedException {
+            Record response,
+            WatchRegistration watchRegistration)
+        throws InterruptedException 
+    {
         ReplyHeader r = new ReplyHeader();
-        Packet packet = queuePacket(h, r, request, response, null, null, null);
+        Packet packet = 
+            queuePacket(h, r, request, response, null, null, null,
+                    watchRegistration);
         synchronized (packet) {
             while (!packet.finished) {
                 packet.wait();

     }
 
     Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
-            Record response, AsyncCallback cb, String path, Object ctx) {
+            Record response, AsyncCallback cb, String path, Object ctx,
+            WatchRegistration watchRegistration)
+    {
         Packet packet = null;
         synchronized (outgoingQueue) {
             if (h.getType() != OpCode.ping && h.getType() != OpCode.auth) {
                 h.setXid(getXid());
             }
-            packet = new Packet(h, r, request, response, null);
+            packet = new Packet(h, r, request, response, null,
+                    watchRegistration);
             packet.cb = cb;
             packet.ctx = ctx;
             packet.path = path;

         authInfo.add(new AuthData(scheme, auth));
         if (zooKeeper.state == States.CONNECTED) {
             queuePacket(new RequestHeader(-4, OpCode.auth), null,
-                    new AuthPacket(0, scheme, auth), null, null, null, null);
+                    new AuthPacket(0, scheme, auth), null, null, null, null,
+                    null);
         }
     }
 }
<EOC>
<SOC>
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
-import java.util.List;
 import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 import org.apache.log4j.Logger;
 

 import com.yahoo.zookeeper.proto.SyncResponse;
 import com.yahoo.zookeeper.proto.WatcherEvent;
 import com.yahoo.zookeeper.server.DataTree;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
 
 /**
  * This is the main class of ZooKeeper client library. To use a ZooKeeper

 public class ZooKeeper {
     private static final Logger LOG = Logger.getLogger(ZooKeeper.class);
 
-    volatile Watcher watcher;
+    private volatile Watcher defaultWatcher;
+
+    private final Map<String, Set<Watcher>> dataWatches =
+        new HashMap<String, Set<Watcher>>();
+    private final Map<String, Set<Watcher>> childWatches =
+        new HashMap<String, Set<Watcher>>();
+
+    /**
+     * Process a WatchEvent.
+     *
+     * Looks up the watch in the set of watches, processes the event
+     * if found, otw uses the default watcher (registered during instance
+     * creation) to process the watch.
+     *
+     * @param event the event to process.
+     */
+    public void processWatchEvent(WatcherEvent event) {
+        // clear the watches if we are not connected
+        if (event.getState() != Watcher.Event.KeeperStateSyncConnected) {
+            synchronized (dataWatches) {
+                for (Set<Watcher> watchers : dataWatches.values()) {
+                    for (Watcher watcher : watchers) {
+                        watcher.process(event);
+                    }
+                }
+                dataWatches.clear();
+            }
+            synchronized (childWatches) {
+                for (Set<Watcher> watchers : childWatches.values()) {
+                    for (Watcher watcher : watchers) {
+                        watcher.process(event);
+                    }
+                }
+                childWatches.clear();
+            }
+        }
+
+        Set<Watcher> watchers = null;
+
+        switch (event.getType()) {
+        case Watcher.Event.EventNone:
+            defaultWatcher.process(event);
+            return;
+        case Watcher.Event.EventNodeDataChanged:
+        case Watcher.Event.EventNodeCreated:
+            synchronized (dataWatches) {
+                watchers = dataWatches.remove(event.getPath());
+            }
+            break;
+        case Watcher.Event.EventNodeChildrenChanged:
+            synchronized (childWatches) {
+                watchers = childWatches.remove(event.getPath());
+            }
+            break;
+        case Watcher.Event.EventNodeDeleted:
+            synchronized (dataWatches) {
+                watchers = dataWatches.remove(event.getPath());
+            }
+            Set<Watcher> cwatches;
+            synchronized (childWatches) {
+                cwatches = childWatches.remove(event.getPath());
+            }
+            if (cwatches != null) {
+                if (watchers == null) {
+                    watchers = cwatches;
+                } else {
+                    watchers.addAll(cwatches);
+                }
+            }
+            break;
+        default:
+            String msg = "Unhandled watch event type " + event.getType();
+            LOG.error(msg);
+            throw new RuntimeException(msg);
+        }
+
+        if (watchers != null) {
+            for (Watcher watcher : watchers) {
+                watcher.process(event);
+            }
+        }
+    }
+    
+    /**
+     * Register a watcher for a particular path.
+     */
+    class WatchRegistration {
+        private Map<String, Set<Watcher>> watches;
+        private Watcher watcher;
+        private String path;
+        public WatchRegistration(Map<String, Set<Watcher>> watches,
+                Watcher watcher, String path)
+        {
+            this.watches = watches;
+            this.watcher = watcher;  
+            this.path = path;
+        }
+        
+        /**
+         * Register the watcher with the set of watches on path.
+         * @param rc the result code of the operation that attempted to
+         * add the watch on the path.
+         */
+        public void register(int rc) {
+            if (shouldAddWatch(rc)) {
+                synchronized(watches) {
+                    Set<Watcher> watchers = watches.get(path);
+                    if (watchers == null) {
+                        watchers = new HashSet<Watcher>();
+                        watches.put(path, watchers);
+                    }
+                    watchers.add(watcher);
+                }
+            }
+        }
+        /**
+         * Determine whether the watch should be added based on return code.
+         * @param rc the result code of the operation that attempted to add the
+         * watch on the node
+         * @return true if the watch should be added, otw false
+         */
+        protected boolean shouldAddWatch(int rc) {
+            return rc == 0;
+        }
+    }
+
+    /** Handle the special case of exists watches - they add a watcher
+     * even in the case where NONODE result code is returned.
+     */
+    class ExistsWatchRegistration extends WatchRegistration {
+        public ExistsWatchRegistration(Map<String, Set<Watcher>> watches,
+                Watcher watcher, String path)
+        {
+            super(watches, watcher, path);
+        }
+        protected boolean shouldAddWatch(int rc) {
+            return rc == 0 || rc == KeeperException.Code.NoNode;
+        }
+    }
 
     public enum States {
         CONNECTING, ASSOCIATING, CONNECTED, CLOSED, AUTH_FAILED;

 
     public ZooKeeper(String host, int sessionTimeout, Watcher watcher)
             throws IOException {
-        this.watcher = watcher;
+        this.defaultWatcher = watcher;
         cnxn = new ClientCnxn(host, sessionTimeout, this);
     }
 
     public ZooKeeper(String host, int sessionTimeout, Watcher watcher,
             long sessionId, byte[] sessionPasswd) throws IOException {
-        this.watcher = watcher;
+        this.defaultWatcher = watcher;
         cnxn = new ClientCnxn(host, sessionTimeout, this, sessionId,
                 sessionPasswd);
     }

     }
 
     public synchronized void register(Watcher watcher) {
-        this.watcher = watcher;
+        this.defaultWatcher = watcher;
     }
 
     /**

     public synchronized void close() throws InterruptedException {
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.closeSession);
-        cnxn.submitRequest(h, null, null);
+        cnxn.submitRequest(h, null, null, null);
         try {
             cnxn.close();
         } catch (IOException e) {

             throw new KeeperException.InvalidACLException();
         }
         request.setAcl(acl);
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        ReplyHeader r = cnxn.submitRequest(h, request, response, null);
         if (r.getErr() != 0) {
             throw KeeperException.create(r.getErr(), path);
         }

         request.setFlags(flags);
         request.setPath(path);
         request.setAcl(acl);
-        cnxn.queuePacket(h, r, request, response, cb, path, ctx);
+        cnxn.queuePacket(h, r, request, response, cb, path, ctx, null);
     }
 
     /**

         DeleteRequest request = new DeleteRequest();
         request.setPath(path);
         request.setVersion(version);
-        ReplyHeader r = cnxn.submitRequest(h, request, null);
+        ReplyHeader r = cnxn.submitRequest(h, request, null, null);
         if (r.getErr() != 0) {
             throw KeeperException.create(r.getErr());
         }

         DeleteRequest request = new DeleteRequest();
         request.setPath(path);
         request.setVersion(version);
-        cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, path, ctx);
+        cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, path, ctx, null);
+    }
+
+    /**
+     * Return the stat of the node of the given path. Return null if no such a
+     * node exists.
+     * <p>
+     * If the watch is non-null and the call is successful (no exception is thrown),
+     * a watch will be left on the node with the given path. The watch will be
+     * triggered by a successful operation that creates/delete the node or sets
+     * the data on the node.
+     *
+     * @param path the node path
+     * @param watcher explicit watcher
+     * @return the stat of the node of the given path; return null if no such a
+     *         node exists.
+     * @throws KeeperException If the server signals an error
+     * @throws InterruptedException If the server transaction is interrupted.
+     */
+    public Stat exists(String path, Watcher watcher) throws KeeperException,
+        InterruptedException
+    {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.exists);
+        ExistsRequest request = new ExistsRequest();
+        request.setPath(path);
+        request.setWatch(watcher != null);
+        SetDataResponse response = new SetDataResponse();
+        WatchRegistration wcb = null;
+        if (watcher != null) {
+            wcb = new ExistsWatchRegistration(dataWatches, watcher, path);
+        }
+        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);
+        if (r.getErr() != 0) {
+            if (r.getErr() == KeeperException.Code.NoNode) {
+                return null;
+            }
+            throw KeeperException.create(r.getErr());
+        }
+
+        return response.getStat().getCzxid() == -1 ? null : response.getStat();
     }
 
     /**

      * @throws InterruptedException If the server transaction is interrupted.
      */
     public Stat exists(String path, boolean watch) throws KeeperException,
-            InterruptedException {
+        InterruptedException
+    {
+        return exists(path, watch ? defaultWatcher : null);
+    }
+
+    /**
+     * The Asynchronous version of exists. The request doesn't actually until
+     * the asynchronous callback is called.
+     *
+     * @see #exists(String, boolean)
+     */
+    public void exists(String path, Watcher watcher, StatCallback cb,
+            Object ctx)
+    {
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.exists);
         ExistsRequest request = new ExistsRequest();
         request.setPath(path);
-        request.setWatch(watch);
+        request.setWatch(watcher != null);
         SetDataResponse response = new SetDataResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
-        if (r.getErr() != 0) {
-            if (r.getErr() == KeeperException.Code.NoNode) {
-                return null;
-            }
-            throw KeeperException.create(r.getErr());
+        WatchRegistration wcb = null;
+        if (watcher != null) {
+            wcb = new ExistsWatchRegistration(dataWatches, watcher, path);
         }
-        return response.getStat().getCzxid() == -1 ? null : response.getStat();
+        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path,
+                        ctx, wcb);
     }
 
     /**

      * @see #exists(String, boolean)
      */
     public void exists(String path, boolean watch, StatCallback cb, Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.exists);
-        ExistsRequest request = new ExistsRequest();
-        request.setPath(path);
-        request.setWatch(watch);
-        SetDataResponse response = new SetDataResponse();
-        cnxn
-                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
+        exists(path, watch ? defaultWatcher : null, cb, ctx);
     }
 
     /**
      * Return the data and the stat of the node of the given path.
      * <p>
-     * If the watch is true and the call is successfull (no exception is
+     * If the watch is non-null and the call is successful (no exception is
      * thrown), a watch will be left on the node with the given path. The watch
-     * will be triggered by a sucessful operation that sets data on the node, or
+     * will be triggered by a successful operation that sets data on the node, or
      * deletes the node.
      * <p>
      * A KeeperException with error code KeeperException.NoNode will be thrown
      * if no node with the given path exists.
      *
-     * @param path
-     *                the given path
-     * @param watch
-     *                whether need to watch this node
-     * @param stat
-     *                teh stat of the node
+     * @param path the given path
+     * @param watcher explicit watcher
+     * @param stat the stat of the node
      * @return the data of the node
      * @throws KeeperException If the server signals an error with a non-zero error code
      * @throws InterruptedException If the server transaction is interrupted.
      */
-    public byte[] getData(String path, boolean watch, Stat stat)
+    public byte[] getData(String path, Watcher watcher, Stat stat)
             throws KeeperException, InterruptedException {
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getData);
         GetDataRequest request = new GetDataRequest();
         request.setPath(path);
-        request.setWatch(watch);
+        request.setWatch(watcher != null);
         GetDataResponse response = new GetDataResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        WatchRegistration wcb = null;
+        if (watcher != null) {
+            wcb = new WatchRegistration(dataWatches, watcher, path);
+        }
+        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);
         if (r.getErr() != 0) {
             throw KeeperException.create(r.getErr());
         }

     }
 
     /**
+     * Return the data and the stat of the node of the given path.
+     * <p>
+     * If the watch is true and the call is successful (no exception is
+     * thrown), a watch will be left on the node with the given path. The watch
+     * will be triggered by a successful operation that sets data on the node, or
+     * deletes the node.
+     * <p>
+     * A KeeperException with error code KeeperException.NoNode will be thrown
+     * if no node with the given path exists.
+     *
+     * @param path the given path
+     * @param watch whether need to watch this node
+     * @param stat the stat of the node
+     * @return the data of the node
+     * @throws KeeperException If the server signals an error with a non-zero error code
+     * @throws InterruptedException If the server transaction is interrupted.
+     */
+    public byte[] getData(String path, boolean watch, Stat stat)
+            throws KeeperException, InterruptedException {
+        return getData(path, watch ? defaultWatcher : null, stat);
+    }
+
+    /**
+     * The Asynchronous version of getData. The request doesn't actually until
+     * the asynchronous callback is called.
+     *
+     * @see #getData(String, Watcher, Stat)
+     */
+    public void getData(String path, Watcher watcher, DataCallback cb, Object ctx) {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.getData);
+        GetDataRequest request = new GetDataRequest();
+        request.setPath(path);
+        request.setWatch(watcher != null);
+        GetDataResponse response = new GetDataResponse();
+        WatchRegistration wcb = null;
+        if (watcher != null) {
+            wcb = new WatchRegistration(dataWatches, watcher, path);
+        }
+        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path,
+                        ctx, wcb);
+    }
+
+    /**
      * The Asynchronous version of getData. The request doesn't actually until
      * the asynchronous callback is called.
      *
      * @see #getData(String, boolean, Stat)
      */
-
     public void getData(String path, boolean watch, DataCallback cb, Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.getData);
-        GetDataRequest request = new GetDataRequest();
-        request.setPath(path);
-        request.setWatch(watch);
-        GetDataResponse response = new GetDataResponse();
-        cnxn
-                .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
+        getData(path, watch ? defaultWatcher : null, cb, ctx);
     }
 
     /**

         request.setData(data);
         request.setVersion(version);
         SetDataResponse response = new SetDataResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        ReplyHeader r = cnxn.submitRequest(h, request, response, null);
         if (r.getErr() != 0) {
             throw KeeperException.create(r.getErr());
         }

         SetDataResponse response = new SetDataResponse();
         cnxn
                 .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
+                        ctx, null);
     }
 
     /**

         GetACLRequest request = new GetACLRequest();
         request.setPath(path);
         GetACLResponse response = new GetACLResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        ReplyHeader r = cnxn.submitRequest(h, request, response, null);
         if (r.getErr() != 0) {
             throw KeeperException.create(r.getErr());
         }

         GetACLResponse response = new GetACLResponse();
         cnxn
                 .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
+                        ctx, null);
     }
 
     /**

         request.setAcl(acl);
         request.setVersion(version);
         SetACLResponse response = new SetACLResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
+        ReplyHeader r = cnxn.submitRequest(h, request, response, null);
         if (r.getErr() != 0) {
             throw KeeperException.create(r.getErr());
         }

         SetACLResponse response = new SetACLResponse();
         cnxn
                 .queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
+                        ctx, null);
+    }
+
+    /**
+     * Return the list of the children of the node of the given path.
+     * <p>
+     * If the watch is non-null and the call is successful (no exception is thrown),
+     * a watch will be left on the node with the given path. The watch willbe
+     * triggered by a successful operation that deletes the node of the given
+     * path or creates/delete a child under the node.
+     * <p>
+     * A KeeperException with error code KeeperException.NoNode will be thrown
+     * if no node with the given path exists.
+     *
+     * @param path
+     * @param watcher explicit watcher
+     * @return an array of children of the node with the given path
+     * @throws InterruptedException If the server transaction is interrupted.
+     * @throws KeeperException If the server signals an error with a non-zero error code.
+     */
+    public List<String> getChildren(String path, Watcher watcher)
+            throws KeeperException, InterruptedException {
+        RequestHeader h = new RequestHeader();
+        h.setType(ZooDefs.OpCode.getChildren);
+        GetChildrenRequest request = new GetChildrenRequest();
+        request.setPath(path);
+        request.setWatch(watcher != null);
+        GetChildrenResponse response = new GetChildrenResponse();
+        WatchRegistration wcb = null;
+        if (watcher != null) {
+            wcb = new WatchRegistration(childWatches, watcher, path);
+        }
+        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);
+        if (r.getErr() != 0) {
+            throw KeeperException.create(r.getErr());
+        }
+        return response.getChildren();
     }
 
     /**

      * <p>
      * If the watch is true and the call is successful (no exception is thrown),
      * a watch will be left on the node with the given path. The watch willbe
-     * triggered by a sucessful operation that deletes the node of the given
+     * triggered by a successful operation that deletes the node of the given
      * path or creates/delete a child under the node.
      * <p>
      * A KeeperException with error code KeeperException.NoNode will be thrown

      */
     public List<String> getChildren(String path, boolean watch)
             throws KeeperException, InterruptedException {
+        return getChildren(path, watch ? defaultWatcher : null);
+    }
+
+    /**
+     * The Asynchronous version of getChildren. The request doesn't actually
+     * until the asynchronous callback is called.
+     *
+     * @see #getChildren(String, Watcher)
+     */
+    public void getChildren(String path, Watcher watcher, ChildrenCallback cb,
+            Object ctx) {
         RequestHeader h = new RequestHeader();
         h.setType(ZooDefs.OpCode.getChildren);
         GetChildrenRequest request = new GetChildrenRequest();
         request.setPath(path);
-        request.setWatch(watch);
+        request.setWatch(watcher != null);
         GetChildrenResponse response = new GetChildrenResponse();
-        ReplyHeader r = cnxn.submitRequest(h, request, response);
-        if (r.getErr() != 0) {
-            throw KeeperException.create(r.getErr());
+        WatchRegistration wcb = null;
+        if (watcher != null) {
+            wcb = new WatchRegistration(childWatches, watcher, path);
         }
-        return response.getChildren();
+        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path,
+                        ctx, wcb);
     }
 
     /**

      */
     public void getChildren(String path, boolean watch, ChildrenCallback cb,
             Object ctx) {
-        RequestHeader h = new RequestHeader();
-        h.setType(ZooDefs.OpCode.getChildren);
-        GetChildrenRequest request = new GetChildrenRequest();
-        request.setPath(path);
-        request.setWatch(watch);
-        GetChildrenResponse response = new GetChildrenResponse();
-        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path,
-                        ctx);
+        getChildren(path, watch ? defaultWatcher : null, cb, ctx);
     }
 
     /**

         SyncRequest request = new SyncRequest();
         SyncResponse response = new SyncResponse();
         request.setPath(path);
-        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path, ctx);
+        cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, path, ctx,
+                null);
     }
 
     public States getState() {
<EOC>
<SOC>
  * limitations under the License.
  */
 
-package com.yahoo.zookeeper;
+package org.apache.zookeeper;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;

 
 import org.apache.log4j.Logger;
 
-import com.yahoo.jute.BinaryInputArchive;
-import com.yahoo.jute.BinaryOutputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.AsyncCallback.ACLCallback;
-import com.yahoo.zookeeper.AsyncCallback.ChildrenCallback;
-import com.yahoo.zookeeper.AsyncCallback.DataCallback;
-import com.yahoo.zookeeper.AsyncCallback.StatCallback;
-import com.yahoo.zookeeper.AsyncCallback.StringCallback;
-import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
-import com.yahoo.zookeeper.Watcher.Event;
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.ZooKeeper.States;
-import com.yahoo.zookeeper.ZooKeeper.WatchRegistration;
-import com.yahoo.zookeeper.proto.AuthPacket;
-import com.yahoo.zookeeper.proto.ConnectRequest;
-import com.yahoo.zookeeper.proto.ConnectResponse;
-import com.yahoo.zookeeper.proto.CreateResponse;
-import com.yahoo.zookeeper.proto.ExistsResponse;
-import com.yahoo.zookeeper.proto.GetACLResponse;
-import com.yahoo.zookeeper.proto.GetChildrenResponse;
-import com.yahoo.zookeeper.proto.GetDataResponse;
-import com.yahoo.zookeeper.proto.ReplyHeader;
-import com.yahoo.zookeeper.proto.RequestHeader;
-import com.yahoo.zookeeper.proto.SetACLResponse;
-import com.yahoo.zookeeper.proto.SetDataResponse;
-import com.yahoo.zookeeper.proto.WatcherEvent;
-import com.yahoo.zookeeper.server.ByteBufferInputStream;
-import com.yahoo.zookeeper.server.ZooKeeperServer;
-import com.yahoo.zookeeper.server.ZooTrace;
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.AsyncCallback.ACLCallback;
+import org.apache.zookeeper.AsyncCallback.ChildrenCallback;
+import org.apache.zookeeper.AsyncCallback.DataCallback;
+import org.apache.zookeeper.AsyncCallback.StatCallback;
+import org.apache.zookeeper.AsyncCallback.StringCallback;
+import org.apache.zookeeper.AsyncCallback.VoidCallback;
+import org.apache.zookeeper.Watcher.Event;
+import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.ZooKeeper.States;
+import org.apache.zookeeper.ZooKeeper.WatchRegistration;
+import org.apache.zookeeper.proto.AuthPacket;
+import org.apache.zookeeper.proto.ConnectRequest;
+import org.apache.zookeeper.proto.ConnectResponse;
+import org.apache.zookeeper.proto.CreateResponse;
+import org.apache.zookeeper.proto.ExistsResponse;
+import org.apache.zookeeper.proto.GetACLResponse;
+import org.apache.zookeeper.proto.GetChildrenResponse;
+import org.apache.zookeeper.proto.GetDataResponse;
+import org.apache.zookeeper.proto.ReplyHeader;
+import org.apache.zookeeper.proto.RequestHeader;
+import org.apache.zookeeper.proto.SetACLResponse;
+import org.apache.zookeeper.proto.SetDataResponse;
+import org.apache.zookeeper.proto.WatcherEvent;
+import org.apache.zookeeper.server.ByteBufferInputStream;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.ZooTrace;
 
 /**
  * This class manages the socket i/o for the client. ClientCnxn maintains a list
<EOC>
<SOC>
  * limitations under the License.
  */
 
-package com.yahoo.zookeeper;
+package org.apache.zookeeper;
 
-import com.yahoo.zookeeper.proto.WatcherEvent;
+import org.apache.zookeeper.proto.WatcherEvent;
 
 /**
  * This interface specifies the public interface an event handler class must
<EOC>
<SOC>
  * limitations under the License.
  */
 
-package com.yahoo.zookeeper;
+package org.apache.zookeeper;
 
 import java.io.BufferedReader;
 import java.io.IOException;

 
 import org.apache.log4j.Logger;
 
-import com.yahoo.zookeeper.AsyncCallback.ACLCallback;
-import com.yahoo.zookeeper.AsyncCallback.ChildrenCallback;
-import com.yahoo.zookeeper.AsyncCallback.DataCallback;
-import com.yahoo.zookeeper.AsyncCallback.StatCallback;
-import com.yahoo.zookeeper.AsyncCallback.StringCallback;
-import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
-import com.yahoo.zookeeper.ZooDefs.Ids;
-import com.yahoo.zookeeper.data.ACL;
-import com.yahoo.zookeeper.data.Id;
-import com.yahoo.zookeeper.data.Stat;
-import com.yahoo.zookeeper.proto.CreateRequest;
-import com.yahoo.zookeeper.proto.CreateResponse;
-import com.yahoo.zookeeper.proto.DeleteRequest;
-import com.yahoo.zookeeper.proto.ExistsRequest;
-import com.yahoo.zookeeper.proto.GetACLRequest;
-import com.yahoo.zookeeper.proto.GetACLResponse;
-import com.yahoo.zookeeper.proto.GetChildrenRequest;
-import com.yahoo.zookeeper.proto.GetChildrenResponse;
-import com.yahoo.zookeeper.proto.GetDataRequest;
-import com.yahoo.zookeeper.proto.GetDataResponse;
-import com.yahoo.zookeeper.proto.ReplyHeader;
-import com.yahoo.zookeeper.proto.RequestHeader;
-import com.yahoo.zookeeper.proto.SetACLRequest;
-import com.yahoo.zookeeper.proto.SetACLResponse;
-import com.yahoo.zookeeper.proto.SetDataRequest;
-import com.yahoo.zookeeper.proto.SetDataResponse;
-import com.yahoo.zookeeper.proto.SyncRequest;
-import com.yahoo.zookeeper.proto.SyncResponse;
-import com.yahoo.zookeeper.proto.WatcherEvent;
-import com.yahoo.zookeeper.server.DataTree;
+import org.apache.zookeeper.AsyncCallback.ACLCallback;
+import org.apache.zookeeper.AsyncCallback.ChildrenCallback;
+import org.apache.zookeeper.AsyncCallback.DataCallback;
+import org.apache.zookeeper.AsyncCallback.StatCallback;
+import org.apache.zookeeper.AsyncCallback.StringCallback;
+import org.apache.zookeeper.AsyncCallback.VoidCallback;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.data.ACL;
+import org.apache.zookeeper.data.Id;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.proto.CreateRequest;
+import org.apache.zookeeper.proto.CreateResponse;
+import org.apache.zookeeper.proto.DeleteRequest;
+import org.apache.zookeeper.proto.ExistsRequest;
+import org.apache.zookeeper.proto.GetACLRequest;
+import org.apache.zookeeper.proto.GetACLResponse;
+import org.apache.zookeeper.proto.GetChildrenRequest;
+import org.apache.zookeeper.proto.GetChildrenResponse;
+import org.apache.zookeeper.proto.GetDataRequest;
+import org.apache.zookeeper.proto.GetDataResponse;
+import org.apache.zookeeper.proto.ReplyHeader;
+import org.apache.zookeeper.proto.RequestHeader;
+import org.apache.zookeeper.proto.SetACLRequest;
+import org.apache.zookeeper.proto.SetACLResponse;
+import org.apache.zookeeper.proto.SetDataRequest;
+import org.apache.zookeeper.proto.SetDataResponse;
+import org.apache.zookeeper.proto.SyncRequest;
+import org.apache.zookeeper.proto.SyncResponse;
+import org.apache.zookeeper.proto.WatcherEvent;
+import org.apache.zookeeper.server.DataTree;
 
 /**
  * This is the main class of ZooKeeper client library. To use a ZooKeeper

      *                and/or sequential
      * @return the actual path of the created node
      * @throws KeeperException if the server returns a non-zero error code
-     * @throws com.yahoo.zookeeper.KeeperException.InvalidACLException if the ACL is invalid
+     * @throws org.apache.zookeeper.KeeperException.InvalidACLException if the ACL is invalid
      * @throws InterruptedException if the transaction is interrrupted
      */
     public String create(String path, byte data[], List<ACL> acl, int flags)

      * @return the stat of the node.
      * @throws InterruptedException If the server transaction is interrupted.
      * @throws KeeperException If the server signals an error with a non-zero error code.
-     * @throws com.yahoo.zookeeper.KeeperException.InvalidACLException If the acl is invalide.
+     * @throws org.apache.zookeeper.KeeperException.InvalidACLException If the acl is invalide.
      */
     public Stat setACL(String path, List<ACL> acl, int version)
             throws KeeperException, InterruptedException {
<EOC>
<SOC>
  * limitations under the License.
  */
 
-package com.yahoo.zookeeper.server;
+package org.apache.zookeeper.server;
 
 import java.io.IOException;
 import java.util.ArrayList;

 
 import org.apache.log4j.Logger;
 
-import com.yahoo.jute.InputArchive;
-import com.yahoo.jute.OutputArchive;
-import com.yahoo.jute.Record;
-import com.yahoo.zookeeper.KeeperException;
-import com.yahoo.zookeeper.Watcher;
-import com.yahoo.zookeeper.KeeperException.Code;
-import com.yahoo.zookeeper.Watcher.Event;
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.data.ACL;
-import com.yahoo.zookeeper.data.Stat;
-import com.yahoo.zookeeper.txn.CreateTxn;
-import com.yahoo.zookeeper.txn.DeleteTxn;
-import com.yahoo.zookeeper.txn.ErrorTxn;
-import com.yahoo.zookeeper.txn.SetACLTxn;
-import com.yahoo.zookeeper.txn.SetDataTxn;
-import com.yahoo.zookeeper.txn.TxnHeader;
+import org.apache.jute.InputArchive;
+import org.apache.jute.OutputArchive;
+import org.apache.jute.Record;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.KeeperException.Code;
+import org.apache.zookeeper.Watcher.Event;
+import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.data.ACL;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.txn.CreateTxn;
+import org.apache.zookeeper.txn.DeleteTxn;
+import org.apache.zookeeper.txn.ErrorTxn;
+import org.apache.zookeeper.txn.SetACLTxn;
+import org.apache.zookeeper.txn.SetDataTxn;
+import org.apache.zookeeper.txn.TxnHeader;
 
 /**
  * This class maintains the tree data structure. It doesn't have any networking

         return nodes.size();
     }
 
+    public int getWatchCount(){
+        return dataWatches.size()+childWatches.size();
+    }
+
     /**
      * This is a pointer to the root of the DataTree. It is the source of truth,
      * but we usually use the nodes hashmap to find nodes in the tree.

     }
 
     void killSession(long session) {
-        // the list is already removed from the ephemerals 
+        // the list is already removed from the ephemerals
         // so we do not have to worry about synchronyzing on
         // the list. This is only called from FinalRequestProcessor
-        // so there is no need for synchornization. The list is not 
+        // so there is no need for synchornization. The list is not
         // changed here. Only create and delete change the list which
         // are again called from FinalRequestProcessor in sequence.
         HashSet<String> list = ephemerals.remove(session);
<EOC>
<SOC>
  * limitations under the License.
  */
 
-package com.yahoo.zookeeper.jmx.server;
+package org.apache.zookeeper.jmx.server;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.Date;
 
-import com.yahoo.zookeeper.Version;
-import com.yahoo.zookeeper.jmx.ZKMBeanInfo;
-import com.yahoo.zookeeper.server.ServerConfig;
-import com.yahoo.zookeeper.server.ServerStats;
+import org.apache.zookeeper.Version;
+import org.apache.zookeeper.jmx.ZKMBeanInfo;
+import org.apache.zookeeper.server.ServerConfig;
+import org.apache.zookeeper.server.ServerStats;
 
 /**
  * This class implements the zookeeper server MBean interface.
<EOC>
<SOC>
  * limitations under the License.
  */
 
-package com.yahoo.zookeeper.server.quorum;
+package org.apache.zookeeper.server.quorum;
 
 import java.util.ArrayList;
 import java.util.LinkedList;
 
 import org.apache.log4j.Logger;
 
-import com.yahoo.zookeeper.ZooDefs.OpCode;
-import com.yahoo.zookeeper.server.Request;
-import com.yahoo.zookeeper.server.RequestProcessor;
-import com.yahoo.zookeeper.server.ZooTrace;
+import org.apache.zookeeper.ZooDefs.OpCode;
+import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.server.RequestProcessor;
+import org.apache.zookeeper.server.ZooTrace;
 
 /**
  * This RequestProcessor matches the incoming committed requests with the
<EOC>
<SOC>
  * limitations under the License.
  */
 
-package com.yahoo.zookeeper.jmx.server.quorum;
+package org.apache.zookeeper.jmx.server.quorum;
 
-import com.yahoo.zookeeper.jmx.ZKMBeanInfo;
-import com.yahoo.zookeeper.server.quorum.QuorumPeer;
+import org.apache.zookeeper.jmx.ZKMBeanInfo;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
 
 /**
  * A remote peer bean only provides limited information about the remote peer,
<EOC>
<SOC>
  * limitations under the License.
  */
 
-package com.yahoo.zookeeper.version.util;
+package org.apache.zookeeper.version.util;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 
 public class VerGen {
-    private static final String PACKAGE_NAME = "com.yahoo.zookeeper.version";
+    private static final String PACKAGE_NAME = "org.apache.zookeeper.version";
     private static final String TYPE_NAME = "Info";
 
     static void printUsage() {
-        System.out.print("Usage:\tjava  -cp <classpath> com.yahoo.zookeeper."
+        System.out.print("Usage:\tjava  -cp <classpath> org.apache.zookeeper."
                 + "version.util.VerGen maj.min.micro rev buildDate");
         System.exit(1);
     }

         File file = new File(pkgdir, TYPE_NAME + ".java");
         try {
             FileWriter w = new FileWriter(file);
-            w.write("// Do not edit!\n// File generated by com.yahoo.zookeeper"
+            w.write("// Do not edit!\n// File generated by org.apache.zookeeper"
                     + ".version.util.VerGen.\n");
             w.write("package " + PACKAGE_NAME + ";\n\n");
             w.write("public interface " + TYPE_NAME + " {\n");

     }
 
     /**
-     * Emits a com.yahoo.zookeeper.version.Info interface file with version and
+     * Emits a org.apache.zookeeper.version.Info interface file with version and
      * revision information constants set to the values passed in as command
      * line parameters. The file is created in the current directory. <br>
-     * Usage: java com.yahoo.zookeeper.version.util.VerGen maj.min.micro rev
+     * Usage: java org.apache.zookeeper.version.util.VerGen maj.min.micro rev
      * buildDate
-     * 
+     *
      * @param args
      *            <ul>
      *            <li>maj - major version number

             String[] v = args[0].split("\\.");
             if (v.length != 3) {
                 System.err
-                        .println("Ivalid version number format, must be \"x.y.z\"");
+                        .println("Invalid version number format, must be \"x.y.z\"");
                 System.exit(1);
             }
             int maj = Integer.parseInt(v[0]);

             generateFile(maj, min, micro, rev, args[2]);
         } catch (NumberFormatException e) {
             System.err
-                    .println("All version-related parameters must be invalid integers!");
-            System.exit(1);
+                .println("All version-related parameters must be valid integers!");
+            throw e;
         }
     }
 
<EOC>
<SOC>
     private String mName;
     private ArrayList mInclFiles;
     private ArrayList mRecList;
+    private final File outputDirectory;
     
     /** Creates a new instance of CppGenerator
      *
      * @param name possibly full pathname to the file
      * @param ilist included files (as JFile)
      * @param rlist List of records defined within this file
+     * @param outputDirectory 
      */
-    CGenerator(String name, ArrayList ilist, ArrayList rlist) {
+    CGenerator(String name, ArrayList ilist, ArrayList rlist, File outputDirectory) {
         mFullName = name;
+        this.outputDirectory = outputDirectory;
         mName = (new File(name)).getName();
         mInclFiles = ilist;
         mRecList = rlist;

      * record-level code is generated by JRecord.
      */
     void genCode() throws IOException {
-        FileWriter c = new FileWriter(mName+".c");
-        FileWriter h = new FileWriter(mName+".h");
+        outputDirectory.mkdirs();
+        FileWriter c = new FileWriter(new File(outputDirectory, mName+".c"));
+        FileWriter h = new FileWriter(new File(outputDirectory, mName+".h"));
         h.write("#ifndef __"+mName.toUpperCase().replace('.','_')+"__\n");
         h.write("#define __"+mName.toUpperCase().replace('.','_')+"__\n");
         
<EOC>
<SOC>
     private String mName;
     private ArrayList mInclFiles;
     private ArrayList mRecList;
+    private final File outputDirectory;
     
     /** Creates a new instance of CppGenerator
      *
      * @param name possibly full pathname to the file
      * @param ilist included files (as JFile)
      * @param rlist List of records defined within this file
+     * @param outputDirectory 
      */
-    CppGenerator(String name, ArrayList ilist, ArrayList rlist) {
+    CppGenerator(String name, ArrayList ilist, ArrayList rlist, File outputDirectory) {
         mFullName = name;
+        this.outputDirectory = outputDirectory;
         mName = (new File(name)).getName();
         mInclFiles = ilist;
         mRecList = rlist;

      * record-level code is generated by JRecord.
      */
     void genCode() throws IOException {
-        FileWriter cc = new FileWriter(mName+".cc");
-        FileWriter hh = new FileWriter(mName+".hh");
+        outputDirectory.mkdirs();
+        FileWriter cc = new FileWriter(new File(outputDirectory, mName+".cc"));
+        FileWriter hh = new FileWriter(new File(outputDirectory, mName+".hh"));
         hh.write("#ifndef __"+mName.toUpperCase().replace('.','_')+"__\n");
         hh.write("#define __"+mName.toUpperCase().replace('.','_')+"__\n");
         
<EOC>
<SOC>
         System.exit(1);
     }
 
-    static void generateFile(int maj, int min, int micro, int rev,
+    static void generateFile(File outputDir, int maj, int min, int micro, int rev,
             String buildDate) {
         String path = PACKAGE_NAME.replaceAll("\\.", "/");
-        File pkgdir = new File(path);
+        File pkgdir = new File(outputDir, path);
         if (!pkgdir.exists()) {
             // create the pkg directory
             boolean ret = pkgdir.mkdirs();

             int min = Integer.parseInt(v[1]);
             int micro = Integer.parseInt(v[2]);
             int rev = Integer.parseInt(args[1]);
-            generateFile(maj, min, micro, rev, args[2]);
+            generateFile(new File("."), maj, min, micro, rev, args[2]);
         } catch (NumberFormatException e) {
             System.err
                 .println("All version-related parameters must be valid integers!");
<EOC>
<SOC>
     static boolean skipACL;
     static {
         skipACL = System.getProperty("zookeeper.skipACL", "no").equals("yes");
+        if (skipACL) {
+            LOG.info("zookeeper.skipACL==\"yes\", ACL checks will be skipped");
+        }
     }
 
     LinkedBlockingQueue<Request> submittedRequests = new LinkedBlockingQueue<Request>();

                         .getNextZxid(), zks.getTime(), OpCode.setACL);
                 zks.sessionTracker.checkSession(request.sessionId);
                 SetACLRequest setAclRequest = new SetACLRequest();
+                ZooKeeperServer.byteBuffer2Record(request.request,
+                        setAclRequest);
                 if (!fixupACL(request.authInfo, setAclRequest.getAcl())) {
                     throw new KeeperException.InvalidACLException();
                 }
-                ZooKeeperServer.byteBuffer2Record(request.request,
-                        setAclRequest);
                 path = setAclRequest.getPath();
                 nodeRecord = getRecordForPath(path);
                 checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN,

     }
 
     /**
+     * This method checks out the acl making sure it isn't null or empty,
+     * it has valid schemes and ids, and expanding any relative ids that
+     * depend on the requestor's authentication information.
      *
      * @param authInfo list of ACL IDs associated with the client connection
      * @param acl list of ACLs being assigned to the node (create or setACL operation)

             Id id = a.getId();
             if (id.getScheme().equals("world") && id.getId().equals("anyone")) {
             } else if (id.getScheme().equals("auth")) {
+                // This is the "auth" id, so we have to expand it to the
+                // authenticated ids of the requestor
                 it.remove();
                 if (toAdd == null) {
                     toAdd = new LinkedList<ACL>();
                 }
+                boolean authIdValid = false;
                 for (Id cid : authInfo) {
                     AuthenticationProvider ap = ProviderRegistry.getProvider(cid.getScheme());
                     if (ap == null) {
                         LOG.error("Missing AuthenticationProvider for "
                                 + cid.getScheme());
                     } else if (ap.isAuthenticated()) {
+                        authIdValid = true;
                         toAdd.add(new ACL(a.getPerms(), cid));
                     }
                 }
+                if (!authIdValid) {
+                    return false;
+                }
             } else {
                 AuthenticationProvider ap = ProviderRegistry.getProvider(id
                         .getScheme());

                 acl.add(a);
             }
         }
-        return true;
+        return acl.size() > 0;
     }
 
     public void processRequest(Request request) {
<EOC>
<SOC>
                         request.authInfo);
                 int parentCVersion = parentRecord.stat.getCversion();
                 if ((createRequest.getFlags() & CreateFlags.SEQUENCE) != 0) {
-                    path = path + parentCVersion;
+                    path = path + String.format("%010d", parentCVersion);
                 }
                 try {
                     if (getRecordForPath(path) != null) {
<EOC>
<SOC>
                 err = rc.err;
                 break;
             case OpCode.sync:
+                LOG.debug("OpCode.sync " + request);
                 SyncRequest syncRequest = new SyncRequest();
                 ZooKeeperServer.byteBuffer2Record(request.request,
                         syncRequest);
<EOC>
<SOC>
      */
     LinkedList<Request> committedRequests = new LinkedList<Request>();
 
-    /*
-     * Pending sync requests
-     */
-    LinkedList<Request> pendingSyncs = new LinkedList<Request>();
-
     RequestProcessor nextProcessor;
 
     public CommitProcessor(RequestProcessor nextProcessor) {

                             break;
                         case OpCode.sync:
                             nextPending = request;
-                            pendingSyncs.add(request);
+                            //pendingSyncs.add(request);
                             break;
                         default:
                             toProcess.add(request);

                          new Exception("committing a null! "));
                 return;
             }
+            LOG.debug("Committing" + request.cxid);
             committedRequests.add(request);
             notifyAll();
         }
<EOC>
<SOC>
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 import org.apache.log4j.Logger;
 

 
     SyncRequestProcessor syncProcessor;
 
+    /*
+     * Pending sync requests
+     */
+    ConcurrentLinkedQueue<Request> pendingSyncs;
+    
     /**
      * @param port
      * @param dataDir

             QuorumPeer self,DataTreeBuilder treeBuilder) throws IOException {
         super(dataDir, dataLogDir, self.tickTime,treeBuilder);
         this.self = self;
+        this.pendingSyncs = new ConcurrentLinkedQueue<Request>();
     }
 
     public Follower getFollower(){

     }
     
     public void sync(){
-        if(commitProcessor.pendingSyncs.size() ==0){
+        if(pendingSyncs.size() ==0){
             LOG.warn("Not expecting a sync.");
             return;
         }
                 
-        commitProcessor.commit(commitProcessor.pendingSyncs.remove());
+        commitProcessor.commit(pendingSyncs.remove());
     }
              
          
<EOC>
<SOC>
                         }
                         commit(zxid);
                         zk.commitProcessor.commit(p.request);
+                        if(pendingSyncs.containsKey(zxid)){
+                            sendSync(syncHandler.get(pendingSyncs.get(zxid).sessionId), pendingSyncs.get(zxid));
+                            syncHandler.remove(pendingSyncs.get(zxid));
+                            pendingSyncs.remove(zxid);
+                        }
                     }
                 }
                 return;

         lastCommitted = zxid;
         QuorumPacket qp = new QuorumPacket(Leader.COMMIT, zxid, null, null);
         sendPacket(qp);
-               
-        if(pendingSyncs.containsKey(zxid)){
-            sendSync(syncHandler.get(pendingSyncs.get(zxid).sessionId), pendingSyncs.get(zxid));
-            syncHandler.remove(pendingSyncs.get(zxid));
-            pendingSyncs.remove(zxid);
-        }
     }
 
     long lastProposed;

      */
             
     public void sendSync(FollowerHandler f, Request r){
-        QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);
-        f.queuePacket(qp);
+        if(f != null){
+            QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);
+            f.queuePacket(qp);
+        }
+        else{
+            LOG.warn("Committing sync: " + r.cxid );
+            zk.commitProcessor.commit(r);
+        }
     }
                 
     /**
<EOC>
<SOC>
         // request.addRQRec(">prop");
                 
         
+        /* In the following IF-THEN-ELSE block, we process syncs on the leader. 
+         * If the sync is coming from a follower, then the follower
+         * handler adds it to syncHandler. Otherwise, if it is a client of
+         * the leader that issued the sync command, then syncHandler won't 
+         * contain the handler. In this case, we add it to syncHandler, and 
+         * call processRequest on the next processor.
+         */
+        
         if(request.type == ZooDefs.OpCode.sync){
-            if(zks.getLeader().syncHandler.containsKey(request.sessionId)){
-                zks.getLeader().processSync(request);
-            }
-            else{
+            zks.getLeader().processSync(request);
+
+            if(!zks.getLeader().syncHandler.containsKey(request.sessionId)){
+                zks.getLeader().syncHandler.put(request.sessionId, null);
                 nextProcessor.processRequest(request);
-                zks.commitProcessor.commit(request);
             }
+            
         }
         else{
             nextProcessor.processRequest(request);
<EOC>
<SOC>
 
 import org.apache.zookeeper.Version;
 import org.apache.zookeeper.jmx.ZKMBeanInfo;
-import org.apache.zookeeper.server.ServerConfig;
 import org.apache.zookeeper.server.ServerStats;
+import org.apache.zookeeper.server.ZooKeeperServer;
 
 /**
  * This class implements the zookeeper server MBean interface.
  */
 public class ZooKeeperServerBean implements ZooKeeperServerMXBean, ZKMBeanInfo {
     private Date startTime=new Date();
+    private ZooKeeperServer zooKeeperServer;
+    
+    public ZooKeeperServerBean() {        
+    }
+    public ZooKeeperServerBean(ZooKeeperServer zooKeeperServer) {
+        this.zooKeeperServer = zooKeeperServer;
+    }
 
     public String getClientPort() {
+        ZooKeeperServer zks = getZooKeeperServer();
+        if( zks == null ) {
+            return null;
+        }
         try {
             return InetAddress.getLocalHost().getHostAddress() + ":"
-                    + ServerConfig.getClientPort();
+                    + zks.getClientPort();
         } catch (UnknownHostException e) {
-            return "localhost:" + ServerConfig.getClientPort();
+            return "localhost:" + zks.getClientPort();
         }
     }
     

         ServerStats.getInstance().resetRequestCounters();
         ServerStats.getInstance().resetLatency();
     }
+
+    public ZooKeeperServer getZooKeeperServer() {
+        return zooKeeperServer;
+    }
+
+    public void setZooKeeperServer(ZooKeeperServer zooKeeperServer) {
+        this.zooKeeperServer = zooKeeperServer;
+    }
+
 }
<EOC>
<SOC>
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.zookeeper.server.quorum;
 
-
-import static org.apache.zookeeper.server.ServerConfig.getClientPort;
-import static org.apache.zookeeper.server.ServerConfig.getDataDir;
-import static org.apache.zookeeper.server.ServerConfig.getDataLogDir;
-import static org.apache.zookeeper.server.quorum.QuorumPeerConfig.getElectionAlg;
-import static org.apache.zookeeper.server.quorum.QuorumPeerConfig.getElectionPort;
-import static org.apache.zookeeper.server.quorum.QuorumPeerConfig.getInitLimit;
-import static org.apache.zookeeper.server.quorum.QuorumPeerConfig.getServerId;
-import static org.apache.zookeeper.server.quorum.QuorumPeerConfig.getServers;
-import static org.apache.zookeeper.server.quorum.QuorumPeerConfig.getSyncLimit;
-import static org.apache.zookeeper.server.quorum.QuorumPeerConfig.getTickTime;
-
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileInputStream;

 import java.util.ArrayList;
 import java.util.List;
 
-import org.apache.log4j.Logger;
-
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.InputArchive;
+import org.apache.log4j.Logger;
 import org.apache.zookeeper.server.NIOServerCnxn;
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.apache.zookeeper.txn.TxnHeader;

  * </pre>
  *
  * The request for the current leader will consist solely of an xid: int xid;
- *
- * <h2>Configuration file</h2>
- *
- * When the main() method of this class is used to start the program, the file
- * "zoo.cfg" in the current directory will be used to obtain configuration
- * information. zoo.cfg is a Properties file, so keys and values are separated
- * by equals (=) and the key/value pairs are separated by new lines. The
- * following keys are used in the configuration file:
- * <ol>
- * <li>dataDir - The directory where the zookeeper data is stored.</li>
- * <li>clientPort - The port used to communicate with clients.</li>
- * <li>tickTime - The duration of a tick in milliseconds. This is the basic
- * unit of time in zookeeper.</li>
- * <li>initLimit - The maximum number of ticks that a follower will wait to
- * initially synchronize with a leader.</li>
- * <li>syncLimit - The maximum number of ticks that a follower will wait for a
- * message (including heartbeats) from the leader.</li>
- * <li>server.<i>id</i> - This is the host:port that the server with the
- * given id will use for the quorum protocol.</li>
- * </ol>
- * In addition to the zoo.cfg file. There is a file in the data directory called
- * "myid" that contains the server id as an ASCII decimal value.
  */
 public class QuorumPeer extends Thread implements QuorumStats.Provider {
     private static final Logger LOG = Logger.getLogger(QuorumPeer.class);

      */
     private File dataLogDir;
 
+    private int electionType;
+
     Election electionAlg;
 
     int electionPort;
 
     NIOServerCnxn.Factory cnxnFactory;
 
-    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
-            File dataLogDir, int electionAlg, int electionPort,long myid, int tickTime,
-            int initLimit, int syncLimit,NIOServerCnxn.Factory cnxnFactory) throws IOException {
+
+    public QuorumPeer() {
         super("QuorumPeer");
+    }
+    
+    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int electionType, int electionPort,long myid, int tickTime,
+            int initLimit, int syncLimit,NIOServerCnxn.Factory cnxnFactory) throws IOException {
+        this();
+        this.electionType = electionType;
         this.cnxnFactory = cnxnFactory;
         this.quorumPeers = quorumPeers;
         this.dataDir = dataDir;

         this.myid = myid;
         this.tickTime = tickTime;
         this.initLimit = initLimit;
-        this.syncLimit = syncLimit;
+        this.syncLimit = syncLimit;        
+        
+        QuorumStats.getInstance().setStatsProvider(this);
+    }
+
+    @Override
+    public synchronized void start() {
+        
         currentVote = new Vote(myid, getLastLoggedZxid());
         for (QuorumServer p : quorumPeers) {
             if (p.id == myid) {

             }
         }
         if (myQuorumAddr == null) {
-            throw new SocketException("My id " + myid + " not in the peer list");
+            throw new RuntimeException("My id " + myid + " not in the peer list");
         }
-        if (electionAlg == 0) {
-            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
-            new ResponderThread().start();
+        if (electionType == 0) {
+            try {
+                udpSocket = new DatagramSocket(myQuorumAddr.getPort());
+                new ResponderThread().start();
+            } catch (SocketException e) {
+                new RuntimeException(e);
+            }
         }
-        this.electionAlg = createElectionAlgorithm(electionAlg);
-        QuorumStats.getInstance().setStatsProvider(this);
+        this.electionAlg = createElectionAlgorithm(electionType);
+        super.start();
     }
-
+    
     /**
      * This constructor is only used by the existing unit test code.
      */

         this(quorumPeers,dataDir,dataLogDir,electionAlg,electionPort,myid,tickTime,
                 initLimit,syncLimit,new NIOServerCnxn.Factory(clientPort));
     }
-    /**
-     *  The constructor uses the quorum peer config to instantiate the class
-     */
-    public QuorumPeer(NIOServerCnxn.Factory cnxnFactory) throws IOException {
-        this(getServers(), new File(getDataDir()), new File(getDataLogDir()),
-                getElectionAlg(), getElectionPort(),getServerId(),getTickTime(),
-                getInitLimit(), getSyncLimit(),cnxnFactory);
-    }
 
     public Follower follower;
     public Leader leader;
 
+    private int clientPort;
+
     protected Follower makeFollower(File dataDir,File dataLogDir) throws IOException {
-        return new Follower(this, new FollowerZooKeeperServer(dataDir,
-                dataLogDir, this,new ZooKeeperServer.BasicDataTreeBuilder()));
+        FollowerZooKeeperServer zks = new FollowerZooKeeperServer(dataDir, dataLogDir, this,new ZooKeeperServer.BasicDataTreeBuilder());
+        zks.setClientPort(clientPort);
+        return new Follower(this, zks);
     }
 
     protected Leader makeLeader(File dataDir,File dataLogDir) throws IOException {
-        return new Leader(this, new LeaderZooKeeperServer(dataDir, dataLogDir,
-                this,new ZooKeeperServer.BasicDataTreeBuilder()));
+        LeaderZooKeeperServer zks = new LeaderZooKeeperServer(dataDir, dataLogDir,
+                this,new ZooKeeperServer.BasicDataTreeBuilder());
+        zks.setClientPort(clientPort);
+        return new Leader(this, zks);
     }
 
     private Election createElectionAlgorithm(int electionAlgorithm){

         return zxid;
     }
 
-    public static void runPeer(QuorumPeer.Factory qpFactory) {
-        try {
-            QuorumStats.registerAsConcrete();
-            QuorumPeer self = qpFactory.create(qpFactory.createConnectionFactory());
-            self.start();
-            self.join();
-        } catch (Exception e) {
-            LOG.fatal("Unexpected exception",e);
-        }
-        System.exit(2);
-    }
-
     public String[] getQuorumPeers() {
         List<String> l = new ArrayList<String>();
         synchronized (this) {

         return QuorumStats.Provider.UNKNOWN_STATE;
     }
 
-    public static void main(String args[]) {
-        if (args.length == 2) {
-            ZooKeeperServer.main(args);
-            return;
-        }
-        QuorumPeerConfig.parse(args);
-
-        if (!QuorumPeerConfig.isStandalone()) {
-            runPeer(new QuorumPeer.Factory() {
-                public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory)
-                        throws IOException {
-                    return new QuorumPeer(cnxnFactory);
-                }
-                public NIOServerCnxn.Factory createConnectionFactory()
-                        throws IOException {
-                    return new NIOServerCnxn.Factory(getClientPort());
-                }
-            });
-        }else{
-            // there is only server in the quorum -- run as standalone
-            ZooKeeperServer.main(args);
-        }
+    /**
+     * get the id of this quorum peer.
+     */
+    public long getMyid() {
+        return myid;
     }
+
+    /**
+     * set the id of this quorum peer.
+     */
+    public void setMyid(long myid) {
+        this.myid = myid;
+    }
+
+    /**
+     * Get the number of milliseconds of each tick
+     */
+    public int getTickTime() {
+        return tickTime;
+    }
+
+    /**
+     * Set the number of milliseconds of each tick
+     */
+    public void setTickTime(int tickTime) {
+        this.tickTime = tickTime;
+    }
+
+    /**
+     * Get the number of ticks that the initial synchronization phase can take
+     */
+    public int getInitLimit() {
+        return initLimit;
+    }
+
+    /**
+     * Set the number of ticks that the initial synchronization phase can take
+     */
+    public void setInitLimit(int initLimit) {
+        this.initLimit = initLimit;
+    }
+
+    /**
+     * Get the number of ticks that can pass between sending a request and getting
+     * an acknowledgement
+     */
+    public int getSyncLimit() {
+        return syncLimit;
+    }
+
+    /**
+     * Set the number of ticks that can pass between sending a request and getting
+     * an acknowledgement
+     */
+    public void setSyncLimit(int syncLimit) {
+        this.syncLimit = syncLimit;
+    }
+
+    /**
+     * Get the directory where the snapshot is stored.
+     */
+    public File getDataDir() {
+        return dataDir;
+    }
+
+    /**
+     * Set the directory where the snapshot is stored.
+     */
+    public void setDataDir(File dataDir) {
+        this.dataDir = dataDir;
+    }
+
+    /**
+     * Get the directory where the logs are stored.
+     */
+    public File getDataLogDir() {
+        return dataLogDir;
+    }
+
+    /**
+     * Set the directory where the logs are stored.
+     */
+    public void setDataLogDir(File dataLogDir) {
+        this.dataLogDir = dataLogDir;
+    }
+
+    /**
+     * Gets the election port
+     */
+    public int getElectionPort() {
+        return electionPort;
+    }
+
+    /**
+     * Gets the election type
+     */
+    public int getElectionType() {
+        return electionType;
+    }
+
+    /**
+     * Sets the election type
+     */
+    public void setElectionType(int electionType) {
+        this.electionType = electionType;
+    }
+
+    /**
+     * Sets the election port
+     */
+    public void setElectionPort(int electionPort) {
+        this.electionPort = electionPort;
+    }
+
+    public NIOServerCnxn.Factory getCnxnFactory() {
+        return cnxnFactory;
+    }
+
+    public void setCnxnFactory(NIOServerCnxn.Factory cnxnFactory) {
+        this.cnxnFactory = cnxnFactory;
+    }
+
+    public void setQuorumPeers(ArrayList<QuorumServer> quorumPeers) {
+        this.quorumPeers = quorumPeers;
+    }
+
+    public int getClientPort() {
+        return clientPort;
+    }
+
+    public void setClientPort(int clientPort) {
+        this.clientPort = clientPort;
+    }
+
 }
<EOC>
<SOC>
      */
     private LinkedList<Packet> pendingQueue = new LinkedList<Packet>();
 
-    private LinkedBlockingQueue waitingEvents = new LinkedBlockingQueue();
+    private LinkedBlockingQueue<Object> waitingEvents = 
+        new LinkedBlockingQueue<Object>();
 
     /**
      * These are the packets that need to be sent.

     public long getSessionId() {
         return sessionId;
     }
-
+    
     public byte[] getSessionPasswd() {
         return sessionPasswd;
     }
 
     public String toString() {
         StringBuffer sb = new StringBuffer();
-        sb.append("sessionId: ").append(sessionId).append("\n");
+        sb.append("sessionId: 0x").append(Long.toHexString(getSessionId())).append("\n");
         sb.append("lastZxid: ").append(lastZxid).append("\n");
         sb.append("xid: ").append(xid).append("\n");
         sb.append("nextAddrToTry: ").append(nextAddrToTry).append("\n");

                 primeConnection(sockKey);
             }
             initialized = false;
-            
+
             /*
              * Reset incomingBuffer
              */

                     }
                     selected.clear();
                 } catch (Exception e) {
-                    LOG.warn("Closing: ", e);
+                    LOG.warn("Closing session 0x" 
+                            + Long.toHexString(getSessionId()),
+                            e);
                     cleanup();
                     if (zooKeeper.state.isAlive()) {
                         waitingEvents.add(new WatcherEvent(Event.EventNone,

 
     @SuppressWarnings("unchecked")
     public void close() throws IOException {
-        long traceMask = ZooTrace.SESSION_TRACE_MASK;
-        if (ZooTrace.isTraceEnabled(LOG, traceMask)) {
-            ZooTrace.logTraceMessage(LOG, traceMask,
-                    "Close ClientCnxn for session: " + sessionId + "!");
-        }
+        LOG.info("Closing ClientCnxn for session: 0x" 
+                + Long.toHexString(getSessionId()));
+
         sendThread.close();
         waitingEvents.add(eventOfDeath);
     }
<EOC>
<SOC>
         try {
             zk.closeSession(connection.getSessionId());
         } catch (Exception e) {
-            LOG.warn("Unable to closeSession() for session: "+getSessionId()+
-                    ", "+e.getMessage());
+            LOG.warn("Unable to closeSession() for session: 0x" 
+                    + getSessionId(), e);
         }
     }
     

     }
     
     public String toString() {
-        return "ConnectionBean{ClientIP="+getSourceIP()+",SessionId="+getSessionId()+"}";
+        return "ConnectionBean{ClientIP="+getSourceIP()+",SessionId=0x"+getSessionId()+"}";
     }
     
     public long getOutstandingRequests() {
<EOC>
<SOC>
 package org.apache.zookeeper.server;
 
 import java.nio.ByteBuffer;
-import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.jute.Record;

 
     public String toString() {
         StringBuffer sb = new StringBuffer();
-        sb.append(Long.toHexString(sessionId)).append(" ");
-        sb.append(Long.toHexString(cxid)).append(" ");
-        sb.append(Long.toHexString((hdr == null ? -2 : hdr.getZxid()))).append(
+        sb.append("session 0x").append(Long.toHexString(sessionId));
+        sb.append(" cxid 0x").append(Long.toHexString(cxid));
+        sb.append("zxid 0x").append(Long.toHexString((hdr == null ? -2 : hdr.getZxid()))).append(
                 " ");
         sb
                 .append(
<EOC>
<SOC>
     public int commitLogBuffer = 700;
     public LinkedList<Proposal> committedLog = new LinkedList<Proposal>();
     public long minCommittedLog, maxCommittedLog;
-    private DataTreeBuilder treeBuilder = new BasicDataTreeBuilder();
+    private DataTreeBuilder treeBuilder;
     public DataTree dataTree;
     protected SessionTracker sessionTracker;
     /**

     }
 
     /**
+     * Creates a ZooKeeperServer instance. Nothing is setup, use the setX
+     * methods to prepare the instance (eg datadir, datalogdir, ticktime, 
+     * builder, etc...)
      * 
      * @throws IOException
      */
     public ZooKeeperServer() {
         ServerStats.getInstance().setStatsProvider(this);
+        treeBuilder = new BasicDataTreeBuilder();
     }
     /**
      * Creates a ZooKeeperServer instance. It sets everything up, but doesn't
      * actually start listening for clients until run() is invoked.
      *
-     * @param dataDir
-     *            the directory to put the data
+     * @param dataDir the directory to put the data
      * @throws IOException
      */
     public ZooKeeperServer(File dataDir, File dataLogDir, int tickTime,
             DataTreeBuilder treeBuilder) throws IOException {
-        this.treeBuilder = treeBuilder;
         this.dataDir = dataDir;
         this.dataLogDir = dataLogDir;
         this.tickTime = tickTime;
+        this.treeBuilder = treeBuilder;
         ServerStats.getInstance().setStatsProvider(this);
+        
+        LOG.info("Created server with dataDir:" + dataDir 
+                + " dataLogDir:" + dataLogDir
+                + " tickTime:" + tickTime);
     }
 
     /**
-     * This constructor is for backward comaptibility with the existing unit
+     * This constructor is for backward compatibility with the existing unit
      * test code.
      */
     public ZooKeeperServer(File dataDir, File dataLogDir, int tickTime)
-            throws IOException {
-        this();
-        this.dataDir = dataDir;
-        this.dataLogDir = dataLogDir;
-        this.tickTime = tickTime;
+        throws IOException 
+    {
+        this(dataDir, dataLogDir, tickTime, new BasicDataTreeBuilder());
+    }
+
+    /**
+     * Default constructor, relies on the config for its agrument values
+     *
+     * @throws IOException
+     */
+    public ZooKeeperServer(DataTreeBuilder treeBuilder) throws IOException {
+        this(new File(ServerConfig.getDataDir()), new File(ServerConfig
+                .getDataLogDir()), DEFAULT_TICK_TIME, treeBuilder);
     }
 
     public static long getZxidFromName(String name, String prefix) {

                             ((CreateSessionTxn) txn).getTimeOut());
                     ZooTrace.logTraceMessage(LOG,
                                              ZooTrace.SESSION_TRACE_MASK,
-                            "playLog --- create session in log: "
+                            "playLog --- create session in log: 0x"
                                     + Long.toHexString(hdr.getClientId())
                                     + " with timeout: "
                                     + ((CreateSessionTxn) txn).getTimeOut());

                     sessionsWithTimeouts.remove(hdr.getClientId());
                     ZooTrace.logTraceMessage(LOG,
                             ZooTrace.SESSION_TRACE_MASK,
-                            "playLog --- close session in log: "
+                            "playLog --- close session in log: 0x"
                                     + Long.toHexString(hdr.getClientId()));
                     dataTree.processTxn(hdr, txn);
                     break;

         }
         if (truncated == false) {
             // not able to truncate the log
-            LOG.error("Not able to truncate the log "
+            LOG.error("Not able to truncate the log zxid 0x"
                     + Long.toHexString(finalZxid));
             System.exit(13);
         }

     public void snapshot() throws InterruptedException {
         long lastZxid = dataTree.lastProcessedZxid;
         ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                "Snapshotting: " + Long.toHexString(lastZxid));
+                "Snapshotting: zxid 0x" + Long.toHexString(lastZxid));
         try {
             File f =new File(dataDir, "snapshot." + Long.toHexString(lastZxid));
             OutputStream sessOS = new BufferedOutputStream(new FileOutputStream(f));

             sessOS.flush();
             sessOS.close();
             ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),
-                    "Snapshotting finished: " + Long.toHexString(lastZxid));
+                    "Snapshotting finished: zxid 0x" + Long.toHexString(lastZxid));
         } catch (IOException e) {
             LOG.error("Severe error, exiting",e);
             // This is a severe error that we cannot recover from,

 
     public void closeSession(long sessionId) throws InterruptedException {
         ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
-                                 "ZooKeeperServer --- Session to be closed: "
+                                 "ZooKeeperServer --- Session to be closed: 0x"
                 + Long.toHexString(sessionId));
         // we do not want to wait for a session close. send it as soon as we
         // detect it!

     protected void killSession(long sessionId) {
         dataTree.killSession(sessionId);
         ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,
-                                     "ZooKeeperServer --- killSession: "
+                                     "ZooKeeperServer --- killSession: 0x"
                 + Long.toHexString(sessionId));
         if (sessionTracker != null) {
             sessionTracker.removeSession(sessionId);

     public void expire(long sessionId) {
         try {
             ZooTrace.logTraceMessage(LOG,
-                                     ZooTrace.SESSION_TRACE_MASK,
-                    "ZooKeeperServer --- Session to expire: " + Long.toHexString(sessionId));
+                     ZooTrace.SESSION_TRACE_MASK,
+                    "ZooKeeperServer --- Session to expire: 0x" 
+                     + Long.toHexString(sessionId));
             closeSession(sessionId);
         } catch (Exception e) {
             LOG.error("FIXMSG",e);

         long id = cnxn.getSessionId();
         int to = cnxn.getSessionTimeout();
         if (!sessionTracker.touchSession(id, to)) {
-            throw new IOException("Missing session " + Long.toHexString(id));
+            throw new IOException("Missing session 0x" + Long.toHexString(id));
         }
     }
 
     public void startup() throws IOException, InterruptedException {
+        if (dataDir == null || !dataDir.isDirectory()) {
+            throw new IOException("data directory does not exist: " + dataDir);
+        }
+        if (dataLogDir == null || !dataLogDir.isDirectory()) {
+            throw new IOException("data log directory does not exist: "
+                    + dataLogDir);
+        }
+
         if (dataTree == null) {
             loadData();
         }

             int sessionTimeout) throws IOException, InterruptedException {
         boolean rc = sessionTracker.touchSession(sessionId, sessionTimeout);
         ZooTrace.logTraceMessage(LOG,ZooTrace.SESSION_TRACE_MASK,
-                                 "Session " + Long.toHexString(sessionId) +
+                                 "Session 0x" + Long.toHexString(sessionId) +
                 " is valid: " + rc);
         cnxn.finishSessionInit(rc);
     }

     /**
      * Sets directoy for storing the log tnxns
      */
-    public void setDataLogDir(File dataLogDir) {
+    public void setDataLogDir(File dataLogDir) throws IOException {
         this.dataLogDir = dataLogDir;
+        if (!dataLogDir.isDirectory()) {
+            throw new IOException("data log directory does not exist");
+        }
     }
 
     public int getClientPort() {
<EOC>
<SOC>
                 // Long.toHexString(zxid) + " is " + p.ackCount);
                 if (p.ackCount > self.quorumPeers.size() / 2){
                     if (!first) {
-                        LOG.error("Commiting " + Long.toHexString(zxid)
+                        LOG.error("Commiting zxid 0x" + Long.toHexString(zxid)
                                 + " from " + followerAddr + " not first!");
                         LOG.error("First is "
                                 + outstandingProposals.element().packet);

                 first = false;
             }
         }
-        LOG.error("Trying to commit future proposal: "
+        LOG.error("Trying to commit future proposal: zxid 0x"
                 + Long.toHexString(zxid) + " from " + followerAddr);
     }
 
<EOC>
<SOC>
             bufferedOutput.flush();
             // only if we are not truncating or fast sycning
             if (packetToSend == Leader.SNAP) {
-                LOG.warn("Sending snapshot last zxid of peer is "
-                        + Long.toHexString(peerLastZxid) + " " + " zxid of leader is "
+                LOG.warn("Sending snapshot last zxid of peer is 0x"
+                        + Long.toHexString(peerLastZxid) + " " 
+                        + " zxid of leader is 0x"
                         + Long.toHexString(leaderLastZxid));
                 // Dump data to follower
                 leader.zk.snapshot(oa);

                     boolean valid = leader.zk.touch(id, to);
                     ZooTrace.logTraceMessage(LOG,
                                              ZooTrace.SESSION_TRACE_MASK,
-                                             "Session " + Long.toHexString(id)
+                                             "Session 0x" + Long.toHexString(id)
                                              + " is valid: "+ valid);
                     dos.writeBoolean(valid);
                     qp.setData(bos.toByteArray());
<EOC>
<SOC>
 
 package org.apache.zookeeper.test;
 
+import java.io.BufferedReader;
 import java.io.File;
 import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.Socket;
+import java.util.Arrays;
 
 import junit.framework.TestCase;
 
 import org.apache.log4j.Logger;
-
-import org.apache.zookeeper.Watcher;
-import org.apache.zookeeper.ZooKeeper;
 import org.apache.zookeeper.server.NIOServerCnxn;
 import org.apache.zookeeper.server.ServerStats;
+import org.apache.zookeeper.server.SyncRequestProcessor;
 import org.apache.zookeeper.server.ZooKeeperServer;
 
 public abstract class ClientBase extends TestCase {
     protected static final Logger LOG = Logger.getLogger(ClientBase.class);
-    protected static String hostPort = "127.0.0.1:33221";
-    protected static final int CONNECTION_TIMEOUT = 30000;
-    protected NIOServerCnxn.Factory f = null;
-    protected File tmpDir = null;
-    protected static File baseTest =
+
+    static final int CONNECTION_TIMEOUT = 30000;
+    static final File BASETEST =
         new File(System.getProperty("build.test.dir", "build"));
 
+    protected String hostPort = "127.0.0.1:33221";
+    protected NIOServerCnxn.Factory serverFactory = null;
+    protected File tmpDir = null;
+
     public ClientBase() {
         super();
     }

         super(name);
     }
 
+    public static boolean waitForServerUp(String hp, long timeout) {
+        long start = System.currentTimeMillis();
+        String split[] = hp.split(":");
+        String host = split[0];
+        int port = Integer.parseInt(split[1]);
+        while (true) {
+            try {
+                Socket sock = new Socket(host, port);
+                BufferedReader reader = null;
+                try {
+                    OutputStream outstream = sock.getOutputStream();
+                    outstream.write("stat".getBytes());
+                    outstream.flush();
+
+                    reader =
+                        new BufferedReader(
+                                new InputStreamReader(sock.getInputStream()));
+                    String line = reader.readLine();
+                    if (line != null && line.startsWith("Zookeeper version:")) {
+                        return true;
+                    }
+                } finally {
+                    sock.close();
+                    if (reader != null) {
+                        reader.close();
+                    }
+                }
+            } catch (IOException e) {
+                // ignore as this is expected
+                LOG.info("server " + hp + " not up " + e);
+            }
+
+            if (System.currentTimeMillis() > start + timeout) {
+                break;
+            }
+            try {
+                Thread.sleep(250);
+            } catch (InterruptedException e) {
+                // ignore
+            }
+        }
+        return false;
+    }
+    public static boolean waitForServerDown(String hp, long timeout) {
+        long start = System.currentTimeMillis();
+        String split[] = hp.split(":");
+        String host = split[0];
+        int port = Integer.parseInt(split[1]);
+        while (true) {
+            try {
+                Socket sock = new Socket(host, port);
+                try {
+                    OutputStream outstream = sock.getOutputStream();
+                    outstream.write("stat".getBytes());
+   